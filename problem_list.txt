<문제 1000>
두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 A와 B가 주어진다. (0 < A, B < 10)
<출력값>
첫째 줄에 A+B를 출력한다.

<문제 1001>
두 정수 A와 B를 입력받은 다음, A-B를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 A와 B가 주어진다. (0 < A, B < 10)
<출력값>
첫째 줄에 A-B를 출력한다.

<문제 1002>
조규현과 백승환은 터렛에 근무하는 직원이다. 하지만 워낙 존재감이 없어서 인구수는 차지하지 않는다. 다음은 조규현과 백승환의 사진이다.

이석원은 조규현과 백승환에게 상대편 마린(류재명)의 위치를 계산하라는 명령을 내렸다. 조규현과 백승환은 각각 자신의 터렛 위치에서 현재 적까지의 거리를 계산했다.
조규현의 좌표 (x1, y1)와 백승환의 좌표 (x2, y2)가 주어지고, 조규현이 계산한 류재명과의 거리 r1과 백승환이 계산한 류재명과의 거리 r2가 주어졌을 때, 류재명이 있을 수 있는 좌표의 수를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 다음과 같이 이루어져 있다.
한 줄에 x1, y1, r1, x2, y2, r2가 주어진다. x1, y1, x2, y2는 -10,000보다 크거나 같고, 10,000보다 작거나 같은 정수이고, r1, r2는 10,000보다 작거나 같은 자연수이다.
<출력값>
각 테스트 케이스마다 류재명이 있을 수 있는 위치의 수를 출력한다. 만약 류재명이 있을 수 있는 위치의 개수가 무한대일 경우에는 -1을 출력한다.

<문제 1003>
다음 소스는 N번째 피보나치 수를 구하는 C++ 함수이다.

int fibonacci(int n) {
    if (n == 0) {
        printf("0");
        return 0;
    } else if (n == 1) {
        printf("1");
        return 1;
    } else {
        return fibonacci(n‐1) + fibonacci(n‐2);
    }
}

fibonacci(3)을 호출하면 다음과 같은 일이 일어난다.

fibonacci(3)은 fibonacci(2)와 fibonacci(1) (첫 번째 호출)을 호출한다.
fibonacci(2)는 fibonacci(1) (두 번째 호출)과 fibonacci(0)을 호출한다.
두 번째 호출한 fibonacci(1)은 1을 출력하고 1을 리턴한다.
fibonacci(0)은 0을 출력하고, 0을 리턴한다.
fibonacci(2)는 fibonacci(1)과 fibonacci(0)의 결과를 얻고, 1을 리턴한다.
첫 번째 호출한 fibonacci(1)은 1을 출력하고, 1을 리턴한다.
fibonacci(3)은 fibonacci(2)와 fibonacci(1)의 결과를 얻고, 2를 리턴한다.

1은 2번 출력되고, 0은 1번 출력된다. N이 주어졌을 때, fibonacci(N)을 호출했을 때, 0과 1이 각각 몇 번 출력되는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 테스트 케이스의 개수 T가 주어진다.
각 테스트 케이스는 한 줄로 이루어져 있고, N이 주어진다. N은 40보다 작거나 같은 자연수 또는 0이다.
<출력값>
각 테스트 케이스마다 0이 출력되는 횟수와 1이 출력되는 횟수를 공백으로 구분해서 출력한다.

<문제 1004>
어린 왕자는 소혹성 B-664에서 자신이 사랑하는 한 송이 장미를 위해 살아간다. 어느 날 장미가 위험에 빠지게 된 것을 알게 된 어린 왕자는, 장미를 구하기 위해 은하수를 따라 긴 여행을 하기 시작했다. 하지만 어린 왕자의 우주선은 그렇게 좋지 않아서 행성계 간의 이동을 최대한 피해서 여행해야 한다. 아래의 그림은 어린 왕자가 펼쳐본 은하수 지도의 일부이다.

빨간 실선은 어린 왕자가 출발점에서 도착점까지 도달하는데 있어서 필요한 행성계 진입/이탈 횟수를 최소화하는 경로이며, 원은 행성계의 경계를 의미한다. 이러한 경로는 여러 개 존재할 수 있지만 적어도 3번의 행성계 진입/이탈이 필요하다는 것을 알 수 있다.
위와 같은 은하수 지도, 출발점, 도착점이 주어졌을 때 어린 왕자에게 필요한 최소의 행성계 진입/이탈 횟수를 구하는 프로그램을 작성해 보자. (행성계의 경계가 맞닿거나 서로 교차하는 경우는 없다고 가정한다. 또한, 출발점이나 도착점이 행성계 경계에 걸쳐진 경우 역시 입력으로 주어지지 않는다.)
<입력값>
입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트케이스에 대해 첫째 줄에 출발점 (x1, y1)과 도착점 (x2, y2)이 주어진다. 두 번째 줄에는 행성계의 개수 n이 주어지며, 세 번째 줄부터 n줄에 걸쳐 행성계의 중점과 반지름 (cx, cy, r)이 주어진다. 입력제한은 다음과 같다. (-1000 ≤ x1, y1, x2, y2, cx, cy ≤ 1000, 1 ≤ r ≤ 1000, 1 ≤ n ≤ 50)
좌표와 반지름은 모두 정수이다.
<출력값>
각 테스트 케이스에 대해 어린 왕자가 거쳐야 할 최소의 행성계 진입/이탈 횟수를 출력한다.

<문제 1005>
서기 2012년! 드디어 2년간 수많은 국민들을 기다리게 한 게임 ACM Craft (Association of Construction Manager Craft)가 발매되었다.
이 게임은 지금까지 나온 게임들과는 다르게 ACM크래프트는 다이나믹한 게임 진행을 위해 건물을 짓는 순서가 정해져 있지 않다. 즉, 첫 번째 게임과 두 번째 게임이 건물을 짓는 순서가 다를 수도 있다. 매 게임시작 시 건물을 짓는 순서가 주어진다. 또한 모든 건물은 각각 건설을 시작하여 완성이 될 때까지 Delay가 존재한다.
 

위의 예시를 보자.
이번 게임에서는 다음과 같이 건설 순서 규칙이 주어졌다. 1번 건물의 건설이 완료된다면 2번과 3번의 건설을 시작할수 있다. (동시에 진행이 가능하다) 그리고 4번 건물을 짓기 위해서는 2번과 3번 건물이 모두 건설 완료되어야지만 4번건물의 건설을 시작할수 있다.
따라서 4번건물의 건설을 완료하기 위해서는 우선 처음 1번 건물을 건설하는데 10초가 소요된다. 그리고 2번 건물과 3번 건물을 동시에 건설하기 시작하면 2번은 1초뒤에 건설이 완료되지만 아직 3번 건물이 완료되지 않았으므로 4번 건물을 건설할 수 없다. 3번 건물이 완성되고 나면 그때 4번 건물을 지을수 있으므로 4번 건물이 완성되기까지는 총 120초가 소요된다.
프로게이머 최백준은 애인과의 데이트 비용을 마련하기 위해 서강대학교배 ACM크래프트 대회에 참가했다! 최백준은 화려한 컨트롤 실력을 가지고 있기 때문에 모든 경기에서 특정 건물만 짓는다면 무조건 게임에서 이길 수 있다. 그러나 매 게임마다 특정건물을 짓기 위한 순서가 달라지므로 최백준은 좌절하고 있었다. 백준이를 위해 특정건물을 가장 빨리 지을 때까지 걸리는 최소시간을 알아내는 프로그램을 작성해주자.
<입력값>
첫째 줄에는 테스트케이스의 개수 T가 주어진다. 각 테스트 케이스는 다음과 같이 주어진다. 첫째 줄에 건물의 개수 N 과 건물간의 건설순서규칙의 총 개수 K이 주어진다. (건물의 번호는 1번부터 N번까지 존재한다) 
둘째 줄에는 각 건물당 건설에 걸리는 시간 D가 공백을 사이로 주어진다. 셋째 줄부터 K+2줄까지 건설순서 X Y가 주어진다. (이는 건물 X를 지은 다음에 건물 Y를 짓는 것이 가능하다는 의미이다) 
마지막 줄에는 백준이가 승리하기 위해 건설해야 할 건물의 번호 W가 주어진다.
<출력값>
건물 W를 건설완료 하는데 드는 최소 시간을 출력한다. 편의상 건물을 짓는 명령을 내리는 데는 시간이 소요되지 않는다고 가정한다.
건설순서는 모든 건물이 건설 가능하도록 주어진다.

<문제 1006>
초라기는 한국의 비밀국방기지(원타곤)를 습격하라는 임무를 받은 특급요원이다. 원타곤의 건물은 도넛 형태이며, 초라기는 효율적인 타격 포인트를 정하기 위해 구역을 아래와 같이 두 개의 원 모양으로 나누었다. (그림의 숫자는 각 구역의 번호이다.)

초라기는 각각 W명으로 구성된 특수소대를 다수 출동시켜 모든 구역에 침투시킬 예정이며, 각 구역 별로 적이 몇 명씩 배치되어 있는지는 초라기가 모두 알고 있다. 특수소대를 아래 조건에 따라 침투 시킬 수 있다.

한 특수소대는 침투한 구역 외에, 인접한 한 구역 더 침투할 수 있다. (같은 경계를 공유하고 있으면 인접 하다고 한다. 위 그림에서 1구역은 2, 8, 9 구역과 서로 인접한 상태다.) 즉, 한 특수소대는 한 개 혹은 두 개의 구역을 커버할 수 있다.
특수소대끼리는 아군인지 적인지 구분을 못 하기 때문에, 각 구역은 하나의 소대로만 커버해야 한다.
한 특수소대가 커버하는 구역의 적들의 합은 특수소대원 수 W 보다 작거나 같아야 한다.

이때 초라기는 원타곤의 모든 구역을 커버하기 위해 침투 시켜야 할 특수 소대의 최소 개수를 알고 싶어 한다.
<입력값>
첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 다음과 같이 구성되어있다.
첫째 줄에는 (구역의 개수)/2 값 N과 특수 소대원의 수 W가 주어진다. (1 ≤ N ≤ 10000, 1 ≤ W ≤ 10000).
둘째 줄에는 1~N번째 구역에 배치된 적의 수가 주어지고, 셋째 줄에는 N+1 ~ 2N번째 구역에 배치된 적의 수가 공백으로 구분되어 주어진다. (1 ≤ 각 구역에 배치된 최대 적의 수 ≤ 10000) 단, 한 구역에서 특수 소대원의 수보다 많은 적이 배치된 구역은 존재하지 않는다. (따라서, 각 구역에 배치된 최대 적의 수 ≤ W)
<출력값>
각 테스트케이스에 대해서 한 줄에 하나씩 원타곤의 모든 구역을 커버하기 위해 침투 시켜야 할 특수 소대의 최소 개수를 출력하시오.

<문제 1007>
평면 상에 N개의 점이 찍혀있고, 그 점을 집합 P라고 하자. 집합 P의 벡터 매칭은 벡터의 집합인데, 모든 벡터는 집합 P의 한 점에서 시작해서, 또 다른 점에서 끝나는 벡터의 집합이다. 또, P에 속하는 모든 점은 한 번씩 쓰여야 한다.
V에 있는 벡터의 개수는 P에 있는 점의 절반이다.
평면 상의 점이 주어졌을 때, 집합 P의 벡터 매칭에 있는 벡터의 합의 길이의 최솟값을 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 다음과 같이 구성되어있다.
테스트 케이스의 첫째 줄에 점의 개수 N이 주어진다. N은 짝수이다. 둘째 줄부터 N개의 줄에 점의 좌표가 주어진다. N은 20보다 작거나 같은 자연수이고, 좌표는 절댓값이 100,000보다 작거나 같은 정수다. 모든 점은 서로 다르다.
<출력값>
각 테스트 케이스마다 정답을 출력한다. 절대/상대 오차는 10-6까지 허용한다.

<문제 1008>
두 정수 A와 B를 입력받은 다음, A/B를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 A와 B가 주어진다. (0 < A, B < 10)
<출력값>
첫째 줄에 A/B를 출력한다. 실제 정답과 출력값의 절대오차 또는 상대오차가 10-9 이하이면 정답이다.

<문제 1009>
재용이는 최신 컴퓨터 10대를 가지고 있다. 어느 날 재용이는 많은 데이터를 처리해야 될 일이 생겨서 각 컴퓨터에 1번부터 10번까지의 번호를 부여하고, 10대의 컴퓨터가 다음과 같은 방법으로 데이터들을 처리하기로 하였다.
1번 데이터는 1번 컴퓨터, 2번 데이터는 2번 컴퓨터, 3번 데이터는 3번 컴퓨터, ... ,
10번 데이터는 10번 컴퓨터, 11번 데이터는 1번 컴퓨터, 12번 데이터는 2번 컴퓨터, ...
총 데이터의 개수는 항상 ab개의 형태로 주어진다. 재용이는 문득 마지막 데이터가 처리될 컴퓨터의 번호가 궁금해졌다. 이를 수행해주는 프로그램을 작성하라.
<입력값>
입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트 케이스에 대해 정수 a와 b가 주어진다. (1 ≤ a < 100, 1 ≤ b < 1,000,000)
<출력값>
각 테스트 케이스에 대해 마지막 데이터가 처리되는 컴퓨터의 번호를 출력한다.

<문제 1010>
재원이는 한 도시의 시장이 되었다. 이 도시에는 도시를 동쪽과 서쪽으로 나누는 큰 일직선 모양의 강이 흐르고 있다. 하지만 재원이는 다리가 없어서 시민들이 강을 건너는데 큰 불편을 겪고 있음을 알고 다리를 짓기로 결심하였다. 강 주변에서 다리를 짓기에 적합한 곳을 사이트라고 한다. 재원이는 강 주변을 면밀히 조사해 본 결과 강의 서쪽에는 N개의 사이트가 있고 동쪽에는 M개의 사이트가 있다는 것을 알았다. (N ≤ M)
재원이는 서쪽의 사이트와 동쪽의 사이트를 다리로 연결하려고 한다. (이때 한 사이트에는 최대 한 개의 다리만 연결될 수 있다.) 재원이는 다리를 최대한 많이 지으려고 하기 때문에 서쪽의 사이트 개수만큼 (N개) 다리를 지으려고 한다. 다리끼리는 서로 겹쳐질 수 없다고 할 때 다리를 지을 수 있는 경우의 수를 구하는 프로그램을 작성하라.
<입력값>
입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트케이스에 대해 강의 서쪽과 동쪽에 있는 사이트의 개수 정수 N, M (0 < N ≤ M < 30)이 주어진다.
<출력값>
각 테스트 케이스에 대해 주어진 조건하에 다리를 지을 수 있는 경우의 수를 출력한다.

<문제 1011>
우현이는 어린 시절, 지구 외의 다른 행성에서도 인류들이 살아갈 수 있는 미래가 오리라 믿었다. 그리고 그가 지구라는 세상에 발을 내려 놓은 지 23년이 지난 지금, 세계 최연소 ASNA 우주 비행사가 되어 새로운 세계에 발을 내려 놓는 영광의 순간을 기다리고 있다.
그가 탑승하게 될 우주선은 Alpha Centauri라는 새로운 인류의 보금자리를 개척하기 위한 대규모 생활 유지 시스템을 탑재하고 있기 때문에, 그 크기와 질량이 엄청난 이유로 최신기술력을 총 동원하여 개발한 공간이동 장치를 탑재하였다. 하지만 이 공간이동 장치는 이동 거리를 급격하게 늘릴 경우 기계에 심각한 결함이 발생하는 단점이 있어서, 이전 작동시기에 k광년을 이동하였을 때는 k-1 , k 혹은 k+1 광년만을 다시 이동할 수 있다. 예를 들어, 이 장치를 처음 작동시킬 경우 -1 , 0 , 1 광년을 이론상 이동할 수 있으나 사실상 음수 혹은 0 거리만큼의 이동은 의미가 없으므로 1 광년을 이동할 수 있으며, 그 다음에는 0 , 1 , 2 광년을 이동할 수 있는 것이다. ( 여기서 다시 2광년을 이동한다면 다음 시기엔 1, 2, 3 광년을 이동할 수 있다. )

김우현은 공간이동 장치 작동시의 에너지 소모가 크다는 점을 잘 알고 있기 때문에 x지점에서 y지점을 향해 최소한의 작동 횟수로 이동하려 한다. 하지만 y지점에 도착해서도 공간 이동장치의 안전성을 위하여 y지점에 도착하기 바로 직전의 이동거리는 반드시 1광년으로 하려 한다.
김우현을 위해 x지점부터 정확히 y지점으로 이동하는데 필요한 공간 이동 장치 작동 횟수의 최솟값을 구하는 프로그램을 작성하라.
<입력값>
입력의 첫 줄에는 테스트케이스의 개수 T가 주어진다. 각각의 테스트 케이스에 대해 현재 위치 x 와 목표 위치 y 가 정수로 주어지며, x는 항상 y보다 작은 값을 갖는다. (0 ≤ x < y < 231)
<출력값>
각 테스트 케이스에 대해 x지점으로부터 y지점까지 정확히 도달하는데 필요한 최소한의 공간이동 장치 작동 횟수를 출력한다.

<문제 1012>
차세대 영농인 한나는 강원도 고랭지에서 유기농 배추를 재배하기로 하였다. 농약을 쓰지 않고 배추를 재배하려면 배추를 해충으로부터 보호하는 것이 중요하기 때문에, 한나는 해충 방지에 효과적인 배추흰지렁이를 구입하기로 결심한다. 이 지렁이는 배추근처에 서식하며 해충을 잡아 먹음으로써 배추를 보호한다. 특히, 어떤 배추에 배추흰지렁이가 한 마리라도 살고 있으면 이 지렁이는 인접한 다른 배추로 이동할 수 있어, 그 배추들 역시 해충으로부터 보호받을 수 있다.
(한 배추의 상하좌우 네 방향에 다른 배추가 위치한 경우에 서로 인접해있다고 간주한다)
한나가 배추를 재배하는 땅은 고르지 못해서 배추를 군데군데 심어놓았다. 배추들이 모여있는 곳에는 배추흰지렁이가 한 마리만 있으면 되므로 서로 인접해있는 배추들이 몇 군데에 퍼져있는지 조사하면 총 몇 마리의 지렁이가 필요한지 알 수 있다.
예를 들어 배추밭이 아래와 같이 구성되어 있으면 최소 5마리의 배추흰지렁이가 필요하다.
(0은 배추가 심어져 있지 않은 땅이고, 1은 배추가 심어져 있는 땅을 나타낸다.)



1
1
0
0
0
0
0
0
0
0


0
1
0
0
0
0
0
0
0
0


0
0
0
0
1
0
0
0
0
0


0
0
0
0
1
0
0
0
0
0


0
0
1
1
0
0
0
1
1
1


0
0
0
0
1
0
0
1
1
1
<입력값>
입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트 케이스에 대해 첫째 줄에는 배추를 심은 배추밭의 가로길이 M(1 ≤ M ≤ 50)과 세로길이 N(1 ≤ N ≤ 50), 그리고 배추가 심어져 있는 위치의 개수 K(1 ≤ K ≤ 2500)이 주어진다. 그 다음 K줄에는 배추의 위치 X(0 ≤ X ≤ M-1), Y(0 ≤ Y ≤ N-1)가 주어진다.
<출력값>
각 테스트 케이스에 대해 필요한 최소의 배추흰지렁이 마리 수를 출력한다.

<문제 1013>
“무한히 넓은 저 우주에 인류만이 홀로 존재한다면, 그건 정말 슬픈 일이 아닐까요”
푸에르토리코 아레시보에 위치한 아레시보 전파망원경(Arecibo radio telescope)은 수십 년째 존재하지 않을 지도 모르는 외계 문명으로부터의 전파를 수신하기 위해 밤하늘을 바라보고 있다.
이 망원경이 수집한 전파 속에서 자연적으로 발생하기 힘든 패턴들을 찾아내어, 그것을 증거로 외계 문명의 존재 여부를 가리려는 노력은 줄곧 이어져왔지만 아직까지도 그러한 패턴은 발견되지 않았다. 한국 천문학계의 자존심 김동혁 박사는 국내 기술로 이러한 탐사를 진행하기 위하여 다음의 전파 표기를 표준으로 삼았다.
전파의 기본 단위는 { 0 , 1 } 두 가지로 구성되어있으며, x+ (  ) 는 임의의 개수(최소 1개) x의 반복으로 이루어진 전파의 집합을 나타낸다.
(xyx)+ (  ) 는 괄호 내의 xyx의 반복으로 이루어진 전파의 집합을 뜻한다. 아래는 이해를 돕기 위한 예제이다.

1+ = { 1, 11, 111, 1111, 11111, … }
10+ = { 10, 100, 1000, 10000, 100000, … }
(01)+ = { 01, 0101, 010101, 01010101, 0101010101, … }
(1001)+ = { 1001, 10011001, 100110011001, … }
10+11 = { 1011, 10011, 100011, 1000011, 10000011, … }
(10+1)+ = { 101, 1001, 10001, 1011001, 1001101, 100011011000001, … }

반복을 의미하는 + 외에도 or 를 의미하는 | 기호가 있다. { x | y } 는 x 혹은 y 를 의미하는 것으로, { 0+ | 1+ } 는 { 0 , 1 , 00 , 11 , 000 , 111 , … } 의 집합을 의미한다. 아래는 두 기호를 복합적으로 사용한 예이다.

(100 | 11)+ = { 100 , 11 , 10011 , 11100 , 1110011100 , 100111111100100, … }

최근 김동혁 박사는 아레시보 전파망원경에서 star Vega(직녀성) 으로부터 수신한 전파 기록의 일부를 조사하여 그 전파들의 패턴을 분석하여 아래와 같이 기록하였다.

(100+1+ | 01)+

김동혁 박사는 다양한 전파 기록 중에서 위의 패턴을 지니는 전파를 가려내는 프로그램을 필요로 한다. 이를 수행할 수 있는 프로그램을 작성하라.
<입력값>
입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트 케이스에 대해 전파를 표현하는, { 0, 1 }만으로 이루어진 문자열이 공백 없이 주어진다. 문자열 길이는 (1 ≤ N ≤ 200)의 범위를 갖는다.
<출력값>
각 테스트 케이스에 대해 주어진 전파가 문제에서 제시한 패턴이면 “YES”를 그렇지 않은 경우는 “NO”를 출력한다. 출력 문자열은 모두 대문자로 구성되어 있다.

<문제 1014>
최백준은 서강대학교에서 “컨닝의 기술”이라는 과목을 가르치고 있다. 이 과목은 상당히 까다롭기로 정평이 나있기 때문에, 몇몇 학생들은 시험을 보는 도중에 다른 사람의 답지를 베끼려 한다.
시험은 N행 * M열 크기의 직사각형 교실에서 이루어진다. 교실은 1*1 크기의 단위 정사각형으로 이루어져 있는데, 각 단위 정사각형은 자리 하나를 의미한다.
최백준은 컨닝을 방지하기 위해서 다음과 같은 전략을 세웠다. 모든 학생은 자신의 왼쪽, 오른쪽, 왼쪽 대각선 위, 오른쪽 대각선 위, 이렇게 총 네 자리에 앉아있는 친구의 답지를 항상 베낀다고 가정한다. 따라서, 자리 배치는 모든 학생이 컨닝을 할 수 없도록 배치되어야 한다.

위의 그림을 보자. A , C , D 혹은 E에 다른 학생을 앉히는 것은 좋은 생각이 아니다. 그 이유는 이미 앉아있는 학생이 그들의 답안지를 베낄 우려가 있기 때문이다. 하지만, B에 다른 학생을 앉힌다면, 두 학생은 서로의 답지를 베낄 수 없어 컨닝의 우려가 없다.
위와 같이 컨닝이 불가능하도록 자리를 배치 하려는 최백준의 행동에 분노한 일부 학생들이 교실의 책상을 부숴버렸기 때문에, 일부 자리에는 학생이 앉을 수 없다.
최백준은 교실의 모양이 주어졌을 때, 이 곳에서 아무도 컨닝을 할 수 없도록 학생을 배치하였을 경우에 교실에 배치할 수 있는 최대 학생 수가 몇 명인지 궁금해졌다. 최백준을 위해 이를 구하는 프로그램을 작성하라.
<입력값>
입력의 첫 줄에는 테스트케이스의 개수 C가 주어진다. 각각의 테스트 케이스는 아래와 같이 두 부분으로 이루어진다.
첫 번째 부분에서는 교실의 세로길이 N과 가로길이 M이 한 줄에 주어진다. (1 ≤ M ≤ 10, 1 ≤ N ≤ 10)
두 번째 부분에서는 정확하게 N줄이 주어진다. 그리고 각 줄은 M개의 문자로 이루어져있다. 모든 문자는 ‘.’(앉을 수 있는 자리) 또는 ‘x’(앉을 수 없는 자리, 소문자)로 구성된다.
<출력값>
각각의 테스트 케이스에 대해 그 교실에서 시험을 볼 수 있는 최대 학생의 수를 출력한다.

<문제 1015>
P[0], P[1], ...., P[N-1]은 0부터 N-1까지(포함)의 수를 한 번씩 포함하고 있는 수열이다. 수열 P를 길이가 N인 배열 A에 적용하면 길이가 N인 배열 B가 된다. 적용하는 방법은 B[P[i]] = A[i]이다.
배열 A가 주어졌을 때, 수열 P를 적용한 결과가 비내림차순이 되는 수열을 찾는 프로그램을 작성하시오. 비내림차순이란, 각각의 원소가 바로 앞에 있는 원소보다 크거나 같을 경우를 말한다. 만약 그러한 수열이 여러개라면 사전순으로 앞서는 것을 출력한다.
<입력값>
첫째 줄에 배열 A의 크기 N이 주어진다. 둘째 줄에는 배열 A의 원소가 0번부터 차례대로 주어진다. N은 50보다 작거나 같은 자연수이고, 배열의 원소는 1,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 비내림차순으로 만드는 수열 P를 출력한다.

<문제 1016>
어떤 수 X가 1보다 큰 제곱수로 나누어 떨어지지 않을 때, 제곱ㄴㄴ수라고 한다. 제곱수는 정수의 제곱이다. min과 max가 주어지면, min과 max를 포함한 사이에 제곱ㄴㄴ수가 몇 개 있는지 출력한다.
<입력값>
첫째 줄에 두 정수 min과 max가 주어진다.
<출력값>
첫째 줄에 [min,max]구간에 제곱ㄴㄴ수가 몇 개인지 출력한다.

<문제 1017>
지민이는 수의 리스트가 있을 때, 이를 짝지어 각 쌍의 합이 소수가 되게 하려고 한다. 예를 들어, {1, 4, 7, 10, 11, 12}가 있다고 하자. 지민이는 다음과 같이 그룹지을 수 있다.
1 + 4 = 5, 7 + 10 = 17, 11 + 12 = 23
또는
1 + 10 = 11, 4 + 7 = 11, 11 + 12 = 23
수의 리스트가 주어졌을 때, 지민이가 모든 수를 다 짝지었을 때, 첫 번째 수와 어떤 수를 짝지었는지 오름차순으로 출력하는 프로그램을 작성하시오. 위의 예제에서 1 + 12 = 13으로 소수이다. 그러나, 남은 4개의 수를 합이 소수가 되게 짝지을 수 있는 방법이 없다. 따라서 예제의 답은 4, 10이다.
<입력값>
첫째 줄에 리스트의 크기 N이 주어진다. N은 50보다 작거나 같은 자연수이며, 짝수이다. 둘째 줄에 리스트에 들어있는 수가 주어진다. 리스트에 들어있는 수는 1,000보다 작거나 같은 자연수이며, 중복되지 않는다.
<출력값>
첫째 줄에 정답을 출력한다. 없으면 -1을 출력한다.

<문제 1018>
지민이는 자신의 저택에서 MN개의 단위 정사각형으로 나누어져 있는 M*N 크기의 보드를 찾았다. 어떤 정사각형은 검은색으로 칠해져 있고, 나머지는 흰색으로 칠해져 있다. 지민이는 이 보드를 잘라서 8*8 크기의 체스판으로 만들려고 한다.
체스판은 검은색과 흰색이 번갈아서 칠해져 있어야 한다. 구체적으로, 각 칸이 검은색과 흰색 중 하나로 색칠되어 있고, 변을 공유하는 두 개의 사각형은 다른 색으로 칠해져 있어야 한다. 따라서 이 정의를 따르면 체스판을 색칠하는 경우는 두 가지뿐이다. 하나는 맨 왼쪽 위 칸이 흰색인 경우, 하나는 검은색인 경우이다.
보드가 체스판처럼 칠해져 있다는 보장이 없어서, 지민이는 8*8 크기의 체스판으로 잘라낸 후에 몇 개의 정사각형을 다시 칠해야겠다고 생각했다. 당연히 8*8 크기는 아무데서나 골라도 된다. 지민이가 다시 칠해야 하는 정사각형의 최소 개수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N과 M이 주어진다. N과 M은 8보다 크거나 같고, 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 보드의 각 행의 상태가 주어진다. B는 검은색이며, W는 흰색이다.
<출력값>
첫째 줄에 지민이가 다시 칠해야 하는 정사각형 개수의 최솟값을 출력한다.

<문제 1019>
지민이는 전체 페이지의 수가 N인 책이 하나 있다. 첫 페이지는 1 페이지이고, 마지막 페이지는 N 페이지이다. 각 숫자가 전체 페이지 번호에서 모두 몇 번 나오는지 구해보자.
<입력값>
첫째 줄에 N이 주어진다. N은 1,000,000,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 0이 총 몇 번 나오는지, 1이 총 몇 번 나오는지, ..., 9가 총 몇 번 나오는지를 공백으로 구분해 출력한다.

<문제 1020>
지민이는 매 초마다 수가 증가하는 N자리의 디지털 카운터를 가지고 있다. 카운터에 나오는 수는 순환된다. 10^N-1에 이르면 다시 0부터 시작한다.
각 숫자는 다음과 같은 7개의 선분으로 이루어져 있다.

    +   +---+   +---+   +   +   +---+
    |       |       |   |   |   |
    +   +---+   +---+   +---+   +---+
    |   |           |       |       |
    +   +---+   +---+       +   +---+

+---+   +---+   +---+   +---+   +---+
|           |   |   |   |   |   |   |
+---+       +   +---+   +---+   +   +
|   |       |   |   |       |   |   |
+---+       +   +---+       +   +---+

모든 인접한 두 개의 선분은 +로 이어져 있다. 예를 들어, 1은 두 개의 선분, 9는 다섯 개의 선분으로 이루어져 있다.
현재 카운터에 나와있는 숫자가 주어진다. 그럴 때, 현재 나와있는 숫자의 선분의 개수와 같은 숫자는 최소 몇 초가 지나야 나오는지 구하는 프로그램을 작성하시오.
1, 2, ..., 9, 그리고 0은 모두 2, 5, 5, 4, 5, 6, 3, 7, 5, 6개의 선분으로 이루어져 있고, 모든 수는 N자리를 채워야 하므로, N자리보다 작을 때는 앞에 0이 있을 수도 있다.
<입력값>
첫째 줄에 현재 카운터에 나와있는 수가 주어진다. N은 그 수의 길이와 같다. (수가 0으로 시작할 수도 있음) 그리고, N은 15보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 최소 몇 초가 지나야 현재 카운터에 나와 있는 수와 선분의 개수가 같아지는지 출력한다.

<문제 1021>
지민이는 N개의 원소를 포함하고 있는 양방향 순환 큐를 가지고 있다. 지민이는 이 큐에서 몇 개의 원소를 뽑아내려고 한다.
지민이는 이 큐에서 다음과 같은 3가지 연산을 수행할 수 있다.

첫 번째 원소를 뽑아낸다. 이 연산을 수행하면, 원래 큐의 원소가 a1, ..., ak이었던 것이 a2, ..., ak와 같이 된다.
왼쪽으로 한 칸 이동시킨다. 이 연산을 수행하면, a1, ..., ak가 a2, ..., ak, a1이 된다.
오른쪽으로 한 칸 이동시킨다. 이 연산을 수행하면, a1, ..., ak가 ak, a1, ..., ak-1이 된다.

큐에 처음에 포함되어 있던 수 N이 주어진다. 그리고 지민이가 뽑아내려고 하는 원소의 위치가 주어진다. (이 위치는 가장 처음 큐에서의 위치이다.) 이때, 그 원소를 주어진 순서대로 뽑아내는데 드는 2번, 3번 연산의 최솟값을 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 큐의 크기 N과 뽑아내려고 하는 수의 개수 M이 주어진다. N은 50보다 작거나 같은 자연수이고, M은 N보다 작거나 같은 자연수이다. 둘째 줄에는 지민이가 뽑아내려고 하는 수의 위치가 순서대로 주어진다. 위치는 1보다 크거나 같고, N보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 문제의 정답을 출력한다.

<문제 1022>
크기가 무한인 정사각형 모눈종이가 있다. 모눈종이의 각 정사각형은 행과 열의 쌍으로 표현할 수 있다.
이 모눈종이 전체를 양의 정수의 소용돌이 모양으로 채울 것이다. 일단 숫자 1을 0행 0열에 쓴다. 그리고 나서 0행 1열에 숫자 2를 쓴다. 거기서 부터 소용돌이는 반시계 방향으로 시작된다. 다음 숫자는 다음과 같이 채우면 된다.

    -3 -2 -1  0  1  2  3
    --------------------
-3 |37 36 35 34 33 32 31
-2 |38 17 16 15 14 13 30
-1 |39 18  5  4  3 12 29
 0 |40 19  6  1  2 11 28
 1 |41 20  7  8  9 10 27
 2 |42 21 22 23 24 25 26
 3 |43 44 45 46 47 48 49
이 문제는 위와 같이 채운 것을 예쁘게 출력하면 된다. r1, c1, r2, c2가 입력으로 주어진다. r1, c1은 가장 왼쪽 위 칸이고, r2, c2는 가장 오른쪽 아래 칸이다.
예쁘게 출력한다는 것은 다음과 같이 출력하는 것이다.

출력은 r1행부터 r2행까지 차례대로 출력한다.
각 원소는 공백으로 구분한다.
모든 행은 같은 길이를 가져야 한다.
공백의 길이는 최소로 해야 한다.
모든 숫자의 길이(앞에 붙는 공백을 포함)는 같아야 한다.
만약 수의 길이가 가장 길이가 긴 수보다 작다면, 왼쪽에서부터 공백을 삽입해 길이를 맞춘다.
<입력값>
첫째 줄에 네 정수 r1, c1, r2, c2가 주어진다.
<출력값>
r2 - r1 + 1개의 줄에 소용돌이를 예쁘게 출력한다.

<문제 1023>
괄호 문자열은 다음과 같이 정의 한다.

빈 문자열은 괄호 문자열이다.
S가 괄호 문자열일 때, (S)도 괄호 문자열이다.
S와 T가 괄호 문자열이라면, ST도 괄호 문자열이다.
모든 괄호 문자열은 위의 3개 규칙으로만 만들 수 있다.

이 문제에서는 괄호 문자열이 아닌 문자열이 나온다. 만약 문자열이 ‘(’와 ‘)’로만 이루어져 있고, 괄호 문자열이 아니라면, 그 문자열을 괄호ㄴㄴ문자열이라고 한다.
길이가 N인 괄호ㄴㄴ문자열 중에 사전순으로 K번째인 문자열을 출력하는 프로그램을 작성하시오. 그러한 것이 없으면 -1을 출력한다. ‘(’가 ‘)’보다 사전순으로 앞선다.
<입력값>
첫째 줄에 두 정수 N과 K가 주어진다.
<출력값>
첫째 줄에 문제의 정답을 출력한다.

<문제 1024>
N과 L이 주어질 때, 합이 N이면서, 길이가 적어도 L인 가장 짧은 연속된 음이 아닌 정수 리스트를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N과 L이 주어진다. N은 1,000,000,000보다 작거나 같은 자연수이고, L은 2보다 크거나 같고, 100보다 작거나 같은 자연수이다.
<출력값>
만약 리스트의 길이가 100보다 작거나 같으면, 연속된 수를 첫째 줄에 공백으로 구분하여 출력한다. 만약 길이가 100보다 크거나 그러한 수열이 없을 때는 -1을 출력한다.

<문제 1025>
지민이는 천장을 보다가 직사각형 격자판을 생각했고, 각 칸에 숫자를 한 자리씩 적어 놓았다.
수업시간이 너무 지루해서 지민이는 행의 숫자가 등차수열이고, 열의 숫자도 등차수열을 이루는 서로 다른 칸의 수열을 생각해 보았다. 그리고 나서 그 수열의 수를 모두 이어 붙였다. 이렇게 만든 수 중에 가장 큰 제곱수를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 세로 크기 N과 가로 크기 M이 주어진다. 둘째 줄부터 N개의 줄에 직사각형 격자판에 쓰여 있는 수가 주어진다. 모두 한자리이다. N과 M은 9보다 작거나 같은 자연수 또는 0이다.
<출력값>
첫째 줄에 지민이가 만든 수 중에 가장 큰 제곱수를 출력한다. 만약 제곱수가 없다면 -1을 출력한다.

<문제 1026>
옛날 옛적에 수학이 항상 큰 골칫거리였던 나라가 있었다. 이 나라의 국왕 김지민은 다음과 같은 문제를 내고 큰 상금을 걸었다.
길이가 N인 정수 배열 A와 B가 있다. 다음과 같이 함수 S를 정의하자.
S = A[0]×B[0] + ... + A[N-1]×B[N-1]
S의 값을 가장 작게 만들기 위해 A의 수를 재배열하자. 단, B에 있는 수는 재배열하면 안 된다.
S의 최솟값을 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N이 주어진다. 둘째 줄에는 A에 있는 N개의 수가 순서대로 주어지고, 셋째 줄에는 B에 있는 수가 순서대로 주어진다. N은 50보다 작거나 같은 자연수이고, A와 B의 각 원소는 100보다 작거나 같은 음이 아닌 정수이다.
<출력값>
첫째 줄에 S의 최솟값을 출력한다.

<문제 1027>
세준시에는 고층 빌딩이 많다. 세준시의 서민 김지민은 가장 많은 고층 빌딩이 보이는 고층 빌딩을 찾으려고 한다. 빌딩은 총 N개가 있는데, 빌딩은 선분으로 나타낸다. i번째 빌딩 (1부터 시작)은 (i,0)부터 (i,높이)의 선분으로 나타낼 수 있다. 고층 빌딩 A에서 다른 고층 빌딩 B가 볼 수 있는 빌딩이 되려면, 두 지붕을 잇는 선분이 A와 B를 제외한 다른 고층 빌딩을 지나거나 접하지 않아야 한다. 가장 많은 고층 빌딩이 보이는 빌딩을 구하고, 거기서 보이는 빌딩의 수를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 빌딩의 수 N이 주어진다. N은 50보다 작거나 같은 자연수이다. 둘째 줄에 1번 빌딩부터 그 높이가 주어진다. 높이는 1,000,000,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 문제의 정답을 출력한다.

<문제 1028>
다이아몬드 광산은 0과 1로 이루어진 R행*C열 크기의 배열이다.
다이아몬드는 1로 이루어진 정사각형의 경계선을 45도 회전시킨 모양이다. 크기가 1, 2, 3인 다이아몬드 모양은 다음과 같이 생겼다.

size 1:    size 2:    size 3:
                         1
              1         1 1
   1         1 1       1   1
              1         1 1
                         1

다이아몬드 광산에서 가장 큰 다이아몬드의 크기를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 R과 C가 주어진다. R과 C는 750보다 작거나 같은 자연수이다. 둘째 줄부터 R개의 줄에는 다이아몬드 광산의 모양이 주어진다.
<출력값>
첫째 줄에 다이아몬드 광산에서 가장 큰 다이아몬드의 크기를 출력한다. 만약 다이아몬드가 없을 때는 0을 출력한다.

<문제 1029>
예술을 사랑하는 사람들이 시장에 모여서 그들의 그림을 서로 거래하려고 한다. 모든 그림의 거래는 다음과 같은 조건을 만족해야 한다.

그림을 팔 때, 그림을 산 가격보다 크거나 같은 가격으로 팔아야 한다.
같은 그림을 두 번 이상 사는 것은 불가능하다.

방금 시장에 새로운 그림이 들어왔다. 1번 아티스트는 그 그림을 외부 상인에게 가격 0을 주고 샀다. 이제 그 그림을 자신의 예술가 친구들에게 팔려고 한다. 위의 조건을 모두 만족하는 거래만 이루어진다고 가정했을 때, 그림을 소유했던 사람의 수의 최댓값을 출력하는 프로그램을 작성하시오. (1번 아티스트와 마지막으로 그 그림을 소유한 사람도 포함한다).
<입력값>
첫째 줄에 예술가의 수 N이 주어진다. N은 2보다 크거나 같고, 15보다 작거나 같은 자연수이다.
둘째 줄부터 N개의 줄에는 N개의 수가 주어진다. i번째 줄의 j번째 수는 j번 예술가가 i번 예술가에게 그 그림을 살 때의 가격이다. 모든 가격은 0이 제일 낮은 가격이고, 9가 제일 높은 가격이다.
<출력값>
첫째 줄에 그 그림을 소유 했던 사람들 (잠시라도 소유했던 사람도 포함)의 최댓값을 출력한다.

<문제 1030>
프렉탈 평면은 다음과 같이 커진다. 시간 0에서 프렉탈은 흰색 정사각형 하나이다. 단위 시간(1)이 진행될 때마다 N×N개의 크기가 동일한 단위 정사각형으로 나누어진다. 만약 나누어진 정사각형이 흰색이라면 가운데 K×K 정사각형이 검정색으로 채워진다. N과 K는 둘 다 홀수이거나, 둘 다 짝수이다.
예를 들어, N=3, K=1이라면, 시간 1에 3×3 정사각형이 된다. 가운데 정사각형은 검정색이고, 나머지는 흰색이 된다. 시간 2때 9×9 정사각형이 되고, 17개는 검정이고, 나머지는 흰색이다.

s, N, K, R1, R2, C1, C2가 주어질 때, 시간 s일 때, R1행 C1열부터 R2행 C2열까지의 모습을 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 7개의 정수 s, N, K, R1, R2, C1, C2가 주어진다.
<출력값>
첫째 줄에 문제의 정답을 출력한다. 첫째 줄에 R1행의 모습을 출력하고 이런 식으로 총 R2-R1+1개의 줄에 출력하면 된다. 각 행의 모습을 출력할 때, C1열부터 C2열까지 차례대로 흰색이면 숫자 '0' 검정이면 숫자 '1'을 출력한다. 숫자 사이에 공백을 넣으면 안 된다.

<문제 1031>
서울의 서쪽에서 스타를 가장 잘하는 팀은 지민이의 팀이고, 동쪽에서 가장 잘하는 팀은 한수의 팀이다.
두 사람은 누가 서울에서 가장 스타크래프트를 잘하는지 결정하기 위해 대결을 하기로 했다.
지민이의 팀은 총 N명, 한수의 팀은 총 M명이다. 모든 팀원은 한 사람당 해야 하는 경기의 수가 정해져 있다. 이 숫자는 사람마다 다를 수 있다.
경기 대진표는 다음과 같은 규칙을 지켜서 만들어야 한다.

모든 경기는 지민이의 팀 중 한 명, 한수의 팀 중 한 명이 대결한다.
같은 대결은 최대 한 번 할 수 있다.
모든 팀원은 한 사람당 해야 하는 경기의 수 만큼 경기를 해야 한다.
가능한 경기 대진표가 여러 가지라면 사전 순으로 가장 앞서는 것을 선택한다. 사전 순의 정의는 후술한다.

경기 대진표는 N*M 크기의 행렬이다. 행은 지민이의 팀에 대응하고, 열은 한수의 팀에 대응한다. (i,j)가 1이면 지민이의 팀의 i번 선수와 한수의 팀의 j번 선수가 대결을 하는 것이고, 0이면 대결을 하지 않는 것이다.
대진표의 사전 순 비교는 다음과 같이 정의된다. 두 대진표의 행 중에서 맨 처음으로 다른 행 i를 찾는다. 그리고 나서 그 행에서 가장 처음 다른 열 j를 찾는다. (i,j)가 0인 대진표가 사전 순으로 앞서는 대진표이다.
지민이의 팀의 각 팀원이 해야 하는 경기의 수, 한수의 팀의 각 팀원이 해야 하는 경기의 수가 주어졌을 때, 사전 순으로 가장 앞서는 대진표를 출력하는 프로그램을 작성하시오. 만약 가능한 대진표가 없으면 -1을 출력한다.
<입력값>
첫째 줄에 지민이의 팀의 팀원 수 N과 한수의 팀의 팀원 수 M이 주어진다. 둘째 줄에는 지민이의 팀의 각 팀원이 해야 하는 경기의 수가 주어지고, 셋째 줄에는 한수의 팀의 각 팀원이 해야 하는 경기의 수가 주어진다. N과 M은 50보다 작거나 같은 자연수이고, 경기의 수는 50보다 작거나 같은 자연수 또는 0이다.
<출력값>
대진표를 N개의 줄에 출력한다.

<문제 1032>
시작 -> 실행 -> cmd를 쳐보자. 검정 화면이 눈에 보인다. 여기서 dir이라고 치면 그 디렉토리에 있는 서브디렉토리와 파일이 모두 나온다. 이때 원하는 파일을 찾으려면 다음과 같이 하면 된다.
dir *.exe라고 치면 확장자가 exe인 파일이 다 나온다. "dir 패턴"과 같이 치면 그 패턴에 맞는 파일만 검색 결과로 나온다. 예를 들어, dir a?b.exe라고 검색하면 파일명의 첫 번째 글자가 a이고, 세 번째 글자가 b이고, 확장자가 exe인 것이 모두 나온다. 이때 두 번째 문자는 아무거나 나와도 된다. 예를 들어, acb.exe, aab.exe, apb.exe가 나온다.
이 문제는 검색 결과가 먼저 주어졌을 때, 패턴으로 뭘 쳐야 그 결과가 나오는지를 출력하는 문제이다. 패턴에는 알파벳과 "." 그리고 "?"만 넣을 수 있다. 가능하면 ?을 적게 써야 한다. 그 디렉토리에는 검색 결과에 나온 파일만 있다고 가정하고, 파일 이름의 길이는 모두 같다.
<입력값>
첫째 줄에 파일 이름의 개수 N이 주어진다. 둘째 줄부터 N개의 줄에는 파일 이름이 주어진다. N은 50보다 작거나 같은 자연수이고 파일 이름의 길이는 모두 같고 길이는 최대 50이다. 파일이름은 알파벳과 "." 그리고 "?"로만 이루어져 있다.
<출력값>
첫째 줄에 패턴을 출력하면 된다.

<문제 1033>
august14는 세상에서 가장 맛있는 칵테일이다. 이 칵테일을 만드는 정확한 방법은 아직 세상에 공개되지 않았지만, 들어가는 재료 N개는 공개되어 있다. 
경근이는 인터넷 검색을 통해서 재료 쌍 N-1개의 비율을 알아냈고, 이 비율을 이용해서 칵테일에 들어가는 전체 재료의 비율을 알아낼 수 있다.
총 재료 쌍 N-1개의 비율이 입력으로 주어진다. 이때, 칵테일을 만드는데 필요한 각 재료의 양을 구하는 프로그램을 작성하시오. 이때, 필요한 재료의 질량을 모두 더한 값이 최소가 되어야 한다. 칵테일을 만드는 재료의 양은 정수이고, 총 질량은 0보다 커야한다.
비율은 "a b p q"와 같은 형식이고, a번 재료의 질량을 b번 재료의 질량으로 나눈 값이 p/q라는 뜻이다.
<입력값>
첫째 줄에 august14를 만드는데 필요한 재료의 개수 N이 주어지며, N은 10보다 작거나 같은 자연수이다.
둘째 줄부터 N-1개의 줄에는 재료 쌍의 비율이 한 줄에 하나씩 주어지는데, 문제 설명에 나온 형식인 "a b p q"로 주어진다. 재료는 0번부터 N-1까지이며, a와 b는 모두 N-1보다 작거나 같은 자연수, 또는 0이다. p와 q는 9보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 칵테일을 만드는데 필요한 각 재료의 질량을 0번 재료부터 순서대로 공백으로 구분해 출력한다.

<문제 1034>
지민이는 각 칸마다 (1*1크기의 정사각형) 램프가 들어있는 직사각형 모양의 탁자를 샀다. 모든 램프는 켜져있거나 꺼져있다. 각 열의 아래에는 스위치가 하나씩 달려있는데, 이 스위치를 누를 때마다 그 열에 있는 램프의 상태가 바뀐다. (켜져있는 램프는 꺼지고, 꺼져있는 램프는 켜진다)
만약 어떤 행에 있는 램프가 모두 켜져있을 때, 그 행이 켜져있다고 말한다. 지민이는 스위치를 K번 누를 것이다. 서로다른 스위치 K개를 누르지 않아도 된다. 지민이는 스위치를 K번 눌러서 켜져있는 행을 최대로 하려고 한다.
지민이의 탁자에 있는 램프의 상태와 K가 주어졌을 때, 스위치를 K번 누른 후에 켜져있는 행의 최댓값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N과 M이 주어진다. N은 행의 개수이고, M은 열의 개수이다. N과 M은 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 램프의 상태가 주어진다. 1이 켜져있는 상태이고, 0이 꺼져있는 상태이다. 마지막 줄에는 K가 주어진다. K는 1,000보다 작거나 같은 자연수 또는 0이다.
<출력값>
첫째 줄에 문제의 정답을 출력한다.

<문제 1035>
최대 5개의 조각이 있는 5*5 크기의 보드가 있다. 김지민은 조각을 적절히 움직여서 모든 조각이 연결 요소를 이루게 하려고 한다. 즉 상하좌우로 인접한 조각을 모두 연결했을 때, 모든 쌍의 조각이 적어도 하나의 경로로 연결되어 있어야 한다.
한 번의 이동으로 하나의 조각을 상하좌우로 인접한 칸으로 옮길 수 있다. 보드의 상태가 주어질 때, 최소 몇 번 이동해야 모든 조각이 연결 요소를 이루게 되는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄부터 다섯째 줄까지 보드의 상태가 주어진다. 빈 곳은 "."이고, 조각은 "*"이다. 조각은 1개 이상 5개 이하이다.
<출력값>
첫째 줄에 문제의 정답을 출력한다.

<문제 1036>
36진법의 숫자는 0부터 9까지의 수와 알파벳 A에서 Z로 나타낸다. A부터 Z까지 알파벳은 10부터 35에 차례대로 대응한다.
36진법의 수 N개가 주어진다. 36진법 숫자(0-9, A-Z) 중에서 K개의 숫자를 고른다. 그러고 나서 N개의 수 모두에서 나타난 그 숫자를 Z로 바꾼다. 그 이후에 N개의 수를 모두 더한다.
이때 가능한 합의 최댓값을 구하는 프로그램을 작성하시오. 합의 최댓값도 36진수로 출력한다.
<입력값>
첫째 줄에 수의 개수 N이 주어진다. 둘째 줄부터 N개의 줄에 수가 주어진다. N은 최대 50이고, 수의 길이도 최대 50이다. 마지막 줄에 K가 주어진다. K는 36보다 작거나 같은 자연수 또는 0이다.
<출력값>
첫째 줄에 문제의 정답을 출력한다.

<문제 1037>
양수 A가 N의 진짜 약수가 되려면, N이 A의 배수이고, A가 1과 N이 아니어야 한다. 어떤 수 N의 진짜 약수가 모두 주어질 때, N을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N의 진짜 약수의 개수가 주어진다. 이 개수는 50보다 작거나 같은 자연수이다. 둘째 줄에는 N의 진짜 약수가 주어진다. 1,000,000보다 작거나 같고, 2보다 크거나 같은 자연수이고, 중복되지 않는다.
<출력값>
첫째 줄에 N을 출력한다. N은 항상 32비트 부호있는 정수로 표현할 수 있다.

<문제 1038>
음이 아닌 정수 X의 자릿수가 가장 큰 자릿수부터 작은 자릿수까지 감소한다면, 그 수를 감소하는 수라고 한다. 예를 들어, 321과 950은 감소하는 수지만, 322와 958은 아니다. N번째 감소하는 수를 출력하는 프로그램을 작성하시오. 0은 0번째 감소하는 수이고, 1은 1번째 감소하는 수이다. 만약 N번째 감소하는 수가 없다면 -1을 출력한다.
<입력값>
첫째 줄에 N이 주어진다. N은 1,000,000보다 작거나 같은 자연수 또는 0이다.
<출력값>
첫째 줄에 N번째 감소하는 수를 출력한다.

<문제 1039>
0으로 시작하지 않는 정수 N이 주어진다. 이때, M을 정수 N의 자릿수라고 했을 때, 다음과 같은 연산을 K번 수행한다.

1 ≤ i < j ≤ M인 i와 j를 고른다. 그 다음, i번 위치의 숫자와 j번 위치의 숫자를 바꾼다. 이때, 바꾼 수가 0으로 시작하면 안 된다.

위의 연산을 K번 했을 때, 나올 수 있는 수의 최댓값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 정수 N과 K가 주어진다. N은 1,000,000보다 작거나 같은 자연수이고, K는 10보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 문제에 주어진 연산을 K번 했을 때, 만들 수 있는 가장 큰 수를 출력한다. 만약 연산을 K번 할 수 없으면 -1을 출력한다.

<문제 1040>
정수 N이 주어진다. N보다 크거나 같은 수 중에, K개의 서로 다른 숫자로 이루어진 수 중 가장 작은 수를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N과 K가 주어진다. N은 1018보다 작거나 같은 자연수이다. K는 10보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 문제의 정답을 출력한다.

<문제 1041>
+---+        
    | D |        
+---+---+---+---+
| E | A | B | F |
+---+---+---+---+
    | C |        
    +---+        

주사위는 위와 같이 생겼다. 주사위의 여섯 면에는 수가 쓰여 있다. 위의 전개도를 수가 밖으로 나오게 접는다.
A, B, C, D, E, F에 쓰여 있는 수가 주어진다.
지민이는 현재 동일한 주사위를 N3개 가지고 있다. 이 주사위를 적절히 회전시키고 쌓아서, N×N×N크기의 정육면체를 만들려고 한다. 이 정육면체는 탁자위에 있으므로, 5개의 면만 보인다.
N과 주사위에 쓰여 있는 수가 주어질 때, 보이는 5개의 면에 쓰여 있는 수의 합의 최솟값을 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N이 주어진다. 둘째 줄에 주사위에 쓰여 있는 수가 주어진다. 위의 그림에서 A, B, C, D, E, F에 쓰여 있는 수가 차례대로 주어진다. N은 1,000,000보다 작거나 같은 자연수이고, 쓰여 있는 수는 50보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 문제의 정답을 출력한다.

<문제 1042>
DNA 문자열은 뉴클레오타이드(A, C, G, T)로 이루어진 문자열이다. 어떤 DNA 문자열은 단백질로 바꿀 수 있는데, 이것은 아미노산으로 이루어진 길이가 0이 아닌 수열이다. DNA 변환 과정을 살펴보자.

뉴클레오타이드를 왼쪽부터 차례대로 3개씩 겹치지 않게 자른다. 3개씩 잘라서 만든 조각 각각을 코돈이라고 한다. 마지막에 한 개 또는 두 개의 뉴클레오타이드가 남으면 무시한다. 예를 들어, DNA 문자열이 ACCTGTACG라면 ACC, TGT, ACG 코돈이 순서대로 나오고, 문자열이 ACCTGTAC라면 ACC, TGT 코돈이 순서대로 나오고 AC는 무시된다.
코돈 변환 표가 주어진다. 이제 왼쪽부터 차례대로 코돈 변환 표에서 그 코돈을 찾아서 대응하는 아미노산으로 바꾸면 된다. 만약 대응하는 것이 없다면, 이 문자열은 단백질로 변환되지 못한다. 예를 들어, ACC가 thr에 대응하고, TGT가 cys에 대응하고, ACG가 thr에 대응한다면, DNA 문자열 ACCTGTACG는 thr cys thr로 변환될 것이다.

가끔 DNA 문자열 중 하나 이상의 뉴클레오타이드가 사라지기도 한다. 이러한 현상을 결실이라고 한다. 예를 들어, DNA 문자열이 ACTG인데 결실이 일어난다면 ACG나 CG 등이 될 수 있다.
DNA 문자열과 코돈 변환 표가 주어졌을 때, 결실이 0번 이상 일어났을 때 나올 수 있는 서로 다른 단백질이 몇 개인지 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 DNA 문자열이 주어진다. 길이는 최대 2,600이다. 둘째 줄에는 코돈 변환 표에 들어있는 코돈의 개수 M이 주어지고, 이 수는 50보다 작거나 같다. 셋째 줄부터 M개의 줄에는 코돈 변환 표가 주어지는데, 각 줄에는 코돈과 아미노산이 순서대로 주어진다. 코돈은 A, C, G, T로만 이루어진 길이가 3인 문자열이고, 아미노산은 알파벳 소문자 또는 대문자로 이루어진 길이가 최대 20인 비어있지 않은 문자열이다. 코돈 변환 표에서 중복되는 코돈은 주어지지 않는다.
<출력값>
첫째 줄에 서로 다른 단백질 개수를 1,000,000,007로 나눈 나머지를 출력한다.

<문제 1043>
지민이는 파티에 가서 이야기 하는 것을 좋아한다. 파티에 갈 때마다, 지민이는 지민이가 가장 좋아하는 이야기를 한다. 지민이는 그 이야기를 말할 때, 있는 그대로 진실로 말하거나 엄청나게 과장해서 말한다. 당연히 과장해서 이야기하는 것이 훨씬 더 재미있기 때문에, 되도록이면 과장해서 이야기하려고 한다. 하지만, 지민이는 거짓말쟁이로 알려지기는 싫어한다. 문제는 몇몇 사람들은 그 이야기의 진실을 안다는 것이다. 따라서 이런 사람들이 파티에 왔을 때는, 지민이는 진실을 이야기할 수 밖에 없다. 당연히, 어떤 사람이 어떤 파티에서는 진실을 듣고, 또다른 파티에서는 과장된 이야기를 들었을 때도 지민이는 거짓말쟁이로 알려지게 된다. 지민이는 이런 일을 모두 피해야 한다.
사람의 수 N이 주어진다. 그리고 그 이야기의 진실을 아는 사람이 주어진다. 그리고 각 파티에 오는 사람들의 번호가 주어진다. 지민이는 모든 파티에 참가해야 한다. 이때, 지민이가 거짓말쟁이로 알려지지 않으면서, 과장된 이야기를 할 수 있는 파티 개수의 최댓값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 사람의 수 N과 파티의 수 M이 주어진다.
둘째 줄에는 이야기의 진실을 아는 사람의 수와 번호가 주어진다. 진실을 아는 사람의 수가 먼저 주어지고 그 개수만큼 사람들의 번호가 주어진다. 사람들의 번호는 1부터 N까지의 수로 주어진다.
셋째 줄부터 M개의 줄에는 각 파티마다 오는 사람의 수와 번호가 같은 방식으로 주어진다.
N, M은 50 이하의 자연수이고, 진실을 아는 사람의 수와 각 파티마다 오는 사람의 수는 모두 0 이상 50 이하의 정수이다.
<출력값>
첫째 줄에 문제의 정답을 출력한다.

<문제 1044>
팀원의 수가 서로 같은 팀을 만들려고 하는 두 명의 대장이 있다. 선수는 현재 N명이 있고, 두 팀장은 각 선수에게 자기 나름대로의 점수를 매겼다. 각 팀의 점수는 그 팀의 팀장이 자신의 팀원에게 매긴 점수의 합이다. 모든 선수는 두 팀 중 하나에 속해야 하고, 이제 두 팀의 점수의 차이가 최소가 되게 팀을 나눠야 한다. 각 선수가 무슨 팀에 속해야 두 팀의 점수의 차이가 최소가 되는지를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 선수의 수 N이 주어진다. N은 2보다 크거나 같고, 36보다 작거나 같은 짝수이다. 둘째 줄에는 팀장1이 각 선수에게 매긴 점수가 주어지고, 셋째 줄에는 팀장2가 각 선수에게 매긴 점수가 주어진다. 모든 점수는 10^15보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 선수1부터 각 선수가 어떤 팀에 속해야 하는지 출력한다. 팀장1의 팀이 팀 1이며, 팀장2의 팀이 팀 2이다. 만약 그러한 것이 여러 개라면 사전순으로 앞서는 것을 출력한다.

<문제 1045>
0부터 N-1까지의 번호가 매겨져 있는 N개의 도시와 두 도시를 연결하는 도로가 있다. 도로에는 우선순위가 있는데, A와 B가 (A < B) 도로 x로 연결되어 있고, C와 D가 (C < D) 도로 y로 연결되어 있을 때, 튜플 (A, B) < (C, D)이면 x > y, 즉 x의 우선순위가 더 높다. 여기서 ai ≠ bi인 가장 작은 양의 정수 i에 대해 ai < bi이면 (a1, ..., ak) < (b1, ..., bk)로 정의한다.
도로의 집합은 하나 이상의 도로가 우선순위에 대한 내림차순으로 정렬되어 있는 것이다. 집합 사이에도 우선순위가 있는데, 두 집합을 튜플로 나타냈을 때의 우선순위를 따른다. 한 집합에 있는 도로만으로 임의의 도시에서 임의의 도시로 이동할 수 있을 때, 그 집합은 연결되어 있다고 한다.
김지민이 할 일은 M개의 도로를 가진 도로의 집합 중 연결되어 있으면서 우선 순위가 가장 높은 것을 찾는 것이다.
<입력값>
첫째 줄에 도시의 개수 N과 M이 주어진다. N은 50보다 작거나 같은 자연수이고, M은 N-1보다 크거나 같고, 1,000보다 작거나 같은 정수이다. 둘째 줄부터 N개의 줄에는 인접행렬이 주어진다. 즉 i번째 행의 j번째 열이 Y이면 도시 i와 j를 연결하는 도로가 존재하고, N이면 존재하지 않는다. i와 j가 연결되어 있으면 j와 i도 연결되어 있음이 보장되고, i와 i는 연결되어 있지 않다.
<출력값>
만약 정답이 없을 때는 -1을 출력한다. 정답이 존재하면, 그 집합에 속하는 도로 중 0을 끝점으로 갖는 도로의 개수, 1을 끝점으로 갖는 도로의 개수, ..., N-1을 끝점으로 갖는 도로의 개수를 차례로 출력한다.

<문제 1046>
직사각형 모양의 방이 있다. 방의 크기는 N*M이고, 1*1크기의 단위 정사각형으로 나누어져 있다. 방에는 빈 곳, 벽, 광원이 있다.
다음과 같이 생긴 방을 보자
 

 
  그림자의 크기는 13.5이다.
  방의 모양이 주어질 때, 그림자의 크기를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N과 M이 주어진다. N과 M은 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 방의 모양이 주어진다. ‘.’은 빈칸, ‘#’은 벽, ‘*’은 광원이다. 방에는 단 한 개의 광원이 있다.
<출력값>
첫째 줄에 문제의 정답을 출력한다. 절대/상대 오차는 10-9까지 허용한다.

<문제 1047>
은진이의 집 앞에는 많은 나무가 심어져 있는 아름다운 정원이 있다.
최근에 새로운 법이 제정되었다. 이 법은 모든 정원은 울타리로 둘러쌓여야 한다는 법이다. 울타리는 반드시 변이 축에 평행한 직사각형 모양이어야 한다. 모든 나무는 울타리의 안에 있거나, 울타리의 경계에 접해 있어야 한다.
이러한 새로운 법을 듣게된 은진이는 마음이 아팠다. 안타깝게도, 은진이는 울타리를 만들 나무를 살 돈이 없다. 따라서, 은진이는 정원에 심어져있는 나무를 조금 잘라 울타리를 만드는 방법밖에 없다.
각 나무가 심어져 있는 (x, y)위치와, 나무를 베었을 때, 만들 수 있는 울타리의 길이가 주어진다.
은진이는 나무를 매우 사랑하기 때문에, 나무를 되도록이면 조금만 나무를 벌목하려고 한다. 은진이가 새로운 법을 지키기 위해 잘라야 하는 나무 개수의 최솟값을 구하는 프로그램을 작성하시오.
가로 세로의 길이 중 하나가 0이어도 직사각형이며, 모두 0이어도 직사각형이다.
<입력값>
첫째 줄에 N이 주어진다. N은 2보다 크거나 같고, 40보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 각 나무가 심어져 있는 위치와 그 나무로 만들 수 있는 울타리의 길이가 순서대로 주어진다. 모든 값은 1,000,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 문제의 정답을 출력한다.

<문제 1048>
유니콘은 체스에서 나이트와 비슷한 말이다. 단, 나이트는 두 칸을 한 방향으로 움직이고, 또 다른 한 칸을 다른 방향으로  움직이지만, 유니콘은 두 칸보다 많은 칸을 한 방향으로 움직이고, 한 칸보다 많은 칸을 또다른 방향으로 움직인다.
좀 더 정확하게 유니콘이 움직이는 방법을 살펴보면 다음과 같다.

유니콘을 든다.
유니콘을 4개의 기본 방향 중 하나로 두 칸보다 많이 움직인다.
유니콘을 방금 움직인 방향과 수직인 방향 2개 중 하나로 한 칸보다 많이 움직인다.
유니콘을 놓는다.

체스판의 크기는 N*M이다. 체스판의 각 칸에는 알파벳의 처음 L개의 문자 중 하나가 쓰여 있다.
N, M, L, 그리고 단어가 주어진다. 유니콘이 움직인 경로 (유니콘을 놓은 곳)가 입력으로 주어진 단어와 일치하는 경우의 수를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N M L이 주어진다. N과 M은 300보다 작거나 같은 자연수이다. L은 26보다 작거나 같은 자연수이다. 둘째 줄에 단어가 주어진다. 단어의 길이는 최대 50이며, 알파벳 대문자로만 이루어져 있다. 셋째 줄 부터 N개의 줄에 체스판에 쓰여 있는 단어가 주어진다.
<출력값>
첫째 줄에 경로를 1,000,000,007로 나눈 나머지를 출력한다.

<문제 1049>
Day Of Mourning의 기타리스트 강토가 사용하는 기타에서 N개의 줄이 끊어졌다. 따라서 새로운 줄을 사거나 교체해야 한다. 강토는 되도록이면 돈을 적게 쓰려고 한다. 6줄 패키지를 살 수도 있고, 1개 또는 그 이상의 줄을 낱개로 살 수도 있다.
끊어진 기타줄의 개수 N과 기타줄 브랜드 M개가 주어지고, 각각의 브랜드에서 파는 기타줄 6개가 들어있는 패키지의 가격, 낱개로 살 때의 가격이 주어질 때, 적어도 N개를 사기 위해 필요한 돈의 수를 최소로 하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N과 M이 주어진다. N은 100보다 작거나 같은 자연수이고, M은 50보다 작거나 같은 자연수이다. 둘째 줄부터 M개의 줄에는 각 브랜드의 패키지 가격과 낱개의 가격이 공백으로 구분하여 주어진다. 가격은 0보다 크거나 같고, 1,000보다 작거나 같은 정수이다.
<출력값>
첫째 줄에 기타줄을 적어도 N개 사기 위해 필요한 돈의 최솟값을 출력한다.

<문제 1050>
과학자 임문빈은 마법의 물약을 만든다. 임문빈은 많은 재료를 가지고 있고, 다음과 같은 식을 이용해서 만든다.
S=N1×S1+...+Nk×Sk
여기서 N1, ..., Nk는 1보다 크거나 같고, 9보다 작거나 같은 한 자리 숫자이고, S1, ..., Sk는 재료의 이름이다. 그리고, k는 1보다 크거나 같은 자연수이다. 마지막으로 S는 마법의 물약의 이름이다. 위의 식은 N1만큼 S1을 넣고, ..., Nk만큼 Sk를 넣으면 S가 1만큼 만들어 진다는 얘기와 같다.
같은 물약을 만드는데 여러 가지 재료법이 있을 수도 있다. 이때는, 아무거나 사용하면 된다. 마법의 물약은 또 다른 물약을 만드는데 재료가 될 수도 있고, 이 중 어떤 재료는 시장에서 살 수 있다.
임문빈은 이름이 LOVE인 마법의 물약을 만들려고 한다. (이 물약을 먹으면 임문빈을 사랑하게 된다) 시장에서 파는 재료와 그 가격이 주어지고, 임문빈이 만들 수 있는 모든 물약의 식이 주어진다. 이때, LOVE를 1만큼 만드는데 드는 비용의 최솟값을 출력한다.
<입력값>
첫째 줄에 시장에서 파는 재료의 개수 N과 임문빈이 만들 수 있는 물약의 식의 개수 M이 주어진다. 둘째 줄 부터 N개의 줄에는 시장에서 파는 재료의 이름과 그 가격이 공백으로 구분해서 주어진다. 재료의 이름은 오직 알파벳 대문자로만 이루어져 있고, 파는 재료는 중복되지 않는다. 그 다음 줄 부터 M개의 줄에는 물약의 식이 문제 상단과 같은 형식으로 주어진다. N은 50보다 작거나 같은 자연수이고, 재료의 이름의 길이는 최대 50이다. 가격은 100보다 작거나 같은 자연수이다. M은 50보다 작거나 같은 자연수 또는 0이다. 각 식의 길이도 최대 50이다.
<출력값>
첫째 줄에 LOVE를 1만큼 만드는데 드는 비용의 최솟값을 출력한다. 만약 그 값이 1000000000보다 크다면 1000000001을 출력한다. 만약 LOVE를 만드는 것이 불가능 하다면 -1을 출력한다.

<문제 1051>
N*M크기의 직사각형이 있다. 각 칸은 한 자리 숫자가 적혀 있다. 이 직사각형에서 꼭짓점에 쓰여 있는 수가 모두 같은 가장 큰 정사각형을 찾는 프로그램을 작성하시오. 이때, 정사각형은 행 또는 열에 평행해야 한다.
<입력값>
첫째 줄에 N과 M이 주어진다. N과 M은 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 수가 주어진다.
<출력값>
첫째 줄에 정답 정사각형의 크기를 출력한다.

<문제 1052>
지민이는 N개의 물병을 가지고 있다. 각 물병에는 물을 무한대로 부을 수 있다. 처음에 모든 물병에는 물이 1리터씩 들어있다. 지민이는 이 물병을 또 다른 장소로 옮기려고 한다. 지민이는 한 번에 K개의 물병을 옮길 수 있다. 하지만, 지민이는 물을 낭비하기는 싫고, 이동을 한 번보다 많이 하기는 싫다. 따라서, 지민이는 물병의 물을 적절히 재분배해서, K개를 넘지 않는 비어있지 않은 물병을 만들려고 한다.
물은 다음과 같이 재분배 한다.

먼저 같은 양의 물이 들어있는 물병 두 개를 고른다. 그 다음에 한 개의 물병에 다른 한 쪽에 있는 물을 모두 붓는다. 이 방법을 필요한 만큼 계속 한다.

이런 제약 때문에, N개로 K개를 넘지않는 비어있지 않은 물병을 만드는 것이 불가능할 수도 있다. 다행히도, 새로운 물병을 살 수 있다. 상점에서 사는 물병은 물이 1리터 들어있다.
예를 들어, N=3이고, K=1일 때를 보면, 물병 3개로 1개를 만드는 것이 불가능하다. 한 병을 또다른 병에 부으면, 2리터가 들어있는 물병 하나와, 1리터가 들어있는 물병 하나가 남는다. 만약 상점에서 한 개의 물병을 산다면, 2리터가 들어있는 물병 두 개를 만들 수 있고, 마지막으로 4리터가 들어있는 물병 한 개를 만들 수 있다.
<입력값>
첫째 줄에 N과 K가 주어진다. N은 107보다 작거나 같은 자연수이고, K는 1,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 상점에서 사야하는 물병의 최솟값을 출력한다. 만약 정답이 없을 경우에는 -1을 출력한다.

<문제 1053>
팰린드롬이란, 앞에서부터 읽었을 때와, 뒤에서부터 읽었을 때가 같은 문자열이다.
모든 문자열이 팰린드롬이 아니기 때문에 다음과 같은 4가지 연산으로 보통 문자열을 팰린드롬으로 만든다.

문자열의 어떤 위치에 어떤 문자를 삽입 (시작과 끝도 가능)
어떤 위치에 있는 문자를 삭제
어떤 위치에 있는 문자를 교환
서로 다른 문자를 교환

1~3번 연산은 마음껏 사용할 수 있지만, 마지막 연산은 많아야 한 번 사용할 수 있다.
문자열이 주어졌을 때, 팰린드롬으로 만들기 위해 필요한 연산의 최솟값을 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 문자열이 주어진다. 영어 소문자로만 이루어져 있고, 길이는 최대 50이다.
<출력값>
첫째 줄에 문제의 정답을 출력한다.

<문제 1054>
지민이는 단어 N개를 가지고 있고, 이 단어를 이용해서 팰린드롬 문장을 몇 개 만들 수 있는지 알아보려고 한다. 단어는 알파벳 소문자로만 이루어져 있고, 길이는 0보다 크다. 문장은 단어로만 구성되어 있고, 각 단어의 사이에는 공백이 한 칸 있다. 문장의 길이는 0보다 커야 한다.
팰린드롬 문장은 공백을 무시했을 때, 앞에서부터 읽을 때와 뒤에서부터 읽을 때가 같은 것이다.
몇 개의 팰린드롬 문장을 몇 개 만들 수 있는 지 구해보자. 각 단어는 문장 내에서 최대 1번까지 사용할 수 있고, 두 문장이 공백을 무시했을 때 같아도, 생긴 형태가 다르면 서로 다른 문장이다. 예를 들어 “a ba”와 “ab a”는 다른 문장이다.
<입력값>
첫째 줄에 단어의 개수 N(1 ≤ N ≤ 13)이 주어진다. 둘째 줄부터 N개의 줄에 각 단어가 주어진다. 각 단어의 길이는 최대 13이고, 중복되지 않는다.
<출력값>
첫째 줄에 단어를 이용해서 만들 수 있는 팰린드롬 문장의 개수를 출력한다.

<문제 1055>
김지민이 Endless란 프로그램을 만들었다. 맨 처음 이 프로그램을 실행시킬 때는, 어떤 문자열을 입력으로 받는다. 그 이후에는 그 전 실행의 출력이 이번 실행의 입력이 된다.
처음에 입력되는 문자열은 알파벳 소문자로만 이루어져 있다.
이 Endless 프로그램이 하는 일은 다음과 같다. 어떤 문자열 S가 정의되어 있다. 이 문자열 S는 알파벳 소문자와 ‘\$’로 이루어져 있다. 이제 S에서 ‘\$’를 입력으로 들어온 문자열로 모두 바꾼 후에 출력한다.
예를 들어, 처음 입력이 “a”이고, 문자열 S가 “\$meric\$”라고 하자.
그럼 처음 실행될 때는 “america”가 출력된다. 그리고 그 다음 실행 될 때는 그 전의 출력된 문자열이 입력으로 쓰이므로, “americamericamerica”가 출력될 것이다.
처음 입력 문자열과, 문자열 S, 그리고 이 프로그램을 실행 시킬 횟수가 주어질 때, min번째 문자부터 max번째 문자까지 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 이 프로그램의 처음 입력이 주어진다. 길이는 최대 50이다. 둘째 줄에는 문자열 S가 주어진다. 길이는 2보다 크거나 같고, 50보다 작거나 같고, 가장 첫 문자는 항상 ‘$’이다. 셋째 줄에는 실행 시킬 횟수가 주어지며, 1,000,000,000보다 작거나 같은 자연수이다 마지막 줄에는 min과 max가 주어진다. min은 1,000,000,000보다 작거나 같은 자연수이고, max는 min보다 크거나 같고, min+99보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 문제의 정답을 출력한다. 만약 해당하는 문자가 없을 때는 ‘-‘를 대신 출력한다.

<문제 1056>
1부터 시작해서 N을 만들려고 한다. 사용할 수 있는 연산은 아래와 같이 총 3가지이다. 이때, N을 만드는데 사용하는 연산의 최소 횟수를 구하는 프로그램을 작성하시오.

현재 수를 1 증가시킴 (현재 수+1)
현재 수가 1보다 크면 1 감소 시킴 (현재 수-1)
현재 수를 자연수 제곱함. (현재 수^x, x는 자연수)
<입력값>
첫째 줄에 N이 주어진다. N은 1018보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 문제의 정답을 출력한다.

<문제 1057>
김지민은 N명이 참가하는 스타 토너먼트에 진출했다. 토너먼트는 다음과 같이 진행된다. 일단 N명의 참가자는 번호가 1번부터 N번까지 배정받는다. 그러고 난 후에 서로 인접한 번호끼리 스타를 한다. 이긴 사람은 다음 라운드에 진출하고, 진 사람은 그 라운드에서 떨어진다. 만약 그 라운드의 참가자가 홀수명이라면, 마지막 번호를 가진 참가자는 다음 라운드로 자동 진출한다. 다음 라운드에선 다시 참가자의 번호를 1번부터 매긴다. 이때, 번호를 매기는 순서는 처음 번호의 순서를 유지하면서 1번부터 매긴다. 이 말은 1번과 2번이 스타를 해서 1번이 진출하고, 3번과 4번이 스타를 해서 4번이 진출했다면, 4번은 다음 라운드에서 번호 2번을 배정받는다. 번호를 다시 배정받은 후에 한 명만 남을 때까지 라운드를 계속 한다.
마침 이 스타 대회에 임한수도 참가했다. 김지민은 갑자기 스타 대회에서 우승하는 욕심은 없어지고, 몇 라운드에서 임한수와 대결하는지 궁금해졌다. 일단 김지민과 임한수는 서로 대결하기 전까지 항상 이긴다고 가정한다. 1 라운드에서 김지민의 번호와 임한수의 번호가 주어질 때, 과연 김지민과 임한수가 몇 라운드에서 대결하는지 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 참가자의 수 N과 1 라운드에서 김지민의 번호와 임한수의 번호가 순서대로 주어진다. N은 100,000보다 작거나 같은 자연수이고, 김지민의 번호와 임한수의 번호는 N보다 작거나 같은 자연수이고, 서로 다르다.
<출력값>
첫째 줄에 김지민과 임한수가 대결하는 라운드 번호를 출력한다. 만약 서로 대결하지 않을 때는 -1을 출력한다.

<문제 1058>
지민이는 세계에서 가장 유명한 사람이 누구인지 궁금해졌다. 가장 유명한 사람을 구하는 방법은 각 사람의 2-친구를 구하면 된다. 어떤 사람 A가 또다른 사람 B의 2-친구가 되기 위해선, 두 사람이 친구이거나, A와 친구이고, B와 친구인 C가 존재해야 된다. 여기서 가장 유명한 사람은 2-친구의 수가 가장 많은 사람이다. 가장 유명한 사람의 2-친구의 수를 출력하는 프로그램을 작성하시오.A와 B가 친구면, B와 A도 친구이고, A와 A는 친구가 아니다.
<입력값>
첫째 줄에 사람의 수 N이 주어진다. N은 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 각 사람이 친구이면 Y, 아니면 N이 주어진다. (예제를 참고)
<출력값>
첫째 줄에 가장 유명한 사람의 2-친구의 수를 출력한다.

<문제 1059>
정수 집합 S가 주어졌을때, 다음 조건을 만족하는 구간 [A, B]를 좋은 구간이라고 한다.

A와 B는 양의 정수이고, A < B를 만족한다.
A ≤ x ≤ B를 만족하는 모든 정수 x가 집합 S에 속하지 않는다.

집합 S와 n이 주어졌을 때, n을 포함하는 좋은 구간의 개수를 구해보자.
<입력값>
첫째 줄에 집합 S의 크기 L이 주어진다. 둘째 줄에는 집합에 포함된 정수가 주어진다. 셋째 줄에는 n이 주어진다.
<출력값>
첫째 줄에 n을 포함하는 좋은 구간의 개수를 출력한다.

<문제 1060>
정수 집합 S가 주어졌을때, 다음 조건을 만족하는 구간 [A, B]를 좋은 구간이라고 한다.

A와 B는 양의 정수이고, A < B를 만족한다.
A ≤ x ≤ B를 만족하는 모든 정수 x가 집합 S에 속하지 않는다.

정수 x를 포함하는 좋은 구간의 개수가 정수 y를 포함하는 좋은 구간의 개수보다 작으면 x는 y보다 더 좋다고 한다. x와 y를 포함하는 좋은 구간의 개수가 같거나, 구간의 개수가 둘 다 무한대와 같은 경우, 작은 수를 더 좋다고 한다.
집합 S가 주어지고, 이를 이용해 전체 정수를 더 좋은 수가 앞으로 오게 정렬했다고 가정하자. 앞에 오는 수 n개를 구해보자.
<입력값>
첫째 줄에 집합 S의 크기 L이 주어진다. 둘째 줄에는 집합에 포함된 정수가 주어진다. 셋째 줄에는 n이 주어진다.
<출력값>
상위 N개의 수를 공백으로 구분해 출력한다.

<문제 1061>
N*M크기의 직사각형이 있고, 1*1크기의 단위 정사각형으로 나누어져 있다. 각각의 정사각형 중심에는 점이 한 개 찍혀있고, 색은 빨강, 초록, 파랑중의 하나다.
서로 다른 세 개의 점을 선택해보자. (일직선 상에 있어도 된다.) 그리고 세 점을 서로 이은다. 그럼 삼각형을 만들 수 있다. (일직선도 삼각형이다) 만약 이런 삼각형의 꼭짓점 색이 서로 다르다면 이 삼각형을 아름다운 삼각형이라고 한다.
만약 아름다운 삼각형 A와 아름다운 삼각형 B가 두 개의 꼭짓점이 같고, B의 넓이가 A보다 크다면, 삼각형 A를 커질 수 있는 아름다운 삼각형이라고 한다. (일직선 모양의 삼각형 넓이는 0이다)
N*M 직사각형이 주어질 때, 서로 다른 커질 수 있는 아름다운 삼각형의 개수를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N과 M이 주어진다. 둘째 줄부터 N개의 줄에 직사각형 내부 모양이 주어진다. R은 빨강, G는 초록, B는 파랑이다. N과 M은 50보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 커질 수 있는 아름다운 삼각형의 개수를 출력하면 된다.

<문제 1062>
남극에 사는 김지민 선생님은 학생들이 되도록이면 많은 단어를 읽을 수 있도록 하려고 한다. 그러나 지구온난화로 인해 얼음이 녹아서 곧 학교가 무너지기 때문에, 김지민은 K개의 글자를 가르칠 시간 밖에 없다. 김지민이 가르치고 난 후에는, 학생들은 그 K개의 글자로만 이루어진 단어만을 읽을 수 있다. 김지민은 어떤 K개의 글자를 가르쳐야 학생들이 읽을 수 있는 단어의 개수가 최대가 되는지 고민에 빠졌다.
남극언어의 모든 단어는 "anta"로 시작되고, "tica"로 끝난다. 남극언어에 단어는 N개 밖에 없다고 가정한다. 학생들이 읽을 수 있는 단어의 최댓값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 단어의 개수 N과 K가 주어진다. N은 50보다 작거나 같은 자연수이고, K는 26보다 작거나 같은 자연수 또는 0이다. 둘째 줄부터 N개의 줄에 남극 언어의 단어가 주어진다. 단어는 영어 소문자로만 이루어져 있고, 길이가 8보다 크거나 같고, 15보다 작거나 같다. 모든 단어는 중복되지 않는다.
<출력값>
첫째 줄에 김지민이 K개의 글자를 가르칠 때, 학생들이 읽을 수 있는 단어 개수의 최댓값을 출력한다.

<문제 1063>
8*8크기의 체스판에 왕이 하나 있다. 킹의 현재 위치가 주어진다. 체스판에서 말의 위치는 다음과 같이 주어진다. 알파벳 하나와 숫자 하나로 이루어져 있는데, 알파벳은 열을 상징하고, 숫자는 행을 상징한다. 열은 가장 왼쪽 열이 A이고, 가장 오른쪽 열이 H까지 이고, 행은 가장 아래가 1이고 가장 위가 8이다. 예를 들어, 왼쪽 아래 코너는 A1이고, 그 오른쪽 칸은 B1이다.
킹은 다음과 같이 움직일 수 있다.

R : 한 칸 오른쪽으로
L : 한 칸 왼쪽으로
B : 한 칸 아래로
T : 한 칸 위로
RT : 오른쪽 위 대각선으로
LT : 왼쪽 위 대각선으로
RB : 오른쪽 아래 대각선으로
LB : 왼쪽 아래 대각선으로

체스판에는 돌이 하나 있는데, 돌과 같은 곳으로 이동할 때는, 돌을 킹이 움직인 방향과 같은 방향으로 한 칸 이동시킨다. 아래 그림을 참고하자.

입력으로 킹이 어떻게 움직여야 하는지 주어진다. 입력으로 주어진 대로 움직여서 킹이나 돌이 체스판 밖으로 나갈 경우에는 그 이동은 건너 뛰고 다음 이동을 한다.
킹과 돌의 마지막 위치를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 킹의 위치, 돌의 위치, 움직이는 횟수 N이 주어진다. 둘째 줄부터 N개의 줄에는 킹이 어떻게 움직여야 하는지 주어진다. N은 50보다 작거나 같은 자연수이고, 움직이는 정보는 위에 쓰여 있는 8가지 중 하나이다.
<출력값>
첫째 줄에 킹의 마지막 위치, 둘째 줄에 돌의 마지막 위치를 출력한다.

<문제 1064>
평행사변형은 평행한 두 변을 가진 사각형이다. 세 개의 서로 다른 점이 주어진다. A(xA,yA), B(xB,yB), C(xC,yC)
이때, 적절히 점 D를 찾아서 네 점으로 평행사변형을 만들면 된다. 이때, D가 여러 개 나올 수도 있다.
만들어진 모든 사각형 중 가장 큰 둘레 길이와 가장 작은 둘레 길이의 차이를 출력하는 프로그램을 작성하시오. 만약 만들 수 있는 평행사변형이 없다면 -1을 출력한다.
<입력값>
첫째 줄에 xA yA xB yB xC yC가 주어진다. 모두 절댓값이 5000보다 작거나 같은 정수이다.
<출력값>
첫째 줄에 문제의 정답을 출력한다. 절대/상대 오차는 10-9까지 허용한다.

<문제 1065>
어떤 양의 정수 X의 각 자리가 등차수열을 이룬다면, 그 수를 한수라고 한다. 등차수열은 연속된 두 개의 수의 차이가 일정한 수열을 말한다. N이 주어졌을 때, 1보다 크거나 같고, N보다 작거나 같은 한수의 개수를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 1,000보다 작거나 같은 자연수 N이 주어진다.
<출력값>
첫째 줄에 1보다 크거나 같고, N보다 작거나 같은 한수의 개수를 출력한다.

<문제 1066>
어떤 수 X의 자리수를 A개의 연속된 그룹(그룹에 있는 각각의 자리수는 등차수열을 이룬다)으로 나눌 수 있을 때, 그 수를 A한수라고 한다.
만약 어떤 양의 정수가 A한수이면서 A-1한수가 아닐 때, 그리고 그 수의 자리수가 비내림차순일 때, 그 수를 진짜A한수라고 한다.
N과 A가 주어질 때, N자리이면서(가장 첫 수는 0이 아니다) 진짜A한수의 개수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N과 A가 주어진다. 모두 1,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 N자리이면서 진짜A한수의 개수를 1,000,000,007로 나눈 나머지를 출력한다.

<문제 1067>
N개의 수가 있는 X와 Y가 있다. 이때 X나 Y를 순환 이동시킬 수 있다. 순환 이동이란 마지막 원소를 제거하고 그 수를 맨 앞으로 다시 삽입하는 것을 말한다. 예를 들어, {1, 2, 3}을 순환 이동시키면 {3, 1, 2}가 될 것이고, {3, 1, 2}는 {2, 3, 1}이 된다. 순환 이동은 0번 또는 그 이상 할 수 있다. 이 모든 순환 이동을 한 후에 점수를 구하면 된다. 점수 S는 다음과 같이 구한다.
S = X[0]×Y[0] + X[1]×Y[1] + ... + X[N-1]×Y[N-1]
이때 S를 최대로 하면 된다.
<입력값>
첫째 줄에 N이 주어진다. 둘째 줄에는 X에 들어있는 N개의 수가 주어진다. 셋째 줄에는 Y에 있는 수가 모두 주어진다. N은 60,000보다 작거나 같은 자연수이고, X와 Y에 들어있는 모든 수는 100보다 작은 자연수 또는 0이다.
<출력값>
첫째 줄에 S의 최댓값을 출력한다.

<문제 1068>
트리에서 리프 노드란, 자식의 개수가 0인 노드를 말한다.
트리가 주어졌을 때, 노드 하나를 지울 것이다. 그 때, 남은 트리에서 리프 노드의 개수를 구하는 프로그램을 작성하시오. 노드를 지우면 그 노드와 노드의 모든 자손이 트리에서 제거된다.
예를 들어, 다음과 같은 트리가 있다고 하자.

현재 리프 노드의 개수는 3개이다. (초록색 색칠된 노드) 이때, 1번을 지우면, 다음과 같이 변한다. 검정색으로 색칠된 노드가 트리에서 제거된 노드이다.

이제 리프 노드의 개수는 1개이다.
<입력값>
첫째 줄에 트리의 노드의 개수 N이 주어진다. N은 50보다 작거나 같은 자연수이다. 둘째 줄에는 0번 노드부터 N-1번 노드까지, 각 노드의 부모가 주어진다. 만약 부모가 없다면 (루트) -1이 주어진다. 셋째 줄에는 지울 노드의 번호가 주어진다.
<출력값>
첫째 줄에 입력으로 주어진 트리에서 입력으로 주어진 노드를 지웠을 때, 리프 노드의 개수를 출력한다.

<문제 1069>
백은진은 지금 (x, y)에 있고, (0, 0)에 있는 집으로 가능한 빨리 가려고 한다. 백은진은 다음과 같이 두 가지 방법으로 움직일 수 있다.
첫 번째 방법은 걷는것이다. 걸을 때는, 1초에 1만큼 움직인다.
두 번째 방법은 점프하는 것이다. 점프를 하게 되면, T초에 D만큼 움직인다. 점프는 일직선으로만 할 수 있고, 정확하게 D칸만 움직일 수 있다.
위의 두 가지 방법을 이용해서 백은진이 집에 돌아오는데 걸리는 시간의 최솟값을 구하는 프로그램을 작성하시오. 꼭 한 가지 방법만 사용해야 되는것이 아니고, 두 가지 방법을 적절히 조합해서 가장 빠른 시간을 구하는 것이다.
<입력값>
첫째 줄에 X Y D T가 주어진다. X와 Y는 1,000보다 작거나 같은 자연수이고, D와 T는 10,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 백은진이 집에 돌아오는데 걸리는 시간의 최솟값을 출력한다. 절대/상대 오차는 10-9까지 허용한다.

<문제 1070>
임한수가 통치하는 왕국이 반란군 김지민의 침략에 의해 위협받고 있다. 김지민은 생김새와 어울리지 않지만, 영리하게도 모든 방향에서 임한수의 왕국을 침략하고 있다. 임한수는 이 야만인들이 수도에는 들어오지 못하게 해야 한다고 결정했다. 일단 임한수는 왕궁의 지도를 펼쳤다. 지도는 N*M크기의 직사각형 모양이고, 수도는 '*'로 표시되어 있고, 지나갈 수 없는 정사각형은 '-'로 표시되어 있다. 그리고 나머지 정사각형은 지형을 상징하는 알파벳 대문자이다.
임한수는 장애물을 적절히 배치해서 경계에서부터 수도로 갈 수 없도록 할 것이다. 즉, 야만인들이 수도에 갈 수 없어야 하기 때문에, 경계선에서 수도로 가는 모든 경로가 지나갈 수 없는 정사각형 또는 장애물로 막혀있어야 한다. 김지민의 군대는 동서남북으로만 이동할 수 있고, 변을 공유하는 정사각형으로만 이동할 수 있다. 따라서, 모든 경로는 변을 공유하는 정사각형의 집합이다.
각각의 지형은 모두 특정한 크기의 장애물을 필요로 한다. 필요한 장애물의 개수를 최소로 하는 프로그램을 작성하시오. 만약 그러한 경우가 여러개라면 장애물의 크기의 합이 최소가 되는것을 선택한다. 필요한 장애물의 크기의 합을 출력하면 된다.
<입력값>
첫째 줄에 N과 M가 주어진다. N과 M은 50보다 작거나 같고, 3보다 크거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 지도가 주어진다. 마지막 줄에는 26개의 숫자가 주어지는데, 첫 번째 숫자는 A지형에 필요한 장애물의 크기, 두 번째 숫자는 B지형에 필요한 장애물의 크기, ...와 같다.
수도는 한 개만 존재하며, 처음 또는 마지막 열/행에 존재하지 않는다. 또, 장애물의 크기는 1 이상 1,000,000 이하이다.
<출력값>
첫째 줄에 임한수가 설치한 장애물의 크기의 합을 출력한다.

<문제 1071>
N개의 정수가 주어지면, 이것을 연속된 두 수가 연속된 값이 아니게 정렬(A[i] + 1 ≠ A[i+1])하는 프로그램을 작성하시오. 가능한 것이 여러 가지라면 사전순으로 가장 앞서는 것을 출력한다.
<입력값>
첫째 줄에 N이 주어진다. N은 50보다 작거나 같은 자연수이다. 둘째 줄에는 N개의 수가 주어진다. N개의 수는 1,000보다 작거나 같은 자연수 또는 0이다.
<출력값>
첫째 줄에 문제의 정답을 출력한다.

<문제 1072>
김형택은 지금 몰래 Spider Solitaire(스파이더 카드놀이)를 하고 있다. 형택이는 이 게임을 이길 때도 있었지만, 질 때도 있었다. 누군가의 시선이 느껴진 형택이는 게임을 중단하고 코딩을 하기 시작했다. 의심을 피했다고 생각한 형택이는 다시 게임을 켰다. 그 때 형택이는 잠시 코딩을 하는 사이에 자신의 게임 실력이 눈에 띄게 향상된 것을 알았다.
이제 형택이는 앞으로의 모든 게임에서 지지 않는다. 하지만, 형택이는 게임 기록을 삭제 할 수 없기 때문에, 자신의 못하던 예전 기록이 현재 자신의 엄청난 실력을 증명하지 못한다고 생각했다.
게임 기록은 다음과 같이 생겼다.

게임 횟수 : X
이긴 게임 : Y (Z%)
Z는 형택이의 승률이고, 소수점은 버린다. 예를 들어, X=53, Y=47이라면, Z=88이다.

X와 Y가 주어졌을 때, 형택이가 게임을 최소 몇 번 더 해야 Z가 변하는지 구하는 프로그램을 작성하시오.
<입력값>
각 줄에 정수 X와 Y가 주어진다.
<출력값>
첫째 줄에 형택이가 게임을 최소 몇 판 더 해야하는지 출력한다. 만약 Z가 절대 변하지 않는다면 -1을 출력한다.

<문제 1073>
은진이는 도미노 게임을 좋아한다. 도미노는 직사각형 모양이고, 두 개의 정사각형으로 나누어져 있다. 그리고, 각 정사각형에는 0보다 크거나 같고, 9보다 작거나 같은 정수가 하나 쓰여 있다. 따라서, 가능한 모든 조각은 45조각이다. 조각은 뒤집을 수도 있어서, 숫자 1과 2가 포함된 조각은 다음과 같이 하나이다.

안타깝게도, 장엄지가 조각 몇 개를 가지고 가버렸다. 따라서, 은진이는 은진이답게 남은 도미노 조각을 가지고 할 수 있는 게임을 생각했다. 바로 “남은 도미노 조각을 가지고 사이클 콜렉션을 만들 수 있을까?” 이다.
사이클 콜렉션이란, 조각을 공유하지 않는 1개 또는 그 이상의 사이클이 모인 집합이다. 사이클은 i번째 놓인 조각의 왼쪽 번호와 i-1번째 놓인 조각의 오른쪽 번호가 같은 것 끼리 배열한 것이다. 그리고, 가장 처음에 놓은 조각의 왼쪽 번호와 가장 마지막에 놓은 조각의 오른쪽 번호도 같아야 한다.

위의 그림은 같은 조각의 집합을 가지고 만들 수 있는 세 가지 사이클 콜렉션이다.

조각이 연결되어 있다는 말은, 조각을 둘러 싸고 있는 두 조각과 연결되어 있는 것이다. 물론, 처음 조각과 마지막 조각도 연결되어 있는 것이다.
두 사이클이 같다는 말은 각 조각이 두 사이클에서 같은 조각과 연결되어 있을 때이고, 두 사이클 콜렉션이 같다는 말은, 같은 사이클의 집합을 포함할 때이다.
남은 조각이 주어질 때, 사이클 콜렉션을 총 몇 개 만들 수 있는지 구하는 프로그램을 작성하시오. 조각은 모두 사용해야 한다.
<입력값>
첫째 줄에 조각의 개수 N (1 ≤ N ≤ 45)이 주어진다. 둘째 줄부터 N개의 줄에는 각 조각이 주어진다. 조각은 2개의 숫자로 되어 있고, 앞에 있는 숫자는 항상 뒤에 있는 숫자보다 작다. 조각은 중복되지 않는다.
<출력값>
첫째 줄에 만들 수 있는 사이클 콜렉션의 개수를 출력한다. 이 값은 2^63보다 작다.

<문제 1074>
한수는 크기가 2N × 2N인 2차원 배열을 Z모양으로 탐색하려고 한다. 예를 들어, 2×2배열을 왼쪽 위칸, 오른쪽 위칸, 왼쪽 아래칸, 오른쪽 아래칸 순서대로 방문하면 Z모양이다.

만약, N > 1이 라서 왼쪽 위에 있는 칸이 하나가 아니라면, 배열을 크기가 2N-1 × 2N-1로 4등분 한 후에 재귀적으로 순서대로 방문한다.
다음 예는 22 × 22 크기의 배열을 방문한 순서이다.

N이 주어졌을 때, r행 c열을 몇 번째로 방문하는지 출력하는 프로그램을 작성하시오.
다음은 N=3일 때의 예이다.
<입력값>
첫째 줄에 정수 N, r, c가 주어진다.
<출력값>
r행 c열을 몇 번째로 방문했는지 출력한다.

<문제 1075>
두 정수 N과 F가 주어진다. 지민이는 정수 N의 가장 뒤 두 자리를 적절히 바꿔서 N을 F로 나누어 떨어지게 만들려고 한다. 만약 가능한 것이 여러 가지이면, 뒤 두 자리를 가능하면 작게 만들려고 한다.
예를 들어, N=275이고, F=5이면, 답은 00이다. 200이 5로 나누어 떨어지기 때문이다. N=1021이고, F=11이면, 정답은 01인데, 1001이 11로 나누어 떨어지기 때문이다.
<입력값>
첫째 줄에 N, 둘째 줄에 F가 주어진다. N은 100보다 크거나 같고, 2,000,000,000보다 작거나 같은 자연수이다. F는 100보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 마지막 두 자리를 모두 출력한다. 한자리이면 앞에 0을 추가해서 두 자리로 만들어야 한다.

<문제 1076>
전자 제품에는 저항이 들어간다. 저항은 색 3개를 이용해서 그 저항이 몇 옴인지 나타낸다.
처음 색 2개는 저항의 값이고, 마지막 색은 곱해야 하는 값이다.
저항의 값은 다음 표를 이용해서 구한다.



색
값
곱




black
0
1


brown
1
10


red
2
100


orange
3
1000


yellow
4
10000


green
5
100000


blue
6
1000000


violet
7
10000000


grey
8
100000000


white
9
1000000000



예를 들어, 저항에 색이 yellow, violet, red였다면 저항의 값은 4,700이 된다.
<입력값>
첫째 줄에 첫 번째 색, 둘째 줄에 두 번째 색, 셋째 줄에 세 번째 색이 주어진다. 색은 모두 위의 표에 쓰여 있는 색만 주어진다.
<출력값>
입력으로 주어진 저항의 저항값을 계산하여 첫째 줄에 출력한다.

<문제 1077>
두 개의 볼록 다각형이 주어진다. 두 볼록 다각형의 넓이는 0이 아니다. 그리고, 볼록 다각형 1의 꼭짓점은 볼록 다각형2의 변 위에 있지 않고, 그 반대도 마찬가지이다.
이때, 두 볼록 다각형의 겹쳐진 부분의 넓이를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 볼록 다각형1의 꼭짓점의 개수 N, 볼록 다각형2의 꼭짓점의 개수 M이 주어진다. N과 M은 100보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 볼록 다각형1의 꼭짓점이 반시계 방향 순서대로 주어지고, 다음 줄부터 M개의 줄에는 볼록 다각형2의 꼭짓점이 반시계 방향 순서대로 주어진다. 각 좌표의 절댓값은 1,000보다 작거나 같은 정수이다. 그리고 각 볼록 다각형의 넓이는 0이 아니다.
<출력값>
첫째 줄에 두 다각형의 겹친 부분의 넓이를 출력한다. 절대/상대 오차는 10-9까지 허용한다.

<문제 1078>
어떤 수를 뒤집는다는 것은 오른쪽부터 다시 쓰는것이다. 예를 들어, 1234를 뒤집으면 4321이 되고, 100을 뒤집으면 1이 된다. (앞에 0은 무시)
어떤 수 D가 주어질 때, x – (x를 뒤집은 수)가 D가 되는 가장 작은 음이 아닌 정수 x를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 D가 주어진다. D는 1,000,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 가장 작은 x를 출력한다. 만약 그러한 x가 없다면 -1을 출력한다.

<문제 1079>
은진이는 요즘 마피아라는 게임에 빠져 있다. 이 게임의 규칙은 다음과 같다.

참가자는 두 그룹으로 나누어진다. 한 그룹은 마피아이고, 또 다른 그룹은 선량한 시민이다. 마피아의 정체는 시민에게 알려져 있지 않다. 참가자의 번호는 0번부터 시작한다.
참가자가 짝수 명 남았을 때는 밤이다. 밤에는 마피아가 죽일 사람 한 명을 고른다. 죽은 사람은 게임에 더 이상 참여할 수 없다.
참가자가 홀수 명 남았을 때는 낮이다. 낮에는 참가자들이 가장 죄가 있을 것 같은 사람 한 명을 죽인다.
만약 게임에 마피아가 한 명도 안 남았다면, 그 게임은 시민 팀이 이긴 것이고, 시민이 한 명도 안 남았다면, 그 게임은 마피아 팀이 이긴 것이다. 게임은 즉시 종료된다.

게임을 잠시 동안 한 후에 은진이는 지금 이 게임에서 자기가 마지막으로 남은 마피아라는 것을 알았다. 따라서 은진이는 이 게임을 이기기 위해 방법을 생각하기 시작했다.
각 사람의 유죄 지수가 주어진다. 이 유죄 지수는 낮에 시민들이 어떤 참가자를 죽일 것인지 고를 때 쓰인다. 그리고 참가자 간의 반응을 나타내는 2차원 배열 R이 주어진다.
게임은 다음과 같이 진행된다.

밤에는 마피아가 죽일 사람을 한 명 고른다. 이 경우 각 사람의 유죄 지수가 바뀐다. 만약 참가자 i가 죽었다면, 다른 참가자 j의 유죄 지수는 R[i][j]만큼 변한다.
낮에는 현재 게임에 남아있는 사람 중에 유죄 지수가 가장 높은 사람을 죽인다. 그런 사람이 여러 명일 경우 그중 번호가 가장 작은 사람이 죽는다. 이 경우 유죄 지수는 바뀌지 않는다.

은진이는 되도록이면 이 게임을 오래 하고 싶다. 은진이가 이 게임에 정말 천재적으로 임하여 매번 최적의 선택을 할 때, 몇 번의 밤이 지나는지 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 참가자의 수 N이 주어진다. 둘째 줄에는 각 참가자의 유죄 지수가 주어진다. 셋째 줄부터 N개의 줄에는 배열 R이 주어진다. 마지막 줄에는 은진이의 참가자 번호가 주어진다. N은 16보다 작거나 같은 자연수이고, 유죄 지수는 300보다 크거나 같고, 800보다 작거나 같은 자연수이다. R배열에 있는 수는 모두 절댓값이 1보다 크거나 같고 26보다 작거나 같은 정수이다.
<출력값>
첫째 줄에 문제의 정답을 출력한다.

<문제 1080>
0과 1로만 이루어진 행렬 A와 행렬 B가 있다. 이때, 행렬 A를 행렬 B로 바꾸는데 필요한 연산의 횟수의 최솟값을 구하는 프로그램을 작성하시오.
행렬을 변환하는 연산은 어떤 3*3크기의 부분 행렬에 있는 모든 원소를 뒤집는 것이다. (0 -> 1, 1 -> 0)
<입력값>
첫째 줄에 행렬의 크기 N M이 주어진다. N과 M은 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 행렬 A가 주어지고, 그 다음줄부터 N개의 줄에는 행렬 B가 주어진다.
<출력값>
첫째 줄에 문제의 정답을 출력한다. 만약 A를 B로 바꿀 수 없다면 -1을 출력한다.

<문제 1081>
L보다 크거나 같고, U보다 작거나 같은 모든 정수의 각 자리의 합을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 두 정수 L과 U이 주어진다.
<출력값>
첫째 줄에 문제의 정답을 출력한다.

<문제 1082>
이번에 VIP 회장으로 새로 부임한 백은진은 빅뱅의 위대함을 세계에 널리 알리기 위해서 사무실을 하나 임대했다.
빅뱅은 위대하기 때문에, 사무실의 번호도 되도록이면 커야 한다고 생각한다. 따라서 지금 가지고 있는 돈 전부를 가지고 방 번호를 만들려고 한다.
1층에 있는 문방구에서는 숫자를 판다. 각 숫자의 가격은 서로 다를 수 있기 때문에, 현재 가지고 있는 돈을 이용해서 만들 수 있는 가장 큰 숫자를 만들려고 한다.
예를 들어, 문방구에서 파는 숫자가 0, 1, 2이고, 각 숫자의 가격이 6, 7, 8이고, 백은진이 현재 가지고 있는 돈이 21이라면, 백은진이 만들 수 있는 가장 큰 수는 210(8+7+6=21)이다.
<입력값>
문방구에서 파는 숫자의 개수 N이 주어진다. N은 10보다 작거나 같은 자연수이다. 문방구에서 파는 숫자는 0보다 크거나 같고, N-1보다 작거나 같은 정수이다. 예를 들어, N=4이면, 문방구에서 파는 숫자는 0,1,2,3인 것이다. 둘째 줄에 각 숫자를 사는데 드는 비용이 작은 숫자부터 주어진다. 이 비용은 50보다 작거나 같은 자연수이다. 마지막 줄에는 백은진이 현재 가지고 있는 돈이 주어진다. 돈은 50보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 백은진이 가지고 있는 돈으로 만들 수 있는 가장 큰 수를 출력한다. 백은진이 가지고 있는 돈은 적어도 숫자 하나는 살 수 있기 때문에, 답은 항상 존재한다.
0을 제외하고 0으로 시작하는 수는 없다.

<문제 1083>
크기가 N인 배열 A가 있다. 배열에 있는 모든 수는 서로 다르다. 이 배열을 소트할 때, 연속된 두 개의 원소만 교환할 수 있다. 그리고, 교환은 많아봐야 S번 할 수 있다. 이때, 소트한 결과가 사전순으로 가장 뒷서는 것을 출력한다.
<입력값>
첫째 줄에 N이 주어진다. N은 50보다 작거나 같은 자연수이다. 둘째 줄에는 각 원소가 차례대로 주어진다. 이 값은 1000000보다 작거나 같은 자연수이다. 마지막 줄에는 S가 주어진다. S는 1000000보다 작거나 같은 음이 아닌 정수이다.
<출력값>
첫째 줄에 문제의 정답을 출력한다.

<문제 1084>
이번에 VIP 회장으로 새로 부임한 백은진은 빅뱅의 위대함을 세계에 널리 알리기 위해서 사무실을 하나 임대했다.
빅뱅은 위대하기 때문에, 사무실의 번호도 되도록이면 커야 한다고 생각한다. 따라서 지금 가지고 있는 돈 전부를 가지고 방 번호를 만들려고 한다.
1층에 있는 문방구에서는 숫자를 판다. 각 숫자의 가격은 서로 같지 않기 때문에, 현재 가지고 있는 돈을 이용해서 만들 수 있는 가장 큰 숫자를 만들려고 한다.
예를 들어, 문방구에서 파는 숫자가 0, 1, 2이고, 각 숫자의 가격이 6, 7, 8이고, 백은진이 현재 가지고 있는 돈이 21이라면, 백은진이 만들 수 있는 가장 큰 수는 210(8+7+6=21)이다.
<입력값>
문방구에서 파는 숫자의 개수 N이 주어진다. N은 10보다 작거나 같은 자연수이다. 문방구에서 파는 숫자는 0보다 크거나 같고, N-1보다 작거나 같은 자연수이다. 예를 들어, N=4이면, 문방구에서 파는 숫자는 0,1,2,3인 것이다. 둘째 줄에 숫자 0을 사는 비용, 숫자 1을 사는 비용, … 숫자 N-1을 사는 비용이 차례대로 주어진다. 이 비용은 10^18보다 작거나 같다. 마지막 줄에는 백은진이 현재 가지고 있는 돈이 주어진다. 돈은 10^18보다 작거나 같은 자연수 또는 0이다.
<출력값>
첫째 줄에 백은진이 가지고 있는 돈으로 만들 수 있는 가장 큰 수의 자리수를 출력한다. 둘째 줄에는 그 수의 처음 50자리를 출력하고, 셋째 줄에는 그 수의 마지막 50자리를 출력한다.

<문제 1085>
한수는 지금 (x, y)에 있다. 직사각형의 왼쪽 아래 꼭짓점은 (0, 0)에 있고, 오른쪽 위 꼭짓점은 (w, h)에 있다. 직사각형의 경계선까지 가는 거리의 최솟값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 x, y, w, h가 주어진다.
<출력값>
첫째 줄에 문제의 정답을 출력한다.

<문제 1086>
박성원은 이 문제를 풀지 못했다.
서로 다른 정수로 이루어진 집합이 있다. 이 집합의 순열을 합치면 큰 정수 하나를 만들 수 있다. 예를 들어, {5221,40,1,58,9}로 5221401589를 만들 수 있다. 합친수가 정수 K로 나누어 떨어지는 순열을 구하는 프로그램을 작성하시오.
하지만, 박성원은 이 문제를 풀지 못했다.
따라서 박성원은 그냥 랜덤하게 순열 하나를 정답이라고 출력하려고 한다. 이 문제에는 정답이 여러 개 있을 수도 있고, 박성원이 우연히 문제의 정답을 맞출 수도 있다.
박성원이 우연히 정답을 맞출 확률을 분수로 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 집합의 수의 개수 N이 주어진다. N은 15보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 집합에 포함된 수가 주어진다. 각 수의 길이는 길어야 50인 자연수이다. 마지막 줄에는 K가 주어진다. K는 100보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 정답을 기약분수 형태로 출력한다. p/q꼴로 출력하며, p는 분자, q는 분모이다. 정답이 0인 경우는 0/1로, 1인 경우는 1/1로 출력한다.

<문제 1087>
이번에 김지민은 쥐를 잡는 게임을 만들어냈다. 이 게임은 큰 보드 위를 움직이는 로봇 쥐를 가지고 한다. 이 게임의 참가자는 정사각형 모양의 우리를 움직일 수 있다.
참가자는 이 우리를 보드 위라면 어느 곳이든지 이동할 수 있고, 떨어뜨려서 쥐를 잡을 수 있다.
하지만 김지민은 모든 쥐를 한 번에 잡는 것이 불가능하도록 우리의 크기를 작게 하고 싶다.
로봇 쥐는 2차원 평면에서 움직인다. 쥐는 항상 일정한 속도로 움직이고, 처음 위치가 알려져 있다고 가정한다. 우리는 길이가 L이고 축에 평행한 정사각형 모양이고 회전시키지 못한다. 우리는 게임이 시작된 직후부터 움직이거나 떨어뜨릴 수 있다.
게임은 쥐가 우리 내부에 완벽하게 포함되어야 잡혔다고 간주한다. 만약 쥐가 우리의 경계에 있다면 그 쥐는 잡힌 쥐가 아니다. 한 번에 모든 쥐를 절대로 잡을 수 없는 가장 큰 L을 구하는 프로그램을 작성하시오..
<입력값>
첫째 줄에 쥐의 수 N이 주어진다. N은 2보다 크거나 같고, 50보다 작거나 같은 자연수이다. 둘째 줄부터 각 쥐의 시작 위치와 속도가 주어진다. 이 값은 모두 절댓값이 1,000보다 작거나 같은 정수이다. 시작 위치를 (px, py)라고 하고, 속도가 (vx, vy)라면, t초 때 쥐의 위치는 (px+vx*t, py+vy*t)이다.
<출력값>
첫째 줄에 문제의 정답을 출력한다. 절대/상대 오차는 10-9까지 허용한다.

<문제 1088>
지민이는 케이크를 N조각 사왔다. 각 조각은 무게가 서로 다르다. 지민이는 케이크를 최대 M번 자르려고 하는데, 한 조각을 한 번 자를 때마다 두 개의 서로 다른 조각으로 나누어진다. 최대 M번 잘라서 가장 무게가 많이 나가는 조각과 적게 나가는 조각의 무게 차이를 가장 작게 만들었을 때, 그 차이를 출력하라.
<입력값>
첫째 줄에 케이크 조각의 개수 N이 주어진다. N은 50보다 작거나 같다. 둘째 줄에 각 조각의 무게가 주어진다. 이 값은 1,000,000,000보다 작거나 같은 자연수이다. 셋째 줄에는 M이 주어진다. M은 100,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 가장 무게가 많이 나가는 조각과 적게 나가는 조각의 최소 무게 차이를 출력한다. 절대/상대 오차는 10-9까지 허용한다.

<문제 1089>
스타트링크 타워는 총 10N개 층이 있는 고층 건물이고, 0층부터 10N-1층으로 번호가 매겨져 있다. 층 번호를 숫자 N개로 표현한다. 숫자 N개로 층 번호를 표시할 수 없는 경우 앞에 0을 채운다.
숫자 1개를 표현하려면 전구 5×3개가 필요하고, 이 전구를 세로 크기 5, 가로 크기 3인 격자 형태로 배치한다. 다음은 0부터 9까지 숫자를 나타낸 것이다. '#'는 불이 켜있는 전구, '.'는 불이 꺼있는 전구이다.

###...#.###.###.#.#.###.###.###.###.###
#.#...#...#...#.#.#.#...#.....#.#.#.#.#
#.#...#.###.###.###.###.###...#.###.###
#.#...#.#.....#...#...#.#.#...#.#.#...#
###...#.###.###...#.###.###...#.###.###
엘리베이터에 있는 층 번호 안내판의 상태가 주어진다. 안내판의 각 숫자는 불이 꺼있는 전구 한 열로 구분되어 있다. 안내판의 일부 전구는 고장이 나서 항상 꺼있는 상태이다. 꺼있는 전구의 일부가 고장이 났다고 가정할 때, 현재 층 번호 안내판이 나타내고 있다고 볼 수 있는 모든 층 번호의 평균을 구해보자.
<입력값>
첫째 줄에 N이 주어진다. N은 9보다 작거나 같은 자연수이다. 둘째 줄부터 다섯 개의 줄에는 엘리베이터 층 번호 안내판의 상태가 주어진다. 각 문자열의 길이는 4N-1이다.
<출력값>
첫째 줄에 층 번호 안내판이 나타내고 있다고 가정할 수 있는 모든 층 번호의 평균을 출력한다. 만약, 가능한 층 번호가 없는 경우 -1을 출력한다.
정답과의 절대/상대 오차는 10-5까지 허용한다.

<문제 1090>
N개의 체커가 엄청 큰 보드 위에 있다. i번 체커는 (xi, yi)에 있다. 같은 칸에 여러 체커가 있을 수도 있다. 체커를 한 번 움직이는 것은 그 체커를 위, 왼쪽, 오른쪽, 아래 중의 한 방향으로 한 칸 움직이는 것이다.
<입력값>
첫째 줄에 N이 주어진다. N은 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 각 체커의 x좌표와 y좌표가 주어진다. 이 값은 1,000,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 수 N개를 출력한다. k번째 수는 적어도 k개의 체커가 같은 칸에 모이도록 체커를 이동해야 하는 최소 횟수이다.

<문제 1091>
지민이는 카지노의 딜러이고, 지금 3명의 플레이어(0, 1, 2)가 있다. 이 게임은 N개의 카드를 이용한다. (0 ~ N-1번)
일단 지민이는 카드를 몇 번 섞은 다음에, 그것을 플레이어들에게 나누어 준다. 0번째 위치에 있던 카드가 플레이어 0에게 가고, 1번째 위치에 있던 카드는 플레이어 1에게 가고, 2번째 위치에 있던 카드는 플레이어 2에게 가고, 3번째 위치에 있던 카드는 플레이어 0에게 가고, 이런식으로 카드를 나누어 준다. 하지만, 지민이는 약간 사기를 치려고 한다.
지민이는 처음에 카드를 섞기 전에 카드의 순서를 알고 있고, 이 정보를 이용해 각 카드가 특정한 플레이어에게 보내지게 할 것이다.
카드를 한 번 섞을 때는 주어진 방법을 이용해서만 섞을 수 있고, 이 방법은 길이가 N인 수열 S로 주어진다. 카드를 한 번 섞고 나면 i번째 위치에 있던 카드는 S[i]번째 위치로 이동하게 된다.
각 카드가 어떤 플레이어에게 가야 하는지에 대한 정보는 길이가 N인 수열 P로 주어진다. 맨 처음 i번째 위치에 있던 카드를 최종적으로 플레이어 P[i] 에게 보내야한다.
지민이가 목적을 달성하기 위해 필요한 카드 섞는 횟수의 최솟값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N이 주어진다. N은 3보다 크거나 같고, 48보다 작거나 같은 3의 배수이다.
둘째 줄에 길이가 N인 수열 P가 주어진다. 수열 P에 있는 수는 0, 1, 2 중 하나이다.
셋째 줄에 길이가 N인 수열 S가 주어진다. 수열 S에 있는 수는 모두 N-1보다 작거나 같은 자연수 또는 0이고 중복되지 않는다.
<출력값>
첫째 줄에 몇 번 섞어야 하는지 출력한다. 만약, 섞어도 섞어도 카드를 해당하는 플레이어에게 줄 수 없다면, -1을 출력한다.

<문제 1092>
지민이는 항구에서 일한다. 그리고 화물을 배에 실어야 한다. 모든 화물은 박스에 안에 넣어져 있다. 항구에는 크레인이 N대 있고, 1분에 박스를 하나씩 배에 실을 수 있다. 모든 크레인은 동시에 움직인다.
각 크레인은 무게 제한이 있다. 이 무게 제한보다 무거운 박스는 크레인으로 움직일 수 없다. 모든 박스를 배로 옮기는데 드는 시간의 최솟값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N이 주어진다. N은 50보다 작거나 같은 자연수이다. 둘째 줄에는 각 크레인의 무게 제한이 주어진다. 이 값은 1,000,000보다 작거나 같다. 셋째 줄에는 박스의 수 M이 주어진다. M은 10,000보다 작거나 같은 자연수이다. 넷째 줄에는 각 박스의 무게가 주어진다. 이 값도 1,000,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 모든 박스를 배로 옮기는데 드는 시간의 최솟값을 출력한다. 만약 모든 박스를 배로 옮길 수 없으면 -1을 출력한다.

<문제 1093>
영훈이의 취미는 스티커 수집이다. 서로 다른 스티커가 N개가 있고, 모두 번호가 0번부터 N-1번까지 매겨져 있다. 각 스티커는 한 개뿐이다. 각 스티커의 가격과 가치가 주어진다. 그리고, 영훈이가 현재 가지고 있는 스티커도 주어진다.
이때, 영훈이는 스티커를 팔고 사는 행동을 반복해서 가지고 있는 스티커의 가치의 합이 적어도 K가 되게 하려고 한다.
영훈이가 처음에 돈이 얼마가 있어야 영훈이가 가지고 있는 스티커의 가치의 합이 적어도 K가 되는지를 구하시오. 가능한 돈이 한 개가 아니라면 가장 작은 값을 출력한다.
<입력값>
첫째 줄에 N이 주어진다. N은 32보다 작거나 같은 자연수이다. 둘째 줄에는 각 스티커의 가격이 주어진다. 셋째 줄에는 각 스티커의 가치가 주어진다. 넷째 줄에는 K가 주어진다. 다섯째 줄에는 영훈이가 현재 가지고 있는 스티커의 개수가 주어진다. 여섯째 줄에는 영훈이가 가지고 있는 스티커의 번호가 주어진다. 가격은 30,000,000보다 작거나 같은 자연수이고, 영훈이가 가지고 있는 스티커의 개수는 0보다 크거나 같고, N보다 작거나 같은 정수이다. K는 0보다 크거나 같고, 1,000,000,000보다 작거나 같은 정수이다. 가치는 1 이상 30,000,000 이하의 정수이다.
<출력값>
첫째 줄에 문제의 정답을 출력한다. 만약 불가능 할 때는 -1을 출력한다.

<문제 1094>
지민이는 길이가 64cm인 막대를 가지고 있다. 어느 날, 그는 길이가 Xcm인 막대가 가지고 싶어졌다. 지민이는 원래 가지고 있던 막대를 더 작은 막대로 자른다음에, 풀로 붙여서 길이가 Xcm인 막대를 만들려고 한다.
막대를 자르는 가장 쉬운 방법은 절반으로 자르는 것이다. 지민이는 아래와 같은 과정을 거쳐서 막대를 자르려고 한다.

지민이가 가지고 있는 막대의 길이를 모두 더한다. 처음에는 64cm 막대 하나만 가지고 있다. 이때, 합이 X보다 크다면, 아래와 같은 과정을 반복한다.
	
가지고 있는 막대 중 길이가 가장 짧은 것을 절반으로 자른다.
만약, 위에서 자른 막대의 절반 중 하나를 버리고 남아있는 막대의 길이의 합이 X보다 크거나 같다면, 위에서 자른 막대의 절반 중 하나를 버린다.


이제, 남아있는 모든 막대를 풀로 붙여서 Xcm를 만든다.

X가 주어졌을 때, 위의 과정을 거친다면, 몇 개의 막대를 풀로 붙여서 Xcm를 만들 수 있는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 X가 주어진다. X는 64보다 작거나 같은 자연수이다.
<출력값>
문제의 과정을 거친다면, 몇 개의 막대를 풀로 붙여서 Xcm를 만들 수 있는지 출력한다.

<문제 1095>
옛날에 백은진이라는 마법사가 S개의 마법의 구슬을 만들었다. 이 마법의 구슬은 함께 모여있을 때는, 상상을 초월하는 힘의 근원이 된다. 이것을 김지민과 같은 악당이 사용하는 것을 막기 위해 백은진은 F개의 가짜 구슬을 만들었다. 이 가짜 구슬은 마법의 구슬과 똑같이 생겼지만, 마법의 힘은 없다.
이제 김형택은 세계를 지배하기 위해 어떤 구슬이 진짜 구슬인지 알아야 한다. 따라서 김지민은 N명의 사람을 모아서, S+F개 중 모든 S개의 조합을 테스트하기로 했다.
김형택은 각 사람들에게 미리 어떤 조합을 테스트 할 것인지 정해주었다. 그리고 같은 조합을 최대 한 번만 테스트한다.
그런데, 이 사람들은 절대로 다른 사람보다 일을 많이 하지 않는다. 즉, 모두 같은 개수의 조합을 테스트 한다. 따라서 김형택은 몇 명의 사람을 뽑아야, 모든 조합을 테스트하면서, 모든 사람이 같은 횟수의 테스트를 하는지 궁금해졌다.
김형택이 모을 수 있는 사람의 최댓값 M이 주어질 때, M을 넘지 않으면서, 김형택이 뽑을 수 있는 최대 사람의 수를 구하는 프로그램을 작성하시오
<입력값>
첫째 줄에 S F M이 주어진다. S와 F는 1,000,000,000보다 작거나 같은 자연수이고, M은 100,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 문제의 정답을 출력한다. 만약 불가능 할 때는 -1을 출력한다.

<문제 1096>
형택이는 직사각형 종이를 가지고 있다. 이 종이는 1*1크기의 칸으로 나누어져 있고, 각 칸에는 숫자가 쓰여 있다.
형택이는 종이를 적절히 접는다. 종이를 접을 때는 두 행 또는 두 열의 사이를 접는다. 이렇게 종이를 접고 나면, 겹치는 칸이 있다. 이때, 겹친 칸의 수는 원래 각 칸의 두 수를 더한 것이다.
형택이가 종이를 적절히 접어서 나올 수 있는 각 칸에 쓰여 있는 수 중 최댓값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 종이의 세로 크기 N과 가로 크기 M이 주어진다. N과 M은 12보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 종이의 각 칸에 쓰여 있는 수가 주어진다. 이 값은 절댓값이 100보다 작거나 같은 정수이다.
<출력값>
첫째 줄에 문제의 정답을 출력한다.

<문제 1097>
T는 길이가 L인 문자열이다.
T(i)는 T의 i번째 위치부터 시작하게 이동시킨 것이다. (0 ≤ i < L)
T(i)는 T의 길이와 같다.
따라서, 0보다 크거나 같고, L-1보다 작거나 같은 모든 j에 대해, T(i)의 j번째 문자는 T의 (i+j)%L번째 문자와 같을 것이다.
만약에, T(i) = T인 i가 정확하게 K개 있다면, T를 마법의 단어라고 한다.
N개의 단어(S)가 주어진다. 0보다 크거나 같고, N-1보다 작거나 같은 각 순열 p = {p[0], p[1], …, p[N-1]}을 이용해서 새로운 단어를 만들 수 있다. S[p[0]] + S[p[1]] + … + S[p[N-1]]과 같이 만들면 된다. 이때, 마법의 단어가 나오는 순열의 개수를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 단어의 개수 N이 주어진다. N은 8보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 각 단어가 주어진다. 단어의 길이는 최대 20이다. 단어는 알파벳 대문자로만 이루어져 있다. 마지막 줄에 K가 주어진다. K는 200보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 문제의 정답을 출력한다.

<문제 1098>
쌍둥이 마을은 두 마을의 사람들 간에 커뮤니케이션과 문화적 교류를 위해서 만든 것이다.
따라서 정부는 마을 사이에 쌍둥이 마을을 많이 제정하려고 한다. 물론 가능한 모든 마을의 쌍을 쌍둥이 마을로 제정하면 좋겠지만, 다음과 같은 규칙을 지켜야 한다.

각 마을은 P개 이하의 쌍둥이 마을을 가진다. 쌍둥이 마을이 없을 수도 있다.
각 쌍둥이 마을의 거리는 적어도 D이다.두 마을이 (x1, y1) 과 (x2, y2) 에 있을 때, 두 마을 사이의 거리는 |x1-x2| + |y1-y2|이다.

정부는 되도록이면 많은 쌍둥이 마을을 만들려고 한다. 만약 이러한 것이 여러 가지라면, 쌍둥이 마을 사이의 거리의 합을 최소로하는 것을 선택한다. 각 마을의 위치와 P와 D가 주어질 때, 쌍둥이 마을의 개수의 최댓값과 그 때 쌍둥이 마을 사이의 거리의 합을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 마을의 개수 N이 주어진다. N은 10보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 각 마을의 좌표가 주어진다. x좌표와 y좌표 순서대로 주어지며, 각 좌표는 1,000보다 작거나 같은 자연수 또는 0이다. 마지막 줄에는 P와 D가 주어진다. P는 3보다 작거나 같은 자연수이고, D는 2,000보다 작거나 같은 자연수이다. 두 도시의 위치가 중복되는 경우는 없다.
<출력값>
첫째 줄에 문제의 정답을 출력한다.

<문제 1099>
형택이와 그의 친구들은 자꾸 다른 사람들이 대화를 엿듣는 것이 짜증났다. 따라서, 새로운 언어를 만들었다.
이 언어에는 단어가 N개 있다. 그리고 이 언어의 문장은 단어를 공백없이 붙여쓴 것이다. 이 문장에서 각 단어는 0번 또는 그 이상 나타날 수 있다. 이 언어가 형택스러운 이유는 (특별한 이유는) 단어에 쓰여 있는 문자의 순서를 바꿔도 되기 때문이다. 이때, 원래 단어의 위치와 다른 위치에 있는 문자의 개수 만큼이 그 순서를 바꾼 단어를 만드는 비용이다. 예를 들어, abc란 단어가 있을 때, abc는 비용 0으로 만들 수 있고, acb, cba, bac는 비용 2로 바꿀 수 있고, bca, cab는 비용 3으로 바꿀 수 있다.
따라서, 한 문장을 여러 가지 방법으로 해석할 수 있다. 이때 비용의 최솟값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 문장이 주어진다. 문장의 길이는 최대 50이다. 둘째 줄에 단어의 개수 N이 주어지며, N은 50보다 작거나 같은 자연수이다. 셋째 줄부터 N개의 줄에 각 단어가 주어진다. 단어의 길이는 최대 50이다. 문장과 단어는 알파벳 소문자로만 이루어져 있다.
<출력값>
첫째 줄에 문제의 정답을 출력한다. 만약 문장을 해석할 수 없다면 -1을 출력한다.

<문제 1100>
체스판은 8*8크기이고, 검정 칸과 하얀 칸이 번갈아가면서 색칠되어 있다. 가장 왼쪽 위칸 (0,0)은 하얀색이다. 체스판의 상태가 주어졌을 때, 하얀 칸 위에 말이 몇 개 있는지 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄부터 8개의 줄에 체스판의 상태가 주어진다. ‘.’은 빈 칸이고, ‘F’는 위에 말이 있는 칸이다.
<출력값>
첫째 줄에 문제의 정답을 출력한다.

<문제 1101>
차영훈은 스티커 수집가이다. 그는 스티커를 박스에 보관한다. 물론 김지민처럼 아무렇게나 보관하는 것은 아니고, 순서를 정해서 정리한다.
어느 날 차영훈의 동생 임문빈이 그의 스티커를 가지고 놀았다. 스티커를 모두 가지고 논 후에 임문빈은 박스에 아무렇게나 넣어버렸다. 따라서 어떤 박스에는 다른 색의 스티커가 같이 있을 수도 있다.
차영훈은 다음과 같은 조건을 만족하게 스터키를 다시 정리하려고 한다.
1. 많아야 한 박스는 조커 박스이다. 이 박스에는 다른 색의 스티커를 보관할 수 있다.
2. 조커 박스를 제외한 모든 박스는 비어있거나, 같은 색의 스티커만을 보관해야 한다.
3. 같은 색을 가진 모든 스티커 (조커 박스에 들어있는 스티커는 제외)는 모두 같은 박스에 있어야 한다.
현재 박스에 어떤 색의 스티커가 몇 개 들어있는 지가 주어질 때, 몇 번 움직여야 위의 조건을 만족하게 스티커를 정리하는지 구하는 프로그램을 자성하시오.
움직임이란 한 박스에서 몇 개의 스티커 (모두 같은 색일 필요는 없다)를 뺀 후에 다른 박스에 모두 넣는 것을 말한다.
<입력값>
첫째 줄에 박스의 개수 N과 스티커 색의 개수 M이 주어진다. N과 M은 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 각 색을 가진 스티커가 각 박스에 몇 개 들어있는지 주어진다. 이 값은 9보다 작거나 같은 자연수 또는 0이다.
<출력값>
첫째 줄에 정답을 출력한다. 만약 불가능하면 -1을 출력한다.

<문제 1102>
은진이는 발전소에서 근무한다. 은진이가 회사에서 잠깐 잘 때마다, 몇몇 발전소가 고장이난다. 게다가, 지금 은진이의 보스 형택이가 은진이의 사무실로 걸어오고 있다. 만약 은진이가 형택이가 들어오기 전까지 발전소를 고쳐놓지 못한다면, 은진이는 해고당할 것이다.
발전소를 고치는 방법은 간단하다. 고장나지 않은 발전소를 이용해서 고장난 발전소를 재시작하면 된다. 하지만, 이때 비용이 발생한다. 이 비용은 어떤 발전소에서 어떤 발전소를 재시작하느냐에 따라 다르다.
적어도 P개의 발전소가 고장나 있지 않도록, 발전소를 고치는 비용의 최솟값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 발전소의 개수 N이 주어진다. N은 16보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 발전소 i를 이용해서 발전소 j를 재시작할 때 드는 비용이 주어진다. i줄의 j번째 값이 그 값이다. 그 다음 줄에는 각 발전소가 켜져있으면 Y, 꺼져있으면 N이 순서대로 주어진다. 마지막 줄에는 P가 주어진다. 비용은 50보다 작거나 같은 음이 아닌 정수이고, P는 0보다 크거나 같고, N보다 작거나 같은 정수이다.
<출력값>
첫째 줄에 문제의 정답을 출력한다. 불가능한 경우에는 -1을 출력한다.

<문제 1103>
형택이는 1부터 9까지의 숫자와, 구멍이 있는 직사각형 보드에서 재밌는 게임을 한다.
일단 보드의 가장 왼쪽 위에 동전을 하나 올려놓는다. 그다음에 다음과 같이 동전을 움직인다.

동전이 있는 곳에 쓰여 있는 숫자 X를 본다.
위, 아래, 왼쪽, 오른쪽 방향 중에 한가지를 고른다.
동전을 위에서 고른 방향으로 X만큼 움직인다. 이때, 중간에 있는 구멍은 무시한다.

만약 동전이 구멍에 빠지거나, 보드의 바깥으로 나간다면 게임은 종료된다. 형택이는 이 재밌는 게임을 되도록이면 오래 하고 싶다.
보드의 상태가 주어졌을 때, 형택이가 최대 몇 번 동전을 움직일 수 있는지 구하는 프로그램을 작성하시오.
<입력값>
줄에 보드의 세로 크기 N과 가로 크기 M이 주어진다. 이 값은 모두 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 보드의 상태가 주어진다. 쓰여 있는 숫자는 1부터 9까지의 자연수 또는 H이다. 가장 왼쪽 위칸은 H가 아니다. H는 구멍이다.
<출력값>
첫째 줄에 문제의 정답을 출력한다. 만약 형택이가 동전을 무한번 움직일 수 있다면 -1을 출력한다.

<문제 1104>
두 문자열 S1과 S2가 있다. 이 문자열은 0과 1로만 이루어져 있다.
문자열 S(N)은 S1을 1,000,000개 연결한 다음에 S2를 N개 연결한 것이다.
길이가 무한인 문자열 S는 S(1), S(2), S(3), …을 순서대로 계속 연결한 것이다.
문자열 T는 문자열 S의 처음 1016개 문자이다.
자 이제, T의 부분 문자열 중에 길이가 C이면서 0으로만 이루어진 것을 찾으려고 한다. 이러한 부분 문자열의 T에서 가장 처음 나타나는 위치를 구하는 프로그램을 작성하시오. 문자열의 위치는 0부터 시작한다.
<입력값>
첫째 줄에 S1이 주어지고, 둘째 줄에 S2가 주어진다. S1과 S2의 길이는 최대 50이다. 셋째 줄에는 C가 주어진다. C는 1016보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 문제의 정답을 출력한다. 만약 그러한 부분 문자열이 없다면 -1을 출력한다.

<문제 1105>
L과 R이 주어진다. 이때, L보다 크거나 같고, R보다 작거나 같은 자연수 중에 8이 가장 적게 들어있는 수에 들어있는 8의 개수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 L과 R이 주어진다. L은 2,000,000,000보다 작거나 같은 자연수이고, R은 L보다 크거나 같고, 2,000,000,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 L보다 크거나 같고, R보다 작거나 같은 자연수 중에 8이 가장 적게 들어있는 수에 들어있는 8의 개수를 구하는 프로그램을 작성하시오.

<문제 1106>
세계적인 호텔인 형택 호텔의 사장인 김형택은 이번에 수입을 조금 늘리기 위해서 홍보를 하려고 한다.
형택이가 홍보를 할 수 있는 도시가 주어지고, 각 도시별로 홍보하는데 드는 비용과, 그 때 몇 명의 호텔 고객이 늘어나는지에 대한 정보가 있다.
예를 들어, “어떤 도시에서 9원을 들여서 홍보하면 3명의 고객이 늘어난다.”와 같은 정보이다. 이때, 이러한 정보에 나타난 돈에 정수배 만큼을 투자할 수 있다. 즉, 9원을 들여서 3명의 고객, 18원을 들여서 6명의 고객, 27원을 들여서 9명의 고객을 늘어나게 할 수 있지만, 3원을 들여서 홍보해서 1명의 고객, 12원을 들여서 4명의 고객을 늘어나게 할 수는 없다.
각 도시에는 무한 명의 잠재적인 고객이 있다. 이때, 호텔의 고객을 적어도 C명 늘이기 위해 형택이가 투자해야 하는 돈의 최솟값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 C와 형택이가 홍보할 수 있는 도시의 개수 N이 주어진다. C는 1,000보다 작거나 같은 자연수이고, N은 20보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 각 도시에서 홍보할 때 대는 비용과 그 비용으로 얻을 수 있는 고객의 수가 주어진다. 이 값은 100보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 문제의 정답을 출력한다.

<문제 1107>
수빈이는 TV를 보고 있다. 수빈이는 채널을 돌리려고 했지만, 버튼을 너무 세게 누르는 바람에, 일부 숫자 버튼이 고장났다.
리모컨에는 버튼이 0부터 9까지 숫자, +와 -가 있다. +를 누르면 현재 보고있는 채널에서 +1된 채널로 이동하고, -를 누르면 -1된 채널로 이동한다. 채널 0에서 -를 누른 경우에는 채널이 변하지 않고, 채널은 무한대 만큼 있다.
수빈이가 지금 이동하려고 하는 채널은 N이다. 어떤 버튼이 고장났는지 주어졌을 때, 채널 N으로 이동하기 위해서 버튼을 최소 몇 번 눌러야하는지 구하는 프로그램을 작성하시오. 
수빈이가 지금 보고 있는 채널은 100번이다.
<입력값>
첫째 줄에 수빈이가 이동하려고 하는 채널 N (0 ≤ N ≤ 500,000)이 주어진다.  둘째 줄에는 고장난 버튼의 개수 M (0 ≤ M ≤ 10)이 주어진다. 고장난 버튼이 있는 경우에는 셋째 줄에는 고장난 버튼이 주어지며, 같은 버튼이 여러 번 주어지는 경우는 없다.
<출력값>
첫째 줄에 채널 N으로 이동하기 위해 버튼을 최소 몇 번 눌러야 하는지를 출력한다.

<문제 1108>
새로운 검색 엔진을 만들었다. 이 검색 엔진은 구글을 뛰어넘는 세계 최고의 검색 엔진이기 때문에, 신뢰도가 높은 결과를 보여줘야 한다. 하지만, 사용자가 검색어를 입력했을 때, 이것에 맞는 결과가 수천, 수만개가 될 수 있으므로, 이 중에 어떤 것이 중요하고, 어떤 사이트를 보여줘야 하는지가 큰 문제이다.
구글은 이러한 것을 사이트를 크롤링해서 자체 알고리즘을 이용해서 사이트의 순위를 매긴다.
우리의 검색 엔진은 다음과 같은 방법을 사용할 것이다.
일단 모든 웹사이트에 1점을 준다. 만약에 웹사이트 A에 웹사이트 B로 가는 링크가 있다면, 웹사이트 B의 점수에 웹사이트 A의 점수를 더한다.
예를 들어, 웹사이트가 총 3개가 있다. A, B, C이다. 일단 모든 웹사이트의 점수는 1이다. 이제, 웹사이트 A와 B에 모두 C로 가는 링크가 있다고 하면, C의 점수는 3이 되고, A와 B의 점수는 그대로 1이다. 만약 어떤 검색어가 입력 되었는데, 이 웹사이트 A B C에 모두 해당하는 것이었다면, C가 가장 위에 표시된다.
이런 웹사이트에 점수를 매기는 일이 어려운 이유는 바로, 링크를 교환하는 사이트 들이 있기 때문이다. 이 말은 A가 B를 링크하고, B가 A를 링크하는 것이다. 따라서, 이런 현상으로 점수가 무한대로 늘어나는 것을 방지하기 위해서, A의 점수를 B에 더할 때는, B에서 A로의 링크가 직접적으로 또는 간접적으로 없을 때이다.
링크가 어떻게 되어있는 지가 주어지고, 웹사이트의 이름이 주어질 때, 그 웹사이트의 점수를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 링크 정보의 개수 N이 주어진다. 이 N은 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 링크의 정보가 주어진다. 링크의 정보는 다음과 같다. 가장 처음 등장하는 문자열은 웹사이트의 이름이다. 그 다음에 등장하는 수는 그 웹사이트를 가리키고 있는 웹사이트 이름의 개수이다. 그 개수 만큼 웹사이트의 이름이 주어진다. 예를 들어, C 2 A B 라면, A->C로 가는 링크가 있고, B->C로 가는 링크가 있는 것이다.마지막 줄에는 웹사이트의 이름이 주어진다. 이 웹사이트의 점수를 출력하는 것이다. 웹사이트의 이름은 알파벳 대문자로만 이루어져 있으며 길이는 최대 50이다. 다른 제한은 모두 50이다. 그리고, 링크의 정보에서 처음 등장하는 문자열 즉 웹사이트의 이름은 같은 것이 여러 번 나오지 않는다.
<출력값>
첫째 줄에 문제의 정답을 출력한다.

<문제 1109>
지민이는 보물을 찾아 떠나기 위해 섬과 바다가 그려져 있는 지도를 샀다.
지도는 N*M 크기의 직사각형 모양이고, 각각의 1*1크기의 칸에는 ‘x’ 또는 ‘.’중의 하나가 쓰여 있다.
바다는 ‘.’이 가로로 또는 세로로 최대로 연결되어 있는 그룹이다.
섬은 ‘x’가 가로, 세로, 또는 대각선으로 최대로 연결되어 있는 그룹이다.
만약 어떤 섬이 다른 섬을 포함하고 있지 않는다면, 그 섬은 높이가 0이다. 만약 어떤 섬A가 포함하고 있는 섬중에 가장 높이가 높은 섬의 높이가 K라면, 그 섬 A의 높이는 K+1이다.
섬 A가 섬 B를 포함한다는 말은, 일단 A와 B가 다르고, 섬 B의 어느 곳에서 출발해도 A의 밖으로 나갈 수 없을 때이다. 이때 대각선으로 이동은 불가능하다.
다음과 같은 지도를 보자.

xxx.x...xxxxx        000.0...11111
xxxx....x...x        0000....1...1
........x.x.x        ........1.4.1
..xxxxx.x...x        ..55555.1...1
..x...x.xxx.x        ..5...5.111.1
..x.x.x...x..        ..5.3.5...1..
..x...x...xxx        ..5...5...111
...xxxxxx....        ...555555....
x............        2............
섬은 총 6개가 있다. 높이가 0인 섬은 5개이다. (0~4) 그리고, 높이가 1인 섬은 1개 있다. (5) 3번 섬에서 출발해서 5번 섬의 밖으로 나갈 수 없기 때문에 섬5는 섬3을 포함하고 있는 것이다. 하지만, 섬4에서 출발해서 섬1을 나갈 수 있으므로 ,섬1은 섬4를 포함하고 있는 것이 아니다.
지도가 주어졌을 때, 높이가 0인 섬의 개수부터 높이가 M인 섬의 개수까지를 차례대로 출력하는 프로그램을 작성하시오. M은 지도에 있는 섬 중에서 가장 높은 높이이다.
<입력값>
첫째 줄에 N과 M이 주어진다. N과 M은 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 섬의 지도가 주어진다.
<출력값>
첫째 줄에 높이가 0인 섬의 개수, 높이가 1인 섬의 개수, …, 높이가 M인 섬의 개수 까지 공백으로 구분해서 출력한다. 만약 섬이 하나도 없을 때는 -1을 출력한다.

<문제 1110>
0보다 크거나 같고, 99보다 작거나 같은 정수가 주어질 때 다음과 같은 연산을 할 수 있다. 먼저 주어진 수가 10보다 작다면 앞에 0을 붙여 두 자리 수로 만들고, 각 자리의 숫자를 더한다. 그 다음, 주어진 수의 가장 오른쪽 자리 수와 앞에서 구한 합의 가장 오른쪽 자리 수를 이어 붙이면 새로운 수를 만들 수 있다. 다음 예를 보자.
26부터 시작한다. 2+6 = 8이다. 새로운 수는 68이다. 6+8 = 14이다. 새로운 수는 84이다. 8+4 = 12이다. 새로운 수는 42이다. 4+2 = 6이다. 새로운 수는 26이다.
위의 예는 4번만에 원래 수로 돌아올 수 있다. 따라서 26의 사이클의 길이는 4이다.
N이 주어졌을 때, N의 사이클의 길이를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N이 주어진다. N은 0보다 크거나 같고, 99보다 작거나 같은 정수이다.
<출력값>
첫째 줄에 N의 사이클 길이를 출력한다.

<문제 1111>
IQ Test의 문제 중에는 공통된 패턴을 찾는 문제가 있다. 수열이 주어졌을 때, 다음 수를 찾는 문제이다.
예를 들어, 1, 2, 3, 4, 5가 주어졌다. 다음 수는 무엇인가? 당연히 답은 6이다. 약간 더 어려운 문제를 보면, 3, 6, 12, 24, 48이 주어졌을 때, 다음 수는 무엇인가? 역시 답은 96이다.
이제 제일 어려운 문제를 보자.
1, 4, 13, 40이 주어졌을 때, 다음 수는 무엇일까? 답은 121이다. 그 이유는 항상 다음 수는 앞 수*3+1이기 때문이다.
은진이는 위의 3문제를 모두 풀지 못했으므로, 자동으로 풀어주는 프로그램을 작성하기로 했다. 항상 모든 답은 구하는 규칙은 앞 수*a + b이다. 그리고, a와 b는 정수이다.
수 N개가 주어졌을 때, 규칙에 맞는 다음 수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N이 주어진다. N은 50보다 작거나 같은 자연수이다. 둘째 줄에는 N개의 수가 주어진다. 이 수는 모두 절댓값이 100보다 작거나 같은 정수이다.
<출력값>
다음 수를 출력한다. 만약 다음 수가 여러 개일 경우에는 A를 출력하고, 다음 수를 구할 수 없는 경우에는 B를 출력한다.

<문제 1112>
우리는 10진수를 사용한다. 10진수는 0부터 9까지 숫자를 사용한다. 12345가 10진수라면, 이 값은 1×104 + 2×103 + 3×102 + 4×101 + 5×100이다.
자 이제 -10진법을 보자. 이 수도 0부터 9까지 숫자를 사용하고, -10진수 12345는, 1×(-10)4 + 2×(-10)3 + 3×(-10)2 + 4(-10)1 + 5(-10)0 이다. 따라서, 10진법으로는 10000-2000+300-40+5 = 8265가 된다.
어떤 수를 음의 진법으로 나타내는 방법도 항상 일정하다. 음의 진법이 신기한 이유는 음수를 나타내는데 –가 필요 없기 때문이다. 예를 들어, -10진법에서, 10진수 -1은 19로 나타내면 되고, 10진수 -2는 18로 나타내면 된다.
10진수 x를 b진법으로 바꾸는 프로그램을 작성하시오. 음의 진법일 때는 음수를 나타낼 때 -부호가 있으면 안 된다.
<입력값>
첫째 줄에 두 정수 x와 b가 주어진다.
<출력값>
첫째 줄에 문제의 정답을 출력한다.

<문제 1113>
지민이는 수영장을 만들려고 한다. 수영장을 만들 곳의 크기는 N*M이고, 각 칸은 직육면체이다. 따라서, 각 칸의 직육면체의 높이가 쓰여 있는 다음과 같은 땅을 생각할 수 있다.
16661
61116
16661
이 수영장은 15만큼의 물이 들어있는 수영장을 만들 수 있다. 가운데 3개의 칸에 5만큼 물을 채우면 되기 때문이다.
자 이제 가운데 물을 더 추가했다고 생각하면, 벽(높이가 6인 직육면체)을 넘어서 밖으로 나갈 것이다. 물은 항상 높이가 더 낮은 곳으로만 흐르고, 직육면체 위의 표면에는 물이 없다. 그리고, 땅의 높이는 0이고, 땅은 물을 무한대로 흡수 할 수 있다.
땅의 모양이 주어질 때, 수영장에 물이 얼마만큼 있을 수 있는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N과 M이 주어진다. N과 M은 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 땅의 높이가 주어진다. 높이는 1보다 크거나 같고, 9보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 문제의 정답을 출력한다.

<문제 1114>
벌목꾼 백은진은 나무를 종이 공장에 옮겨야 한다. 하지만, 통나무의 길이가 너무 길어서 트럭에 들어가지 않으므로, 여러개의 조각으로 나눠야 한다.
통나무의 길이는 L cm이다. 그리고 통나무의 특정한 위치에서만 자를 수 있다. 통나무를 자를 수 있는 위치가 주어지고, 이때 이 위치는 통나무의 가장 왼쪽에서부터 떨어진 거리이다. 백은진은 많아야 C번 통나무를 자를 수 있다.
이때, 통나무의 가장 긴 조각을 작게 만드는 프로그램을 작성하시오.
<입력값>
첫째 줄에 L, K와 C가 주어진다. L은1,000,000,000보다 작거나 같은 자연수이고, K는 통나무를 자를 수 있는 위치의 개수이다. K와 C는 10,000보다 작거나 같은 자연수이다. 둘째 줄에 통나무를 자를 수 있는 위치가 주어진다.
<출력값>
첫째 줄에 두 개의 수를 출력한다. 첫 번째 수는 가장 긴 조각의 길이이고, 두 번째 수는 그 때 처음 자르는 위치를 출력한다. 만약 가능한 것이 여러 가지라면, 처음 자르는 위치가 작은 것을 출력한다.

<문제 1115>
0부터 N-1까지 모든 정수를 한 번씩 포함하고 있는 순열 A[0], A[1], ..., A[N-1]이 있다. 순열 A를 이용해서 A와 길이가 같은 자식 배열 B을 아래와 같은 방법으로 구할 수 있다.

B[0] = 0
B[i] = A[B[i-1]] (1 ≤ i ≤ N-1)

위의 과정을 통해서 만든 순열 A의 자식 배열 B가 순열인 경우에 순열 A를 완벽한 순열이라고 한다.
아래 표는 길이가 3인 모든 순열과 그 순열의 자식 배열을 나타낸다. {1, 2, 0}과 {2, 0, 1}은 자식 배열도 순열이기 때문에, 두 순열은 완벽한 순열이다.



A
B




0, 1, 2
0, 0, 0


0, 2, 1
0, 0, 0


1, 0, 2
0, 1, 0


1, 2, 0
0, 1, 2


2, 0, 1
0, 2, 1


2, 1, 0
0, 2, 0



길이가 N인 순열 P가 주어진다. 이때, P와 차이가 가장 작은 완벽한 순열 Q를 구하는 프로그램을 작성하시오. 두 순열 P와 Q의 차이는 P[i]와 Q[i]의 값이 다른 i의 개수이다.
<입력값>
첫째 줄에 순열 P의 크기 N (1 ≤ N ≤ 50)이 주어진다. 둘째 줄에는 순열 P가 주어진다.
<출력값>
첫째 줄에 입력으로 주어진 순열 P와 차이가 가장 작은 완벽한 순열 Q의 차이를 출력한다.

<문제 1116>
0부터 N-1까지 모든 정수를 한 번씩 포함하고 있는 순열 A[0], A[1], ..., A[N-1]이 있다. 순열 A를 이용해서 A와 길이가 같은 자식 배열 B을 아래와 같은 방법으로 구할 수 있다.

B[0] = 0
B[i] = A[B[i-1]] (1 ≤ i ≤ N-1)

위의 과정을 통해서 만든 순열 A의 자식 배열 B가 순열인 경우에 순열 A를 완벽한 순열이라고 한다.
아래 표는 길이가 3인 모든 순열과 그 순열의 자식 배열을 나타낸다. {1, 2, 0}과 {2, 0, 1}은 자식 배열도 순열이기 때문에, 두 순열은 완벽한 순열이다.



A
B




0, 1, 2
0, 0, 0


0, 2, 1
0, 0, 0


1, 0, 2
0, 1, 0


1, 2, 0
0, 1, 2


2, 0, 1
0, 2, 1


2, 1, 0
0, 2, 0



길이가 N인 순열 P가 주어진다. 이때, P와 차이가 가장 작은 완벽한 순열 Q를 구하는 프로그램을 작성하시오. 두 순열 P와 Q의 차이는 P[i]와 Q[i]의 값이 다른 i의 개수이다.
<입력값>
첫째 줄에 순열 P의 크기 N (1 ≤ N ≤ 50)이 주어진다. 둘째 줄에는 순열 P가 주어진다.
<출력값>
첫째 줄에 입력으로 주어진 순열 P와 차이가 가장 작은 완벽한 순열 Q를 출력한다. 가능한 순열 Q가 여러 가지인 경우에는 자식 순열이 사전순으로 가장 앞서는 것을 출력한다.

<문제 1117>
지민이는 종이에 색칠하기를 좋아한다. 지민이는 W*H크기의 직사각형 종이를 가지고 있다. 지민이는 종이에 다음과 같이 색칠 하려고 한다.
1. 종이를 x=f에 맞춰서 접는다. 이때, 왼쪽 종이가 오른쪽 종이 위에 올라오게 접는다.
2. 종이를 가로로 c+1개의 크기가 동일 한 구간으로 나눈다. 그 다음에 c번 가장 위의 구간부터 차례대로 접는다.
3. 왼쪽 아래가 (x1, y1) 이고, 오른쪽 위가 (x2, y2)인 직사각형을 찾는다. 이때, (0, 0)은 현재 접힌 상태에서 가장 왼쪽 아래 점이다. 그 직사각형을 칠한다. 이때, 페인트는 겹쳐있는 모든 곳에 스며든다.
4. 종이를 편다.
다음 예를 보자. 다음 예는 5*6 종이에, x=2이고, c=2이고, (x1, y1) = (1, 1), (x2, y2) = (3, 2)인 예제이다.






W, H, f, c, x1, y1, x2, y2가 주어질 때, 색칠되어 있지 않은 면적을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 W H f c x1 y1 x2 y2가 주어진다. W와 H는 10^9보다 작거나 같은 자연수이고, f는 0보다 크거나 같고, W보다 작거나 같은 정수, c는 1000보다 작거나 같은 정수 또는 0이다. c+1은 H의 약수이고, 0<=x1<x2<max(f,W-f), 0<=y1<y2<=H/(c+1)이다.
<출력값>
첫째 줄에 색칠되지 않은 영역의 넓이를 출력한다.

<문제 1118>
지민이는 종이에 색칠하기를 좋아한다. 지민이는 W*H크기의 직사각형 종이를 가지고 있다. 지민이는 종이에 다음과 같이 색칠을 K번 하려고 한다. 0보다 크거나 같고, K-1보다 작거나 같은 i에 대해서, 다음과 같은 행동을 한 번씩 한다.
1. 종이를 x=f[i]에 맞춰서 접는다. 이때, 왼쪽 종이가 오른쪽 종이 위에 올라오게 접는다.
2. 종이를 가로로 c[i]+1개의 크기가 동일 한 구간으로 나눈다. 그 다음에 c[i]번 가장 위의 구간부터 차례대로 접는다.
3. 왼쪽 아래가 (x1[i], y1[i]) 이고, 오른쪽 위가 (x2[i], y2[i])인 직사각형을 찾는다. 이때, (0, 0)은 현재 접힌 상태에서 가장 왼쪽 아래 점이다. 그 직사각형을 칠한다. 이때, 페인트는 겹쳐있는 모든 곳에 스며든다.
4. 종이를 편다.
예제는 1117번 문제를 참고한다.
W, H K, 그리고 각각의 i(0<=i<K)에 대해 f[i], c[i], x1[i], y1[i], x2[i], y2[i]가 주어질 때, 색칠되어 있지 않은 면적을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 W H K가 주어진다. W와 H는 10^9보다 작거나 같은 자연수이고, K는 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 각각 접고 색칠하는 정보가 주어진다. f[i] c[i] x1[i] y1[i] x2[i] y2[i]가 주어진다. F[i]는 0보다 크거나 같고, W보다 작거나 같은 정수, c[i]는 1000보다 작거나 같은 정수 또는 0이다. C[i]+1은 H의 약수이고,  0<=x1[i]<x2[i]< max(f[i],W-f[i]), 0<=y1[i]<y2[i]<=H/(c[i]+1)이다.
<출력값>
첫째 줄에 색칠되지 않은 영역의 넓이를 출력한다.

<문제 1119>
N개의 도시가 있고, 몇몇 도시들이 양방향 도로로 연결되어 있는 나라가 있다. 은진이는 이나라의 도로 몇 개를 수정해서 모든 도시가 서로 연결되어 있게 하려고 한다. 이때, 도로를 수정하는 회수를 최소로 하려고 한다. 도로를 수정하는 방법은 다음과 같다.

A와 B가 연결되어 있고, C와 D가 연결되어 있으면서, A와 C, A와 D, B와 C, B와 D가 연결되어 있지 않은 4개의 도시 A, B, C, D를 선택한다.
A와 B를 연결하는 도로와 C와 D를 연결하는 도로를 없앤다.
A와 C, B와 D를 연결하거나 A와 D, B와 C를 연결한다.

다음 그림을 살펴보자.
 

위와 같은 도로가 있을 때 이것을 다음에 보이는 둘 중에 하나로 바꿀 수 있다.


N이 주어지고, 각 도로의 정보가 주어진다. 이때, 몇 개의 도로를 수정해야 하는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N이 주어진다 N은 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 도로의 정보가 주어진다. 인접행렬형식으로 표현되어 있다. 예제를 보면 된다. g[i][j] = g[j][i]이고, g[i][i] = N이다.
<출력값>
첫째 줄에 문제의 정답을 출력한다. 만약 불가능  할 때는 -1을 출력한다.

<문제 1120>
길이가 N으로 같은 문자열 X와 Y가 있을 때, 두 문자열 X와 Y의 차이는 X[i] ≠ Y[i]인 i의 개수이다. 예를 들어, X=”jimin”, Y=”minji”이면, 둘의 차이는 4이다.
두 문자열 A와 B가 주어진다. 이때, A의 길이는 B의 길이보다 작거나 같다. 이제 A의 길이가 B의 길이와 같아질 때 까지 다음과 같은 연산을 할 수 있다.

A의 앞에 아무 알파벳이나 추가한다.
A의 뒤에 아무 알파벳이나 추가한다.

이때, A와 B의 길이가 같으면서, A와 B의 차이를 최소로 하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 A와 B가 주어진다. A와 B의 길이는 최대 50이고, A의 길이는 B의 길이보다 작거나 같고, 알파벳 소문자로만 이루어져 있다.
<출력값>
A와 B의 길이가 같으면서, A와 B의 차이를 최소가 되도록 했을 때, 그 차이를 출력하시오.

<문제 1121>
1부터 N까지 번호가 매겨져 있는 선분이 있다. 각 선분의 길이가 주어진다. 이때, 이 선분을 이용해서 만들 수 있는 서로 다른 K각형의 개수를 출력하는 프로그램을 작성하시오. K각형의 한 변은 주어진 선분 중의 하나여야 한다. 그리고 각 선분은 한 번만 사용할 수 있다.
다각형이 서로 다른 것은, 두 다각형 A와 B가 있을 때, A에 쓰였는데, B에 쓰이지 않은 선분이 있다면, 두 다각형을 서로 다르다고 한다.
<입력값>
첫째 줄에 N이 주어진다. N은 50보다 작거나 같은 자연수이다. 둘째 줄에는 N개의 선분의 길이가 주어진다. 길이는 50,000보다 작거나 같은 자연수이다. 셋째 줄에는 K가 주어진다. K는 10보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 문제의 정답을 출력한다.

<문제 1122>
홍준이는 A개의 0과 B개의 1을 가지고 있다. 이것을 가지고 게임을 할 것이다. 이 게임의 목표는 모두 1로 만드는 것이다. 각 턴은 정확하게 K개의 숫자를 뒤집는 것이다. (0->1, 1->0) 매번 수의 값이나, 이전에 뒤집은 적이 있는지 없는지에 상관없이 아무 K개의 숫자를 고를 수 있다. 게임에서 이기기 위한 뒤집는 횟수의 최솟값을 출력하는 프로그램을 작성하시오. 만약 불가능하면 -1을 출력한다.
<입력값>
첫째 줄에 A B K가 주어진다. 모든 수는 100,000보다 작거나 같은 자연수 또는 0이다.
<출력값>
첫째 줄에 문제의 정답을 출력한다.

<문제 1123>
다음은 류원룡의 말이다.
나는 음악을 사랑하기 때문에, 항상 음악을 듣는다. 나는 많은 곡을 소장하고 있고, 음악을 매번 곡을 선택하는 것보다, 셔플로 (무작위로) 듣는다. 그러나 나는 다른 장르의 음악도 듣지만, 어떤 것들은 서로 맞지 않는다. (예를 들어, 조용한 클래식을 듣다가, 갑자기 쏘리쏘리와 같이 시끄러운 가요가 나오는 것은 좀 불편하다) 따라서, 나는 다음과 같은 룰을 적용해서 셔플을 하게 하는 프로그램을 작성하려고 한다. 룰은 다음과 같다.
나는 여러 개의 장르를 정의해 놓았고, 모든 곡은 하나의 장르에 속한다. 그리고 나는 어떤 장르가 서로 맞는지도 정해놓았다. (서로 맞다는 말은 i라는 장르가 j와 맞다면, i란 장르의 노래를 듣고, j를 듣는것은 괜찮다는 것, 서로 맞지 않으면, i란 장르의 노래를 듣고, j란 장르의 노래를 듣는것은 안 된다는 것)
나의 프로그램은 다음과 같이 작동한다.
처음에 하나의 곡을 랜덤하게 재생한다. 그 곡이 끝나면, 그 곡의 장르와 맞는 곳을 랜덤하게 선택해서, 그 곡을 재생한다. 같은 곡은 여러 번 재생될 수도 있고, 연속해서 재생하는 것도 가능한다.
나의 프로그램을 이용해서 재생할 수 있는 곡의 순서 중 그 길이가 A보다 크거나 같고, B보다 작거나 같은 것의 경우의 수를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 곡의 개수 N이 주어진다. 곡의 개수는 1000보다 작거나 같은 자연수이다. 둘째 줄 부터 N개의 줄에는 각 곡의 장르번호와 곡의 길이가 주어진다. 다음 줄에는 장르의 개수 M이 주어진다. M은 9보다 작거나 같은 자연수이고, 장르 번호는 0부터 M-1까지 이다. 곡의 길이는 9보다 작거나 같은 자연수이다. 다음 줄에는 서로 맞는 장르가 인접행렬 형식으로 주어진다. Y는 서로 맞는 장르, N은 아니다. 이때, 이 인접행렬을 T라고 했을 때, T[i][i] = ‘Y’이다. 마지막 줄에는 A와 B가 주어진다. B는 A보다 크거나 같고, 1,000,000,000보다 작거나 같은 자연수이다.
<출력값>
곡의 순서 중 그 길이가 A보다 크거나 같고, B보다 작거나 같은 것의 경우의 수를 600921647로 나눈 나머지를 출력한다.

<문제 1124>
자연수 X를 소인수 분해 하면, 곱해서 X가 되는 소수의 리스트가 나온다. 12는 2*2*3이고, 1은 소수가 아니다. 이때, X가 언더프라임이기 위한 조건은 소인수 분해 했을 때, 나오는 소수의 개수가 소수일 때이다. 예를 들어, 12는 언더프라임이다. 그 이유는 나오는 소수의 개수가 3개이기 때문이다. A와 B가 주어졌을 때, A보다 크거나 같고, B보다 작거나 같은 언더프라임의 개수를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 A와 B가 주어진다. A는 B보다 작거나 같고, A와 B는 100,000보다 작거나 같고, 2보다 크거나 같은 자연수이다.
<출력값>
첫째 줄에 문제의 정답을 출력한다.

<문제 1125>
방 바닥을 꾸미려고 한다. 다음과 같이 1*5 크기의 나무 판으로 만든 무한한 패턴의 평면을 생각해보자. 가장 왼쪽 위 좌표는 (0,0)이고, X좌표는 왼쪽에서 오른쪽으로 증가하고, Y좌표는 위에서 아래로 증가한다.
이제 이 패턴에서 방 크기와 맞는 구역을 선택할 것이다. 이때 왼쪽 위의 좌표가 (x1, y1)이고, 오른쪽 아래의 좌표가 (x2, y2)인 직사각형 구역을 선택한다. 자 이제 선택한 구역의 모양을 만들 것이다.
하지만, 근처의 상점에서는 오직 1*5크기의 나무 판만 판다. 따라서, 1*3, 1*2크기의 나무 판은 1*5크기의 나무 판을 적절히 잘라서 만들면 된다. 예를 들어, 1*5를 잘라서 1*3과 1*2를 만들 수 있고, 1*2 2개와 1*1 1개를 만들 수도 있다.
 

위의 그림은 (x1, y1)이 (8, 5)이고, (x2, y2)가 (20, 16)일 때이다. 23개의 1*5와 6개의 1*2, 5개의 1*1이 필요하다. 따라서 27개의 나무 판을 사면 된다.
x1, y1, x2, y2가 주어질 때 구매해야 하는 나무 판의 개수의 최솟값을 구하는 프로그램을 작성하시오. 필요없는 조각은 버려도 된다.
<입력값>
첫째 줄에 x1 y1 x2 y2가 주어진다. 모든 좌표는1,000,000보다 작거나 같은 자연수 또는 0이다. x2는 x1보다 크고, y2는 y1보다 크다.
<출력값>
첫째 줄에 문제의 정답을 출력한다.

<문제 1126>
홍준이는 N개의 직사각형 블록을 가지고 있다. 홍준이는 블록 위에 또다른 블록을 올려놓는 방식으로 탑을 만들 수 있다. 이때, 두 개의 탑을 만드는데, 이 두 탑의 높이가 같게 만들려고 한다. (각 탑은 적어도 한 개의 블록을 포함해야 한다) 홍준이는 되도록이면 탑의 높이를 최대로 하려고 한다. 그리고 모든 블록을 사용할 필요는 없다.
각 블록의 높이가 주어질 때, 홍준이가 만들 수 있는 탑의 높이의 최댓값을 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 조각의 개수 N이 주어진다. N은 50보다 작거나 같은 자연수이다. 둘째 줄에 각 조각의 높이가 주어진다. 높이는 500,000보다 작거나 같은 자연수이고, 모든 조각의 높이의 합은 500,000을 넘지 않는다.
<출력값>
첫째 줄에 문제의 정답을 출력한다. 불가능할 때는 -1을 출력한다.

<문제 1127>
떡국의 왕 도현이는 나라를 지키기 위해 각각의 도시에 경비를 뽑으려고 한다. 떡국에는 총 K개의 서로 다른 경비업체가 있으며, 각 경비업체는 일부 도시들에 사무실을 가지고 있다.
어떤 도시 A에서 경비업체 B가 일을 하려면, B는 A에 사무실이 있어야 한다. 이런 경우에 B는 A에 한 명의 경비를 일하게 할 수 있다. 사무실이 없는 경우에는 그 도시에 경비를 둘 수 없다.
도현이는 위의 규칙을 지키는 동안에는 원하는 만큼 경비를 고용할 수 있다. 하지만, 이미 있는 경비를 이동시키거나 해고시킬수는 없다.
도시 간에는 협력하는 관계가 있을 수 있다. 도시 A와 도시 B가 협력하는 관계이고, 경비업체 C의 경비가 A에서 일하는데, B에서는 경비업체 C의 경비가 없는 경우가 있다. 이런 경우를 충돌이라고 한다. 충돌의 개수는 모든 협력하는 도시의 쌍에서 존재하는 충돌의 개수이다. 한 도시에서 일하는 경비업체는 여러 개일 수 있기 때문에, 한 도시의 쌍에서 존재하는 충돌의 개수는 여러 개일 수도 있다.
협력하는 도시의 쌍과, 각 도시에 이미 있는 경비의 회사 이름, 경비업체의 사무실이 주어졌을 때, 경비를 적절히 뽑아 충돌의 개수를 최소로 하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 도시의 개수 N(1 ≤ N ≤ 50)이 주어진다.
둘째 줄에는 협력하는 도시의 관계가 인접행렬 형식으로 주어진다. 0은 협력하지 않는 관계를 나타내고, 1은 협력하는 관계를 나타낸다. 인접행렬을 A라고 했을 때, A[i][i] = 0, A[i][j] = A[j][i]를 만족한다.
다음 줄에는 떡국에 존재하는 경비업체의 수 K (1 ≤ K ≤ 50)가 주어진다. 다음 줄부터 N개의 줄에는 각 도시에 이미 있는 경비의 수와 경비업체의 번호가 0번 도시부터 차례대로 주어진다. 경비업체의 번호는 0부터 시작한다.
다음 줄부터 N개의 줄에는 각 도시에 있는 경비업체 사무실의 개수와 사무실을 가지고 있는 경비업체의 번호가 0번 도시부터 차례대로 주어진다.
<출력값>
첫째 줄에 경비를 적절히 뽑아 만들 수 있는 충돌의 최솟값을 출력한다.

<문제 1128>
종혁이는 물건 N개를 가지고 있고, 각 물건의 무게와 가격을 알고 있다. 또, 가방을 하나 가지고 있다. 가방에 담을 수 있는 무게의 최댓값은 C이다. 종혁이는 가방에 물건을 넣으려고 한다. 이때, 가방에 들어있는 물건의 가격의 합을 최대로 만들려고 한다.
이 문제는 유명한 냅색문제이다. 따라서, 시간 복잡도가 2N 또는 N*무게의 합이 나오기 때문에 풀 수 없다. 따라서, 특별한 조건이 있다. 물건의 무게는 모두 피보나치 수이다.
첫 번째와 두 번째 피보나치 수는 1과 2이고, 그 다음 수는 이전의 두 수를 더해서 만든다. 즉, 피보나치 숫자는 1, 2, 3, 5, 8, 13, ... 으로 시작하게 된다.
<입력값>
첫째 줄에 N이 주어진다. N은 50보다 작거나 같은 자연수이다.
둘째 줄부터 N개의 줄에는 각 물건의 무게와 가격이 주어진다. 무게와 가격은 모두 1016보다 작거나 같은 자연수이다.
마지막 줄에는 C가 주어진다. C는 1016보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 가방에 들어있는 물건의 가격의 합의 최댓값을 출력한다.

<문제 1129>
N명의 사람이 동그란 모양의 테이블에 모여 앉으려고 한다. 이 사람들은 모두 자신의 키에 대한 자의식이 강하기 때문에, 키가 작은 사람을 키 큰 사람 옆에 앉으려고 하지 않는다.
이 말은 인접한 두 사람의 키 차이의 최댓값을 최소로 하려고 하는 것이다.
N명의 사람들의 키가 주어졌을 때, 두 사람의 키 차이의 최댓값이 최소인 배치를 시계방향 대로 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N이 주어진다. N은 50보다 작거나 같은 자연수이다. 둘째 줄에는 각 사람의 키가 주어진다. 키는 1000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 문제의 정답을 출력한다. 그러한 것이 여러 가지라면 사전 순으로 앞서는 것을 출력한다.

<문제 1130>
종혁이와 재홍이는 종이 레이싱을 즐긴다. 트랙은 종이를 정사각형으로 나눈 것이다. 각 칸은 도로 또는 장애물이다. 두 개의 도로는 시작과 끝으로 표시되어져 있다. 이 게임의 목표는 시작에서 차를 출발시켜서 끝으로 최대한 빨리 이동시키는 것이다.
이 게임에서 차는 점 하나로 표시된다. 움직임은 각 턴으로 움직인다. 각 턴의 시작에 차는 어떤 칸의 중심에 있다. 그리고 각 턴의 움직임은 다른 칸의 중심으로 이동하는 것이다. 차의 속도는 정수 좌표를 가진 벡터이다. 각 턴은 다음과 같이 이루어져 있다.

이번 턴이 시작하기 바로 전에 차의 속도를 바꿀 수 있는데, 속도의 각 좌표를 1씩 증가시키거나, 1씩 감소시키거나, 그대로 놔둘 수 있다. (두 좌표를 같이 증가시키거나, 감소시켜야 하는 것은 아니다. 서로 다른 연산을 할 수 있다.)
차를 움직인다. 만약 차가 (r, c)에 있고, 차의 속도가 (vr, vc)라면, 차가 이동하는 새로운 좌표는 (r+vr, c+vc)이다. 차는 이전에 있던 칸의 중심과, 새로운 칸의 중심을 이은 직선을 따라 이동한다.

만약 차의 이동 경로가 끝이 쓰여 있는 도로를 지난다면, 게임은 즉시 끝이 나고, 그때 까지의 턴의 개수가 이동한 시간이 된다. 만약 차의 경로가 게임이 끝나기 전에 장애물을 지난다면, 차는 부수어지고, 게임을 끝마칠 수 없게 된다. (차는 장애물을 스칠 수 있다)
차는 종이를 벗어날 수 없다. (종이를 벗어나면 실격처리 된다)
만약 차가 이동하는 곳의 위치가 장애물이거나, 종이 밖이라고 해도, 그 전에 끝을 통과한다면, 게임은 성공적으로 끝난다.
종이의 모양과 vr, vc가 주어졌을 때, 게임을 끝내는데 드는 턴의 최솟값을 구하는 프로그램을 작성하시오. 만약 끝까지 가는 것이 불가능하다면 -1을 출력한다.
<입력값>
첫째 줄에 N과 M이 주어진다. 둘째 줄부터 N개의 줄에 종이의 모양이 주어진다. ‘.’은 도로, ‘S’는 시작, ‘F’는 끝, ‘X’는 장애물이다. 마지막 줄에는 vr과 vc가 주어진다. N과 M은 50보다 작거나 같은 자연수이고, vr과 vc는 절댓값이 50보다 작거나 같은 정수이다.
<출력값>
첫째 줄에 문제의 정답을 출력한다.

<문제 1131>
자연수 N이 주어졌을 때, N의 각 자리수를 K제곱 한 후에 그 합을 구하는 함수를 SK(N)이라고 하자.
예를 들어, S2(65) = 62 + 52 = 61이다.
따라서, 다음 수열을 생각할 수 있다. N, SK(N), SK(SK(N)), …
이때, A와 B와 K가 주어졌을 때, A보다 크거나 같고, B보다 작거나 같은 모든 N으로 각각 수열을 만들었을 때, 그 수열에서 가장 작은 수의 합을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 A B K가 주어진다. A와 B는 1,000,000보다 작거나 같은 자연수이고, K는 6보다 작거나 같은 자연수이다. B는 A보다 크거나 같다.
<출력값>
첫째 줄에 문제의 정답을 출력한다.

<문제 1132>
N개의 숫자가 주어진다. 이 숫자는 모두 자연수이고, 알파벳 A부터 J가 자리수를 대신해서 쓰여 있다. 이 알파벳은 모두 한 자리를 의미한다. 그리고, 각 자리수는 정확하게 알파벳 하나이다. 0으로 시작하는 숫자는 없다. 이때, 가능한 숫자의 합 중 최댓값을 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N이 주어진다. N은 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 각 숫자가 주어진다. 숫자의 길이는 최대 12이다.
적어도 한 알파벳은 숫자의 가장 처음에 주어지지 않는다.
<출력값>
첫째 줄에 합의 최댓값을 출력한다.

<문제 1133>
자연수 K가 주어졌을 때, 문자열 S에 연속해서 K번 나오는 부분 문자열이 없을 때, 그 문자열 S를 K-반복X라고 부른다.
예를 들어, CCABAABAABAC는 4-반복X이다. 하지만, 3-반복X는 아니다. 그 이유는 ABA가 연속해서 3번 반복되기 때문이다. CCABAABACABA와 ABABAABA는 3-반복X인 단어이다.
K, N, 그리고 A가 주어졌을 때, 길이가 N이면서, K-반복X이면서 알파벳 처음 A개로만 이루어진 단어 중 사전 순으로 가장 앞서는 것을 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 K N A가 주어진다. K는 2보다 크거나 같고, 10보다 작거나 같은 자연수이고, N은 50보다 작거나 같은 자연수이고, A는 1보다 크거나 같고, 26보다 작거나 같은 자연수이다.
<출력값>
문제의 정답을 출력한다. 만약 그러한 것이 없을 때는 -1을 출력한다.

<문제 1134>
A+B=C라는 식이 있다. A, B, 그리고 C는 모두 처음 자리수가 0이 아닌 음이 아닌 정수이다(한 자리인 경우에는 0이 가능하다). 안타깝게도, 어떤 자리는 ?로 되어 있다. 이제 이 식을 복원하려고 한다.
식이 주어졌을 때, ?를 숫자로 적절히 바꿔서 식이 성립하게 하는 프로그램을 작성하시오. 숫자는 0으로 시작하면 안 된다.
예를 들어, 5+?=?4란 식이 있으면, 5+9=14로 만들면 된다.
만약 가능한 것이 여러 가지면, C를 최대로 하는 프로그램을 작성하시오. 만약 그러한 것도 여러 가지라면, A의 값을 최대로 하는 것을 출력하시오.
<입력값>
첫째 줄에 식이 주어진다. 식은 최대 50자이다.
<출력값>
문제의 정답을 출력한다. 불가능한 경우에는 -1을 출력한다.

<문제 1135>
민식이는 회사의 매니저이다. 그리고, 민식이는 회사의 중요한 뉴스를 모든 직원에게 빠르게 전달하려고 한다. 민식이의 회사는 트리 구조이다. 모든 직원은 정확하게 한 명의 직속 상사가 있다. 자기자신은 그들 자기 자신의 직접 또는 간접 상사가 아니고, 모든 직원은 민식이의 직접 또는 간접적인 부하이다.
민식이는 일단 자기 자신의 직속 부하에게 한 번에 한 사람씩 전화를 한다. 뉴스를 들은 후에, 각 부하는 그의 직속 부하에게 한 번에 한 사람씩 전화를 한다. 이 것은 모든 직원이 뉴스를 들을 때 까지 계속된다. 모든 사람은 자신의 직속 부하에게만 전화를 걸 수 있고, 전화는 정확하게 1분 걸린다. 이때 모든 직원이 소식을 듣는데 걸리는 시간의 최솟값을 구하는 프로그램을 작성하시오.
오민식의 사원 번호는 0이고, 다른 사원의 번호는 1부터 시작한다.
<입력값>
첫째 줄에 직원의 수 N이 주어진다. 둘째 줄에는 0번 직원부터 그들의 상사의 번호가 주어진다. 반드시 0번 직원 (오민식)의 상사는 -1이고, -1은 상사가 없다는 뜻이다. N은 50보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 모든 소식을 전하는데 걸리는 시간의 최솟값을 출력한다.

<문제 1136>
민식이는 새로운 퍼즐을 선물로 받았다. 보드는 다양한 길이의 여러개의 조각으로 이루어져 있다. 각 조각은 보드와 같은 폭을 가지고 있다. 퍼즐의 목표는 다른 조각을 더 이상 놓을 수 없게 적은 수의 조각을 놓는 것이다. 조각은 보드의 모서리에 걸치면 안되고, 각도를 비틀어도 안 된다. 모든 조각은 서로 겹치면 안 된다. 그러나, 조각의 모서리는 서로 닿아도 된다. 조각과 조각 사이의 거리와, 조각과 보드의 모서리 사이의 거리는 꼭 정수가 아니어도 된다.
보드의 길이와 각 조각의 길이가 주어질 때, 퍼즐의 목표를 수행하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 L과 조각의 수 N이 주어진다. L은 1,000보다 작거나 같은 자연수이고, N은 30보다 작거나 같은 자연수이다. 둘째 줄에는 각 조각의 길이가 주어진다. 각 조각의 길이는 100보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 문제의 정답을 출력한다.

<문제 1137>
민식이는 영식이와 직사각형 보드에 두 로봇이 있는 게임을 한다. 각 보드의 칸은 비어있거나 장애물 또는 로봇의 시작점이거나 도착점이다. 만약 로봇이 도착 칸에 도착한다면, 민식이는 이 게임을 이기게 된다. 두 로봇은 서로 동시에 도착한다면, 도착 칸에 도착하지 못한다면, 민식이는 게임을 영식이에게 지게 된다.
두 로봇은 다음과 같은 명령이 있다.

S: 남쪽으로 한 칸
N: 북쪽에서 한 칸
E: 동쪽으로 한 칸
W: 서쪽으로 한 칸

시간이 지날 때, 두 로봇은 같은 명령을 듣는다. 로봇은 명령을 수행하거나, 무시할 수 있다. 만약 명령이 로봇을 보드를 벗어나게 만들거나, 장애물이 있는 곳으로 가게 만든다면, 로봇은 명령을 자동으로 무시한다. 두 로봇은 항상 각 로봇이 도착 칸에 되도록 빨리 가도록 최적의 선택을 한다.
보드의 모양과 명령이 주어졌을 때, 민식이의 로봇이 이기는 것이 보장되는 가장 빠른 시작 시간을 출력한다. 시작 시간이 T라는 것은 명령의 T번째 문자부터 명령을 수행한다는 뜻이다. 만약 그러한 것이 없다면 -1을 출력한다.
<입력값>
첫째 줄에 N과 M이 주어진다. N과 M은 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 보드의 모양이 주어진다. ‘.’은 빈 공간, ‘#’는 장애물, ‘Y’는 민식이의 시작 위치, ‘F’는 영식이의 시작 위치, ‘X’는 도착 위치이다. 마지막 줄에는 명령이 주어진다. 명령의 길이는 최대 2500이다.
<출력값>
첫째 줄에 문제의 정답을 출력한다.

<문제 1138>
N명의 사람들은 매일 아침 한 줄로 선다. 이 사람들은 자리를 마음대로 서지 못하고 오민식의 지시대로 선다.
어느 날 사람들은 오민식이 사람들이 줄 서는 위치를 기록해 놓는다는 것을 알았다. 그리고 아침에 자기가 기록해 놓은 것과 사람들이 줄을 선 위치가 맞는지 확인한다.
사람들은 자기보다 큰 사람이 왼쪽에 몇 명 있었는지만을 기억한다. N명의 사람이 있고, 사람들의 키는 1부터 N까지 모두 다르다.
각 사람들이 기억하는 정보가 주어질 때, 줄을 어떻게 서야 하는지 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 사람의 수 N이 주어진다. N은 10보다 작거나 같은 자연수이다. 둘째 줄에는 키가 1인 사람부터 차례대로 자기보다 키가 큰 사람이 왼쪽에 몇 명이 있었는지 주어진다. i번째 수는 0보다 크거나 같고, N-i보다 작거나 같다.
<출력값>
첫째 줄에 줄을 선 순서대로 키를 출력한다.

<문제 1139>
넓은 초원이 있다. 민식이는 초원에 심은 풀이 이상한 사람들이 밟을 까봐 걱정한다. 따라서, 민식이는 초원에 삼각형 모양의 울타리를 치려고 한다.
민식이는 지하실에 N개의 울타리가 있다. 민식이는 3개의 울타리를 이용해서 삼각형 모양을 만든다. 삼각형의 각 변은 울타리 하나이다. 울타리는 붙이거나 쪼갤 수 없다.
민식이는 삼각형 넓이의 합을 최대로 하려고 한다.
<입력값>
첫째 줄에 울타리의 개수 N이 주어진다. N은 16보다 작거나 같은 자연수이다. 둘째 줄에 각 울타리의 길이가 주어진다. 이 값은 100보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 줄을 문제의 정답을 출력한다. 절대/상대 오차는 10-9까지 허용한다.

<문제 1140>
민식텔레콤은 이동통신 회사이다. 여기서 문자를 보낼 때는 한 건에 10원이다. 게다가 문자 팩을 제공한다. 문자 팩은 특정 개수의 문자 메시지를 특별한 가격에 보낼 수 있게 하는 것이다. 영식이는 이런 문자 팩을 여러 개 살 수 있다. 만약 보낸 문자메시지의 개수가 문자 팩으로 보낼 수 있는 개수를 넘어간다면 보통 요금을 내야 한다.
영식이는 문자를 매달 T개 보낸다. 그리고 영식이는 되도록 핸드폰 요금을 최소로 하려고 한다. 문자 팩은 2가지가 있는데, 첫 번째는 P1원에 문자 PK1개를 보낼 수 있고, 두 번째 문자 팩은 P2원에 문자 PK2개를 보낼 수 있다. 영식이는 이러한 문자 팩을 적절히 조합해서 여러 개 살 수 있다. 이때 문자메시지 요금의 최솟값을 출력하는 프로그램을 작성하시오.
<입력값>
입력을 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스는 한 줄로 이루어져 있으며, T PK1 P1 PK2 P2가 주어진다. T는 0보다 크거나 같고, 10^12보다 작거나 같은 정수이고, PK1과 PK2는 10^12보다 작거나 같은 자연수, P1, P2는 10^13보다 작거나 같은 자연수이다. P1은 20*PK1보다 작거나 같고, P2는 20*PK2보다 작거나 같다.
<출력값>
각 테스트 케이스마다 정답을 출력한다.

<문제 1141>
접두사X 집합이란 집합의 어떤 한 단어가, 다른 단어의 접두어가 되지 않는 집합이다. 예를 들어, {hello}, {hello, goodbye, giant, hi}, 비어있는 집합은 모두 접두사X 집합이다.
반면에, {hello, hell}, {giant, gig, g}는 접두사 X 집합이 아니다.
이때, 단어가 N개 주어질 때, 이 단어의 부분 집합 중 접두사X 집합이면서 크기가 가장 큰 것을 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 단어의 개수 N이 주어진다. N은 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 단어가 주어진다. 단어는 알파벳 소문자로만 이루어져 있고, 길이는 최대 50이다.
<출력값>
첫째 줄에 문제의 정답을 출력한다.

<문제 1142>
민식이는 동그란 피자(원)를 한 번 잘라서 두 개의 크기가 같은 조각으로 자르려고 한다. 피자는 여러 개의 토핑을 포함하고 있고, 이것은 원 위의 한 점으로 표현한다.
컷이 아름답다고 하는 것은 잘랐을 때, 두 피자가 거울에 비춘것 처럼 대칭일 때이다.
아래 그림은 피자의 한 예이다. 검정 점은 토핑이고, 아래 조각의 아름다운 컷의 개수는 1개이다.

아래 피자는 아름다운 컷이 총 4개 있다.

피자가 주어지고, 토핑의 위치가 주어졌을 때, 아름다운 컷의 개수를 출력하는 프로그램을 작성하시오. 피자의 크기는 무한히 크기 때문에, 모든 토핑을 포함할 수 있다. 그리고, 피자의 중심이 좌표가 (0, 0)이다.
<입력값>
첫째 줄에 토핑의 개수 N이 주어진다. N은 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 토핑의 위치가 주어진다. 좌표는 절댓값이 500보다 작거나 같은 정수이다. 그리고 토핑의 위치는 중복되지 않는다.
<출력값>
첫째 줄에 문제의 정답을 출력한다. 만약 아름다운 컷의 개수가 무한대일 경우에는 -1을 출력한다.

<문제 1143>
2100년, 민식이는 남극에 살고 있다. 남극에는 N개의 마을이 있고, 몇 개는 좁은 일방 통행 도로로 연결되어 있다.
남극의 대통령은 남극에 경찰서를 설치하기로 결심했다. 각 마을에 경찰서를 설치하는 비용이 주어진다. 그러나, 꼭 모든 마을에 경찰서를 설치할 필요는 없다. 하나의 조건은 모든 마을은 경찰서에서 도로를 통해 갈 수 있어야 한다.
다음 대통령 선거가 다가오기 때문에, 대통령은 비싼 경찰서 설치 비용을 노출시키지 않으려고 한다. 따라서, 대통령은 조건을 만족시키면서, 경찰서를 설치하는데 드는 비용의 평균값을 최소로 하려고 한다.
이때, 경찰서를 설치하는 비용과, 도로의 정보가 주어졌을 때, 조건을 만족시키면서, 경찰서를 설치하는데 드는 비용의 평균값을 최솟값을 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 마을의 개수 N이 주어진다. N은 50보다 작거나 같은 자연수이다. 둘째 줄에는 0번 마을부터 경찰서를 설치하는데 드는 비용이 주어진다. 이 값은 1000보다 작거나 같은 자연수이다. 셋째 줄부터 N개의 줄에는 도로의 정보가 주어진다. 도로의 정보는 인접행렬 형식으로 주어지고, 셋째 줄에서부터 i번째 줄의 j번째 값이 Y라면 i에서 j로 가는 도로가 있는 것이고, N이라면, i에서 j로 가는 도로가 없는 것이다. 그리고, i에서 i로 가는 도로는 없다.
<출력값>
첫째 줄에 문제의 정답을 출력한다. 절대/상대 오차는 10-9까지 허용한다.

<문제 1144>
1*1크기의 정사각형으로 나누어진 N*M크기의 직사각형 종이가 있다. 각 칸에는 정수가 하나씩 쓰여져 있다. 이 숫자를 비용이라고 하자.
이때, 가장 싼 연결된 칸의 집합을 찾는 프로그램을 작성하시오. 연결된 칸의 집합의 비용은 각 칸에 쓰여 있는 비용의 합이다.
칸이 연결되어 있다는 말은 그 집합의 한 칸에서 다른 칸으로 집합에 포함된 인접한 칸을 통해서 모두 이동할 수 있다는 의미이고, 두 칸이 인접해 있다는 소리는, 같은 변을 공유할 때이다. 크기가 0인 집합도 올바른 집합이다.
<입력값>
첫째 줄에 N과 M이 주어진다. N과 M은 9보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 숫자가 M개씩 주어진다. 각 숫자는 절댓값이 1000보다 작거나 같은 정수이다.
<출력값>
첫째 줄에 가장 싼 연결된 칸의 집합의 비용을 출력한다.

<문제 1145>
다섯 개의 자연수가 있다. 이 수의 적어도 대부분의 배수는 위의 수 중 적어도 세 개로 나누어 지는 가장 작은 자연수이다.
서로 다른 다섯 개의 자연수가 주어질 때, 적어도 대부분의 배수를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 다섯 개의 자연수가 주어진다. 100보다 작거나 같은 자연수이고, 서로 다른 수이다.
<출력값>
첫째 줄에 적어도 대부분의 배수를 출력한다.

<문제 1146>
N명의 학생들이 있다. 이 학생들을 다음과 같은 방식으로 줄을 세우려고 한다.

맨 앞줄에는 아무나 설 수 있다.
둘째 줄에도 아무나 설 수 있다.
셋째 줄에는 둘째 줄에 서 있는 사람이 첫째 줄에 서 있는 사람보다 클 경우, 둘째 줄에 서 있는 사람보다 작은 사람만이 설 수 있으며, 둘째 줄에 서 있는 사람이 첫째 줄에 서 있는 사람보다 작을 경우, 둘째 줄에 서 있는 사람보다 큰 사람만이 설 수 있다.
넷째 줄부터는 둘째 줄과 셋째 줄을 비교하는 식으로 해서 N번째의 줄을 서는 사람은 N-2번째 줄과 N-1번째 줄에 서는 사람을 비교해서 세운다.

학생들이 1이 가장 작은 사람, N이 가장 큰 사람이며, 같은 키를 가진 사람이 없다고 할 때, 5명을 세운다면 1 - 3 - 2 - 5 - 4, 3 - 2 - 5 - 1 - 4 등의 방법으로 세울 수 있다.
문제는 N명의 학생을 이런 식으로 줄을 세울 때 총 몇 가지의 경우의 수가 생기는지 찾아내는 것이다.
<입력값>
첫째 줄에 학생 수 N(1 ≤ N ≤ 100)이 입력된다.
<출력값>
첫째 줄에 총 경우의 수를 1,000,000으로 나눈 나머지를 출력한다.

<문제 1147>
오민식과 오영식은 소풍을 왔다. 사실 둘은 서로 말도 안하고 지내는 사이이고, 서로를 싫어한다. 그래서 오민식은 오영식과 따로 텐트를 쓰려고 한다.
오민식은 강박증이 조금 있다. 따라서 텐트를 칠 N*M크기의 직사각형 부지를 선택하고 그 곳을 1*1크기의 단위 정사각형으로 나눴다. 그리고, 텐트를 칠 때는 항상 마름모 모양으로 쳐야 하고, 텐트의 모든 꼭짓점은 꼭 정사각형의 한 꼭짓점에 있어야 한다.
아래 예는 2*2크기의 직사각형에 텐트를 치는 서로다른 6가지 방법이다.


가로 크기 N과 세로 크기 M이 주어졌을 때, 오민식이 텐트를 칠 수 있는 서로 다른 방법이 몇 가지 있는지 출력하는 프로그램을 작성하시오.
마름모는 네 변의 길이가 모두 같은 사각형을 말하고, 텐트는 항상 0이 아닌 넓이를 가져야 한다.
<입력값>
첫째 줄에 가로 크기 N과 세로 크기 M이 주어진다. N과 M은 100보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 오민식이 텐트를 칠 수 있는 경우의 수를 출력한다.

<문제 1148>
어떤 신문엔 이러한 퍼즐이 있다. 3x3의 표에 영문자가 하나씩 있으며, 이 영문자들을 사용해서 최대한 많은 영단어를 만드는 것이 목표이다. 예를 들면, 아래의 퍼즐판에서는 'LINT', 'TILL', 'BRILLIANT' 등을 만들 수 있다.


단어는 최소 4글자 이상이어야 하며, 한 글자당 최대 1번만 사용할 수 있다. 따라서 10글자 이상의 단어는 만들 수 없다. 또한, 표의 정중앙에 있는 글자는 반드시 사용해야 한다. 위 퍼즐판의 경우 'I'는 반드시 사용해야 한다.
따라서 어떤 글자가 가운데에 있느냐에 따라 퍼즐의 난이도는 천차만별일 것이다. 퍼즐 제작자 남규는 퍼즐판에 어떤 글자를 배치할지는 결정했으나 멍청해서 어떤 글자를 가운데에 놓을지까지는 정하지 못했다.
보다 못한 조수 재혁이가 어떤 글자를 놓아야 퍼즐이 가장 쉬워지는지(즉, 만들 수 있는 단어의 개수가 가장 많음), 또 어떤 글자를 놓아야 퍼즐이 가장 어려워지는지(즉, 만들 수 있는 단어의 개수가 가장 적음)를 알려주려고 한다. 그러나 재혁이가 망각한 사실이 있으니 자신도 멍청하다는 것이었다. 따라서 당신이 이 문제를 대신 풀어주어야 한다.
또한 문제 속 세상의 사람들은 우리보다도 멍청해서, 우리보다 훨씬 적은 수의 영단어를 사용한다. 이 단어들을 모두 담고 있는 사전과 퍼즐판에 배치할 9개의 문자가 주어졌을 때, 문제를 푸는 프로그램을 작성하시오.
<입력값>
입력의 처음에는 사전을 이루는 최대 20만 개의 단어가 주어진다. 각 단어는 4~9글자의 영어 대문자로 이루어져 있으며, 한 줄에 하나씩 주어진다. 또한 사전순으로 정렬되어 있다. 사전 입력의 끝에는 한 줄에 걸쳐 '-' 한 글자가 주어진다.
그 다음부터 여러 개의 퍼즐판이 주어진다. 각 퍼즐판은 9개의 영어 대문자로 이루어져 있으며, 한 줄에 하나씩 주어진다. 입력의 맨 끝에는 한 줄에 걸쳐 '#' 한 글자가 주어진다.
<출력값>
각 퍼즐판마다 정답을 예제 형식에 맞게 한 줄에 하나씩 출력한다.
각 문제마다 정답의 개수를 가장 적게 하기 위해 정중앙에 놓아야 할 문자들과 그때의 정답 개수, 정답의 개수를 가장 많게 하기 위해 정중앙에 놓아야 할 문자들과 그 때의 정답 개수를 공백으로 구분하여 출력한다.
한 개 이상의 문자가 답을 만족할 경우 문자들을 알파벳순으로 정렬하여 출력하며, 중복된 문자는 출력하지 않는다. 첫 번째 예제 출력에서 보듯이 I나 L은 여러 번 등장하지만 한 번씩만 출력하였다.

<문제 1149>
RGB거리에는 집이 N개 있다. 거리는 선분으로 나타낼 수 있고, 1번 집부터 N번 집이 순서대로 있다.
집은 빨강, 초록, 파랑 중 하나의 색으로 칠해야 한다. 각각의 집을 빨강, 초록, 파랑으로 칠하는 비용이 주어졌을 때, 아래 규칙을 만족하면서 모든 집을 칠하는 비용의 최솟값을 구해보자.

1번 집의 색은 2번 집의 색과 같지 않아야 한다.
N번 집의 색은 N-1번 집의 색과 같지 않아야 한다.
i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다.
<입력값>
첫째 줄에 집의 수 N(2 ≤ N ≤ 1,000)이 주어진다. 둘째 줄부터 N개의 줄에는 각 집을 빨강, 초록, 파랑으로 칠하는 비용이 1번 집부터 한 줄에 하나씩 주어진다. 집을 칠하는 비용은 1,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 모든 집을 칠하는 비용의 최솟값을 출력한다.

<문제 1150>
당신은 큰 회사들의 컴퓨터 자료를 백업하여주는 정보통신회사를 운영한다. 자료 백업이 즐거운 일이 아니므로, 당신은 서로 다른 두 회사의 자료를 서로 백업하여 주는 시스템을 개발하여 당신이 집에서 게임을 즐기는 동안 백업이 이루어지게 하려 한다.
모든 회사들은 직선인 길을 따라 위치하고 있다. 당신은 서로 백업을 하여 줄 두 회사를 짝 지어 주어야 하는데, 두 회사 사이에 네트워크 케이블을 연결 사용하여야 한다.
네트워크 케이블은 대단히 비쌀 뿐 아니라, 지역 통신 회사에서는 당신에게 오직 k개의 네트워크 케이블을 제공한다 –이 말은 당신이 오직 k 쌍의 회사에만 백업을 할 수 있다는 뜻이다 (전체 2k 개의 회사). 어떤 회사도 두 개 이상의 쌍에 속할 수는 없다 (즉, 여기 2k 개의 회사가 모두 다른 회사라는 것을 뜻한다).
통신 회사는 네트워크 케이블의 길이를 km 단위로 경비를 부과한다. 따라서 당신은 가장 짧은 길이의 케이블을 사용하도록 회사들을 k 쌍으로 짝지어야 한다. 다시 말하자면, 회사들을 짝짓기 하는데, 짝지어진 두 회사간의 거리들의 전체 합을 최소화 하도록 짝을 지어야 한다는 것이다.
예를 들어, 아래 그림과 같이 다섯 개의 고객회사들이 같은 길 위에 위치한다고 하자. 이 회사들은 각각 길의 출발점에서 기준하여 1 km, 3 km, 4 km, 6 km 그리고 12 km 에 위치하고 있다. 통신회사에서는 오직 k = 2 케이블만을 제공한다.

예에서 최선의 짝 짓기 방법은 첫 번째와 두 번째 회사, 그리고 세 번째와 네 번째 회사를 묶어 주는 것이다. k = 2 케이블 만을 사용하게 되며, 첫 번째 케이블의 길이는 3 km –1 km = 2 km 이고, 두 번째 케이블의 길이는 6 km –4 km = 2 km 이다. 이와 같은 짝짓기는 전체 4 km 의 네트워크 케이블을 사용하게 되며, 실제 가능한 가장 짧은 경우이다.
<입력값>
입력의 첫 번째 줄에는 정수 n 과 k 가 주어지는데, 각각 길 위의 회사 수(2 ≤ n≤ 100 000), 그리고 제공되는 네트워크 케이블 수(1 ≤ k ≤ ½ n)를 의미한다. 그 다음 n 줄에는 각각 하나의 정수 s (0 ≤ s ≤ 1 000 000 000) 가 주어지며, 이 정수는 길의 출발점에서 각 회사까지의 거리를 의미한다. 이 정수들은 가장 작은 것에서 가장 큰 것 까지 순서대로 나타난다. 어떤 두 개의 회사도 같은 지점에 있지 않다.
<출력값>
출력은 반드시 하나의 양의 정수로 표현되어야 하는데, 이것은 2k 의 서로 다른 회사를 k 쌍으로 묶었을 때 필요한 가장 짧은 전체 네트워크 케이블의 길이이다.

<문제 1151>
영식이는 가로등 근처에 나무를 심었다. 그러자 영식이의 동생 민식이는 그림자가 얼마나 크고 얼마나 가릴 것인지 궁금해졌다. 영식이가 심은 나무는 직육면체 모양이다. 그리고 가로등은 점 하나에서 빛이 나오는 것으로 생각한다. 이를 간단하게 표현하기 위해서 x,y,z 좌표 시스템을 이용한다. 여기서 z는 땅에서 떨어진 거리(높이)이다.
나무는 두 개의 좌표로 구성되어 있다. 한 좌표는 나무의 한 꼭짓점이고, 또 다른 좌표는 그 꼭짓점의 대각선에 위치한 꼭짓점이다. 가로등은 좌표 하나이다. 그림자의 넓이를 출력하는 프로그램을 작성하시오. (물론 나무가 꼭 땅에 있을 필요는 없다. 공중에 떠 있을 수도 있다.)
<입력값>
첫째 줄에 여섯 개의 수가 주어진다. 처음 세 개의 수는 나무의 한 꼭짓점 좌표이고, 뒤 세 개의 수는 그 대각선쪽의 꼭짓점 좌표이다. 둘째 줄에는 가로등의 좌표가 주어진다. 모든 좌표는 10보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 나무의 넓이를 출력한다. 넓이가 무한대일 경우에는 -1을 출력하고, 그림자가 무한의 직선이라면 0을 출력한다. 절대/상대 오차는 10-6까지 허용한다.

<문제 1152>
영어 대소문자와 띄어쓰기만으로 이루어진 문자열이 주어진다. 이 문자열에는 몇 개의 단어가 있을까? 이를 구하는 프로그램을 작성하시오. 단, 한 단어가 여러 번 등장하면 등장한 횟수만큼 모두 세어야 한다.
<입력값>
첫 줄에 영어 대소문자와 띄어쓰기로 이루어진 문자열이 주어진다. 이 문자열의 길이는 1,000,000을 넘지 않는다. 단어는 띄어쓰기 한 개로 구분되며, 공백이 연속해서 나오는 경우는 없다. 또한 문자열의 앞과 뒤에는 공백이 있을 수도 있다.
<출력값>
첫째 줄에 단어의 개수를 출력한다.

<문제 1153>
임의의 자연수가 주어지면, 이를 네 개의 소수의 합으로 분해하는 프로그램을 작성하시오. 예를 들어 38 = 5 + 7 + 13 + 13이 된다.
<입력값>
첫째 줄에 자연수 N(1 ≤ N ≤ 1,000,000)이 주어진다.
<출력값>
첫째 줄에 네 개의 소수를 빈 칸을 사이에 두고 순서대로 출력한다. 불가능한 경우는 -1을 출력한다.

<문제 1154>
캠프에 많은 학생들이 참석했다. 학생들 모두에게 A팀 또는 B팀을 할당해서 두 개의 팀으로 나누어 팀전을 진행할 예정인데, 아래의 조건을 만족하도록 팀을 편성하고 싶다.

모든 사람은 A팀 또는 B팀 중 오직 하나의 팀에 반드시 속해야 한다.
같은 그룹의 학생들끼리는 모두 서로 아는 사이어야 한다.

이 조건을 만족하면서 팀을 편성하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 학생 수를 나타내는 자연수 N이 주어진다. (N≤1,000) 편의상 각 학생들은 1부터 N까지 번호가 붙어 있다고 가정한다. 둘째 줄부터 각 줄에 두 개의 자연수 a와 b가 빈 칸을 사이에 두고 주어지는데, 이는 a번 학생과 b번 학생이 서로 아는 사이라는 뜻이다. 마지막 줄에 -1 -1이 주어진다.
<출력값>
가능한 경우 첫째 줄에 1을 출력하고, 이어서 두 줄에 학생의 번호를 빈 칸을 사이에 두고 증가하는 순서대로 각각 출력한다. 1번 학생이 포함된 팀을 먼저 출력해야 한다. 이 두 줄의 끝에는 -1을 출력하도록 한다. 불가능한 경우에는 첫째 줄에 -1만을 출력하면 된다.

<문제 1155>
기존 하노이는 모든 학생이 알 것이라 판단하여 설명을 생략한다.
우리는 하노이의 이동을 알파벳 두 글자로 표현할 수 있는데, 예를 들어 A번 폴에서 B번 폴로 가장 위에 있는 디스크를 옮기는 것을 AB라고 표현한다고 한다. 변형 하노이는 문제 조건에 만족하도록 옮기는 것이다. 즉, 자기 임의적으로 디스크를 옮길 수 없다. 디스크를 옮기는 조건은 아래와 같다.․ 동일한 디스크를 연속으로 두 번 옮길 수 없다.
  ․ 총 옮길 수 있는 경우는 6가지(AB, AC, BA, BC, CA, CB)이고 이 여섯 가지의 옮기는 경우의 우선순위가 주어진다. 즉, 1번 조건을 만족하는 옮길 수 있는 경우가 두 가지 이상 존재하면 그 중 우선순위가 높은 것을 택해야 한다.
문제는 위 조건에 따라 판을 옮길 때 모든 디스크를 B폴이나 C폴 중 한 폴로 모두 옮겼을 때 횟수가 몇 번인지 구하는 것이다. (위 조건을 만족하도록 옮기다 보면 항상 어느 폴로 모두 옮겨진다고 한다.)
<입력값>
첫 줄에는 디스크의 수 N(1 ≤ N ≤ 30)과 주어진다. 두 번째 줄에는 6개의 이동 경우에 대해 우선순위가 높은 것부터 차례대로 주어진다.
<출력값>
첫 줄에 이동횟수를 출력한다. 답은 10^18보다 작다고 가정한다.

<문제 1156>
정문이는 생일을 맞아 D일동안 생일파티를 열기로 하였다. 이에 정문이 친구들은 시간을 내어 정문이 생일파티에 참석하기로 하였다. 그리고 정문이는 이번 생일파티는 친구들과 함께 장난감을 갖고 노는 것으로 시간을 보내기로 계획하였다. 좀 더 구체적으로 i번째 날에는 Ti()개의 장난감을 갖고 놀기로 계획을 세웠다.
장난감 가게에는 장난감 하나를 Tc원에 판다. 정문이는 적당히 장난감을 사서 이 장난감들을 계속 재활용하여 파티를 하려고 했으나, 결벽증이 있는 친구들은 새 장난감이나 살균장에서 소독된 장난감이 아니면 안 갖고 놀겠다고 하는 탓에 어쩔 수 없이 계획을 수정하기로 하였다.
정문이가 이용하는 살균장은 두 곳이다. 한 곳은 밤에 장난감을 맡기면 N1일이 지난 아침에 찾아올 수 있고 비용은 한 개당 C1이 든다. 다른 한 곳은 마찬가지로 N2일이 지난 아침에 찾아올 수 있고 비용은 한 개당 C2가 든다.
문제는 정문이를 도와 적당히 장난감을 사고 적당히 이 장난감을 살균장에 맡기는 방식으로 생일파티를 끝낼 수 있는 최소 비용을 구하는 것이다.
<입력값>
첫 줄에는 정수 D(1 ≤ D ≤ 100,000), N1(1 ≤ N1 ≤ D), N2(1 ≤ N2 ≤ D), C1(1 ≤ C1 ≤ 60), C2(1 ≤ C2 ≤ 60), Tc(1 ≤ Tc ≤ 60)가 공백으로 구분되어 주어진다. 두 번째 줄에는 D+1번째 줄까지 i+1번째 줄에는 i번째 날에 필요한 장난감의 수가 주어진다.
<출력값>
첫 줄에 생일파티를 끝내기 위한 최소비용을 출력한다.

<문제 1157>
알파벳 대소문자로 된 단어가 주어지면, 이 단어에서 가장 많이 사용된 알파벳이 무엇인지 알아내는 프로그램을 작성하시오. 단, 대문자와 소문자를 구분하지 않는다.
<입력값>
첫째 줄에 알파벳 대소문자로 이루어진 단어가 주어진다. 주어지는 단어의 길이는 1,000,000을 넘지 않는다.
<출력값>
첫째 줄에 이 단어에서 가장 많이 사용된 알파벳을 대문자로 출력한다. 단, 가장 많이 사용된 알파벳이 여러 개 존재하는 경우에는 ?를 출력한다.

<문제 1158>
요세푸스 문제는 다음과 같다.
1번부터 N번까지 N명의 사람이 원을 이루면서 앉아있고, 양의 정수 K(≤ N)가 주어진다. 이제 순서대로 K번째 사람을 제거한다. 한 사람이 제거되면 남은 사람들로 이루어진 원을 따라 이 과정을 계속해 나간다. 이 과정은 N명의 사람이 모두 제거될 때까지 계속된다. 원에서 사람들이 제거되는 순서를 (N, K)-요세푸스 순열이라고 한다. 예를 들어 (7, 3)-요세푸스 순열은 <3, 6, 2, 7, 5, 1, 4>이다.
N과 K가 주어지면 (N, K)-요세푸스 순열을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N과 K가 빈 칸을 사이에 두고 순서대로 주어진다. (1 ≤ K ≤ N ≤ 5,000)
<출력값>
예제와 같이 요세푸스 순열을 출력한다.

<문제 1159>
상근이는 농구의 세계에서 점차 영향력을 넓혀가고 있다. 처음에 그는 농구 경기를 좋아하는 사람이었다. 농구에 대한 열정은 그를 막을 수 없었고, 결국 상근이는 농구장을 청소하는 일을 시작했다. 상근이도 농구장을 청소하면서 감독이 되기 위해 가져야할 능력을 공부해나갔다. 서당개 3년이면 풍월을 읊듯이 상근이는 점점 감독으로 한 걸음 다가가고 있었다. 어느 날 그에게 지방의 한 프로농구팀을 감독할 기회가 생기게 되었다. 그는 엄청난 지도력을 보여주며 프로 리그에서 우승을 했고, 이제 국가대표팀의 감독이 되었다.
내일은 일본과 국가대표 친선 경기가 있는 날이다. 상근이는 내일 경기에 나설 선발 명단을 작성해야 한다.
국가대표팀의 감독이 된 이후에 상근이는 매우 게을러졌다. 그는 선수의 이름을 기억하지 못하고, 각 선수의 능력도 알지 못한다. 따라서, 누가 선발인지 기억하기 쉽게 하기 위해 성의 첫 글자가 같은 선수 5명을 선발하려고 한다. 만약, 성의 첫 글자가 같은 선수가 5명보다 적다면, 상근이는 내일 있을 친선 경기를 기권하려고 한다.
상근이는 내일 경기를 위해 뽑을 수 있는 성의 첫 글자를 모두 구해보려고 한다.
<입력값>
첫째 줄에 선수의 수 N (1 ≤ N ≤ 150)이 주어진다. 다음 N개 줄에는 각 선수의 성이 주어진다. (성은 알파벳 소문자로만 이루어져 있고, 최대 30글자이다)
<출력값>
상근이가 선수 다섯 명을 선발할 수 없는 경우에는 "PREDAJA" (따옴표 없이)를 출력한다. PREDAJA는 크로아티아어로 항복을 의미한다. 선발할 수 있는 경우에는 가능한 성의 첫 글자를 사전순으로 공백없이 모두 출력한다.

<문제 1160>
홍준이는 통계학을 공부하다가 ‘무작위 추출’의 매력에 푹 빠졌고, 난수 발생기를 이용해 직접 ‘무작위 추출’을 한다. 홍준이는 일차 점화식으로 생성되는 수열을 이용한 난수 발생기가 적당하다고 생각했다. 수열을 만들기 위해서는 음이 아닌 정수 m, a, c, X0이 필요하다. 수열 <Xn>의 점화식은 다음과 같다:
Xn+1 = (aXn + c) mod m
"A mod m"이라는 말은 A를 m으로 나눈 나머지를 뜻한다.
최종적으로, Xn을 양의 정수 g로 나눈 나머지가 난수로 사용한다. 따라서 생성된 난수는 0, 1, …, g-1사이의 값을 가지게 될 것이다.
착한 명우는, 친구 홍준이의 속마음을 읽고, 난수 발생기를 만들어주려고 한다. 명우를 도와 홍준이에게 줄 난수 발생기 프로그램을 작성하시오.
<입력값>
첫째 줄에 6개의 정수 m, a, c, X0, n, g (m, a, c, X0, n ≤ 1018, g ≤ 108)가 차례대로 주어진다. a, c, X0는 음이 아닌 정수이고 m, n, g는 양의 정수이다.
<출력값>
첫째 줄에 Xn mod g의 값을 출력한다.

<문제 1161>
포천 주민들은 여러 버스 정류장에서 버스를 기다리고 있다. 하지만 안타깝게도 버스는 이 모든 사람들을 수용할 수 있는 크기가 되지 못한다. 
문제는 정류장의 개수 N과 M개의 그룹에 대해 현재 기다리는 정류장 번호와 내릴 정류장 번호가 주어지면 1번 정류장에서 출발하여 N번 정류장까지 운행할 때 최대 태울 수 있는 인원을 구하는 것이다. 단, 버스는 1, 2, …, N번 정류장 순서로 방문한다.
<입력값>
첫 줄에는 그룹의 수 K(1 ≤ K ≤ 50,000)와 정류장 개수 N(1 ≤ N ≤ 20,000)과 버스의 최대 수용 인원 C(1 ≤ C ≤ 100)가 공백으로 구분되어 주어진다. 두 번째 줄부터 K+1번째 줄까지 각 줄에 대해 K개의 그룹에 대한 정보가 담긴 Si, Ei, Mi가 주어지는데 이는 이 그룹은 총 Mi명이고 Si번 정류장에서 출발하여 Ei번 정류장에서 내릴려고 한다는 의미이다.
<출력값>
첫 줄에 최대 수송 인원을 출력한다.

<문제 1162>
준영이는 매일 서울에서 포천까지 출퇴근을 한다. 하지만 잠이 많은 준영이는 늦잠을 자 포천에 늦게 도착하기 일쑤다. 돈이 많은 준영이는 고민 끝에 K개의 도로를 포장하여 서울에서 포천까지 가는 시간을 단축하려 한다.
문제는 N개의 도시가 주어지고 그 사이 도로와 이 도로를 통과할 때 걸리는 시간이 주어졌을 때 최소 시간이 걸리도록 하는 K개의 이하의 도로를 포장하는 것이다. 도로는 이미 있는 도로만 포장할 수 있고, 포장하게 되면 도로를 지나는데 걸리는 시간이 0이 된다. 또한 편의상 서울은 1번 도시, 포천은 N번 도시라 하고 1번에서 N번까지 항상 갈 수 있는 데이터만 주어진다.
<입력값>
첫 줄에는 도시의 수 N(1 ≤ N ≤ 10,000)과 도로의 수 M(1 ≤ M ≤ 50,000)과 포장할 도로의 수 K(1 ≤ K ≤ 20)가 공백으로 구분되어 주어진다. M개의 줄에 대해 도로를 연결짓는 두 도시와 도로를 통과하는데 걸리는 시간이 주어진다. 도로들은 양방향 도로이며, 걸리는 시간은 1,000,000보다 작거나 같은 자연수이다.
<출력값>
첫 줄에 K개 이하의 도로를 포장하여 얻을 수 있는 최소 시간을 출력한다.

<문제 1163>
문자열이 증가하는 리스트가 되려면 다음과 같은 조건을 만족해야 한다. 콤마로 구분되어 있는 자연수(0으로 시작하지 않음)가 오름차순이어야 한다.
예를 들어, 문자열 “2,3,9”, “30”, “1,100,1000000”는 증가하는 리스트이지만, “5,6,6”, “1,2,3,”, “0”, “1,02”는 아니다.
이 문제에서 숫자, 콤마, 그리고 물음표로 구성된 문자열이 주어진다. 그러면, 물음표를 적절히 숫자나 콤마로 바꿔서 결과 문자열이 증가하는 리스트가 되게 해야 한다. 만약 그러한 것이 여러 가지 일 경우에는 사전 순으로 앞서는 것을 출력한다. (콤마(,)는 숫자(0-9)보다 사전 순으로 앞선다.)
<입력값>
첫째 줄에 콤마, 숫자, 그리고 물음표로만 구성된 문자열이 주어진다. 이 문자열의 길이는 최대 100이다.
<출력값>
첫째 줄에 문제의 정답을 출력한다. 불가능한 경우에는 -1을 출력한다.

<문제 1164>
민식이는 다음과 같이 두 가지 모양의 종이를 가지고 있다.

           A  A            BB
           AAAA
이 종이를 회전시키는 것은 불가능하다.
영식이는 .과 X로 이루어진 직사각형 모양의 종이를 가지고 있다. 민식이는 X가 되어있는 곳을 모두 두가지 종이를 이용해서 가리려고 한다. (종이를 겹치게 놓는 것은 안됨)
민식이가 종이를 어떻게 가려야 하는지를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 영식이의 종이의 세로 크기 N과 가로 크기 M이 주어진다. 모두 100보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 영식이의 종이가 어떻게 생겼는지 주어진다. (.과 X로만 이루어져 이다.)
<출력값>
N개의 줄에 민식이가 종이를 어떻게 놓아야 하는지를 출력한다. 그러한 경우가 여러 가지일 때는 사전순으로 가장 앞서는 것을 출력한다. (첫 줄이 같다면 둘째 줄을 비교하고, 그 다음 셋째 줄을 비교하고 이런 식으로) 불가능 할 경우에는 -1을 출력한다.

<문제 1165>
5 x 5 행렬에 대문자 알파벳이 하나씩 들어간 퍼즐이 있다. 그리고 이 행렬에서 주어진 단어들을 찾는 것이다. 찾는 방법은 임의의 시작점에서 시작하여 인접한 8방향으로 뻗어나가면서 알파벳을 이어나가는 것이다. 찾을 단어들은 문제와 함께 배포된 dict.txt에 들어있는 단어들이다.

Z C C D X
K Q M N B
U O W Z Y
F C O I J
P A Q Z T
위와 같은 퍼즐이 있을 때 CAP, COW, COOK 등은 퍼즐에서 찾을 수 있지만 COD, PACK 등은 찾을 수 없다.
문제는 퍼즐이 주어졌을 때, 퍼즐 속에 총 몇 개의 단어가 있는지 구하는 것이다.
<입력값>
다섯 줄에 걸쳐 5 x 5알파벳 퍼즐이 공백으로 구분되어 주어진다.
<출력값>
첫 줄에 포함되는 총 단어 개수를 출력한다.

<문제 1166>
오민식은 아이들에게 선물할 모두 같은 크기의 작은 박스를 N개 가지고 있다. 모든 박스는 A * A * A크기의 정육면체이다. 오민식은 이 작은 박스를 L * W * H 크기의 큰 직육면체 박스에 넣으려고 한다. 모든 작은 박스는 큰 박스 안에 있어야 하고, 작은 박스의 변은 큰 박스의 변과 평행해야 한다.
N, L, W, H가 주어질 때, A의 최댓값을 찾는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N L W H가 주어진다. 모든 값은 1,000,000,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 문제의 정답을 출력한다. 절대/상대 오차는 10-9까지 허용한다.

<문제 1167>
트리의 지름이란, 트리에서 임의의 두 점 사이의 거리 중 가장 긴 것을 말한다. 트리의 지름을 구하는 프로그램을 작성하시오.
<입력값>
트리가 입력으로 주어진다. 먼저 첫 번째 줄에서는 트리의 정점의 개수 V가 주어지고 (2≤V≤100,000)둘째 줄부터 V개의 줄에 걸쳐 간선의 정보가 다음과 같이 주어진다. (정점 번호는 1부터 V까지 매겨져 있다고 생각한다)
먼저 정점 번호가 주어지고, 이어서 연결된 간선의 정보를 의미하는 정수가 두 개씩 주어지는데, 하나는 정점번호, 다른 하나는 그 정점까지의 거리이다. 예를 들어 네 번째 줄의 경우 정점 3은 정점 1과 거리가 2인 간선으로 연결되어 있고, 정점 4와는 거리가 3인 간선으로 연결되어 있는 것을 보여준다. 각 줄의 마지막에는 -1이 입력으로 주어진다. 주어지는 거리는 모두 10,000 이하의 자연수이다.
<출력값>
첫째 줄에 트리의 지름을 출력한다.

<문제 1168>
요세푸스 문제는 다음과 같다.
1번부터 N번까지 N명의 사람이 원을 이루면서 앉아있고, 양의 정수 K(≤ N)가 주어진다. 이제 순서대로 K번째 사람을 제거한다. 한 사람이 제거되면 남은 사람들로 이루어진 원을 따라 이 과정을 계속해 나간다. 이 과정은 N명의 사람이 모두 제거될 때까지 계속된다. 원에서 사람들이 제거되는 순서를 (N, K)-요세푸스 순열이라고 한다. 예를 들어 (7, 3)-요세푸스 순열은 <3, 6, 2, 7, 5, 1, 4>이다.
N과 K가 주어지면 (N, K)-요세푸스 순열을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N과 K가 빈 칸을 사이에 두고 순서대로 주어진다. (1 ≤ K ≤ N ≤ 100,000)
<출력값>
예제와 같이 요세푸스 순열을 출력한다.

<문제 1169>
크기가 서로 다른 N개의 정사각형이 있다. 모든 정사각형의 한 변의 길이는 자연수이다. 이제 이 정사각형들을 아래와 같이 45도 기울여서 진열하려고 한다.

먼저, 첫 번째 정사각형 S1을 x축과 y축에 접하게 놓는다. 이럴 때 x축과 정사각형이 만나는 위치를 b1이라고 생각한다.
이어서 S2부터 정사각형을 하나씩 순서대로 놓는데, i번째 정사각형 Si를 놓을 때, bi는 bi-1보다는 커야 하되 다른 정사각형과 겹치지 않으면서 최대한 bi가 작게 놓아야 한다.
이렇게 정사각형들을 진열하고 난 뒤에, 우리는 y축 방향에서 보이는 정사각형들을 구하고 싶다. 정사각형 위의 임의의 한 점에서 y축 방향으로 반직선을 그렸을 때, 다른 정사각형들과 만나지 않는 반직선이 존재하는 경우 "y축 방향에서 보이는 정사각형"으로 정의한다.
<입력값>
첫째 줄에 정사각형의 개수 N(1≤N≤100)이 주어진다. 이어서 둘째 줄에 각 정사각형의 한 변의 길이를 나타내는 N개의 자연수가 순서대로 주어진다. 각 정사각형의 길이는 1,000을 넘지 않는다.
<출력값>
첫째 줄에 y축 방향에서 보이는 정사각형의 번호를 빈 칸을 사이에 두고 증가하는 순서로 출력한다.

<문제 1170>
정점 선인장은 다음 조건을 만족하는 연결된 무방향 그래프이다.
조건 : 모든 정점은 많아야 하나의 단순 사이클에 포함된다.
단순 사이클이란 사이클 중에서 시작과 끝을 제외하고 각 정점들이 많아야 한 번씩 나타날 때이다.
예를 들어, 다음 그림은 정점 선인장이다.

그래프 G의 정점의 개수 N이 주어진다. 정점은 1번부터 N번까지 번호가 매겨져 있다. 그래프의 간선이 어떻게 연결되어 있는지가 주어질 때, 그래프 G의 연결 요소 중 정점 선인장인 것의 개수를 출력하는 프로그램을 작성하시오.
그래프 G의 연결 요소란 정점의 집합인데, 집합 내의 모든 쌍의 정점이 경로로 연결되어 있고, 집합 밖의 정점과 집합 내의 정점이 연결되어 있지 않을 때이다.
<입력값>
첫째 줄에 그래프 G의 정점의 개수 N과 간선의 개수 M이 주어진다. N은  200보다 작거나 같은 자연수이고, M은 0보다 크거나 같은 정수이다. 둘째 줄부터 M개의 줄에 간선의 정보가 주어진다. 간선의 정보는 공백으로 구분되어 있는 한 쌍의 정수이다. 입력으로 주어지는 간선은 중복되지 않으며, 모든 쌍의 정점은 많아야 한 개의 간선으로 연결될 것이다.
<출력값>
첫째 줄에 문제의 정답을 출력한다.

<문제 1171>
민식이는 애들과 토론 중이다. 안타깝게 민식이의 남의 말을 제대로 알아듣지 못한다. 민식이 귀가 다른 사람이 한 말을 인식하는 방법은 다음과 같다. 일단 민식이는 다른 사람이 말한 말을 2진수로 바꾸어 듣는다. 그리고 다른 사람이 한 말의 i번째 비트는 민식이가 인식하는 이진수의 j번째 비트에 위치하게 되는데 항상 |j - i| ≤ D가 성립한다. 이렇게 만들어진 이진수로 민식이는 알아듣게 된다.
만약 다른 사람이 한 말이 0110이라면 민식이가 알아듣는 이진수의 후보는 0101, 0110, 1001, 1010으로 총 4가지이다.

문제는 다른 사람이 말하는 이진수와 정수 D, K가 주어지면 민식이가 알아듣는 이진수 후보의 개수와 이 후보들 중 K번째로 작은 이진수를 출력하는 문제이다.
<입력값>
첫 줄에는 이진수 비트의 개수 N(1 ≤ N ≤ 2,000)과 D(0 ≤ D < N), K(1 ≤ K ≤ 100,000,000)가 공백으로 구분되어 주어진다. 두 번째 줄에는 다른 사람이 말한 N비트의 2진수가 주어진다.
<출력값>
첫 줄에 민식이가 알아들을 것으로 예상되는 2진수의 총 후보의 개수를 100,000,000로 나눈 나머지를 출력한다. 다음 줄에는 이 이진수의 후보 중 K번째로 작은 2진수를 출력한다.

<문제 1172>
정점 선인장은 다음 조건을 만족하는 연결된 무방향 그래프이다.
조건 : 모든 정점은 많아야 하나의 단순 사이클에 포함된다.
단순 사이클이란 사이클 중에서 시작과 끝을 제외하고 각 정점들이 많아야 한 번씩 나타날 때이다.
예를 들어, 다음 그림은 정점 선인장이다.

정점의 번호가 1번부터 N번까지 매겨져 있는 그래프 G가 주어진다. 이것의 Automorphisms은 간선 i-j가 있을 때, 간선 P[i]-P[j]가 항상 존재한다는 조건을 만족하는 순열 P[1], P[2], ..., P[N]이다.
정점 선인장인 그래프 G의 정점의 개수 N이 주어진다. 정점은 1번부터 N번까지 번호가 매겨져 있다. 그래프의 간선이 어떻게 연결되어 있는지가 주어질 때, 주어진 정점 선인장의 Automorphisms의 개수를 10^9+3으로 나눈 나머지를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 그래프 G의 정점의 개수 N과 간선의 개수 M이 주어진다. N은  200보다 작거나 같은 자연수이고, M은 0보다 크거나 같은 정수이다. 둘째 줄부터 M개의 줄에 간선의 정보가 주어진다. 간선의 정보는 공백으로 구분되어 있는 한 쌍의 정수이다. 입력으로 주어지는 간선은 중복되지 않으며, 모든 쌍의 정점은 많아야 한 개의 간선으로 연결될 것이다. 그리고, 그래프 G는 항상 정점 선인장이다.
<출력값>
첫째 줄에 문제의 정답을 출력한다.

<문제 1173>
영식이가 운동을 하는 과정은 1분 단위로 나누어져 있다. 매 분마다 영식이는 운동과 휴식 중 하나를 선택해야 한다.
운동을 선택한 경우, 영식이의 맥박이 T만큼 증가한다. 즉, 영식이의 맥박이 X였다면, 1분 동안 운동을 한 후 맥박이 X+T가 되는 것이다. 영식이는 맥박이 M을 넘는 것을 원하지 않기 때문에, X+T가 M보다 작거나 같을 때만 운동을 할 수 있다. 휴식을 선택하는 경우 맥박이 R만큼 감소한다. 즉, 영식이의 맥박이 X였다면, 1분 동안 휴식을 한 후 맥박은 X-R이 된다. 맥박은 절대로 m보다 낮아지면 안된다. 따라서, X-R이 m보다 작으면 맥박은 m이 된다.
영식이의 초기 맥박은 m이다. 운동을 N분 하려고 한다. 이때 운동을 N분하는데 필요한 시간의 최솟값을 구해보자. 운동하는 시간은 연속되지 않아도 된다.
<입력값>
첫째 줄에 다섯 정수 N, m, M, T, R이 주어진다.
<출력값>
첫째 줄에 운동을 N분하는데 필요한 시간의 최솟값을 출력한다.. 만약 운동을 N분 할 수 없다면 -1을 출력한다.

<문제 1174>
음이 아닌 정수를 십진법으로 표기했을 때, 왼쪽에서부터 자리수가 감소할 때, 그 수를 줄어드는 숫자라고 한다. 예를 들어, 321와 950은 줄어드는 숫자이고, 322와 958은 아니다.
N번째로 작은 줄어드는 수를 출력하는 프로그램을 작성하시오. 만약 그러한 수가 없을 때는 -1을 출력한다. (가장 작은 줄어드는 수가 1번째 작은 줄어드는 수이다.)
<입력값>
N이 주어진다. N은 1,000,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 N번째 작은 줄어드는 수를 출력한다.

<문제 1175>
어제 선물을 모두 포장한 민식이는 이제 선물을 배달하려고 한다. 민식이가 선물을 배달할 곳은 이 문제를 읽는 사람들이 앉아 있는 교실이다. 교실은 직사각형모양이고, 모두 같은 크기의 정사각형 블록으로 나누어져 있다.
입력으로 교실의 지도가 주어진다. 각각의 정사각형 블록은 다음과 같이 4가지 종류가 있다.

S : 지금 민식이가 있는 곳이다. 이곳이 민식이가 배달을 시작하는 곳이다.
C : 민식이가 반드시 선물을 배달해야 하는 곳이다. 이러한 블록은 정확하게 2개 있다.
# : 민식이가 갈 수 없는 곳이다.
. : 민식이가 자유롭게 지나갈 수 있는 곳이다.

민식이가 한 블록 동서남북으로 이동하는데는 1분이 걸린다. 민식이는 네가지 방향 중 하나로 이동할 수 있으며, 교실을 벗어날 수 없다. 민식이가 선물을 배달해야 하는 곳에 들어갈 때, 민식이는 그 곳에 있는 사람 모두에게 선물을 전달해야 한다. 이 상황은 동시에 일어나며, 추가적인 시간이 소요되지 않는다.
민식이는 어느 누구도 자신을 보지 않았으면 하기 때문에, 멈추지 않고 매 시간마다 방향을 바꿔야 한다. 이 말은 같은 방향으로 두 번 연속으로 이동할 수 없다는 말이다. 민식이가 선물을 모두 배달하는데 걸리는 시간의 최솟값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 교실의 세로 크기 N과 가로 크기 M이 주어진다. N과 M은 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 교실의 지도가 주어진다.
<출력값>
첫째 줄에 민식이가 선물을 모두 배달하는데 걸리는 시간의 최솟값을 출력한다. 만약 불가능 할 때는 -1을 출력한다.

<문제 1176>
조교는 N명의 학생들을 벌주기 위해 한 방에 불러 앉혔다. 그리고 이 N명을 어깨동무 앉았다 일어나기를 시키려한다. 하지만 아이들을 최대한 힘들게 하기위한 방법을 고민하던 중 모든 이웃한 학생들의 키 차이가 K를 초과하는 순서로 배열하는 방법을 생각해냈다.
이에 현재 서있는 아이들의 순서를 섞어서 조건을 만족하는 순서로 재배열하는 가짓수가 총 몇 가지가 있는지 알고 싶었다. 예들 들어, 학생들의 키가 1, 3, 5, 2, 6, 4인 순서대로 섞였다면 모든 이웃한 학생 키가 1을 초과하지만 1, 3, 6, 5, 2, 4로 섞였다면 6과 5사이 차이가 1이기 때문에 조건을 만족하지 못한다.
<입력값>
첫 줄에는 학생의 수 N(1 ≤ N ≤ 16)과 최소 넘어야할 키의 차이 값 K(1 ≤ K ≤ 3,400)가 주어진다. 다음 N개의 줄에는 학생들의 키가 순서대로 들어온다. 키는 25,000 이하인 자연수만 들어온다.
<출력값>
첫 줄에 조건을 만족하는 가능한 배열의 개수를 출력한다.

<문제 1177>
학생들은 프로그래밍 시간에 계속해서 떠들고 있다. 더 이상 참지 못한 조쌤은 자리를 박차고 애들을 잡기 위해 뛰기 시작했고 이와 동시에 떠들던 N명의 학생은 도망가기 시작했다.
현재 조쌤은 (BX, BY) 위치에 있다. 그리고 뛰기 시작한 조쌤은 t초 후 (BX+BVX*t, BY+BVY*t) 위치에 있게 된다. 즉 조쌤은 초당 (BVX, BVY) 방향으로 뛰고 있는 것이다.
N명의 학생 역시 현재 (Xi, Yi)에 위치하고 있고 t(t ≥ 0)초 후 (Xi+VXi*t, Yi+VYi*t) 위치에 있게 된다.
조쌤은 현재 자신 위치에서 반경이 R인 원 안에 있는 아이들은 모조리 잡을 수 있다. 하지만 위의 조건을 살펴보면 현재 아이들과 조쌤 모두 뛰는 상황이기에 시간마다 아이들을 잡을 수 있는 숫자가 변한다. 조쌤은 한 번 잡고나면 잡히지 않은 아이들은 모두 도망간 상태기 때문에 단 한번의 기회에 최대한 많은 아이들을 잡고 싶다.
문제는 조쌤과 학생들의 위치 및 뛰는 방향이 주어지면 한 번에 얼마나 많은 학생을 잡을 수 있는지 구하는 것이다. 물론, 최대한 많이 잡을 수 있는 시간이 정수가 아닌 소수일 수도 있다.
<입력값>
첫 줄에는 학생의 수 N(1 ≤ N ≤ 50,000)과 조쌤이 잡을 수 있는 반경 R(1 ≤ R ≤ 2,500), 그리고 조쌤의 위치를 나타내는 BX, BY(-1,000 ≤ BX, BY ≤ 1,000)와 조쌤이 뛰는 방향을 나타내는 BVX, BVY(-100 ≤ BVX, BVY ≤ 100)가 공백으로 구분되어 주어진다. 두 번째 줄부터 N+1번째 줄까지는 각 학생의 정보가 주어지는데 각 줄에는 학생의 초기 위치 Xi, Yi와 뛰는 방향 VXi, VYi(-1,000 ≤ Xi, Yi, VXi, VYi ≤ 1,000)가 공백으로 구분되어 주어진다. 입력되는 모든 수는 정수이다.
<출력값>
첫 줄에 조쌤이 한 번에 잡을 수 있는 최대 학생 숫자를 출력한다. 실수 오차 조정을 위해 학생과 조교 사이의 거리가 R±0.0001이라면 잡을 수 있다고 한다.

<문제 1178>
그래프에 최소 개수의 간선을 추가해서 한붓그리기가 가능한 연결 그래프로 만드는 프로그램을 작성하시오.
한붓그리기가 가능하다는 것은 한 번 지난 간선을 다시 지나지 않으면서 모든 간선을 지나는 경로가 존재한다는 것을 의미한다. 시작점과 끝점은 같을 수도 있고 다를 수도 있다.
<입력값>
첫째 줄에 정점의 개수 V와 간선의 개수 E가 주어진다. (2 ≤ V ≤ 1,000, 1 ≤ E ≤ V×(V-1)/2) 정점에는 1부터 V까지 번호가 매겨져 있다고 생각한다. 이어서 E개의 줄에 걸쳐 간선을 이루는 두 점 a와 b가 주어진다. a와 b는 서로 다르며, 입력으로 주어지는 모든 간선 역시 서로 다르다.
<출력값>
첫째 줄에 추가해야 하는 간선 개수의 최솟값을 출력한다.

<문제 1179>
요세푸스 문제는 다음과 같다.
1번부터 N번까지 N명의 사람이 원을 이루면서 앉아있고, 양의 정수 K(≤ N)가 주어진다. 이제 순서대로 K번째 사람을 제거한다. 한 사람이 제거되면 남은 사람들로 이루어진 원을 따라 이 과정을 계속해 나간다. 이 과정은 N명의 사람이 모두 제거될 때까지 계속된다. 원에서 사람들이 제거되는 순서를 (N, K)-요세푸스 순열이라고 한다. 예를 들어 (7, 3)-요세푸스 순열은 <3, 6, 2, 7, 5, 1, 4>이다.
N과 K가 주어지면, 마지막으로 남는 사람의 번호를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N과 K가 빈 칸을 사이에 두고 순서대로 주어진다. (1 ≤ N ≤ 1015, 1 ≤ K ≤ 90)
<출력값>
첫째 줄에 마지막으로 남는 사람의 번호를 출력한다.

<문제 1180>
Cactus란 그래프 상의 모든 에지가 최대 하나의 사이클에만 속한 연결된 양방향 그래프이다. 즉, Cactus는 몇몇 그래프를 포함하는 트리라고 생각하면 된다.
문제는 주어진 Cactus의 지름을 찾는 것이다. 지름이란 모든 두 점 사이의 최단 거리 중 최대 거리를 뜻한다.

위의 Cactus의 예에서는 6번 정점에서 12번 정점까지의 최단경로가 8로 이 두 점 사이의 최단 경로가 Cactus 내에 존재하는 최단경로 중 최대가 되므로 지름은 8이 된다.
<입력값>
첫 줄에는 정점의 개수 N(1 ≤ N ≤ 50,000)과 간선의 집합 개수 M(0 ≤ M ≤ 10,000)이 주어진다. 다음 M개의 줄에 M개의 간선의 집합에 대한 정보가 주어지는데, 각 줄에 첫 번째 수 Ki(1 ≤ Ki ≤ 1,000)는 i번째 에지 집합의 개수를 나타낸다. 다음 Ki개의 수는 정점의 번호를 나타내는데 인접한 두 정점간의 에지가 집합에 포함되는 것을 의미한다.
<출력값>
첫 줄에 Cactus의 지름을 출력한다.

<문제 1181>
알파벳 소문자로 이루어진 N개의 단어가 들어오면 아래와 같은 조건에 따라 정렬하는 프로그램을 작성하시오.

길이가 짧은 것부터
길이가 같으면 사전 순으로
<입력값>
첫째 줄에 단어의 개수 N이 주어진다. (1 ≤ N ≤ 20,000) 둘째 줄부터 N개의 줄에 걸쳐 알파벳 소문자로 이루어진 단어가 한 줄에 하나씩 주어진다. 주어지는 문자열의 길이는 50을 넘지 않는다.
<출력값>
조건에 따라 정렬하여 단어들을 출력한다. 단, 같은 단어가 여러 번 입력된 경우에는 한 번씩만 출력한다.

<문제 1182>
N개의 정수로 이루어진 수열이 있을 때, 크기가 양수인 부분수열 중에서 그 수열의 원소를 다 더한 값이 S가 되는 경우의 수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 정수의 개수를 나타내는 N과 정수 S가 주어진다. (1 ≤ N ≤ 20, |S| ≤ 1,000,000) 둘째 줄에 N개의 정수가 빈 칸을 사이에 두고 주어진다. 주어지는 정수의 절댓값은 100,000을 넘지 않는다.
<출력값>
첫째 줄에 합이 S가 되는 부분수열의 개수를 출력한다.

<문제 1183>
캠프에는 두 그룹이 있다. 한 그룹은 오민식을 중심으로 모인 그룹이고, 또다른 그룹은 오영식을 중심으로 모인 그룹이다.
오민식 그룹에 있는 사람들은 오영식 그룹에 있는 사람들을 만나기로 약속했다. 오민식 그룹에 있는 각각의 사람들은 정확하게 한 명의 오영식 그룹의 사람들을 만나야 한다. 이때, 오민식 그룹의 i번째 사람은 오영식 그룹의 i번째 사람을 만나야 한다.
불행하게도, 오민식 그룹의 사람들 중 몇 명은 만나기로 약속한 시간에 오영식 그룹의 사람을 만날 수 없다는 것을 알았다. 그들은 너무 빨리 도착하거나 너무 늦게 도착할 것이다.
기다리는 시간의 총 합을 최소화하기 위해서, 오민식 그룹의 사람들은 어떤 시간만큼 약속 시간을 늦추기로 했다. 총 기다리는 시간은 오민식 그룹의 사람이 오영식 그룹의 사람이 나타나기를 기다리는 시간과 오영식 그룹의 사람이 오민식 그룹의 사람이 나타나기를 기다리는 시간을 포함한다. 오영식 그룹의 사람은 조정된 약속 시간에 정확하게 나타날 것이다.
오민식 그룹의 사람이 오영식 그룹의 사람을 만나기로 한 원래 약속시간이 주어지고, 오민식 그룹의 사람이 도착하는 시간이 주어진다.
예를 들어, 오민식 그룹이 N명이고, 오민식 그룹의 원래 약속시간이 배열 S라고 하고, 도착하는 시간을 배열A이라고 하고, 약속을 T시간만큼 미뤘다면, 기다리는 시간의 총합은 abs(S[i]+T-A[i])를 모두 더한 값이 된다.
기다리는 시간의 합이 최소가 되는 T의 개수가 몇 개인지 구하는 프로그램을 작성하시오. T는 음수일 수도 있다.
<입력값>
첫째 줄에 오민식 그룹의 사람 수 N이 주어진다. N은 10,000보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 각각의 오민식 그룹 사람의 원래 약속시간과 도착시간이 주어진다. 이 값은 10^9보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 기다리는 시간의 합이 최소인 서로 다른 T의 개수를 출력한다.

<문제 1184>
상근이와 선영이는 도심 속의 삶에 싫증을 느꼈고, 친구 현수가 있는 시골로 농사를 지으려 내려왔다. 현수의 땅은 크기가 N×N 인 정사각형이고, 땅은 단위 정사각형 1×1로 나누어져 있다. 각 단위 정사각형 (i,j)의 수익은 Aij이다. Aij는 음수가 될 수도 있다. (땅을 경작하지 않아 관리가 필요한 경우)
현수는 자신의 땅의 일부를 상근이와 선영이에게 빌려주려고 한다. 두 사람이 받게되는 땅은 항상 직사각형 모양이고, 변은 축에 평행하다.
현수는 두 사람이 농사지을 땅의 수익의 합이 같게 되도록 땅을 빌려주려고 한다. 또, 경쟁심을 유도하기위해 두 땅은 꼭짓점 하나에서만 만나게 하려고 한다. (변을 공유할 수는 없다)
현수 땅의 정보가 주어졌을 때, 땅을 나누어주는 방법의 수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 땅의 크기 N (1 ≤ N ≤ 50)이 주어진다.
다음 N개의 줄의 N번째 숫자 Aij는 부분 정사각형 (i,j)의 수익이다. (-1000 < Aij < 1000)
<출력값>
현수의 조건을 만족시키면서 땅을 빌려주는 방법의 수를 출력한다.

<문제 1185>
민식이는 여름에 유럽여행을 떠날 계획이다. 방문할 나라는 총 N개의 나라이고 편리하게 1번부터 N번까지 번호를 붙였다. 또한 이 나라들 사이에 이동 가능한 길은 M개가 있는데 민식이는 귀찮기 때문에 N개의 나라가 서로 연결된 것을 유지시키면서 최대한 많은 길을 지도에서 제거하고자 한다. 즉, N-1개의 길만을 남겨야할 것이다.
각 길을 통과하기 위한 비용이 각기 다르고 한 나라를 도착하면 내야할 비용 역시 나라마다 다르게 정해져있다. 민식이는 모든 도시를 최소 한번 이상 방문하면서 최소 비용이 드는 방법을 찾고 있다. 물론 길과 나라는 여러 번 방문할 수 있고, 첫 시작 나라는 민식이가 정할 수 있고, 마지막 나라는 시작 나라이어야 한다. 이러한 민식이의 유럽 계획을 도와주자.
<입력값>
첫 줄에는 방문할 나라의 수 N(5 ≤ N ≤ 10,000)과 이 나라들 사이를 연결하는 길의 수 P(N-1 ≤ P ≤ 100,000)가 주어진다. 두 번째 줄에는 N+1번째 줄까지 i+1번째 줄에는 i번째 나라를 방문할 때 드는 비용 Ci (1 ≤ Ci ≤ 1,000)가 입력된다. 다음 P개의 줄에는 P개의 길에 대한 정보를 의미하는 세 정수 Sj, Ej, Lj가 입력되는데 이는 Sj번째 나라와 Ej번째 나라 사이를 연결짓는 길을 통과하기 위해서는 Lj 비용이 든다는 의미이다. (Sj ≠ Ej, 0 ≤ Lj ≤ 1,000)
<출력값>
첫 줄에 민식이가 유럽여행을 마치기 위한 최소비용을 출력한다.

<문제 1186>
2차원 평면에 축에 평행한 직사각형 N개가 있다. 이 중 K개를 칠할 것이다.
색칠한 면적 중 보이는 것의 최댓값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 직사각형의 개수 N과 색칠해야하는 직사각형의 개수 K가 주어진다. 둘째 줄부터 N개의 줄에 직사각형의 정보가 주어진다. x1 y1 x2 y2와 같이 주어지며, (x1, y1)이 왼쪽 아래 모서리, (x2, y2)가 오른쪽 위 모서리이다. 만약 어떤 곳에 직사각형이 두 개 이상 있다면, 나중에 입력으로 들어오는 것이 보인다. 좌표는 절댓값이 10,000보다 작거나 같은 정수이고,  N은 100보다 작거나 같은 자연수, K는 N보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 보이는 색칠한 면적을 최대로 하려면, 어떤 직사각형을 칠해야 하는지 출력한다. 빈 칸으로 구분하며, 여러 가지일 경우에는 사전순으로 앞서는 것을 출력한다.

<문제 1187>
2N - 1개(N = 2k, 1 ≤ k ≤ 10)의 정수가 있다. 주어진 수 중 임의로 N개를 뽑았을 때 이 합이 N으로 나누어떨어지도록 하는 N개의 수를 출력하는 것이 문제이다.  답이 여러 개일 경우 아무거나 한 개만 출력하시오.
<입력값>
첫 줄에 N의 값이 주어진다. 두 번째 줄에는 2N-1개의 1000 이하의 음이 아닌 정수가 입력된다.
<출력값>
첫 줄에 N으로 나누어떨어지는 N개의 숫자를 출력한다. 답이 여러 개일 경우 그 중 임의의 하나만 출력하면 되고, 답이 존재하지 않을 경우 -1을 출력한다.

<문제 1188>
선영이의 직업은 소시지 요리사이다. 소시지를 팔기 전에 음식 평론가 M명을 모아서 맛을 테스트해보려고 한다.
선영이는 동일한 소시지를 총 N개를 준비했다. 이 소시지를 모든 평론가들이 같은 양을 받게 소시지를 자르려고 한다. 이때, 소시지를 자르는 횟수를 최소로 하려고 한다.
예를 들어, 소시지가 2개, 평론가가 6명있는 경우를 생각해보자. 이때, 각 소시지를 세 조각으로 만든 다음, 각 평론가에게 한 조각씩 주면 된다. 이 경우에 소시지는 총 네 번 자르게 된다. 다른 경우로 소시지가 3개, 평론가가 4명 있는 경우를 생각해보자. 이때는 각 소시지의 크기를 3:1로 잘라서 큰 조각을 평론가에게 하나씩 주고, 남은 조각을 평론가에게 주면 모두 동일한 양을 받게 된다.
소시지의 수와 평론가의 수가 주어졌을 때, 모든 평론가에게 같은 양의 소시지를 주기 위해 필요한 칼질의 수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 소시지의 수 N과 평론가의 수 M이 주어진다. (1 ≤ N, M ≤ 100)
<출력값>
첫째 줄에 모든 평론가에게 동일한 양을 주기 위해 필요한 칼질 횟수의 최솟값을 출력한다.

<문제 1189>
한수는 캠프를 마치고 집에 돌아가려 한다. 한수는 현재 왼쪽 아래점에 있고 집은 오른쪽 위에 있다. 그리고 한수는 집에 돌아가는 방법이 다양하다. 단, 한수는 똑똑하여 한번 지나친 곳을 다시 방문하지는 않는다.

      cdef  ...f  ..ef  ..gh  cdeh  cdej  ...f 
      bT..  .T.e  .Td.  .Tfe  bTfg  bTfi  .Tde 
      a...  abcd  abc.  abcd  a...  a.gh  abc. 
거리 :  6     6     6     8     8    10    6
위 예제는 한수가 집에 돌아갈 수 있는 모든 경우를 나타낸 것이다. T로 표시된 부분은 가지 못하는 부분이다. 문제는 R x C 맵에 못가는 부분이 주어지고 거리 K가 주어지면 한수가 집까지도 도착하는 경우 중 거리가 K인 가짓수를 구하는 것이다.
<입력값>
첫 줄에 정수 R(1 ≤ R ≤ 5), C(1 ≤ C ≤ 5), K(1 ≤ K < R*C)가 공백으로 구분되어 주어진다. 두 번째부터 R+1번째 줄까지는 R x C 맵의 정보를 나타내는 .과 T로 구성된 길이가 C인 문자열이 주어진다.
<출력값>
첫 줄에 거리가 K인 가짓수를 출력한다.

<문제 1190>
여러분은 골을 넣은 뒤 포효하며 슬라이딩하는 드록바의 모습을 본적이 있는가.
여러분은 이제 동네 축구에서 골을 넣고 드록바처럼 슬라이딩 세레머니를 하려고 한다. 그런데 현실과 이상의 거리는 멀어서 여러분이 뛰는 잔디구장은 드록바가 뛰는 최고급 구장과는 차이가 있다. 여러분의 잔디구장엔 곳곳에 불량한 잔디무더기가 있어서 당신이 슬라이딩을 하다가 그곳을 지나가게 된다면 오랜만에 복귀해서 세레모니하다가 부상당해 찬밥신세가 된 고종수처럼 조기축구회에서 주전자나 나르는 부상자가 될 수도 있다. 그러므로 불량한 잔디무더기는 피해서 세레머니를 하려고 한다.
축구장의 크기와 당신이 골을 넣고 슬라이딩을 시작하는 좌표,  불량 잔디 무더기들(다각형 모양으로 주어진다)가 주어지고 당신의 슬라이딩 경로는 항상 직선이고 축구장 가에서 끝이 나야 할 때 가능한 최장거리의 슬라이딩 경로를 출력하라.
<입력값>
첫째 줄에는 축구장의 가로, 세로 크기인 N, M(1<=N,M<=10000)이 주어지고 다음 줄엔 당신이 슬라이딩을 시작하는 좌표가 주어진다. 그리고 다음 줄에는 불량잔디 무더기의 개수 G(1<=G<=100)이 주어지고 그 다음 G개의 줄에는 각 불량잔디 무더기의 꼭짓점 수 (20이하)와 그 뒤로 시계방향으로 좌표들이 주어진다.
그리고 세레머니의 시작점이 불량잔디 무더기 안에 포함되는 경우는 없다고 한다. 또한 불량잔디 무더기끼리 겹치는 경우는 없다고 한다. 그리고 세레머니의 경로가 불량잔디 무더기를 통과하지는 않고 접할 경우까지는 괜찮다고 가정한다.
<출력값>
당신이 슬라이딩을 마치는 좌표를 출력한다. 절대/상대 오차는 10-3까지 허용한다. 만약 거리가 같은 최종점이 여러개 존재한다면 그 중 가장 x좌표가 작은 것, x좌표가 같다면 y좌표가 작은 것을 출력하여라.
만약 가능한 슬라이딩 경로가 없다면 GG를 출력하여라.

<문제 1191>
드록바와 셰브첸코가 첼시에서 같이 훈련하던 옛날 옛적 어느 날 두 선수는 훈련에 지쳐 다음과 같은 게임을 하며 쉬기로 한다.
편의상 두 플레이어를 A, B라고 부를 때, 두 플레이어는 N*N짜리 정사각형 보드의 한 점에서 시작하게 된다.
그래서 A, B는 각각 시작점을 가지게 되고 보드에는 흰 칸과 검은 칸이 있는데 검은 칸은 지나가지 못하는 칸이다.(물론 A, B의 시작점과 검은 칸이 겹치는 경우는 없다.)
플레이어들은 각 턴마다 상, 하, 좌, 우로 한 번씩 움직일 수 있다. 그리고 만약 플레이어가 움직여서 상대방의 현 위치와 겹치게 되면 그 플레이어는 상, 하, 좌, 우중 한 방향으로 한 번 더 움직일 수 있는 기회를 받는다.
A플레이어가 먼저 턴을 시작한다고 할 때 상대방의 시작점으로 먼저 도착하는 사람이 경기의 승자가 된다. 양 선수는 최선의 전략을 사용한다고 가정할 때 누가 승자가 될지 알아 보아라.
<입력값>
첫째 줄에는 테스트 데이터의 개수 t (1<=t<=10)가 들어온다. 그리고 다음 t개의 세트에는 우선 맵의 크기 n(1<=n<=300)이 주어지고 다음에는 N*N짜리 지도가 주어지는데 A의 위치와 B의 위치가 표시되어있고 흰자리는 ‘.’, 검은 자리는 ‘#’으로 표시되어있다.
<출력값>
누가 승리할지 테스트 케이스 순서대로 출력하여라.

<문제 1192>
어느 날 화학선생님이 화학시간에 맨날 딴짓만 하던 선영이에게 지하실에 가서 실험 때 쓸 장갑을 가져오라고 지시했다.
장갑엔 n가지 색상이 있고 지하실에는 2개의 통이 있는데 한쪽에는 n가지 색상의 왼손쪽 장갑이 들어있고 다른 한쪽에는 n가지 색상의 오른손쪽 장갑이 들어있다. 선영이는 각각의 통에 어떤 색깔의 장갑이 몇 개가 들어있는지 알고 있다.
그런데 지하실은 너무나도 깜깜해서 장갑을 꺼내도 색을 구별하기는 힘들고 양쪽의 통에서 임의로 장갑 여러개를 집어올 수 있다.
여러개의 장갑중에 항상 색깔이 같은 장갑의 쌍이 적어도 한 개이상 존재하도록 하기 위해서 선영이가 각각 통에서 가져와야할 장갑은 몇 개인지 구하라.
<입력값>
입력의 첫 줄에는 색깔의 가지수 N(1 ≤ N ≤ 20)이 주어지고 2번째 줄과 3번째 줄에는 각각 왼쪽 통과 오른쪽 통에 들어 있는 색깔별 장갑의 수(108이하)가 주어진다.
<출력값>
일치하는 장갑을 하나 이상 뽑아내기 위해 가져와야 되는 최소한의 장갑의 수를 각각 출력한다.

<문제 1193>
무한히 큰 배열에 다음과 같이 분수들이 적혀있다.



1/1
1/2
1/3
1/4
1/5
…


2/1
2/2
2/3
2/4
…
…


3/1
3/2
3/3
…
…
…


4/1
4/2
…
…
…
…


5/1
…
…
…
…
…


…
…
…
…
…
…



이와 같이 나열된 분수들을 1/1 -> 1/2 -> 2/1 -> 3/1 -> 2/2 -> … 과 같은 지그재그 순서로 차례대로 1번, 2번, 3번, 4번, 5번, … 분수라고 하자.
X가 주어졌을 때, X번째 분수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 X(1 ≤ X ≤ 10,000,000)가 주어진다.
<출력값>
첫째 줄에 분수를 출력한다.

<문제 1194>
지금 민식이가 계획한 여행은 달이 맨 처음 뜨기 시작할 때 부터, 준비했던 여행길이다. 하지만, 매번 달이 차오를 때마다 민식이는 어쩔 수 없는 현실의 벽 앞에서 다짐을 포기하고 말았다.
민식이는 매번 자신의 다짐을 말하려고 노력했지만, 말을 하면 아무도 못 알아들을 것만 같아서, 지레 겁먹고 벙어리가 되어버렸다. 결국 민식이는 모두 잠든 새벽 네시 반쯤 홀로 일어나, 창 밖에 떠있는 달을 보았다.
하루밖에 남지 않았다. 달은 내일이면 다 차오른다. 이번이 마지막기회다. 이걸 놓치면 영영 못간다.
영식이는 민식이가 오늘도 여태것처럼 그냥 잠 들어버려서 못 갈지도 모른다고 생각했다. 하지만 그러기엔 민식이의 눈에는 저기 뜬 달이 너무나 떨렸다.
민식이는 지금 미로 속에 있다. 미로는 직사각형 모양이고, 여행길을 떠나기 위해 미로를 탈출하려고 한다. 미로는 다음과 같이 구성되어져있다.

빈 곳 : 언제나 이동할 수 있다. ('.‘로 표시됨)
벽 : 절대 이동할 수 없다. (‘#’)
열쇠 : 언제나 이동할 수 있다. 이 곳에 처음 들어가면 열쇠를 집는다. (a - f)
문 : 대응하는 열쇠가 있을 때만 이동할 수 있다. (A - F)
민식이의 현재 위치 : 빈 곳이고, 민식이가 현재 서 있는 곳이다. (숫자 0)
출구 : 달이 차오르기 때문에, 민식이가 가야하는 곳이다. 이 곳에 오면 미로를 탈출한다. (숫자 1)

달이 차오르는 기회를 놓치지 않기 위해서, 미로를 탈출하려고 한다. 한 번의 움직임은 현재 위치에서 수평이나 수직으로 한 칸 이동하는 것이다.
민식이가 미로를 탈출하는데 걸리는 이동 횟수의 최솟값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 미로의 세로 크기 N과 가로 크기 M이 주어진다. (1 ≤ N, M ≤ 50) 둘째 줄부터 N개의 줄에 미로의 모양이 주어진다. 같은 타입의 열쇠가 여러 개 있을 수 있고, 문도 마찬가지이다. 그리고, 영식이가 열쇠를 숨겨놓는 다면 문에 대응하는 열쇠가 없을 수도 있다. 0은 한 개, 1은 적어도 한 개 있다. 그리고, 열쇠는 여러 번 사용할 수 있다.
<출력값>
첫째 줄에 민식이가 미로를 탈출하는데 드는 이동 횟수의 최솟값을 출력한다. 만약 민식이가 미로를 탈출 할 수 없으면, -1을 출력한다.

<문제 1195>
세계적으로 유명한 엄지민 자동차 회사는 효율적인 킥다운 장치를 만들어달라는 의뢰를 받았다. 킥다운이란 자동차에서 낮은 기어로 바꾸는 장치를 의미한다. 연구 끝에 효율적인 킥다운 장치는 '이'와 '홈'이 불규칙하게 배열되어 있는 기어로 만들어져야 한다는 것을 알았다.


첫 번째 그림과 같이 두 기어 파트가 서로 마주보고 있게 된다. 튀어나온 것이 기어의 이, 들어간 곳이 홈이다. 그리고 이들을 두 번째 그림과 같이 서로 맞물리게 끼우는 것으로 킥다운 장치를 만들 수 있다. 하지만 문제는 맞물리게 하였을 때 가로 너비가 짧을수록 효율적인 킥다운 장치가 된다. 때문에 문제는 두 기어가 주어졌을 때 맞물리게 하는 가장 짧은 가로 너비를 구하는 것이다.
<입력값>
첫 줄에는 첫 번째 기어 파트를 나타내는 1과 2로 구성된 문자열이 주어진다. 두 번째 줄에는 마찬가지로 두 번째 기어 파트를 나타내는 1, 2로 구성된 문자열이 주어진다. 여기서 1은 홈을, 2는 이를 의미한다. 길이 <= 100
<출력값>
첫 줄에 만들 수 있는 가장 짧은 가로 너비를 출력한다.

<문제 1196>
다음 이야기는 오후 8시부터 오후 9시 사이에 일어난 일이다.
지난이야기.
두바쿠는 샹갈라에서 가장 악명이 높은 악당이다. 샹갈라는 현재 대규모의 폭동 사태가 일어나고 있고, 미군은 폭동 사태를 해결하기 위해 샹갈라에 주둔하고 있다. 두바쿠는 미국에 미군의 철수를 요구했지만, 미국은 테러리스트와는 협상을 하지 않는다는 핑계를 대면서 두바쿠의 요구를 거절했다. 두바쿠는 크게 분노했고, 미국을 테러하기로 결심했다. 먼저, 두바쿠는 토니 알메이다를 시켜서 CIP장치를 가져오게 했다. CIP장치를 이용해 비행기 두 대를 공중에서 충돌시키는 테러를 저질렀지만, 미국 대통령은 두바쿠의 요구를 또 한번 무시했다. 이때, 지금은 없어진 CTU의 국장 뷰캐넌과 프로그래머 클로이는 FBI 내에 첩자가 있다는 사실을 알게되었다. 두 사람은 첩자의 존재 때문에, 두바쿠를 잡을 수 없다는 것을 알게되었고, 독자적으로 FBI 내의 첩자를 잡아내기로 했다. 사실 토니 알메이다는 두바쿠를 잡기 위해 심어진 사람이었고, 이제 잭 바우어와 함께 두바쿠를 잡으려고 한다.
두바쿠는 잭 바우어가 자기를 잡으러 오기를 내심 기대하고 있었다. 따라서, 두바쿠는 자신의 본거지 주소를 서로 다른 코드로 N개로 변형시켰고, N개의 코드를 모두 모아야 본거지 주소를 알 수 있다. 두바쿠는 이 코드를 자신의 부하들에게 분배했다. 따라서, 각각의 부하들이 어떤 코드를 가질 확률은 1/N이다. (서로 다른 부하가 같은 코드를 가지고 있을 수도 있고, 부하의 수는 무한대이다)
두바쿠의 부하들은 이 코드를 자신의 안 주머니에 넣어놓기 때문에, 잭 바우어는 이들을 죽이기 전까지는 코드를 모을 수 없다. 잭 바우어에게는 뛰어난 컴퓨터 프로그래머이자 주부인 클로이가 있다. 클로이는 너무 뛰어나기 때문에, 코드 K개만 가지고 있어도 두바쿠의 본거지를 찾을 수 있다. 잭 바우어가 서로 다른 코드 K개를 모으기 위해서 죽어야 하는 두바쿠 부하의 수의 기댓값을 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N과 K가 주어진다. N은 1018보다 작거나 같은 자연수이고, K는 N보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 문제의 정답을 출력한다. 절대/상대 오차는 10-9 까지 허용한다.

<문제 1197>
그래프가 주어졌을 때, 그 그래프의 최소 스패닝 트리를 구하는 프로그램을 작성하시오.
최소 스패닝 트리는, 주어진 그래프의 모든 정점들을 연결하는 부분 그래프 중에서 그 가중치의 합이 최소인 트리를 말한다.
<입력값>
첫째 줄에 정점의 개수 V(1 ≤ V ≤ 10,000)와 간선의 개수 E(1 ≤ E ≤ 100,000)가 주어진다. 다음 E개의 줄에는 각 간선에 대한 정보를 나타내는 세 정수 A, B, C가 주어진다. 이는 A번 정점과 B번 정점이 가중치 C인 간선으로 연결되어 있다는 의미이다. C는 음수일 수도 있으며, 절댓값이 1,000,000을 넘지 않는다.
그래프의 정점은 1번부터 V번까지 번호가 매겨져 있고, 임의의 두 정점 사이에 경로가 있다. 최소 스패닝 트리의 가중치가 -2,147,483,648보다 크거나 같고, 2,147,483,647보다 작거나 같은 데이터만 입력으로 주어진다.
<출력값>
첫째 줄에 최소 스패닝 트리의 가중치를 출력한다.

<문제 1198>
볼록 다각형이 있고, 3개의 연속된 점을 선택해서 삼각형을 만든다. 그 다음이 만든 삼각형을 다각형에서 제외한다. 원래 다각형이 N개의 점이 있었다면, 이제 N-1개의 점으로 구성된 볼록 다각형이 된다.
위의 과정은 남은 다각형이 삼각형이 될 때까지 반복한다.
볼록 다각형의 점이 시계 방향순으로 주어진다. 마지막에 남은 삼각형은 여러 가지가 있을 수 있다. 이때, 가능한 넓이의 최댓값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 볼록 다각형 점의 수 N (3 ≤ N ≤ 35)이 주어진다. 둘째 줄부터 N개의 줄에는 점이 시계 방향 순서대로 주어진다. 좌표는 10,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 문제의 정답을 출력한다. 절대/상대 오차는 10-9까지 허용한다.

<문제 1199>
어느 점에서 출발하여 그래프 상에 있는 모든 간선을 지나되 한번 지난 간선은 다시 지나지 않고 출발점으로 돌아오는 회로를 오일러 회로라 한다. 단, 그래프는 양방향 그래프가 주어진다.
문제는 그래프가 주어졌을 때 오일러 회로 경로를 출력하는 것이다.
<입력값>
첫 줄에는 정점의 수 N(1 ≤ N ≤ 1,000)이 주어진다. 그리고 다음 N개의 줄에 대해 인접행렬의 정보가 주어진다. i+1번째 줄에는 i번 정점에 대한 인접행렬이 주어진다. 두 정점 사이에 간선이 여러 개 있을 수 있다. 인접행렬의 값은 두 정점 사이의 간선 개수를 의미하며, 0보다 크거나 같고, 10보다 작거나 같은 정수이다.
입력으로 주어지는 그래프에는 루프 (양 끝점이 같은 간선)는 없다. 또, 입력으로 주어지는 그래프는 모두 연결되어 있다.
<출력값>
첫 줄에 방문하는 점 순서를 공백으로 구분하여 출력한다. 단, 시작점은 어느 위치에서든 상관없고 아무 경로만 하나 찍으면 된다. 불가능한 경우에는 -1을 출력한다.

<문제 1200>
화학이 싫어서 지구과학을 공부한 선영이가 기상예측을 하는 일을 맡게 되었다.
선영이가 기상예측을 해야 되는 지역은 N*M짜리 격자판이고 각각의 칸마다 기상예측을 하는데 걸리는 시간이 있다.
이때 선영이는 이 격자판을 적당히 나눠서 각각의 구간의 작업을 동시에 할 수 있는데 그러므로 나누어진 구간 중 작업시간의 합이 최대인 곳을 최소화 한다면 선영이의 작업량이 최소가 될 것이다. 이때 나누는 기준은 주어진 개수의 가로선과 세로선을 이용해서 나누면 된다.
가로로 나눌 수 있는 선의 개수가 주어지고 세로 역시 주어진다고 할 때 나누어진 구간의 합의 최대를 최소로 하는 나누는 방법을 구하라.
<입력값>
첫줄에는 n, m, r, s(1<=r<n<=18, 1<=s<m<=18) 가 주어지는데 n, m은 지역의 가로, 세로크기, r, s는 가로로 나누는 수, 세로로 나누는 수를 의미한다. 그 뒤로는 각각의 칸을 예측하는데 걸리는 시간이 주어진다(2000000이하)
<출력값>
선영이가 결과를 구하는데 걸리는 최소의 시간을 출력한다.

<문제 1201>
1부터 N까지의 수를 한 번씩 이용해서 가장 긴 증가하는 부분 수열의 길이가 M이고, 가장 긴 감소하는 부분 수열의 길이가 K인 수열을 출력한다.
<입력값>
첫째 줄에 세 정수 N, M, K가 주어진다.
<출력값>
첫째 줄에 문제의 조건을 만족하는 수열을 출력한다. 만약, 조건을 만족하는 수열이 없다면 -1을 출력한다.

<문제 1202>
세계적인 도둑 상덕이는 보석점을 털기로 결심했다.
상덕이가 털 보석점에는 보석이 총 N개 있다. 각 보석은 무게 Mi와 가격 Vi를 가지고 있다. 상덕이는 가방을 K개 가지고 있고, 각 가방에 담을 수 있는 최대 무게는 Ci이다. 가방에는 최대 한 개의 보석만 넣을 수 있다.
상덕이가 훔칠 수 있는 보석의 최대 가격을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N과 K가 주어진다. (1 ≤ N, K ≤ 300,000)
다음 N개 줄에는 각 보석의 정보 Mi와 Vi가 주어진다. (0 ≤ Mi, Vi ≤ 1,000,000)
다음 K개 줄에는 가방에 담을 수 있는 최대 무게 Ci가 주어진다. (1 ≤ Ci ≤ 100,000,000)
모든 숫자는 양의 정수이다.
<출력값>
첫째 줄에 상덕이가 훔칠 수 있는 보석 가격의 합의 최댓값을 출력한다.

<문제 1203>
N명의 학생이 원탁에 둘러앉아 게임을 하려한다. N명의 학생 중 한 사람이 동전을 받으면서 이 게임은 시작된다. 어떤 사람이 동전을 받았을 때 지정된 특정한 확률로 바로 왼쪽 옆 사람에게 주거나 아니면 오른쪽 옆 사람에게 줄 수 있다. 마찬가지로 동전을 받은 사람 역시 옆사람에게 전달을 하는 식으로 게임은 진행된다. 여기서 왼쪽 혹은 오른쪽 사람에게 줄 확률은 개개인마다 서로 다르다. 이런 식으로 모든 사람이 동전을 적어도 한 번 이상 받은 적이 있으면 게임은 끝나게 되고 마지막으로 동전을 받은 사람이 이 게임의 승자가 된다. 

문제는 N명의 학생이 위 그림과 같은 순서로 둘러앉았을 때, (i번 학생의 오른쪽에 i+1번 학생이 앉고 단, N번 학생 오른쪽은 1번 학생이 앉는 방식) N번 학생이 이 게임의 승자가 될 확률을 구하는 것이다.
<입력값>
첫 줄에는 총 학생의 수 N(1 ≤ N ≤ 50)과 처음 동전을 가지고 있는 사람의 번호 K(1 ≤ K ≤ N)가 주어진다. 두 번째 줄에는 N-1개의 실수가 입력되는데 이는 1번부터 N-1번 학생까지 차례대로 각각의 학생이 오른쪽 학생에게 동전을 줄 확률을 의미한다. (오른쪽 학생에게 동전을 줄 확률이 P라면 왼쪽 학생에게 줄 확률을 1-P가 된다.) 입력되는 확률 값은 최대 소수점 두 자리까지이며 0이나 1인 경우는 없다.
<출력값>
첫 줄에 N번 학생이 승자가 될 확률을 출력한다. 절대/상대 오차는 10-6까지 허용한다.

<문제 1204>
팰린드롬이란 왼쪽에서부터 읽을 때와 오른쪽에서부터 읽을 때가 같은 문자열을 말한다. 이때, 공백은 무시한다.
N개의 단어가 주어진다. 이 단어를 이용해서 문자열 S를 만들 수 있다. 단어와 단어 사이에는 공백을 하나 집어 넣어야 하며, 각 단어를 여러 번 사용하거나, 사용하지 않는 단어가 있어도 된다. 같은 단어를 연속해서 사용하는 경우에도 공백을 집어넣어야 한다.
이렇게 만들 수 있는 문자열 S중에서 팰린드롬이면서, 길이가 K이하인 것의 개수를 구하는 프로그램을 작성하시오. 빈 문자열은 팰린드롬이 아니다. 문자열의 길이는 공백을 포함한다. S는 공백으로 시작하거나 끝날 수 없다.
<입력값>
첫째 줄에 단어의 개수 N과 K가 주어진다. N은 50보다 작거나 같고, K는 100보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 단어가 주어진다. 알파벳 소문자로만 구성되어져 있고, 길이는 최대 15이며, 중복되지 않는다.
<출력값>
첫째 줄에 문제의 정답을 835454957로 나눈 나머지를 출력한다.

<문제 1205>
유진이가 즐겨하는 디제이맥스 게임은 각각의 노래마다 랭킹 리스트가 있다. 이것은 매번 게임할 때 마다 얻는 점수가 비오름차순으로 저장되어 있는 것이다.
이 랭킹 리스트의 등수는 보통 위에서부터 몇 번째 있는 점수인지로 결정한다. 하지만, 같은 점수가 있을 때는 그러한 점수의 등수 중에 가장 작은 등수가 된다.
예를 들어 랭킹 리스트가 100, 90, 90, 80일 때 각각의 등수는 1, 2, 2, 4등이 된다
랭킹 리스트에 올라 갈 수 있는 점수의 개수 P가 주어진다. 그리고 리스트에 있는 점수 N개가 비오름차순으로 주어지고, 송유진의 새로운 점수가 주어진다. 이때, 송유진의 새로운 점수가 랭킹 리스트에서 몇 등 하는지 구하는 프로그램을 작성하시오. 만약 점수가 랭킹 리스트에 올라갈 수 없을 정도로 낮다면 -1을 출력한다.
만약, 랭킹 리스트가 꽉 차있을 때, 새 점수가 이전 점수보다 더 좋을 때만 점수가 바뀐다. (예제 2)
<입력값>
첫째 줄에 N, 송유진의 새로운 점수, 그리고 P가 주어진다. P는 10보다 크거나 같고, 50보다 작거나 같은 정수, N은 0보다 크거나 같고, P보다 작거나 같은 정수이다. 그리고 모든 점수는 2,000,000,000보다 작거나 같은 자연수 또는 0이다. 둘째 줄에는 현재 랭킹 리스트에 있는 점수가 비오름차순으로 주어진다. 둘째 줄은 N이 0보다 큰 경우에만 주어진다.
<출력값>
첫째 줄에 문제의 정답을 출력한다.

<문제 1206>
송유진은 길거리에서 사람들에게 설문조사를 하면서 살고 있다. 송유진의 설문조사는 참가자가 각각의 문제를 정수 0부터 10사이의 수로 대답해야하는 것이다.
송유진은 지금 문제 각각의 평균 대답을 가지고 있다. 그리고 이것은 소수 셋째자리에서 자른 값이다. 예를 들어, 어떤 문제를 사람들이 4, 6, 10라고 대답했다면, 이 문제의 평균 점수는 6.666이다.
송유진의 설문 조사 문제의 수는 N개이다. 이 N개 문제의 평균 점수가 주어진다. 이때 설문에 응한 사람의 수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N이 주어진다. 둘째 줄부터 N개의 줄에 각 문제의 점수가 주어진다. N은 100보다 작거나 같은 자연수이고, 모든 점수는 소수 셋째짜리까지 들어온다.
<출력값>
첫째 줄에 문제의 정답을 출력한다. 만약 문제의 정답이 여러 개라면 가장 작은 값을 출력한다.

<문제 1207>
송유진은 L*L크기의 모눈종이를 가지고 있다. 눈금은 크기 1단위로 그려져 있다. 즉, 1*1크기의 정사각형으로 나누어져있다는 소리다.
차영훈은 송유진의 모눈종이를 격자를 따라서 잘라서 5조각 냈다. 이제 송유진이 할 일은 다시 원래 모양으로 만드는 것이다.
<입력값>
첫째 줄에 L이 주어진다. L은 3보다 크거나 같고, 10보다 작거나 같은 자연수이다. 둘째 줄부터는 첫 번째 조각부터 다섯 번째 조각 까지의 정보가 차례대로 들어온다. 조각의 정보는 다음과 같은 형식이다. 첫째 줄에 조각의 세로 크기 N과 가로 크기 M이 있다. N과 M은 L보다 작거나 같은 자연수이다. 둘째 줄부터 N줄에는 조각의 모양이 있다. 조각은 ‘#’과 ‘.’로만 이루어져 있고, 첫 행과 마지막 행에는 적어도 하나의 ‘#’가 있고, 첫 열과 마지막 열에는 적어도 하나의 ‘#’가 있다.
<출력값>
출력은 L*L크기의 정사각형을 출력하면 된다. i번째 줄 j번째 문자는 그 조각의 번호를 출력하면 된다. 만약 그러한 것이 여러 가지면 사전순으로 가장 앞서는 것을 출력한다. 만약 불가능 하면 gg를 출력한다.

<문제 1208>
N개의 정수로 이루어진 수열이 있을 때, 크기가 양수인 부분수열 중에서 그 수열의 원소를 다 더한 값이 S가 되는 경우의 수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 정수의 개수를 나타내는 N과 정수 S가 주어진다. (1 ≤ N ≤ 40, |S| ≤ 1,000,000) 둘째 줄에 N개의 정수가 빈 칸을 사이에 두고 주어진다. 주어지는 정수의 절댓값은 100,000을 넘지 않는다.
<출력값>
첫째 줄에 합이 S가 되는 부분수열의 개수를 출력한다.

<문제 1209>
음이 아닌 정수로 이루어진 수열 A1, A2, …, AN이 있다. 단조수열 B1, B2, …, BN을 만들어서 |A1-B1| + |A2-B2| + … + |AN-BN|을 최소로 하는 프로그램을 작성하시오.
단조수열이란 B1≤B2≤…≤BN을 만족하거나 B1≥B2≥…≥BN를 만족하는 수열을 말한다.
<입력값>
첫째 줄에 수열의 길이 N이 주어진다. (1≤N≤2,000) 이어서 둘째 줄부터 N개의 줄에 걸쳐 A1, A2, …, AN이 순서대로 주어진다. (0≤Ai≤1,000,000,000)
<출력값>
첫째 줄에 절댓값의 합의 최솟값을 출력한다.

<문제 1210>
2015년 구단에서 방출된 셰브첸코는 한때 그의 팬이었던 구단주 로만 아브라히모비치의 도움으로 러시아의 경찰이 되었다.
어느 날 그는 그가 감시를 하고 있는 마피아 조직에서 대규모 이동이 있음을 감지했다. 마피아는 고속도로를 통해서 이동을 하는데 고속도로망은 n개의 톨게이트와 그 사이를 있는 m개의 고속도로로 이루어져있다. 고속도로의 중간에서 밖으로 나가거나 중간으로 들어오지는 못한다고 하자. 즉 모든 이동은 톨게이트와 고속도로를 거쳐서 이루어져야 된다는 것이다. 마피아의 시작점과 도착점이 주어질 때 우리는 몇 개의 톨게이트를 점거해서 마피아가 시작점에서 도착점까지 우리의 점거된 톨게이트를 지나지 않고서는 도착할 수 없게 하고 싶다. 그런데 톨게이트를 점거하는데에는 각각의 톨게이트마다 고유한 비용이 든다.
이때 점거비를 최소화 하며 마피아의 움직임을 막기 위해 점거해야되는 도시들을 출력하여라.
<입력값>
첫 줄에는 톨게이트의 개수 n과 고속도로의 개수 m이 주어진다.(1 ≤ n ≤ 200, 1 ≤ m ≤ 20000) 톨게이트의 번호는 1부터 n까지로 주어진다고 할 때, 다음 줄에는 마피아의 시작점과 도착점이 주어진다. 그리고 그 다음 n개의 줄에는 각 톨게이트별 점거비용이 나온다. 그 뒤 m개의 줄에는 톨게이트를 연결하는 고속도로들이 주어진다. 점거비용은 10,000,000보다 작거나 같은 자연수이다.
<출력값>
점거비를 최소화 하며 마피아의 움직임을 막기 위해 점거해야되는 도시들을 오름차순으로 출력하여라.

<문제 1211>
화학시간에 보일의 법칙에 대해서 설명을 듣던 선영이는 수업이 지겨워서 숫자장난을 하기 시작했다.
어떤 숫자의 digit-product는 그 숫자의 각각 자리 수들을 곱한 값이다. 예를 들면 2612의 digit-product는 2*6*1*2=24이다.
그리고 어떤 숫자의 self-product는 (그 숫자)(그 숫자의 digit-product)이다. 예를 들면 2612의 self-product는 2612*24=62688이다. 이때 A, B가 주어지면 self-product가 A와 B사이(A, B포함)에 있는 숫자들의 개수를 구하라.
<입력값>
첫 번째 줄에 A, B가 주어진다 (1<=A<=B<10^18)
<출력값>
self-product가 A이상 B이하인 숫자들의 개수를 출력한다.

<문제 1212>
8진수가 주어졌을 때, 2진수로 변환하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 8진수가 주어진다. 주어지는 수의 길이는 333,334을 넘지 않는다.
<출력값>
첫째 줄에 주어진 수를 2진수로 변환하여 출력한다. 수가 0인 경우를 제외하고는 반드시 1로 시작해야 한다.

<문제 1213>
임한수와 임문빈은 서로 사랑하는 사이이다.
임한수는 세상에서 팰린드롬인 문자열을 너무 좋아하기 때문에, 둘의 백일을 기념해서 임문빈은 팰린드롬을 선물해주려고 한다.
임문빈은 임한수의 영어 이름으로 팰린드롬을 만들려고 하는데, 임한수의 영어 이름의 알파벳 순서를 적절히 바꿔서 팰린드롬을 만들려고 한다.
임문빈을 도와 임한수의 영어 이름을 팰린드롬으로 바꾸는 프로그램을 작성하시오.
<입력값>
첫째 줄에 임한수의 영어 이름이 있다. 알파벳 대문자로만 된 최대 50글자이다.
<출력값>
첫째 줄에 문제의 정답을 출력한다. 만약 불가능할 때는 "I'm Sorry Hansoo"를 출력한다. 정답이 여러 개일 경우에는 사전순으로 앞서는 것을 출력한다.

<문제 1214>
구사과는 지폐를 오직 두 종류만 가지고 있다. 바로 P원 지폐와 Q원 지폐이다. 이 두 종류의 지폐를 구사과는 무한대만큼 가지고 있다.
오늘 구사과가 구매하려고 하는 물건의 가격은 D원이다. 구사과가 이 물건을 구매하기 위해서 지불해야 하는 금액의 최솟값은 얼마일까?
물건을 구매하기 위해서는 물건의 가격보다 크거나 같은 금액을 지불해야 한다.
<입력값>
첫째 줄에 D, P, Q가 주어진다. 모두 109보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 물건을 구매하기 위해 구사과가 지불해야 하는 금액의 최솟값을 출력한다.

<문제 1215>
요세푸스 문제는 아래와 같이 풀 수 있다.

r := 0;
for i from 1 to n do
    r := (r + k) mod i;
return r;
하지만 상근이는 코드를 잘못 읽고 아래와 같이 작성했다.

r := 0;
for i from 1 to n do
    r := r + (k mod i);
return r;
n과 k가 주어졌을 때, 상근이의 잘못 작성한 소스를 실행시킨 결과를 출력하는 프로그램을 작성하시오.
<입력값>
첫 줄에 n과 k가 주어진다. (1 ≤ n, k ≤ 109)
<출력값>
첫째 줄에 주어진 n과 k로 상근이의 잘못 작성한 소스의 결과를 출력한다.

<문제 1217>
악명높은 의사 House는 환자를 치료할 때 죽을 환자는 버리고 살 환자는 살린다. 중상을 입어 거의 죽을 고비에 다다른 환자만이 그에게 맡겨지는데, 이러한 환자에게서는 여러 가지 증세가 동시에 관측되곤 한다.
House에게는 이러한 증세들 중 두 가지가 동시에 관측될 때면 환자가 죽게 된다는 규칙을 정리해 둔 표가 있다. 이를테면, 뇌출혈과 복막염이 동시에 관측되면 그 환자는 죽게 된다는 규칙이나, 뇌출혈이 일어나지 않는 상태와 불면증이 동시에 관측되면 그 환자는 죽게 된다는 규칙 등이 기록되어 있다.
그런데 최근 House의 손에 맡겨진 환자가 너무 많이 죽어나가는 바람에, House의 규칙이 너무 가혹해서 살아남을 수 있는 환자가 없는 건 아닌지 검사해야 할 필요가 생겼다.
House의 규칙이 주어지면, 이러한 규칙에 의거해서 과연 살아남을 수 있는 환자가 존재하는지, 아니면 이 규칙에 따르면 모든 환자가 죽을 수밖에 없는지를 알아내는 프로그램을 작성하시오.
<입력값>
입력은 여러 개의 테스트 데이터들로 구성되어 있다. 각 데이터의 첫 줄에는 House의 규칙의 개수 N, 증세의 종류 M이 빈 칸을 사이에 두고 주어진다. 다음 줄부터 N개의 줄에 걸쳐 House의 규칙에 대한 정보가 주어진다. 규칙은 두 개의 수로 표현되는데, 각 수는 상태를 나타낸다. 상태의 절댓값은 증세의 번호를 나타내며, 1 이상 M 이하이다. 상태가 양수이면 해당되는 증세가 관측되는 상태를 의미하고, 음수이면 관측되지 않는 상태를 의미한다. 두 개의 상태가 동시에 만족되면 환자는 죽는다. (N ≤ 200,000, M ≤ 20,000)
예를 들어 House의 규칙이 2 -3이라면, 증세 2가 일어나고 동시에 증세 3이 일어나지 않은 경우 환자가 죽게 된다는 뜻이다. 
데이터의 끝은 0 0으로 주어진다. 즉 N과 M이 0으로 주어지면 입력을 종료하면 된다.
<출력값>
첫째 줄부터 각 테스트 데이터마다 한 줄에 규칙에서 살아남을 수 있는 사람이 있으면 1을, 살아남는 게 불가능한 경우 0을 출력한다.

<문제 1218>
공장에서 작업을 하는 로봇은 고정 축 F, 한 개의 관절 A, 두개의 뼈대 B, C와 손 D로 구성되어 있다. 그림 1과 같이 고정축 F는 공장 내부의 한 점에 고정되어 있고, 뼈대 B는 고정축 F와 관절 A사이를 연결하고, 다른 뼈대 C는 관절 A와 손 D사이를 연결한다.

그림 1
단, 뼈대 B와 C는 그림 2와 같이 다음 조건을 만족하면서 움직일 수 있다.

뼈대 B는 고정축에서 왼쪽 또는   오른쪽 수평방향으로 나오거나, 고정 축에서 위쪽 또는 아래쪽 수직방향으로 나올 수 있다.
뼈대 C는 관절 A에서 뼈대 B와 항상 수직을 이루면서 나온다.
뼈대 B와 C는 길이를 0에서 얼마든지 자유자재로 연장할 수 있다.



그림 2
로봇의 고정축이 위치한 공장은 그림 3과 같이 수평 방향과 수직 방향의 벽들이 번갈아 가면서 연결되어 있는 하나의 다각형으로 구성되어 있다. 따라서, 이 공장의 내부에는 벽들이 존재하지 않는다. 이 공장 내부의 어떤 위치에 로봇의 고정축 F를 고정시켰을 때, 위의 세 가지 조건들을 만족하면서 뼈대 B와 C의 위치와 길이를 조절하더라도 로봇의 손 D가 미치지 못하는 공장 내부의 지점이 있을 수 있다.

그림 3
그림 3의 예에서 로봇의 고정축이 P지점에 고정되어 있으면 공장 내부의 모든 위치에 로봇 손 D가 접근할 수 있지만, Q지점에 고정되어 있으면 로봇 손 D가 도달할 수 없는 지점(빗금 친 부분)이 존재한다.
공장의 경계를 나타내는 다각형의 꼭짓점과 로봇의 고정축의 위치가 주어질 때, 공장의 내부에 로봇 손이 도달하지 못하는 부분이 있는 지를 검사하는 프로그램을 작성하시오. 단, 고정축은 공장의 내부에 존재하며, 공장의 내부는 경계선을 포함하지 않는다. 뼈대 B, C는 공장의 경계선을 따라 움직일 수 있고,  고정축, 관절과 손은 점으로, 뼈대는 두께가 없는 선분으로 가정한다.
 
그림 4
<입력값>
첫째 줄에 공장의 경계를 나타내는 꼭짓점의 개수 N이 주어진다. 단, 4≤N≤20,000이다. 다음 줄부터 N개의 꼭짓점의 좌표와 5개의 로봇 고정축의 좌표가 다음과 같이 주어진다: 둘째 줄부터 N개의 줄에 꼭짓점의 좌표 (X, Y)를 나타내는 두 개의 정수 X, Y가 한 줄에 하나씩 빈 칸을 사이에 두고 주어진다. 꼭짓점의 좌표는 다각형 경계선의 반시계방향 순서로 주어지고, 모든 좌표의 값은 0이상 1,000,000 이하의 정수이다. 이어서 다음  5개의 줄에  로봇의 고정축의 좌표 (X, Y)를 나타내는 두 개의 정수 X, Y가 한 줄에 하나씩 빈 칸을 사이에 두고 주어진다.
<출력값>
입력에서 주어진 5개 고정축의 각 위치에 대하여 로봇 손이 공장 내부의 모든 위치에 접근할 수 있는지 여부를 다음과 같이 차례대로 출력한다. 첫째 줄부터 k번째 줄에 입력에서  k번째 주어진 로봇의 고정축의 위치에 대하여 로봇 손이 공장 내부 전체에 접근할 수 있으면 YES를, 아니면 NO를 대문자로  출력한다.

<문제 1219>
오민식은 세일즈맨이다. 오민식의 회사 사장님은 오민식에게 물건을 최대한 많이 팔아서 최대 이윤을 남기라고 했다.
오민식은 고민에 빠졌다.
어떻게 하면 최대 이윤을 낼 수 있을까?
이 나라에는 N개의 도시가 있다. 도시는 0번부터 N-1번까지 번호 매겨져 있다. 오민식의 여행은 A도시에서 시작해서 B도시에서 끝난다.
오민식이 이용할 수 있는 교통수단은 여러 가지가 있다. 오민식은 모든 교통수단의 출발 도시와 도착 도시를 알고 있고, 비용도 알고 있다. 게다가, 오민식은 각각의 도시를 방문할 때마다 벌 수 있는 돈을 알고있다. 이 값은 도시마다 다르며, 액수는 고정되어있다. 또, 도시를 방문할 때마다 그 돈을 벌게 된다.
오민식은 도착 도시에 도착할 때, 가지고 있는 돈의 액수를 최대로 하려고 한다. 이 최댓값을 구하는 프로그램을 작성하시오.
오민식이 버는 돈보다 쓰는 돈이 많다면, 도착 도시에 도착할 때 가지고 있는 돈의 액수가 음수가 될 수도 있다. 또, 같은 도시를 여러 번 방문할 수 있으며, 그 도시를 방문할 때마다 돈을 벌게 된다. 모든 교통 수단은 입력으로 주어진 방향으로만 이용할 수 있으며, 여러 번 이용할 수도 있다.
<입력값>
첫째 줄에 도시의 수 N과 시작 도시, 도착 도시 그리고 교통 수단의 개수 M이 주어진다. 둘째 줄부터 M개의 줄에는 교통 수단의 정보가 주어진다. 교통 수단의 정보는 “시작 끝 가격”과 같은 형식이다. 마지막 줄에는 오민식이 각 도시에서 벌 수 있는 돈의 최댓값이 0번 도시부터 차례대로 주어진다.
N과 M은 100보다 작거나 같고, 돈의 최댓값과 교통 수단의 가격은 1,000,000보다 작거나 같은 음이 아닌 정수이다.
<출력값>
첫째 줄에 도착 도시에 도착할 때, 가지고 있는 돈의 액수의 최댓값을 출력한다. 만약 오민식이 도착 도시에 도착하는 것이 불가능할 때는 "gg"를 출력한다. 그리고, 오민식이 도착 도시에 도착했을 때 돈을 무한히 많이 가지고 있을 수 있다면 "Gee"를 출력한다.

<문제 1220>
신도시 MegaCity의 모든 도로는 가로 방향과 세로 방향으로 되어 있으며, 인접한 수평 도로들 사이의 간격과 인접한 수직 도로들 사이의 간격은 모두 동일하다. 수평 도로 i와 수직 도로 j가 만나는 곳의 좌표를 (i, j)라고 하자. 도로들로 구성되는 블록들의 한 변의 길이를 1이라고 하면 도시의 두 위치 (a, b)와 (c, d) 사이를 연결하는 경로들의 길이 중에서 최솟값은 |a - c| + |b - d|이다.
이 도시의 상가 지역은 항상 차량으로 북적대기 때문에 차로 이동하는 데 시간이 더 소요된다. 각 상가 지역은 직사각형 영역이고, 각 블록을 이동하는 데 걸리는 시간은 상가 지역마다 차이가 있다. 자동차로 이동할 때, 비 상가 지역을 지나는 것이 대체로 유리하기는 하지만, 경우에 따라서는 상가 지역을 통과하는 것이 유리하기도 하다. 따라서 목적지까지 가장 빨리 가기 위한 경로를 찾는 것이 요구된다. 앞으로 출발지에서 목적지까지의 소요 시간이 가장 작은 경로를 가장 빠른 경로라고 부르자.
예를 들어 아래 그림을 보자. 비 상가 지역의 경우 블록 한 변을 이동하는데 걸리는 시간을 10이라고 하고, 각 상가 지역 A, B, C, D의 블록 한 변 이동 시간을 각각 44, 33, 22, 11이라고 하자. 그러면 두 위치 (1, 6)과 (15, 3) 사이의 가장 빠른 경로는 그림에서 표시된 것과 같이 총 길이가 19, 총 소요 시간이 192인 경로이다. 반면에 상가 지역을 전혀 통과하지 않는 경로 중 가장 빠른 경로는 길이가 21이며 총 소요 시간이 210이다.

MegaCity에서 주어진 두 지점 사이의 가장 빠른 경로의 소요 시간을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 네 개의 정수 a, b, c, d가 주어진다, 여기서 (a, b)는 출발지의 좌표이고 (c, d)는 도착 지점의 좌표이다, (a, b) ≠ (c, d). 둘째 줄에는 상가 지역의 개수를 나타내는 정수 n (0 ≤ n ≤ 1,000)이 주어진다. 그 다음 n개의 줄에는 각 줄마다 각 상가 지역인 직사각형 영역을 나타내는 네 개의 정수 lx, ly, hx, hy와 한 칸 이동 시간을 나타내는 정수 t (10 ≤ t ≤ 10^8)가 주어진다, 여기서 (lx, ly)는 직사각형의 왼쪽 아래 꼭짓점 좌표이고 (hx, hy)는 오른쪽 위 꼭짓점 좌표이다. 모든 좌표는 0 이상 10^8 이하의 정수이다. 둘 이상의 상가 지역이 서로 교차하거나 경계가 접하는 경우는 존재하지 않으며, 비 상가 지역의 블록 한 칸 이동 시간은 항상 10이라고 가정하시오.
<출력값>
첫째 줄에 출발지와 도착지 사이의 가장 빠른 경로의 소요 시간을 출력한다.

<문제 1221>
3차원 공간에 점 N개가 있다. 가장 가까운 점의 거리를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 점의 수 N이 주어진다. N은 150,000보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 각 점의 좌표가 주어진다. 좌표의 절댓값은 1000000보다 작거나 같은 정수이다. 중복되는 점은 한 개로 가정하고, 적어도 2개의 서로 다른 점이 있다.
<출력값>
첫째 줄에 가장 가까운 점의 거리의 제곱을 출력한다. 둘째 줄에는 그러한 거리를 가지는 서로 다른 점의 쌍이 총 몇 개 있는지 개수를 출력한다.

<문제 1222>
홍준이는 프로그래밍 대회를 개최했다. 이 대회는 사람들이 팀을 이루어서 참가해야 하며, 팀원의 수는 홍준이가 정해준다. 팀원이 홍준이가 정한 값보다 부족하다면, 그 팀은 대회에 참여할 수 없다. 모든 팀은 같은 수의 팀원으로 이루어져 있다.
대회에 참여 의사를 밝힌 학교는 총 N개이다. 각 학교는 모든 학생이 참여할 수 있는 경우에만 대회에 참가한다. 즉, 남는 사람 없이 모든 학생이 팀에 들어갈 수 있어야 한다.
대회는 예선과 본선으로 구성되어 있다. 모든 팀은 같은 학교 소속으로 이루어져 있어야 한다. 예선에서 각 학교 1등팀만 본선에 진출한다. 
홍준이의 대회는 올해가 첫 해이기 때문에, 많은 관심이 필요하다. 따라서, 본선에 참가하는 사람의 수를 최대가 되도록 팀원의 수를 정하려고 한다. 또, 본선이 지루해지는 것을 막기 위해 적어도 두 팀이 본선에 참가할 수 있어야 한다.
홍준이가 팀원을 몇 명으로 정해야 본선에 참가하는 사람의 수가 최대가 되는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 홍준이의 대회에 참여 의사를 밝힌 학교의 수 N (2 ≤ N ≤ 200,000)이 주어진다.
둘째 줄에는 각 학교 학생의 수가 주어진다. 학생의 수는 구간 [1, 2,000,000]에 포함된다.
<출력값>
첫째 줄에 홍준이의 대회 본선에 참가하는 사람의 수의 최댓값을 출력한다.

<문제 1223>
어느 날 고고학자 선영이는 미지의 세계에서 신비한 마법의 돌을 찾았다. 그런데 그 마법의 돌에는 X와 I로 이루어진 문자열이 새겨져 있었다. 그래서, 선영이는 마법의 돌을 분류하기 위한 기준을 세웠다.
"n-k-마법의 돌"이란 X와 I의 개수가 합해서 n개이고 X와 I가 붙어 있는 부분이 k개 이하인 마법의 돌이다.
그리고 어떤 마법의 돌이 있을 때 그 돌을 180도 회전해서 나온 돌도 같은 돌으로 보는데 그 2개의 돌 중에서 사전순으로 앞서는 돌만 고려한다.(예를 들면 IXXIIXXX와 XXXIIXXI가 있을 때 IXXIIXXX만 쓰인다.)
이때 "n-k-마법의 돌"을 사전순으로 정렬했다고 할 때 그 중 i번째 "n-k-마법의 돌"을 알고 싶다.
<입력값>
첫줄에 n, k, i가 주어진다. (0 ≤ k < n ≤ 60, 0 < i < 1018)
<출력값>
i번째 "n-k-마법의 돌"이 있다면 그것을 출력하고 없다면 NO SUCH STONE을 출력한다.

<문제 1224>
유리수를 표현하기 위해 보통 분수를 사용한다. 분수 a/b에서 a를 분자, b를 분모라고 부르고, a와 b는 모두 정수이다. 분수에서 분모가 너무 큰 숫자이면 수식에서 다루기 힘들어진다. 그래서 수학자들은 분모 b가 매우 큰 분수 a/b가 있을 때, 이를 대신하여 분모가 작은 분수 a1/b1와 a2/b2를 사용한다, 여기서 a1/b1 ≤ a/b ≤ a2/b2이고 b1과 b2는 둘 다 특정한 정수 c보다 크지 않아야 한다. (즉, b1, b2 ≤ c).
분수 a1/b1과 a2/b2를 a/b의 근사치 분수 쌍이라고 하자. 수학자들은 근사치 분수 쌍들 중 두 분수의 차이(즉,  a2/b2 - a1/b1)가 최소가 되는 근사치 분수 쌍을 사용하기를 원한다. 수학자를 도와주기 위해, 주어진 분수에 대해 차이가 최소가 되는 근사치 분수 쌍을 찾는 프로그램을 작성하시오.
<입력값>
첫째 줄에 세 개의 정수 a, b, c가 주어진다.
<출력값>
첫째 줄에 네 개의 정수 a1, b1, a2, b2를 출력한다. 여기서 a1/b1과 a2/b2는 주어진 분수의 근사치 분수 쌍들 중 그 차이가 최소인 것이어야 하고, a1과 b1이 서로소이고 a2와 b2가 서로소이어야 한다. 단, 값이 0인 분수는 항상 “0 1”을 출력한다.

<문제 1225>
A*B를 계산하다 지겨워진 형택이는 A*B를 새로운 방법으로 정의하려고 한다.
A에서 한 자리를 뽑고 * B에서 임의로 한 자리를 뽑아 곱한다.
의 가능한 모든 조합 (A가 n자리, B가 m자리 수라면 총 가능한 조합은 n*m개)을 더한 수로 정의하려고 한다.
예를 들어 121*34는
1*3 + 1*4 + 2*3 + 2*4 + 1*3 + 1*4 = 28
이 된다. 이러한 형택이의 곱셈 결과를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 A와 B가 주어진다. 주어지는 두 수는 모두 10,000자리를 넘지 않는다.
<출력값>
첫째 줄에 형택이의 곱셈 결과를 출력한다.

<문제 1226>
국회에는 당이 N개 있고, 각각의 당은 확보한 의석이 있다.
이번에 당끼리 연합을 맺기로 했다. 연합이 유효하려면, 연합에 속한 당의 의석의 합이 전체 의석의 반을 넘어야 한다.
유효한 연합에서 소속된 당 하나를 제거했을 때, 여전히 유효한 연합이라면, 그 연합을 깔끔하지 못한 연합이라고 한다. 유효한 연합 중에서 깔끔하지 못한 연합을 제외한 것을 깔끔한 연합이라고 한다. 깔끔한 연합 중, 포함하는 의석의 수가 가장 많은 것을 찾는 프로그램을 작성하시오.
<입력값>
첫째 줄에 당의 수 N (1 ≤ N ≤ 300), 둘째 줄에 각 당의 의석 수가 주어진다.
당의 번호는 1번부터 N번까지이며, 의석 수의 합은 100,000을 넘지 않는다.
<출력값>
의석 수가 가장 많은 깔끔한 연합을 구한 다음, 첫째 줄에 당의 수, 둘째 줄에 당의 번호를 출력한다.

<문제 1227>
김상근과 김정인이 그녀의 마음을 얻기 위해 경쟁을 벌이고 있다. 그들은 다음과 같은 방법으로 승자를 결정하기로 했다.
무한한 크기의 2차원 평면에 어떤 지점에서 그녀가 걷기 시작한다. 그리고 그녀는 상, 하, 좌, 우 4방향으로 걸어갈 수 있는데 한번 걸어갈때마다 마음이 바뀐다. 즉, 상근이를 좋아하고 있었다면 정인이를 좋아하게 되고 정인이를 좋아하고 있었다면 상근이를 좋아하게 된다. 시작점에서는 그녀가 상근이를 좋아한다고 한다. 또한 2차원 좌표판 중에는 장애물이 있는 곳이 있어서 그런 곳은 지나가지 못한다고 하자. 이때 그녀는 그 시작점에서 (0, 0)까지 장애물을 피하여 최단거리로 걸어온다고 가정한다.
그녀가 무한한 체력을 가진 것은 아니므로 그녀가 걷는 걸음수를 S걸음 이하로 제한할 때 2차원 좌표 중 최종적으로 그녀가 (0, 0)에 왔을때 상근이를 좋아하게 될 시작점의 개수와 정인이를 좋아하게 될 시작점의 개수를 구하라.
<입력값>
첫 줄에는 장애물의 개수 B와 걸음수 S가 주어진다. (1<=B<=10000, 1<=S<=10000000) 그리고 다음 B줄에는 장애물의 좌표가 주어진다. 장애물의 x, y값의 절댓값은 1000보다 작다고 하자.
<출력값>
상근이를 좋아하게 될 시작점의 개수와 정인이를 좋아하게 될 시작점의 개수를 출력하라.

<문제 1228>
현재 W국은 N개의 나라와 전쟁 중이다. W국의 전력이 월등히 우세하여 전쟁에서 승리하는 것은 시간 문제이다. W국은 첩자를 통해, N개의 나라들 중 M개의 나라만을 정복하면 나머지 나라는 자동으로 항복한다는 정보를 입수했다.
이제 M개의 나라를 적당히 골라서 정복하려고 하는데, 각 나라마다 정복하는 데 걸리는 시간이 다르다. 어떤 나라는 오래 걸리고, 어떤 나라는 매우 순식간에 정복할 수도 있다. 단 그 나라를 정복하는 데 온 전력을 집중해야 하기 때문에, 매 순간 오직 한 나라와만 전쟁을 진행할 수 있다. 우리는 최대한 빨리 M개의 나라를 정복하려고 한다.
단, N개의 나라 사이에는 속국 관계가 존재할 수 있다. 나라 A가 나라 B의 속국인 경우, 나라 B를 정복하면 나라 B의 모든 속국들이 자동으로 항복하게 된다. 속국에는 서로 계층 관계가 존재해서, 나라 A가 나라 B의 속국이고, 나라 B가 나라 C의 속국인 경우, 나라 C를 정복하면 나라 A와 나라 B 모두 자동으로 정복하는 효과를 얻는다. 즉 자신의 속국과, 속국들의 속국과, 속국들의 속국들의 속국과, . . . 이렇게 모든 하위의 나라들이 자동으로 항복하게 된다.
나라 A가 나라 B의 속국이면서 동시에 나라 C의 속국일 수 없다. 즉 속국이라면 오직 한 나라의 속국일 뿐이다. 하지만 나라 A, 나라 B, ... 등 여러 나라가 한 나라의 속국일 수는 물론 있다.
N, M이 주어지고, 속국 관계가 주어지고, 각 나라를 정복하는 데 드는 일수가 주어지면, 최대한 빨리 M개의 나라를 정복할 수 있는 시간을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 나라의 개수 N(1≤N≤200)과 M(0≤M≤N)이 주어진다. 이어서 N개의 줄에 각 나라에 대한 정보가 주어지는데, 먼저 나라의 이름이 문자열로 주어진다. 문자열의 길이는 1 이상 100 이하이며 알파벳 대소문자로 이루어져 있다. 이어서 빈 칸 뒤에 이 나라를 정복하는 데 드는 일수가 주어진다. 이어서 빈 칸이 주어지고 여러 개의 나라 이름들이 빈 칸을 사이에 두고 주어질 수가 있는데, 이 뒤에 주어지는 나라들이 바로 현재 나라의 속국들이 된다.
<출력값>
첫째 줄에 M개의 나라를 최대한 빨리 정복하려고 할 때 며칠이 걸리는지 출력한다.

<문제 1229>
빅뱅은 다섯 명이다. 이종혁 조교는 빅뱅을 다음과 같이 그렸다.

이 그림을 본 YG의 양현석 사장은 이종혁을 빅뱅의 여섯 번째 멤버로 영입하려고 한다.
양현석 사장은 오디션 대신 이종혁에게 다음과 같은 문제를 풀라고 명령했다.

육각형 0개, 1개, 2개, 3개를 위와 같이 점 하나를 중심으로 겹쳐서 그려보자. 그럼 1, 6, 15, 28, 45, 66과 같은 수열이 하나 나온다. 이를 빅뱅수라고 한다.
일단 이종혁은 1791보다 큰 수는 항상 빅뱅수 4개의 합으로 만들 수 있다는 것을 증명했다. 그리고 잠시 더 생각해보니 수가 충분히 크다면 항상 빅뱅수 3개의 합으로 만들 수 있다는 것도 증명했다.
하지만 양현석 사장은 위의 두 가지 증명에도 불구하고 이종혁을 빅뱅의 여섯 번째 멤버로 뽑지 않고, 다음과 같은 문제를 하나 더 내주었다.
어떤 수 N이 있을 때, 이 수를 나타내기 위해 필요한 빅뱅수 개수의 최솟값을 몇 개인가? (빅뱅수의 합으로 N를 만드는 것이다.)



N
최소 개수
합




1
1
1


2
2
1+1


3
3
1+1+1


4
4
1+1+1+1


5
5
1+1+1+1+1


6
1
6


7
2
1+6


8
3
1+1+6


9
4
1+1+1+6


10
5
1+1+1+1+6


11
6
1+1+1+1+1+6


12
2
6+6



이종혁은 1791보다 큰 수에 대해 답이 항상 4보다 작거나 같은 것을 알고 있고, 답이 아무리 커도 6을 넘을 수 없다는 것을 알고 있다. 또 답이 6인 것은 11과 26밖에 없다는 것을 알고 있다.

답이 6인 가장 큰 N은 26이고,
답이 5인 가장 큰 N은 130이고,
답이 4인 가장 큰 N은 146858이다.
<입력값>
첫째 줄에 N이 주어진다. N은 1000000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 N을 만들기 위해 필요한 빅뱅수 개수의 최솟값을 출력한다.

<문제 1230>
문자열 O에서 문자열 N까지 문자열 거리는 O를 N과 같게 만들기 위해 필요한 문자열 삽입의 최솟값이다. 문자열 삽입은 O의 어느 위치에서건 가능하다. 예를 들어, O가 “gosrl"일 때, ”sip gi"을 r이전에 삽입한다면 "gossip girl“이 된다.
문자열 O와 문자열 N이 주어질 때, 두 문자열의 거리를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 문자열 O, 둘째 줄에 문자열 N이 주어진다. 문자열의 길이는 최대 1,000이다.
<출력값>
첫째 줄에 문자열 O와 문자열 N의 문자열 거리를 출력한다. 만약 O를 N으로 만들 수 없다면 -1을 출력한다.

<문제 1231>
동호는 주식으로 떼돈을 벌려고 한다.  동호가 주식왕이라 불리는 이유는 미래의 주식 값의 변화까지도 정확히 예측하기 때문이다. 현재 동호는 C개의 주식을 눈여겨보고 있고 이 주식들을 일정한 기간동안 적당히 사고팔면서 돈을 부풀릴 계획이다.



 
Day 1
Day 2
Day 3


주식 1
10
15
15


주식 2
13
11
20



위와 같이 각 주식에 대해 날짜에 따른 주식 비용이다. 처음 동호가 가지고 있는 자본이 10이라 할 때 3일동안 동호가 최대로 돈을 벌 수 있는 방법은 첫째 날 주식 1을 매입한다. 둘째 날 주식 1을 매각하고 주식 2를 매입한다. 셋째 날 주식 2를 매각하면 초기 자본을 포함하여 총 24의 돈을 갖게 된다.
문제는 주식 종류와 기간, 초기 자금 등이 주어졌을 때 동호가 최종적으로 가질 수 있는 돈의 최댓값을 구하는 것이다.
<입력값>
첫 줄에는 주식의 개수 C(1 ≤ N ≤ 50)과 주식 매입 및 매각을 할 기간 D(2 ≤ D ≤ 10), 초기 자금 M(1 ≤ M ≤ 200,000)이 공백으로 구분되어 주어진다. 두 번째 줄부터 C+1번째 줄까지 각 줄에는 각각 주식이 날짜에 따라 변하는 값이 입력된다.
<출력값>
첫 줄에 동호가 최종적으로 가질 수 있는 돈의 최댓값을 출력한다. 출력값이 500,000을 넘지 않는 데이터만 주어진다.

<문제 1232>
흰색 퀸과 두 검정색 킹이 100*100크기의 체스 판에 있다. 흰색과 검정색은 서로 턴을 번갈아 가면서 움직인다. 흰색 퀸이 먼저 움직인다. (한 턴에 두 검정 킹 중에 하나만 움직인다.)
퀸의 위치와 두 킹의 위치가 주어질 때, 두 킹 중 하나를 잡기 위해 필요한 퀸 움직임의 최솟값을 구하는 프로그램을 작성하시오. (킹은 퀸을 잡을 수 없으며, 퀸의 위치로 움직일 수도 없다.)
검정 편은 가능하면 늦게 잡히려고 노력할 것이다. 킹은 상하좌우, 대각선 8방향으로 한 칸씩 이동할 수 있고, 퀸은 8방향으로 원하는 칸만큼 이동할 수 있다. 퀸이 킹이 있는 칸으로 이동하는 것이 킹을 잡는 것이고, 양 편 모두 턴을 건너 뛸 수 없으며, 체스 판을 벗어날 수 없다.
<입력값>
첫째 줄에 퀸의 위치, 둘째 줄에 킹1의 위치, 셋째 줄에 킹2의 위치가 주어진다. 모든 위치는 “행 열”과 같은 형식을 주어진다. (가장 왼쪽 위에 있는 칸이 (0,0)이고, 가장 오른족 아래에 있는 칸이 (99,99)이다.
<출력값>
첫째 줄에 킹을 잡기 위한 퀸의 움직임의 최솟값을 출력한다.

<문제 1233>
지민이는 주사위 던지기 게임을 좋아하여 어느 날 옆에 있는 동호를 설득하여 주사위 던지기 게임을 하자고 하였다. 총 3개의 주사위가 있다. 그리고 이 주사위는 각각 S1(2 ≤ S1 ≤ 20), S2(2 ≤ S2 ≤ 20), S3(2 ≤ S3 ≤ 40)개의 면이 있다. (실제로는 주사위가 6개의 면이 있는 것이 정상이지만 특별한 주사위라 생각하자.)
문제는 세 개의 주사위를 동시에 던졌을 때 가장 높은 빈도로 나오는 세 주사위의 합을 구하는 것이다.
예를 들어, S1 = 3, S2 = 2, S3 = 3으로 주어질 때, 주사위1은 S1(3)개의 면이 있으므로 1, 2, 3의 눈을 가지고, 주사위2는 S2(2)개의 면이 있으므로 1, 2의 눈을 가지며, 주사위3은 S3(3)개의 면이 있으므로 1, 2, 3의 눈을 가진다. 이 때, 이 3개의 주사위를 던져서 눈의 합을 구하면, (1, 1, 1) = 3, (1, 1, 2) = 4, (1, 1, 3) = 5, ... , (3, 2, 1) = 6, (3, 2, 2) = 7, (3, 2, 3) = 8과 같은 합들을 얻을 수 있다. 이 때, 가장 많이 발생하는 합을 구하는 것이다.
<입력값>
입력 파일의 첫째 줄에 정수 S1, S2, S3가 주어진다.
<출력값>
출력 파일의 첫째 줄에 가장 높은 빈도로 나오는 세 주사위 합을 구하는 것이다. 단 답이 여러개라면 가장 합이 작은 것을 출력한다.

<문제 1234>
오민식은 오늘이 크리스마스라고 생각해서, 크리스마스 트리를 만들려고 한다. 트리는 N개의 레벨로 이루어져 있다. 위에서부터 레벨1, ... 레벨 N이다. 또, 민식이는 빨강, 파랑, 초록색의 장난감을 가지고 있다. 그리고 민식이는 이 장난감을 일정한 규칙에 의해서 장식하려고 한다.
레벨 K에는 딱 K개의 장난감이 있어야 한다. 또, 각 레벨에 놓으려고 선택한 색이 있으면, 그 색의 장난감의 수는 서로 같아야 한다. 예를 들어, 레벨 3에 장난감을 놓으려고 할 때, 빨강 2, 파랑 1과 같이 놓으면, 빨강과 파랑의 수가 다르기 때문에 안 된다. 하지만, 레벨 4에 빨강 2, 파랑 2와 같이 놓으면, 가능하다.
N과, 장난감의 수가 주어질 때, 트리를 장식하는 경우의 수를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 트리의 크기 N, 빨강의 개수, 초록의 개수, 파랑의 개수가 주어진다. N은 10보다 작거나 같다. 빨강, 초록, 파랑의 개수는 0보다 크거나 같고, 100보다 작거나 같다.
<출력값>
첫째 줄에 경우의 수를 출력한다. 만약 주어진 장난감으로 트리를 장식할 수 없으면 0을 출력한다. 문제의 정답은 263-1보다 작거나 같다.

<문제 1235>
이번에는 학생들을 더욱 효율적으로 관리하기 위해 학생마다 고유한 학생 번호를 부여하기로 하였다. 학생 번호는 0부터 9 사이의 숫자로 이루어진 문자열로, 모든 학생들의 학생 번호는 서로 다르지만 그 길이는 모두 같다.
학생들의 번호를 부여해 놓고 보니, 김진영 조교는 어쩌면 번호가 지나치게 긴 것은 아닌가 싶은 생각이 들었다. 예를 들어 아래와 같은 7자리의 학생 번호를 보자.



이름
번호




오민식
1212345


김형택
1212356


이동호
0033445



이처럼 학생 번호를 굳이 7자리로 하지 않고, 뒤에서 세 자리만을 추려서 남겨 놓아도 모든 학생들의 학생 번호를 서로 다르게 만들 수 있다.



이름
번호




오민식
345


김형택
356


이동호
445



하지만 세 자리보다 적게 남겨 놓아서는 모든 학생들의 학생 번호를 서로 다르게 만들 수 없다.
학생들의 번호가 주어 졌을 때, 뒤에서 k자리만을 추려서 남겨 놓았을 때 모든 학생들의 학생 번호를 서로 다르게 만들 수 있는 최소의 k를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 학생의 수 N(2≤N≤1,000)이 주어진다. 둘째 줄부터 N개의 줄에 걸쳐 각 학생의 학생 번호가 순서대로 주어진다. 모든 학생들의 학생 번호는 서로 다르지만 그 길이는 모두 같으며, 0부터 9 사이의 숫자로 이루어진 문자열이 주어진다. 문자열의 길이는 100보다 작거나 같다.
<출력값>
첫째 줄에 구하고자 하는 가장 작은 k값을 출력한다.

<문제 1236>
영식이는 직사각형 모양의 성을 가지고 있다. 성의 1층은 몇 명의 경비원에 의해서 보호되고 있다. 영식이는 모든 행과 모든 열에 한 명 이상의 경비원이 있으면 좋겠다고 생각했다.
성의 크기와 경비원이 어디있는지 주어졌을 때, 몇 명의 경비원을 최소로 추가해야 영식이를 만족시키는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 성의 세로 크기 N과 가로 크기 M이 주어진다. N과 M은 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 성의 상태가 주어진다. 성의 상태는 .은 빈칸, X는 경비원이 있는 칸이다.
<출력값>
첫째 줄에 추가해야 하는 경비원의 최솟값을 출력한다.

<문제 1237>
이 문제를 푸는 자 우주를 정ㅋ벅ㅋ한다.
<입력값>
우주를 정ㅋ벅ㅋ하는 자에겐 입력 따위 필요 없다.
<출력값>
첫째 줄에 문제의 정답을 출력한다.

<문제 1238>
N개의 숫자로 구분된 각각의 마을에 한 명의 학생이 살고 있다.
어느 날 이 N명의 학생이 X (1 ≤ X ≤ N)번 마을에 모여서 파티를 벌이기로 했다. 이 마을 사이에는 총 M개의 단방향 도로들이 있고 i번째 길을 지나는데 Ti(1 ≤ Ti ≤ 100)의 시간을 소비한다.
각각의 학생들은 파티에 참석하기 위해 걸어가서 다시 그들의 마을로 돌아와야 한다. 하지만 이 학생들은 워낙 게을러서 최단 시간에 오고 가기를 원한다.
이 도로들은 단방향이기 때문에 아마 그들이 오고 가는 길이 다를지도 모른다. N명의 학생들 중 오고 가는데 가장 많은 시간을 소비하는 학생은 누구일지 구하여라.
<입력값>
첫째 줄에 N(1 ≤ N ≤ 1,000), M(1 ≤ M ≤ 10,000), X가 공백으로 구분되어 입력된다. 두 번째 줄부터 M+1번째 줄까지 i번째 도로의 시작점, 끝점, 그리고 이 도로를 지나는데 필요한 소요시간 Ti가 들어온다. 시작점과 끝점이 같은 도로는 없으며, 시작점과 한 도시 A에서 다른 도시 B로 가는 도로의 개수는 최대 1개이다.
모든 학생들은 집에서 X에 갈수 있고, X에서 집으로 돌아올 수 있는 데이터만 입력으로 주어진다.
<출력값>
첫 번째 줄에 N명의 학생들 중 오고 가는데 가장 오래 걸리는 학생의 소요시간을 출력한다.

<문제 1239>
민식이는 학교에서 다른 반 친구들이 개를 몇 마리 키우는지 궁금했다. 그래서, 세준이는 다른 반 친구들이 키우는 개의 수를 조사했다. 세준이네 학교에 개를 키우는 사람의 수는 총 100명이었다. 어떤 반에 개를 키우는 사람이 15명이면, 이 것은 15%와 같다.
민식이는 자기가 조사한 개의 수를 가지고 원형 차트를 만들었다. 10, 40, 10, 40 일때의 차트 모양은 다음과 같다.

또, 10, 40, 50 일때의 차트 모양은 다음과 같다.

민식이가 조사한 데이터를 이용해서 차트를 만들 수 있는 방법은 여러 가지가 존재한다. 민식이는 그 중에, 원의 중심을 지나는 선의 개수를 최대로 하고 싶어한다. (원의 중심을 지나는 선이란, 원을 이등분하는 선)
민식이 학교의 반의 개수와, 각 반에서 개를 키우는 사람의 수가 주어졌을 때, 원의 중심을 지나는 선의 개수의 최댓값을 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 8보다 작거나 같다. 둘째 줄에, N개의 데이터가 주어진다. 합은 항상 100이다.
<출력값>
첫째 줄에 정답을 출력한다.

<문제 1240>
N(2≤N≤1,000)개의 노드로 이루어진 트리가 주어지고 M(M≤1,000)개의 두 노드 쌍을 입력받을 때 두 노드 사이의 거리를 출력하라.
<입력값>
첫째 줄에 노드의 개수 N이 입력되고 다음 N-1개의 줄에 트리 상에 연결된 두 점과 거리(10,000 이하의 정수)를 입력받는다. 그 다음 줄에는 거리를 알고 싶은 M개의 노드 쌍이 한 줄에 한 쌍씩 입력된다.
<출력값>
M개의 줄에 차례대로 입력받은 두 노드 사이의 거리를 출력한다.

<문제 1241>
엄지 생일 기념으로 학생들은 파티를 하고 있다. 엄지는 N(1≤N≤100,000)명의 학생에게 1부터 N번까지 차례대로 번호를 부여하였고 그들을 순서대로 빙 둘러앉아 원을 만들게 하였다. (즉 i번째 학생은 i-1과 i+1학생 사이에 앉아있다. 단, N번째 학생은 N-1번째 학생과 첫 번째 학생 사이에 앉아있다.)
N명의 학생은 둘러앉아 "머리톡톡" 게임을 하려한다. 게임 규칙은 다음과 같다. 각각의 학생은 자신의 머리 위에 1,000,000 이하의 자연수 중 하나를 쓴다. 그리고 1번부터 N번 학생까지 한 명씩 차례대로 일어나 원을 돌면서 자신이 쓴 숫자가 다른 사람이 쓴 숫자의 배수이면 그 학생의 머리를 "톡톡" 친다.
문제는 각각의 학생이 일어나 자신의 자리로 돌아올 때까지 총 몇 명의 학생의 머리를 치는지 구하는 것이다.
<입력값>
첫째 줄에 학생의 수 N이 입력되고 다음 N개의 줄에는 1번부터 N번까지 각각의 학생이 자신의 머리에 쓴 숫자를 입력받는다.
<출력값>
총 N개의 줄로 i번째 줄에는 i번째 학생이 한 바퀴를 돌면서 머리를 친 학생의 수를 출력한다.

<문제 1242>
동호와 동호네 반 친구들은 산정호수로 소풍을 갔다. 총 N명이 소풍에 참가했는데, 산정 호수에는 있는 것이 별로 없어서 무대에 올라가기로 했다.
무대에 올라간 N명은 1번부터 N번까지 시계방향으로 원형으로 앉았다. 그런 후에, KIN 이란 게임을 시작했다. 이 게임은 1번부터 시작된다. 그리고 한 명씩 시계방향으로 1, 2, ... , K까지 센다. K를 말하는 사람은 퇴장 당한다. 그 후에는 다음 자리에 앉아있는 사람이 1부터 다시 센다. 동호도 이 게임에 M번 학생으로 참가한다. 동호는 자기가 몇 번째로 퇴장 당하는지 궁금해졌다.
예를 들어, 5명의 학생이 참가하고 K=2이고, 동호는 3번 학생이라고 하면, 가장 처음에는 1 2 3 4 5와 같이 앉아있다. 1부터 게임을 시작하기 때문에, 1이 1이라고 말하고, 2가 2라고 말한다. 2가 퇴장 당한다. 3이 1이라고 말하고, 4가 2라고 말한다. 4가 퇴장 당한다. 그 다음에는 1이 퇴장 당한다. 그 후에는 5가 퇴장당하고, 마지막으로 3이 퇴장 당한다. 동호는 3번 학생이기 때문에, 5번째로 퇴장 당한다.
N, K, M가 주어졌을 때, 동호가 몇 번째로 퇴장 당하는지 알아내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N, K, M가 주어진다. N과 K는 5,000,000보다 작거나 같은 자연수이고, M은 N보다 작거나 같다.
<출력값>
첫째 줄에 동호가 몇 번째로 퇴장당하는 지 출력한다.

<문제 1243>
뒤집어도 같은 말이 되는 단어를 팰린드롬(Palindrome)이라고 한다. N개의 서로 다른 영어 단어가 주어질 때 이를 이어 붙여 길이가 L인 팰린드롬을 모두 몇 가지 방법으로 만들 수 있는지 출력하는 프로그램을 작성하시오. 단, 하나의 단어를 중복해서 사용할 수 있으며, 서로 다른 조합이나 순서로 단어를 붙여 같은 팰린드롬을 만든 경우 다른 방법으로 간주한다.
예를 들어 N이 5, L이 4라고 하고 A, AA, BB, BC, CB 이렇게 5개의 영어 단어가 주어졌다고 하자. 이 경우 아래와 같이 총 9개의 방법으로 팰린드롬을 만들 수 있다.

A|A|A|A
AA|A|A
A|AA|A
A|A|AA
AA|AA
A|BB|A
BB|BB
BC|CB
CB|BC
<입력값>
첫째 줄에 N이, 둘째 줄에 L이 주어진다. N은 50이하의 자연수, L은 30이하의 자연수이다. 셋째 줄부터 N개의 줄에 한 줄에 하나씩 영문자 대문자로만 이루어진 길이가 15이하인 영어 단어가 주어진다. 주어지는 모든 영어 단어는 서로 다르다.
<출력값>
첫째 줄에 입력으로 주어진 단어를 이어 붙여 길이가 L인 팰린드롬을 만들 수 있는 방법의 수를 출력한다. 그 방법의 수는 21억을 넘지 않는다.

<문제 1244>
1부터 연속적으로 번호가 붙어있는 스위치들이 있다. 스위치는 켜져 있거나 꺼져있는 상태이다. <그림 1>에 스위치 8개의 상태가 표시되어 있다. ‘1’은 스위치가 켜져 있음을, ‘0’은 꺼져 있음을 나타낸다. 그리고 학생 몇 명을 뽑아서, 학생들에게 1 이상이고 스위치 개수 이하인 자연수를 하나씩 나누어주었다. 학생들은 자신의 성별과 받은 수에 따라 아래와 같은 방식으로 스위치를 조작하게 된다.

	스위치 번호  ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ 
        스위치 상태   0  1   0  1   0   0   0  1

	<그림 1>
남학생은 스위치 번호가 자기가 받은 수의 배수이면, 그 스위치의 상태를 바꾼다. 즉, 스위치가 켜져 있으면 끄고, 꺼져 있으면 켠다. <그림 1>과 같은 상태에서 남학생이 3을 받았다면, 이 학생은 <그림 2>와 같이 3번, 6번 스위치의 상태를 바꾼다.

	스위치 번호  ① ② ③ ④ ⑤ ⑥ ⑦ ⑧
	스위치 상태   0  1   1  1   0   1   0  1
	<그림 2>
여학생은 자기가 받은 수와 같은 번호가 붙은 스위치를 중심으로 좌우가 대칭이면서 가장 많은 스위치를 포함하는 구간을 찾아서, 그 구간에 속한 스위치의 상태를 모두 바꾼다. 이때 구간에 속한 스위치 개수는 항상 홀수가 된다.
예를 들어 <그림 2>에서 여학생이 3을 받았다면, 3번 스위치를 중심으로 2번, 4번 스위치의 상태가 같고 1번, 5번 스위치의 상태가 같으므로, <그림 3>과 같이 1번부터 5번까지 스위치의 상태를 모두 바꾼다. 만약 <그림 2>에서 여학생이 4를 받았다면, 3번, 5번 스위치의 상태가 서로 다르므로 4번 스위치의 상태만 바꾼다.

	스위치 번호  ① ② ③ ④ ⑤ ⑥ ⑦ ⑧
	스위치 상태   1   0  0   0  1   1   0  1
	<그림 3>
입력으로 스위치들의 처음 상태가 주어지고, 각 학생의 성별과 받은 수가 주어진다. 학생들은 입력되는 순서대로 자기의 성별과 받은 수에 따라 스위치의 상태를 바꾸었을 때, 스위치들의 마지막 상태를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 스위치 개수가 주어진다. 스위치 개수는 100 이하인 양의 정수이다. 둘째 줄에는 각 스위치의 상태가 주어진다. 켜져 있으면 1, 꺼져있으면 0이라고 표시하고 사이에 빈칸이 하나씩 있다. 셋째 줄에는 학생수가 주어진다. 학생수는 100 이하인 양의 정수이다. 넷째 줄부터 마지막 줄까지 한 줄에 한 학생의 성별, 학생이 받은 수가 주어진다. 남학생은 1로, 여학생은 2로 표시하고, 학생이 받은 수는 스위치 개수 이하인 양의 정수이다. 학생의 성별과 받은 수 사이에 빈칸이 하나씩 있다.
<출력값>
스위치의 상태를 1번 스위치에서 시작하여 마지막 스위치까지 한 줄에 20개씩 출력한다. 예를 들어 21번 스위치가 있다면 이 스위치의 상태는 둘째 줄 맨 앞에 출력한다. 켜진 스위치는 1, 꺼진 스위치는 0으로 표시하고, 스위치 상태 사이에 빈칸을 하나씩 둔다.

<문제 1245>
농부 민식이가 관리하는 농장은 N*M 격자로 이루어져 있다. 민식이는 농장을 관리하기 위해 산봉우리마다 guard를 배치하려 한다. 이를 위해 농장에 산봉우리가 총 몇 개 있는지를 세는 것이 문제다.
산봉우리의 정의는 다음과 같다. 산봉우리는 같은 높이를 가지는 하나의 격자 혹은 인접한 격자들의 집합으로 이루어져 있다. (여기서 "인접하다"의 정의는 X좌표 차이와 Y좌표 차이 모두 1 이하일 경우로 정의된다.) 또한 산봉우리와 인접한 격자는 모두 산봉우리의 높이보다 작아야한다.
문제는 격자 내에 산봉우리의 개수가 총 몇 개인지 구하는 것이다.
<입력값>
첫째 줄에 정수 N(1<N≤100), M(1<M≤70)이 주어진다. 둘째 줄부터 N+1번째 줄까지 각 줄마다 격자들의 높이를 의미하는 M개의 정수가 입력된다.
<출력값>
첫째 줄에 산봉우리의 개수를 출력한다.

<문제 1246>
경래는 닭을 기르는데 올 겨울 달걀 풍년으로 함박 웃음을 짓고 있다. 그리고 이 달걀을 영양란으로 둔갑하여 옥션에 판매하려한다.
경래는 총 N개의 달걀이 있고, 그의 잠재적인 고객은 총 M명이다. 그리고 각각의 i번째 고객은 각자 달걀 하나를 Pi 가격 이하로 살 수 있다고 밝혔다.
경래는 영양란이라 속인 죄책감에 한 고객에게 두 개 이상의 달걀은 팔지 않기로 하였다. 하지만 위의 규칙 하에 수익은 최대로 올리고 싶기에 얼마로 팔지 고민하고 있다. 즉, A가격에 달걀을 판다고 하면 Pi가 A가격보다 크거나 같은 모든 고객은 달걀을 산다는 뜻이다. (물론 달걀 총 수량을 초과하여 팔 수 는 없다)
문제는 이러한 경래를 도와 최대 수익을 올릴 수 있는 달걀의 가장 낮은 가격을 책정하는 것이다.
<입력값>
첫째 줄에 정수 N(1≤N≤1,000)과 M(1≤M≤1,000)이 입력된다. 둘째 줄부터 M+1번째 줄까지 i+1번째 줄에는 Pi(1≤Pi≤1,000,000)가 입력된다.
<출력값>
첫째 줄에 경래가 책정한 가격과 이 가격으로 올릴 수 있는 수익을 출력한다.

<문제 1247>
N개의 정수가 주어지면, 이 정수들의 합 S의 부호를 구하는 프로그램을 작성하시오.
<입력값>
총 3개의 테스트 셋이 주어진다. 각 테스트 셋의 첫째 줄에는 N(1≤N≤100,000)이 주어지고, 둘째 줄부터 N개의 줄에 걸쳐 각 정수가 주어진다. 주어지는 정수의 절댓값은 9223372036854775807보다 작거나 같다.
<출력값>
총 3개의 줄에 걸쳐 각 테스트 셋에 대해 N개의 정수들의 합 S의 부호를 출력한다. S=0이면 "0"을, S>0이면 "+"를, S<0이면 "-"를 출력하면 된다.

<문제 1248>
규현이는 멍청하다. 왜냐하면, 1~10까지 수 밖에 모르기 때문이다. 어느 날 규현이 옆을 지나가던 태석이가 규현이를 보고 이렇게 외쳤다. "빵빵!!" 규현이는 "아하!" 하면서 세상에는 빵이란 수도 있구나 했다. 그날 이후로 규현이는 매일 친구들을 볼 때면 "빵빵!!" 거리면서 인사를 했다. 규현이의 친구 중에는 태방이가 있다. 자꾸 규현이가 "빵빵!!" 거릴때 마다 자신을 놀리는 것 처럼 생각했던 태방이는 규현이에게 그건 "빵이 아니고 영이야" 라고 가르쳐 줬다.
이제 규현이는 0~10까지 수를 알고 있다. 어느 날 자신이 알고 있는 숫자를 까먹지 않으려고 종이에 1~10까지 수를 썻다. (0은 잠시 까먹었다) 규현이의 친구 석원이는 밀덕이다. 계급을 엄청나게 좋아해서, 규현이가 써 놓은 숫자에 이등병 마크인 -를 모두 그렸다. 석원이는 규현이에게 이렇게 말했다. "너, 우리 위대하신 미하엘 칼라시니코프께서 뭐라고 했는지 알아? 단순함과 신뢰성, 그리고 저렴한 가격이 최고야!"
규현이는 그 말을 듣고서 아하 세상에는 음수도 있구나 했다.
이제 규현이가 아는 수는 -10부터 10까지 20개가 되었다. 아차, 0을 빼먹었구나, 21개가 되었다.
근처 사파리에 놀러간 규현이는 사파리 가이드 승환이와 함께 관광을 시작했다. "저기, 사자 1마리가 보이죠? 그 옆이 그 사자 부인이에요. 그러니깐, 1 더하기 1은 2죠" 규현이는 덧셈을 익혔다. "저 사자는 아까 그 사자의 자식 2마리 입니다. 그럼 총 사자는 몇 마리이지요?" 이제 규현이는 1+1을 제외한 다른 덧셈도 할 수 있다. 만세!
인도네시아에 놀러간 규현이는 자바 섬에 방문했다. 자바 섬에는 자바 커피를 재배하는 홍태석 농부가 있었다. 홍태석은 "ㅋㅋㅋ 님 음수와 양수와 0의 차이도 모름?" 하면서 음수와 양수와 0을 설명해주었다.
지금까지 배운 것을 종합해서, 한국으로 돌아오는 비행기에서 규현이는 종이에 수를 N개 썼다. (규현이가 아는 가장 큰 수는 10이기 때문에, 수를 10개까지만 쓸 수 있다.)  그 다음에, 가능한 모든 N*(N+1)/2개의 구간의 합을 구했다. 이 것을 해인이는 행렬로 표현했다.
규현이가 쓴 수를 A라고 하면, A[i]는 규현이가 i번째 쓴 수이다. 그리고, S[i][j]는 A[i]부터 A[j]까지 합이 0보다 크면 +, 0이면 0, 0보다 작으면 -이다. 여기서 i는 항상 j보다 작거나 같다. 이렇게 배열을 채우면 배열에는 총 N*(N+1)/2개의 문자가 있다. (+, -, 0 중 하나) 이 S 배열이 주어졌을 때, 규현이가 쓴 N개의 수 A를 구해서 출력하면 된다. 규현이는 -10부터 10까지의 정수밖에 모르기 때문에, A도 -10부터 10까지의 정수로만 이루어져 있어야 한다.
<입력값>
첫째 줄에 수열의 크기 N이 주어진다. N은 10보다 작거나 같은 자연수이다. 둘째 줄에는 N(N+1)/2 길이의 문자열이 주어진다. 처음 N개의 문자는 부호 배열의 첫 번째 줄에 해당하고, 다음 N-1개의 문자는 두 번째 줄에 해당한다. 마찬가지로 마지막 문자는 N번째 줄에 해당하는 문자다.
<출력값>
첫째 줄에 수열의 원소 N개를 빈 칸을 사이에 두고 출력한다. 답이 여러 가지 일 경우에는 아무거나 출력하면 된다.

<문제 1249>
진영이는 워드똑똑을 공부한다. 민승이는 워드똑똑을 공부한다. 종혁이는 워드똑똑을 공부한다. 백준이는 워드똑똑을 공부한다. 하지만, 성경이는 워드똑똑을 공부하지 않는다.
워드똑똑을 공부하지 않는 성경이를 본 진영이는 분노로 휩싸여 교실의 책상을 의자로 부셔버렸다. 그리고 나서 의자를 창 밖으로 던졌다. 이 광경을 본 동호는 자기도 워드똑똑을 공부해야하겠다고 느끼면서, 책을 no24에서 인터넷 주문했다.
하지만, no24는 이름에 걸맞게 책을 잘못 보냈다. 이 책의 이름은 “팰린드롬똑똑 (Palindrome Smart)” 이었다.
이 책의 첫 페이지에는 다음과 같이 쓰여 있다.
이 책을 산 모든 사람은 다음과 같은 문제를 풀어야한다. 문자열의 길이가 1보다 크거나 같고, N보다 작거나 같은 팰린드롬 문자열을 모두 쓰라. 모든 문자는 알파벳 소문자이고, 모든 팰린드롬 문자열은 K개 보다 작거나 같은 서로 다른 문자를 가져야 한다. 다음 페이지에는 한 페이지에 하나씩 N과 K가 쓰여 있다.
동호는 그 많은 문자열을 다 쓰느니 차라리 개수만 구하겠다고 하고, 개수를 구하기로 했다. 동호가 부러워진 많은 학생들은 다같이 개수를 구하기로 했다.
N과 K가 주어졌을 때, 위의 조건을 만족하는 팰린드롬 문자열의 개수를 출력하는 프로그램을 작성하시오. 팰린드롬이란 앞에서 읽으나 뒤에서 읽으나 같은 문자열을 얘기한다. 예) wow, abba
<입력값>
첫째 줄에 N, K이 주어진다. N은 1,000,000,000보다 작거나 같은 자연수이고, K은 26보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 문제의 조건에 맞는 팰린드롬의 개수를 1234567891로 나눈 나머지를 출력한다.

<문제 1250>
규완이는 N개의 순서대로 색칠된 공을 가지고 있다. (색은 영어 대문자로 이루어져 있다.) 당신은 이 공을 가지고 다음과 같은 재미있는 일을 하고자 한다.

가장 많은 개수로 같은 색이 연속된 공을 제거한다.
만약 가장 많은 개수로 같은 색이 연속된 부분이 여럿 있다면, 그 중에서 맨 앞에 있는 부분을 제거한다.
1, 2를 공이 모두 제거될 때 까지 반복한다.

이 과정을 반복하던 도중, 규완이는 k 번째 공이 몇 번째 사라질지 궁금해졌다. 규완이를 도와주자.
<입력값>
첫째 줄에는 공의 개수인 N과, 자신이 언제 없어지는지 알고 싶은 공의 번호 k가 주어진다. 그 다음 줄에는 공의 색이 연속된 N개의 문자열로 주어진다. (1 ≤ N ≤ 10000000)
<출력값>
그 k번째 공이 사라지는 시행횟수가 몇 번째인지 출력한다.

<문제 1251>
알파벳 소문자로 이루어진 단어를 가지고 아래와 같은 과정을 해 보려고 한다.
먼저 단어에서 임의의 두 부분을 골라서 단어를 쪼갠다. 즉, 주어진 단어를 세 개의 더 작은 단어로 나누는 것이다. 각각은 적어도 길이가 1 이상인 단어여야 한다. 이제 이렇게 나눈 세 개의 작은 단어들을 앞뒤를 뒤집고, 이를 다시 원래의 순서대로 합친다.
예를 들어,

단어 : arrested
세 단어로 나누기 : ar / rest / ed
각각 뒤집기 : ra / tser / de
합치기 : ratserde

단어가 주어지면, 이렇게 만들 수 있는 단어 중에서 사전순으로 가장 앞서는 단어를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 영어 소문자로 된 단어가 주어진다. 길이는 3 이상 50 이하이다.
<출력값>
첫째 줄에 구하고자 하는 단어를 출력하면 된다.

<문제 1252>
두 개의 이진수를 입력받아 이를 더하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 두 개의 이진수가 빈 칸을 사이에 두고 주어진다. 각 이진수는 1 또는 0으로만 이루어져 있으며, 0으로 시작할 수도 있다. 또한 각 이진수의 길이는 80을 넘지 않는다.
<출력값>
첫째 줄에 이진수 덧셈 결과를 출력한다. 결과가 0인 경우를 제외하고는 출력되는 이진수는 항상 1로 시작해야 한다.

<문제 1253>
N개의 수 중에서 어떤 수가 다른 수 두 개의 합으로 나타낼 수 있다면 그 수를 “좋다(GOOD)”고 한다.
N개의 수가 주어지면 그 중에서 좋은 수의 개수는 몇 개인지 출력하라.
수의 위치가 다르면 값이 같아도 다른 수이다.
<입력값>
첫째 줄에는 수의 개수 N(1 ≤ N ≤ 2,000), 두 번째 줄에는 i번째 수를 나타내는 Ai가 N개 주어진다. (|Ai| ≤ 1,000,000,000, Ai는 정수)
<출력값>
좋은 수의 개수를 첫 번째 줄에 출력한다.

<문제 1254>
동호와 규완이는 212호에서 문자열에 대해 공부하고 있다. 규완이는 팰린드롬을 엄청나게 좋아한다. 팰린드롬이란 앞에서부터 읽으나 뒤에서부터 읽으나 같게 읽히는 문자열을 말한다.
동호는 규완이를 위한 깜짝 선물을 준비했다. 동호는 규완이가 적어놓고 간 문자열 S에 0개 이상의 문자를 문자열 뒤에 추가해서 팰린드롬을 만들려고 한다. 동호는 가능하면 가장 짧은 문자열을 만들려고 한다.
동호가 만들 수 있는 가장 짧은 팰린드롬의 길이를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 문자열 S가 주어진다. S의 길이는 최대 1000이다.
<출력값>
첫째 줄에 동호가 만들 수 있는 가장 짧은 팰린드롬의 길이를 출력한다.

<문제 1255>
결국 당신과 옆 나라 왕은 서로 화가 난 나머지 전쟁을 시작할 준비를 하게 된다.
그리하여 옆 나라에 선전포고를 하려 했으나, 당신은 자비로운 왕이었기 때문에 옆 나라에 있는 당신의 백성들을 당신의 국가로 귀환 시킨 후 선전 포고를 하고자 했다.
그리하여 Y년 M월 D일. 미리 옆 나라에 있는 모든 백성들에게 귀환 명령을 내려놓았기 때문에, 그들 모두가 한꺼번에 이동을 시작했다.
옆 나라에는 통과할 수 없는 직선모양의 장애물이 있기 때문에 백성들이 국경을 넘는 시간이 지연될 수 있다.
만약 모든 백성들이 가장 빠른 경로로만 이동해서 국경을 넘는다면, 과연 얼마 후에야 모든 사람들이 국경을 넘을 수 있는지 계산하라.
<입력값>
첫째 줄에는 백성의 명수인 N(1 ≤ N ≤ 50)과, 직선 장애물의 개수 M(1 ≤ M ≤ 50)이 주어진다. 2번째 줄에서 N+1번째 줄에는 백성들의 좌표(x, y)와 속도 v가 주어진다.(1 ≤ x.y ≤ 100, 1 ≤ v ≤ 10, x, y, v는 정수) N+2번째 줄에서 N+M+1번째 줄에는 직선 장애물의 좌표 (x1, y1) - (x2, y2)이 주어진다.(1 ≤ x1, y1, x2, y2 ≤ 100, x1, y1, x2, y2는 정수) 직선 장애물은 서로 교차하지 않는다. 또한, 직선 y=0은 국경이다.
거리 a를 가면서 속도가 v이면 시간은 a/v만큼 걸린다.
<출력값>
모든 백성들이 국경을 넘을 수 있는 최소 시간을 소수점 첫째자리 까지 출력한다.

<문제 1256>
동호와 규완이는 212호에서 문자열에 대해 공부하고 있다. 김진영 조교는 동호와 규완이에게 특별 과제를 주었다. 특별 과제는 특별한 문자열로 이루어 진 사전을 만드는 것이다. 사전에 수록되어 있는 모든 문자열은 N개의 "a"와 M개의 "z"로 이루어져 있다. 그리고 다른 문자는 없다. 사전에는 알파벳 순서대로 수록되어 있다.
규완이는 사전을 완성했지만, 동호는 사전을 완성하지 못했다. 동호는 자신의 과제를 끝내기 위해서 규완이의 사전을 몰래 참조하기로 했다. 동호는 규완이가 자리를 비운 사이에 몰래 사전을 보려고 하기 때문에, 문자열 하나만 찾을 여유밖에 없다.
N과 M이 주어졌을 때, 규완이의 사전에서 K번째 문자열이 무엇인지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N, M, K가 순서대로 주어진다. N과 M은 100보다 작거나 같은 자연수이고, K는 1,000,000,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 규완이의 사전에서 K번째 문자열을 출력한다. 만약 규완이의 사전에 수록되어 있는 문자열의 개수가 K보다 작으면 -1을 출력한다.

<문제 1257>
최백준 조교는 사실 엄청난 갑부다. 그는 그 사실을 숨겼지만 어느 날 김재홍 조교에게 그 사실을 발각당한다. 결국 최백준 조교는 가지고 있는 돈을 몽땅 동전으로 바꾸어서 땅에 묻어 둘 생각을 하게 된다.
하지만 최백준 조교가 가진 돈이 워낙 많기 때문에 돈을 묻어두어도 그 위치가 김재홍 조교에게 발각될 위험이 있다.
그 때문에 그는 최소의 동전 개수로 돈을 바꾸고 싶다.
최백준 조교는 엄청난 구두쇠이기 때문에 돈이 단 1원도 줄거나, 심지어는 늘어나는 것도 싫어한다.
정확히 그가 가진 금액을 동전으로 교환하되, 그 개수를 최소화하는 방법을 찾도록 하자.
<입력값>
첫째 줄에는 엄청난 갑부인 최백준 조교가 가진 돈의 금액(109 ≤ M ≤ 1018)이 주어진다. 두 번째 줄에는 동전의 종류 N(1 ≤ N ≤ 1,000)이 주어진다. 세 번째 줄에는 동전의 금액 Ai (1 ≤ Ai ≤ 10,000)가 N개 주어진다.
N가지의 동전 중 1원짜리 동전은 항상 있기 때문에, 금액을 못 만드는 경우는 없다.
<출력값>
동전으로 딱 맞는 금액을 만들 때, 그 최소 개수를 출력한다.

<문제 1258>
N명의 학생들에게 N개의 문제가 출제되었다. 학생들은 각자 한 문제씩을 할당받아 그 문제만을 풀려고 한다. 즉, 모든 학생이 서로 다른 문제를 하나씩 맡아서 푸는 것이다.



 
문제 1
문제 2
문제 3




학생 1
1
3
3


학생 2
2
3
3


학생 3
3
2
4



모든 학생들은 서로 잘 풀 수 있는 문제가 다르기 때문에, 각 문제마다 문제를 푸는 데 걸리는 시간이 다를 수가 있다. 예를 들어 위의 표처럼 문제 1을 푸는 데 학생 1은 1시간이 걸리지만, 학생2는 2시간이 걸린다.
우리는 모든 학생들이 문제를 푸는 데 걸리는 시간의 총 합을 최소화하고 싶다. 예를 들어 학생 1이 문제 1을 풀고, 학생 2가 문제 3을 풀고, 학생 3이 문제 2를 풀면, 문제를 푸는 데 걸리는 시간의 합은 1 + 3 + 2 = 6이 된다. 문제를 푸는 데 걸리는 시간을 이보다 더 짧게 할 수는 없다.
N명의 학생이 N개의 문제를 푸는 데 걸리는 시간이 모두 주어졌을 때, 각 학생에게 서로 다른 문제를 하나씩 할당하여, 문제를 푸는 데 걸리는 시간의 총 합을 최소화하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 N(1 ≤ N ≤ 100)이 주어지고, 둘째 줄부터 N개의 줄에 걸쳐 각 학생이 N개의 문제를 푸는 데 걸리는 시간을 나타내는 N개의 정수가 순서대로 주어진다. 주어지는 모든 정수는 1,000을 넘지 않는다.
<출력값>
각 학생에게 서로 다른 문제를 하나씩 할당하여, 문제를 푸는 데 걸리는 시간의 총 합의 최솟값을 출력한다.

<문제 1259>
어떤 단어를 뒤에서부터 읽어도 똑같다면 그 단어를 팰린드롬이라고 한다. 'radar', 'sees'는 팰린드롬이다.
수도 팰린드롬으로 취급할 수 있다. 수의 숫자들을 뒤에서부터 읽어도 같다면 그 수는 팰린드롬수다. 121, 12421 등은 팰린드롬수다. 123, 1231은 뒤에서부터 읽으면 다르므로 팰린드롬수가 아니다. 또한 10도 팰린드롬수가 아닌데, 앞에 무의미한 0이 올 수 있다면 010이 되어 팰린드롬수로 취급할 수도 있지만, 특별히 이번 문제에서는 무의미한 0이 앞에 올 수 없다고 하자.
<입력값>
입력은 여러 개의 테스트 케이스로 이루어져 있으며, 각 줄마다 1 이상 99999 이하의 정수가 주어진다. 입력의 마지막 줄에는 0이 주어지며, 이 줄은 문제에 포함되지 않는다.
<출력값>
각 줄마다 주어진 수가 팰린드롬수면 'yes', 아니면 'no'를 출력한다.

<문제 1260>
그래프를 DFS로 탐색한 결과와 BFS로 탐색한 결과를 출력하는 프로그램을 작성하시오. 단, 방문할 수 있는 정점이 여러 개인 경우에는 정점 번호가 작은 것을 먼저 방문하고, 더 이상 방문할 수 있는 점이 없는 경우 종료한다. 정점 번호는 1번부터 N번까지이다.
<입력값>
첫째 줄에 정점의 개수 N(1 ≤ N ≤ 1,000), 간선의 개수 M(1 ≤ M ≤ 10,000), 탐색을 시작할 정점의 번호 V가 주어진다. 다음 M개의 줄에는 간선이 연결하는 두 정점의 번호가 주어진다. 어떤 두 정점 사이에 여러 개의 간선이 있을 수 있다. 입력으로 주어지는 간선은 양방향이다.
<출력값>
첫째 줄에 DFS를 수행한 결과를, 그 다음 줄에는 BFS를 수행한 결과를 출력한다. V부터 방문된 점을 순서대로 출력하면 된다.

<문제 1261>
알고스팟 운영진이 모두 미로에 갇혔다. 미로는 N*M 크기이며, 총 1*1크기의 방으로 이루어져 있다. 미로는 빈 방 또는 벽으로 이루어져 있고, 빈 방은 자유롭게 다닐 수 있지만, 벽은 부수지 않으면 이동할 수 없다.
알고스팟 운영진은 여러명이지만, 항상 모두 같은 방에 있어야 한다. 즉, 여러 명이 다른 방에 있을 수는 없다. 어떤 방에서 이동할 수 있는 방은 상하좌우로 인접한 빈 방이다. 즉, 현재 운영진이 (x, y)에 있을 때, 이동할 수 있는 방은 (x+1, y), (x, y+1), (x-1, y), (x, y-1) 이다. 단, 미로의 밖으로 이동 할 수는 없다.
벽은 평소에는 이동할 수 없지만, 알고스팟의 무기 AOJ를 이용해 벽을 부수어 버릴 수 있다. 벽을 부수면, 빈 방과 동일한 방으로 변한다.
만약 이 문제가 알고스팟에 있다면, 운영진들은 궁극의 무기 sudo를 이용해 벽을 한 번에 다 없애버릴 수 있지만, 안타깝게도 이 문제는 Baekjoon Online Judge에 수록되어 있기 때문에, sudo를 사용할 수 없다.
현재 (1, 1)에 있는 알고스팟 운영진이 (N, M)으로 이동하려면 벽을 최소 몇 개 부수어야 하는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 미로의 크기를 나타내는 가로 크기 M, 세로 크기 N (1 ≤ N, M ≤ 100)이 주어진다. 다음 N개의 줄에는 미로의 상태를 나타내는 숫자 0과 1이 주어진다. 0은 빈 방을 의미하고, 1은 벽을 의미한다.
(1, 1)과 (N, M)은 항상 뚫려있다.
<출력값>
첫째 줄에 알고스팟 운영진이 (N, M)으로 이동하기 위해 벽을 최소 몇 개 부수어야 하는지 출력한다.

<문제 1262>
알파벳 다이아몬드는 정수 길이의 마름모가 여러 개 누적되는 모양이다. 각각의 마름모는 하나의 알파벳 소문자로 그리며, a로 시작해서 z로 끝난다. (가운데에서부터) 그리고, z 이후에는 다시 a로 시작한다.

  알파벳 다이아몬드는 다음과 같이 생겼다.



a


N=1







.b.
            bab
            .b.


N=2








..c..
            .cbc.
            cbabc
            .cbc.
            ..c..


N=3








...d...
            ..dcd..
            .dcbcd.
            dcbabcd
            .dcbcd.
            ..dcd..
            ...d...


N=4








....e....
            ...ede...
            ..edcde..
            .edcbcde.
            edcbabcde
            .edcbcde.
            ..edcde..
            ...ede...
            ....e....


N=5








.....f.....
            ....fef....
            ...fedef...
            ..fedcdef..
            .fedcbcdef.
            fedcbabcdef
            .fedcbcdef.
            ..fedcdef..
            ...fedef...
            ....fef....
            .....f.....


N=6








......g......
            .....gfg.....
            ....gfefg....
            ...gfedefg...
            ..gfedcdefg..
            .gfedcbcdefg.
            gfedcbabcdefg
            .gfedcbcdefg.
            ..gfedcdefg..
            ...gfedefg...
            ....gfefg....
            .....gfg.....
            ......g......


N=7




  동호는 이런 알파벳 다이아몬드를 타일로 만들어서, 방 바닥을 타일로 모두 채웠다. 예를 들어, N=5인 아스키 다이아몬드를 세로17 * 가로46 크기의 방에 채운다면 다음과 같은 모양이 된다.

  동호는 좌표 쳬게를 도입해서 위에서부터 0행, 1행 차례대로 번호를 매기고 왼쪽에서부터 0열 1열과 같이 차례대로 번호를 매겼다.
  동호는 자신의 방의 어떤 부분 직사각형에 쓰여 있는 알파벳이 궁금해졌다. N이 주어지고, 동호가 알고 싶어하는 직사각형의 왼쪽 위 좌표 (R1, C1)와 오른쪽 아래 좌표 (R2, C2)가 주어질 때, 그 직사각형 모양을 출력하는 프로그램을 작성하시오. 동호의 방은 무한하다고 가정한다.
  모든 좌표는 (세로, 가로)이다.
<입력값>
첫째 줄에 N R1 C1 R2 C2가 주어진다. N은 20,000보다 작거나 같은 자연수이고, 
  0<=R1<=R2<=20,000 
  0<=C1<=C2<=20,000 
  0<=(R2-R1+1)*(C2-C1+1)<=40,000
  이다.
<출력값>
(R2-R1+1)줄에 (C2-C1+1)개의 문자를 출력한다.

<문제 1263>
진영이는 캠프 조교를 온 후 효율적으로 시간 관리를 해야 한다는 것을 깨달았다. 진영이는 하루에 해야 할 일이 총 N개가 있고 이 일들을 편하게 1번부터 N번까지 차례대로 번호를 붙였다.
진영이는 시간을 효율적으로 관리하기 위해, 할 일들에 대해 끝내야할 시간과 걸리는 시간을 적은 명단을 만들었다. 즉, 이 명단은 i번째 일은 일을 처리하는데 정확히 Ti 시간이 걸리고 Si 시 내에 이 일을 처리하여야 한다는 것을 담고 있다. 진영이는 0시부터 활동을 시작할 수 있고, 두 개 이상의 일을 같은 시간에 처리할 수 없다.
진영이가 바라는 점은 최대한 늦잠을 자는 것이다. 문제는 이러한 진영이를 도와 일들은 모두 마감시간 내에 처리할 수 있는 범위 내에서 최대한 늦게 일을 시작할 수 있는 시간이 몇 시인지 알아내는 것이다.
<입력값>
첫째 줄에 일의 수 N이 입력되고 다음 N(1≤N≤1,000)개의 줄에 대해 i+1번째 줄에는 i번째 일에 대한 Ti(1≤Ti≤1,000)와 Si(1≤Si≤1,000,000)가 입력된다.
<출력값>
진영이가 일을 모두 끝마칠 수 있는 가장 늦은 시간을 출력한다. 만약 0시부터 시작하여도 일을 끝마칠 수 없다면 -1을 출력한다.

<문제 1264>
영문 문장을 입력받아 모음의 개수를 세는 프로그램을 작성하시오. 모음은 'a', 'e', 'i', 'o', 'u'이며 대문자 또는 소문자이다.
<입력값>
입력은 여러 개의 테스트 케이스로 이루어져 있으며, 각 줄마다 영어 대소문자, ',', '.', '!', '?', 공백으로 이루어진 문장이 주어진다. 각 줄은 최대 255글자로 이루어져 있다.
입력의 끝에는 한 줄에 '#' 한 글자만이 주어진다.
<출력값>
각 줄마다 모음의 개수를 세서 출력한다.

<문제 1265>
1부터 N까지의 수를 임의로 배열한 순열은 총 N! = N×(N-1)×…×2×1 가지가 있다.
모든 1 ≤ i ≤ N에 대해서 |P[i] - i| ≤ K를 만족하는 순열 P의 개수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N, K가 순서대로 주어진다. N은 100보다 작거나 같은 자연수이고, K는 6보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 문제의 정답을 출력한다.

<문제 1266>
깨어나세요 용사여!
이 세계를 지키는 N명의 용사가 졸면서 빛의 속도로 (용사라서 가능함) 선분 위를 계속 왔다 갔다 한다.
용사는 다른 용사와 부딪힐 때 마다 깜짝 깜짝 깨어난다.
그 횟수가 많다면 김규완의 지구 지배 계획은 물거품이 될 수 있다.
용사들이 부딪히는 위치의 개수를 구하여라. 단, 용사 세 명이 한꺼번에 부딪히거나, 용사가 같은 선분 부분 경로를 공유하는 경우는 없다.
<입력값>
첫째 줄에 용사의 명수 n이 주어진다. (0 ≤ N ≤ 20,000) 둘째 줄에서 n+1줄 까지는 i번째 용사가 움직이는 선분의 양 끝점 (x1, y1)와 (x2, y2)가 주어진다. (-1,000,000 ≤ x1, y1, x2, y2 ≤ 1,000,000)
<출력값>
용사들이 부딪히는 지점의 개수를 구한다. 정답은 100,000보다 작거나 같은 자연수이다.

<문제 1267>
동호는 새악대로 T 통신사의 새 핸드폰 옴머나를 샀다. 새악대로 T 통신사는 동호에게 다음 두 가지 요금제 중 하나를 선택하라고 했다.

영식 요금제
민식 요금제

영식 요금제는 30초마다 10원씩 청구된다. 이 말은 만약 29초 또는 그 보다 적은 시간 통화를 했으면 10원이 청구된다. 만약 30초부터 59초 사이로 통화를 했으면 20원이 청구된다.
민식 요금제는 60초마다 15원씩 청구된다. 이 말은 만약 59초 또는 그 보다 적은 시간 통화를 했으면 15원이 청구된다. 만약 60초부터 119초 사이로 통화를 했으면 30원이 청구된다.
동호가 저번 달에 새악대로 T 통신사를 이용할 때 통화 시간 목록이 주어지면 어느 요금제를 사용 하는 것이 저렴한지 출력하는 프로그램을 작성하시오.
<입력값>
동호가 저번 달에 이용한 통화의 개수 N이 주어진다. N은 20보다 작거나 같은 자연수이다. 둘째 줄에 통화 시간 N개가 주어진다. 통화 시간은 10,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 싼 요금제의 이름을 출력한다. 그 후에 공백을 사이에 두고 요금이 몇 원 나오는지 출력한다. 만약 두 요금제의 요금이 모두 같으면 영식을 먼저 쓰고 민식을 그 다음에 쓴다.
영식은 Y로, 민식은 M으로 출력한다.

<문제 1268>
오민식 선생님은 올해 형택초등학교 6학년 1반 담임을 맡게 되었다. 오민식 선생님은 우선 임시로 반장을 정하고 학생들이 서로 친숙해진 후에 정식으로 선거를 통해 반장을 선출하려고 한다. 그는 자기반 학생 중에서 1학년부터 5학년까지 지내오면서 한번이라도 같은 반이었던 사람이 가장 많은 학생을 임시 반장으로 정하려 한다.
그래서 오민식 선생님은 각 학생들이 1학년부터 5학년까지 몇 반에 속했었는지를 나타내는 표를 만들었다. 예를 들어 학생 수가 5명일 때의 표를 살펴보자.



 
1학년
2학년
3학년
4학년
5학년




1번 학생
2
3
1
7
3


2번 학생
4
1
9
6
8


3번 학생
5
5
2
4
4


4번 학생
6
5
2
6
7


5번 학생
8
4
2
2
2



위 경우에 4번 학생을 보면 3번 학생과 2학년 때 같은 반이었고, 3번 학생 및 5번 학생과 3학년 때 같은 반이었으며, 2번 학생과는 4학년 때 같은 반이었음을 알 수 있다. 그러므로 이 학급에서 4번 학생과 한번이라도 같은 반이었던 사람은 2번 학생, 3번 학생과 5번 학생으로 모두 3명이다. 이 예에서 4번 학생이 전체 학생 중에서 같은 반이었던 학생 수가 제일 많으므로 임시 반장이 된다.
각 학생들이 1학년부터 5학년까지 속했던 반이 주어질 때, 임시 반장을 정하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 반의 학생 수를 나타내는 정수가 주어진다. 학생 수는 3 이상 1000 이하이다. 둘째 줄부터는 1번 학생부터 차례대로 각 줄마다 1학년부터 5학년까지 몇 반에 속했었는지를 나타내는 5개의 정수가 빈칸 하나를 사이에 두고 주어진다. 주어지는 정수는 모두 1 이상 9 이하의 정수이다.
<출력값>
첫 줄에 임시 반장으로 정해진 학생의 번호를 출력한다. 단, 임시 반장이 될 수 있는 학생이 여러 명인 경우에는 그 중 가장 작은 번호만 출력한다.

<문제 1269>
자연수를 원소로 갖는 공집합이 아닌 두 집합 A와 B가 있다. 이때, 두 집합의 대칭 차집합의 원소의 개수를 출력하는 프로그램을 작성하시오. 두 집합 A와 B가 있을 때, (A-B)와 (B-A)의 합집합을 A와 B의 대칭 차집합이라고 한다.
 예를 들어, A = { 1, 2, 4 } 이고, B = { 2, 3, 4, 5, 6 } 라고 할 때,  A-B = { 1 } 이고, B-A = { 3, 5, 6 } 이므로, 대칭 차집합의 원소의 개수는 1 + 3 = 4개이다.
<입력값>
첫째 줄에 집합 A의 원소의 개수와 집합 B의 원소의 개수가 빈 칸을 사이에 두고 주어진다. 둘째 줄에는 집합 A의 모든 원소가, 셋째 줄에는 집합 B의 모든 원소가 빈 칸을 사이에 두고 각각 주어진다. 각 집합의 원소의 개수는 200,000을 넘지 않으며, 모든 원소의 값은 100,000,000을 넘지 않는다.
<출력값>
첫째 줄에 대칭 차집합의 원소의 개수를 출력한다.

<문제 1270>
드디어 전쟁은 전면전이 시작되었고, 서로 땅을 따먹기 시작했다.
현재 여러 지역은 한창 전쟁이 벌어지고 있는 상황인데, 어느 지역은 거의 전쟁이 마무리 단계로 가고 있다.
하지만 당신은 군대를 보낼 때 적군을 혼란시키기 위해서 우리 나라의 군대라는걸 표시하지 않고, 군대의 번호로 표시했다.
어느 땅에서 한 번호의 군대의 병사가 절반을 초과한다면 그 땅은 그 번호의 군대의 지배하에 놓이게 된다.
이때, 각 땅들을 지배한 군대의 번호를 출력하여라. 만약, 아직 전쟁이 한창중인 땅이라면 “SYJKGW”을 쌍 따옴표 없이 출력한다.
<입력값>
첫째 줄에는 땅의 개수 n(n<=200)이 주어진다. 그리고 두 번째 줄에서 n+1번째 줄에는 제일 처음에 숫자 Ti(i번째 땅의 병사수, Ti<=100,000)와, Ti개의 숫자 (각각 병사의 군대 번호)가 주어진다. i번째 땅의 j번째 병사 번호 Nij가 주어진다. ( | Nij | <= 2^31 )
<출력값>
첫째 줄에는 각각의 땅의 상태를 순서대로 출력한다. 만약 땅이 지배가 되어있다면 그 지배한 병사의 번호를 출력하고, 아니라면 “SYJKGW”을 쌍 따옴표 없이 출력한다.

<문제 1271>
갑부 최백준 조교는 동전을 최소로 바꾸는데 성공했으나 김재홍 조교가 그 돈을 발견해서 최백준 조교에게 그 돈을 나누자고 따진다.
그 사실이 전 우주로 알려지자 우주에 있던 많은 생명체들이 자신들에게 돈을 분배해 달라고 당장 달려오기 시작했다.
프로토스 중앙 우주 정부의 정책인, ‘모든 지적 생명체는 동등하다’라는 규칙에 입각해서 돈을 똑같이 분배하고자 한다.
한 생명체에게 얼마씩 돈을 줄 수 있는가?
또, 생명체들에게 동일하게 분배한 후 남는 돈은 얼마인가?
<입력값>
첫째 줄에는 최백준 조교가 가진 돈 n과 돈을 받으러 온 생명체의 수 m이 주어진다. (1 ≤ m ≤ n ≤ 101000, m과 n은 10진수 정수)
<출력값>
첫째 줄에 생명체 하나에게 돌아가는 돈의 양을 출력한다. 그리고 두 번째 줄에는 1원씩 분배할 수 없는 남는 돈을 출력한다.

<문제 1272>
n(1<=n<=1,000)개의 정점을 가지고 있는 트리 T가 있다. T는 루트가 있는 트리이며, 각각의 노드에는 가중치 w(1<=w<=50,000)가 있다. 이때, 각 노드의 가중치는 부모 노드의 가중치보다 크다고 한다. T의 각 노드는 특별 노드와 일반 노드로 분류된다. 만약 어떤 노드가 특별 노드라면, 그 노드의 가중치는 원래의 가중치가 된다. 만약 어떤 노드 v가 특별 노드가 아니라면, 그 노드의 가중치는 그 노드의 가장 가까운 특별 노드인 부모 노드 u에 대해서 v의 가중치 - u의 가중치가 된다. 이해를 돕기 위해 아래의 그림을 보자

왼쪽 그림은 원래의 트리이다. 원 안의 숫자는 노드의 번호이며, 원 옆의 숫자는 그 노드의 가중치이다. 오른쪽 그림은 1번, 2번 노드를 특별 노드로 했을 때, 다시 가중치가 계산된 트리이다.
문제는, 원래의 트리 T가 주어졌을 때, 다시 계산된 가중치의 합의 최소가 되도록 하는 특별 노드들을 찾는 것이다. 위의 예에서는 왼쪽 트리의 가중치의 합이 35이고, 오른쪽 트리의 가중치의 합은 19이다. 루트는 항상 특별 노드라고 하자.
<입력값>
첫째 줄에는 노드의 수 n과 루트의 번호가 주어진다. 둘째 줄에는 1, 2, 3, , n번 노드의 가중치가 공백으로 구분되어 주어진다. 다음 n-1개의 줄에는 각 줄에 두 개의 정수로 주어진 트리 상에서 연결되어 있는 두 정점의 번호가 주어진다.
<출력값>
첫째 줄에 가중치의 합을 출력한다.

<문제 1273>
준수는 생일선물을 맞아 새로운 공기총을 샀다. 그리고 공기총의 성능을 시험해보기 위해 맥주캔을 쌓았다.
맥주캔은 총 검은색, 회색, 흰색으로 총 3가지 종류가 있다. 그리고 이를 N개의 열에 따라 쌓아올렸다. 쌓아올릴 때 순서는 아래에서부터 검은색, 회색, 흰색 순서이다. 한 열에 어느 색이 모두 없을 수는 있지만 색깔 순서를 위배하는 경우는 없다.
이렇게 맥주캔을 쌓아올린 뒤 준수는 높이를 정하고 공기총을 발사했다. 이 공기총은 성능이 뛰어나기에 한 높이를 쏘면 그 높이의 모든 캔은 모두 바깥으로 떨어지고 위쪽의 캔이 쓰러지지 않은 그대로 내려온다.
준수는 성능 시험을 위해 각 높이를 쏘았을 때 점수를 구하려고 한다. 점수 구하는 법은 검은색은 1점, 회색은 2점, 흰색은 5점이고, 바깥으로 떨어진 캔 점수의 총 합이다.

위 그림은 초기에 맥주캔을 쌓은 상태이다. 여기서 2번 높이를 총으로 쏜다면 아래와 같이 된다.

검은색이 3개, 회색이 2개, 흰색이 1개 쓰러졌기 때문에 12점을 얻게 된다. 이 상태에서 4번 높이에 총을 쏘면 아래와 같이 되고, 7점을 얻는다.

캔을 쌓은 정보와 쏘는 높이를 순서대로 알고있을 때, 각 높이를 쏠 때 얻어지는 점수를 구해보자.
<입력값>
첫째 줄에 열의 개수 N(1 ≤ N ≤ 300,000)이 주어진다. 두 번째 줄에는 각 열에 쌓인 검은색의 개수를 나타내는 N개의 정수가 주어진다. 세 번째 줄에는 각 열에 쌓인 회색의 개수를 나타내는 N개의 정수가 주어진다. 네 번째 줄에는 각 열에 쌓인 흰색의 개수를 나타내는 N개의 정수가 주어진다. 모든 수는 106이하인 음이 아닌 정수이다. 다음 줄에는 준수가 쏘는 횟수 M(1 ≤ M ≤ 300,000)이 주어진다. 다음 줄에는 차례대로 준수가 쏘는 높이를 나타내는 M개의 정수가 입력된다.
<출력값>
첫째 줄부터 M번째 줄까지 해당 높이를 쐈을 때 얻게되는 점수를 한 줄에 하나씩 출력한다.

<문제 1274>
동호는 커피숍의 마담이다. (마담이 무엇인지는 본인에게 물어보도록 하자.) 동호는 커피가 너무 안 팔린 나머지, 자신이 커피를 마셔버리기로 결심한다.
그런데 동호의 혀는 특이해서, 현재 마시는 커피보다 진한 커피를 같은 날 마셨었다면 현재 마시는 커피의 맛을 느끼지 못한다. 동호는 커피가 즐기고 싶은 나머지, 다음과 같은 꾀를 내게 된다.

두 항아리 A, B를 준비한다.
A와 B에 커피를 채운다.
A에서 커피 한잔을 퍼서 마시고, B에서 그 양만큼 A에 붓는다.
B에 A로 간 만큼의 물을 붓는다.
3, 4을 반복한다.

매일 이 과정을 반복하여 동호는 커피를 즐기고자 한다. 이때, 오늘 동호는 커피 맛을 몇 잔 느낄 수 있는가?
<입력값>
첫째 줄에 항아리 A의 농도 a와 항아리 B의 농도 b가 주어진다. (0 ≤ a ≤ b ≤ 100, a, b는 10진수 정수) 둘째 줄에는 항아리 A의 크기 Sa와 B의 크기 Sb, 그리고 한 잔의 컵의 크기 S가 mL단위로 주어진다. 1 ≤ Sa, Sb, S ≤ 1,000 (단 Sa,Sb,S,는 10진수 정수)
농도의 단위는 1L에 포함된 커피가루의 g수이다.
<출력값>
첫 번째 줄에 동호가 몇 잔의 커피 맛을 느낄 수 있는지 16진수로 출력한다. 16진수에서 A, B, C, D, E, F는 대문자로 출력해야 한다.
동호가 한 잔도 커피를 마실 수 없거나, 50잔을 넘어가는 경우엔 “gg”를 큰 따옴표 없이 출력한다.

<문제 1275>
모두 알다시피 동호는 커피숍의 마담이다. (마담이 무엇인지는 본인에게 물어보도록 하자.)
어느 날 커피숍의 손님 A씨가 동호에게 게임을 하자고 했다.
그 게임은 다음과 같은 규칙을 갖는다.
N개의 정수가 있으면, 동호는 다음과 같이 말한다. “3~7번째 수의 합은 무엇이죠?” 그러면 상대방은 “그 답은 000입니다. 그리고 8번째 수를 2로 고치도록 하죠” 그러면 동호는 “네 알겠습니다.”라고 한 뒤에 다시 상대방이 동호가 했던 것처럼 “8~9번째 수의 합은 무엇이죠?”라고 묻게된다. 이 것을 번갈아 가면서 반복하는 게임이다.
당신은 이 게임의 심판 역을 맡았다. 요컨대, 질문에 대한 답들을 미리 알아야 한다는 것이다.
당신의 머리가 출중하다면 10만개 가량 되는 정수와 10만턴 정도 되는 게임을 기억할 수 있을 것이다. 몇판 이 게임을 즐기던 동호는 많은 사람들이 이 게임을 하기를 바라게 되었고, 당신에게 심판 프로그램을 구현해달라고 요청했다.
<입력값>
첫째 줄에 수의 개수 N과 턴의 개수 Q가 주어진다.(1 ≤ N, Q ≤ 100,000) 둘째 줄에는 처음 배열에 들어가 있는 정수 N개가 주어진다. 세 번째 줄에서 Q+2번째 줄까지는 x y a b의 형식으로 x~y까지의 합을 구하여라, a번째 수를 b로 바꾸어라 라는 뜻의 데이터가 주어진다.
입력되는 모든 수는 -231보다 크거나 같고, 231-1보다 작거나 같은 정수이다.
<출력값>
한 턴마다 구한 합을 한 줄마다 한 개씩 출력한다.

<문제 1276>
2010년 노원구에 여러 층으로 이루어진 다리를 놓기로 결정했고 실제 디자인까지 완성하였다. 하지만 당연한 소리일지 모르지만 교각 없이 다리가 공중에 떠있을 수는 없기에 적절히 교각을 설치해야한다.
교각 설치 규칙은 다음과 같다. 다리의 양 끝을 다른 다리 위나 혹은 바닥에 설치해야하고 가능한한 교각의 길이는 최소로 하고 싶다. 단, 다리는 모두 수평으로 놓여있고 다리는 수직으로 세워야한다. 교각이 다른 교각과 교차하면 안된다.

예는 위 그림과 같다. 왼쪽 그림은 디자인된 다리를 표시한 것이고 오른쪽 그림은 교각을 놓은 다리를 표시한 것이다. 그리고 교각의 총 길이는 14가 되는 것을 알 수 있다.
문제는 다리가 주어졌을 때 총 교각의 길이 합을 구하는 것이다.
<입력값>
첫째 줄에 다리의 개수를 나타내는 정수 N(1≤N≤100)이 주어진다. 둘째 줄부터 N+1번째 줄까지 각 줄에 다리의 위치를 나타내는 세 정수 Y, X1, X2가 주어지는 이는 (X1, Y)부터 (X2, Y)까지 다리가 놓여있다는 의미이다. 모든 좌표는 10000을 넘지않는 자연수이다. 그리고 바닥의 Y좌표는 0이라고 가정한다. (X2 > X1+1)
<출력값>
첫째 줄에 교각 길이의 총 합을 출력한다.

<문제 1277>
엄청난 벼락을 맞아 많은 전선들이 끊어져 현재 전력 공급이 중단된 상태이다. 가장 심각한 문제는 1번 발전소에서 N번 발전소로 가는 중간의 전선이 끊어진 것이기에 일단 이 두 발전소를 다시 연결하는게 현재 해결해야할 첫 번째 과제이다.
발전소는 1번부터 N번까지 번호로 매겨져 2차원 격자 좌표 위에 있다. 그리고 몇몇 전선은 보존된 채 몇몇 발전소를 잇고 있다. 문제는 현재 전선과 발전소의 위치가 주어졌을 때 최소의 전선 길이를 추가로 사용하여 1번 발전소와 N번 발전소를 연결짓는 것이다. 물론 연결 짓는 중간에 다른 발전소를 거쳐갈 수 있다. 단, 안정성 문제로 어떠한 두 발전소 사이의 전선의 길이가 M을 초과할 수는 없다. 아래에 이에 대한 예를 그려놓았다.

         연결 전                          연결 후

3  . . . 7 9 . . . . .          3  . . . 7 9 . . . . .
                                          /
2  . . 5 6 . . . . . .          2  . . 5 6 . . . . . .
                                        /
1  2-3-4 . 8 . . . . .          1  2-3-4 . 8 . . . . .
   |                               |
0  1 . . . . . . . . .          0  1 . . . . . . . . .

   0 1 2 3 4 5 6 7 8 9             0 1 2 3 4 5 6 7 8 9
<입력값>
첫 줄에는 발전소의 수 N(1 ≤ N ≤ 1,000)과 현재 남아있는 전선의 수 W(1≤ W ≤ 10,000)가 주어진다. 두 번째 줄에는 제한 길이 M(0.0 < M < 200,000.0)가 주어진다. 다음 N개의 줄에는 1번 발전소부터 N번 발전소까지 각각의 발전소의 X좌표와 Y좌표(-100,000 ≤ xi,yi  ≤ 100,000)가 차례대로 주어진다. 다음 W개의 줄에 대해 각 줄에는 두 개의 정수가 입력되어지는데 이는 현재 남아있는 전선이 잇고 있는 두 발전소를 의미한다.
<출력값>
첫 줄에 1번 발전소와 N번 발전소를 잇는데 필요한 추가 전선 길이의 최솟값을 1000배하여 출력한다. (단, 1000배하고 난 후 나머지 소수는 반올림이 아닌 버림을 한다)

<문제 1278>
연극극단 "월드"는 2009년 새해를 맞아 새로운 연극을 기획 중이다. 이 연극에는 새로운 오디션을 통해 선발된 N명의 신인 배우들만이 출연할 예정이다. 극단을 운영하고 있는 김형택 사장의 지시에 따라, 당신은 아래의 조건을 만족시키는 참신한 연극을 만들어야 한다.

연극은 연속된 K개의 장면으로 구성되게 된다. 그리고 각 장면에는 적어도 한 명 이상의 배우가 무대에 서 있어야 한다.
하나의 장면이 계속되는 동안에는 무대에 서는 배우들이 바뀔 수 없다. 즉 장면 중간에 새로운 배우가 무대로 나오거나, 무대에 있던 배우가 무대 뒤로 들어가는 일은 없다.
무대가 혼란스러워지는 것을 방지하기 위해, 한 장면이 끝나고 다음 장면으로 넘어갈 때에는 단 한 명의 배우만 이동해야 한다. 즉 새로운 배우 하나가 무대로 나오거나, 무대에 있던 배우 하나가 무대 뒤로 들어가는 경우만이 허용된다.
연극이 시작되기 전과, 연극이 끝나고 난 후에는 무대가 비어 있어야 한다. 따라서 첫 번째 장면과 마지막 장면에서는 무대 위에 한 명의 배우만이 있어야 한다.
각 장면에서 무대에 서는 배우들의 구성은 장면마다 달라야 한다. 예를 들어 한 장면에서 배우 2, 배우 3, 배우 5가 출연했다면, 동일한 세 명의 배우가 무대에 서는 장면이 있어서는 안 된다.
신인 배우들에게 보다 많은 기회를 주기 위해, 연극은 가능한 많은 장면으로 구성되어 있어야 한다. 즉 K를 최대로 해야 한다.

예를 들어 N=2인 경우, 아래와 같이 연극을 구성하면 모든 조건을 만족시키게 된다.

연극이 시작되기 전:
	
(배우 1) 무대로


첫 번째 장면: (배우 1)
	
(배우 2) 무대로


두 번째 장면: (배우 1), (배우 2)
	
(배우 1) 뒤로


세 번째 장면: (배우 2)
	
(배우 2) 뒤로


연극이 끝나고 난 후: 

배우의 수가 주어지면, 극단의 매니저 김수현을 도와 연극을 구성하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 자연수 N이 주어진다. (2 ≤ N ≤ 17) 신인 배우들은 1부터 N까지 순서대로 번호가 매겨진다.
<출력값>
첫째 줄에 조건을 만족시키는 최대의 장면 수 K를 출력한다. 두 번째 줄에는 첫 번째 장면에 무대로 나올 배우의 번호를 출력한다. 세 번째 줄부터 K-1개 줄에 걸쳐 각 장면이 끝나고 다음 장면으로 넘어갈 때 무대로 나오거나 무대 뒤로 들어가는 배우의 번호를 출력한다. K+2번째 줄에는 마지막 장면에서 무대에 서게 되는 배우의 번호를 출력한다. 연극을 구성하는 방법이 둘 이상이면 아무 것이나 하나 출력한다.

<문제 1279>
진영이는 월드 카지노의 사장이다. 이번에 블랙잭의 신 최백준에게 거의 전 재산을 뺏기고 난 후에 어떻게 하면 다른 게임으로 돈을 되찾을까 고민하다가 새로운 주사위를 만들었다.
진영이가 만든 이 주사위는 6면이고, 각 면에는 양의 정수가 쓰여져 있고, 모두 다른 숫자들이다. 그리고, 주사위에 쓰여 있는 숫자의 평균은 M을 넘을 수 없다.
진영이가 원하는 주사위의 가능한 경우의 수를 구하는 프로그램을 작성하시오.
주사위 A와 B가 있을 때, B를 회전시켜서 A를 얻을 수 있다면, A와 B는 같은 주사위라고 한다. 정답이 매우 커질 수 있으니 1,000,000,007로 나눈 나머지를 출력한다.
<입력값>
첫째 줄에 M이 주어진다. M은 1보다 크거나 같고, 1,000,000보다 작거나 같은 자연수이다.
<출력값>
문제의 정답을 1,000,000,007로 나눈 나머지를 출력한다.

<문제 1280>
1번부터 N번까지 번호가 매겨져 있는 N개의 나무가 있다. i번 나무는 좌표 X[i]에 심어질 것이다.
동호는 나무를 1번 나무부터 차례대로 좌표 X[i]에 심으려고 한다. 1번 나무를 심는 비용은 없고, 각각의 나무를 심는데 드는 비용은 현재 심어져있는 모든 나무 까지 거리의 합이다. 만약 3번 나무를 심는다면, 1번 나무와의 거리 + 2번 나무와의 거리가 3번 나무를 심는데 드는 비용이다.
2번 나무부터 N번 나무까지를 심는 비용의 곱을 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 나무의 개수 N (2 ≤ N ≤ 200,000)이 주어진다. 둘째 줄부터 N개의 줄에 1번 나무의 좌표부터 차례대로 주어진다. 각각의 좌표는 200,000보다 작은 자연수 또는 0이다.
<출력값>
문제의 정답을 1,000,000,007로 나눈 나머지를 출력한다.

<문제 1281>
형택이는 보석상을 운영한다. 보석들은 NxM 형태로 배치되어 있는데, 각 행마다 보석들을 빛나게 해 줄 전등이 하나씩 총 N개 있고, 마찬가지로 각 열마다 전등이 하나씩 총 M개 있다.
각 보석은 일정 정도의 빛을 받아야 가장 아름다운 모양을 유지할 수 있는데, 이 정도는 각 보석마다 다르다. 예를 들어 아래는 2x3 형태로 배치된 보석들의 필요한 빛의 세기를 수치화해서 나타낸 것이다.



 
열전등1
열전등2
열전등3




행전등1
2
1
2


행전등2
3
1
1



(i, j)의 보석이 받는 빛의 세기는 행전등i의 빛의 세기와 열전등j의 빛의 세기의 합과 같다. 우리는 각 행전등과 열전등의 빛의 세기를 결정하려고 하는데, 적어도 주어진 빛의 세기만큼은 빛을 받도록 하고 싶다. 예를 들어 아래와 같이 빛의 세기를 결정했다고 하자.



 
2
0
1




1
3
1
2


1
3
1
2



각 칸에 써져 있는 숫자는 각 보석이 받게 되는 빛의 세기가 된다. 이렇게 되면 모든 보석들이 주어진 조건을 만족하게 되고, 또한 각 전등의 빛의 세기의 합인 2+0+1+1+1 = 5로 최소가 된다.
각 보석이 필요한 빛의 세기가 주어지면, 행전등과 열전등의 빛의 세기를 결정하여 조건을 만족하면서 전등들의 빛의 세기의 합을 최소로 하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 자연수 N, M이 주어진다. N, M은 256을 넘지 않는다. 이어서 둘째 줄부터 N개의 줄에 걸쳐 각 보석이 필요한 빛의 세기를 나타내는 자연수가 각 줄마다 M개씩 주어진다. 주어지는 자연수는 2,000,000을 넘지 않는다.
<출력값>
첫째 줄에 조건을 만족하는 빛의 세기의 총 합의 최솟값을 출력한다.

<문제 1282>
서로 다른 정수로 이루어진 수열 S가 주어진다. 다음과 같은 조건을 만족하는 수열은 S의 P-수열이라고 말한다.

S의 원소를 정확하게 하나씩 포함해야 한다.
임의의 인접한 두 원소 S1, S2가 있을 때, (S1-S2)는 P로 나누어 떨어지지 않아야 한다.

S의 P-수열 개수를 출력하는 프로그램을 작성하시오.
<입력값>
문제는 두 개의 테스트 케이스로 이루어져 있다. 각각의 테스트 케이스 첫째 줄에 S의 원소 개수 N과 P가 주어진다. N은 30보다 작거나 같은 자연수이다. P는 1,000보다 작거나 같은 자연수이다. 둘째 줄에 S의 원소 N개가 주어진다. 모든 원소는 서로 다르고, -1,000,000보다 크거나 같고 1,000,000보다 작거나 같다.
<출력값>
한 줄에 하나 씩 입력 받은 순서대로 S의 P-수열 개수를 1234567891로 나눈 나머지를 출력한다.

<문제 1283>
한글 프로그램의 메뉴에는 총 N개의 옵션이 있다. 각 옵션들은 한 개 또는 여러 개의 단어로 옵션의 기능을 설명하여 놓았다. 그리고 우리는 위에서부터 차례대로 각 옵션에 단축키를 의미하는 대표 알파벳을 지정하기로 하였다. 단축키를 지정하는 법은 아래의 순서를 따른다.

먼저 하나의 옵션에 대해 왼쪽에서부터 오른쪽 순서로 단어의 첫 글자가 이미 단축키로 지정되었는지 살펴본다. 만약 단축키로 아직 지정이 안 되어있다면 그 알파벳을 단축키로 지정한다.
만약 모든 단어의 첫 글자가 이미 지정이 되어있다면 왼쪽에서부터 차례대로 알파벳을 보면서 단축키로 지정 안 된 것이 있다면 단축키로 지정한다.
어떠한 것도 단축키로 지정할 수 없다면 그냥 놔두며 대소문자를 구분치 않는다.
위의 규칙을 첫 번째 옵션부터 N번째 옵션까지 차례대로 적용한다.
<입력값>
첫째 줄에 옵션의 개수 N(1 ≤ N ≤ 30)이 주어진다. 둘째 줄부터 N+1번째 줄까지 각 줄에 옵션을 나타내는 문자열이 입력되는데 하나의 옵션은 5개 이하의 단어로 표현되며, 각 단어 역시 10개 이하의 알파벳으로 표현된다. 단어는 공백 한 칸으로 구분되어져 있다.
<출력값>
N개의 줄에 각 옵션을 출력하는데 단축키로 지정된 알파벳은 좌우에 [] 괄호를 씌워서 표현한다.

<문제 1284>
재석이는 대문에 붙이는 (주소를 나타내는) 호수판 제작업체의 직원이다. 고객에게 전달할 호수판은 숫자와 숫자 사이 그리고 왼쪽 오른쪽으로 적당히 여백이 들어가 줘야하고 숫자마다 차지하는 간격이 조금씩 상이하다. 다행이도 규칙은 매우 간단하다. 

각 숫자 사이에는 1cm의 여백이 들어가야한다.
1은 2cm의 너비를 차지해야한다. 0은 4cm의 너비를 차지해야한다. 나머지 숫자는 모두 3cm의 너비를 차지한다.
호수판의 경계와 숫자 사이에는 1cm의 여백이 들어가야한다.


예를 들어 위의 120 같은 경우,  각 숫자 사이에 여백이 1cm 씩 2개 들어간다. 1은 2cm, 2는 3cm, 0은 4cm를 차지한다. 오른쪽, 왼쪽 경계에서 각각 여백이 1cm씩 차지한다. 따라서 총 2 + 2 + 3 + 4 + 1 + 1 = 13(cm) 가 된다.
재석이는 고객에게 전달해야할 호수판의 너비가 얼마나 되는지 궁금해졌다. 재석이를 도와주자!
<입력값>
호수판에 들어갈 숫자 N의 범위는 1 ≤ N ≤ 9999 이다.
입력은 마지막에 0이 들어오기 전까지 계속해서 줄 단위로 주어진다.
또한, 마지막의 0은 처리하지 않는다.
<출력값>
각 입력마다 얼마만큼 너비를 차지하는지 정수로 출력하면 된다.
각 출력은 줄바꿈으로 구분되어야한다.

<문제 1285>
N2개의 동전이 N행 N열을 이루어 탁자 위에 놓여 있다. 그 중 일부는 앞면(H)이 위를 향하도록 놓여 있고, 나머지는 뒷면(T)이 위를 향하도록 놓여 있다. <그림 1>은 N이 3일 때의 예이다.

이들 N2개의 동전에 대하여 임의의 한 행 또는 한 열에 놓인 N개의 동전을 모두 뒤집는 작업을 수행할 수 있다. 예를 들어 <그림 1>의 상태에서 첫 번째 열에 놓인 동전을 모두 뒤집으면 <그림 2>와 같이 되고, <그림 2>의 상태에서 첫 번째 행에 놓인 동전을 모두 뒤집으면 <그림 3>과 같이 된다.

<그림 3>의 상태에서 뒷면이 위를 향하여 놓인 동전의 개수는 두 개이다. <그림 1>의 상태에서 이와 같이 한 행 또는 한 열에 놓인 N개의 동전을 모두 뒤집는 작업을 계속 수행할 때 뒷면이 위를 향하도록 놓인 동전의 개수를 2개보다 작게 만들 수는 없다.
N2개의 동전들의 초기 상태가 주어질 때, 한 행 또는 한 열에 놓인 N개의 동전을 모두 뒤집는 작업들을 수행하여 뒷면이 위를 향하는 동전 개수를 최소로 하려 한다. 이때의 최소 개수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 20이하의 자연수 N이 주어진다. 둘째 줄부터 N줄에 걸쳐 N개씩 동전들의 초기 상태가 주어진다. 각 줄에는 한 행에 놓인 N개의 동전의 상태가 왼쪽부터 차례대로 주어지는데, 앞면이 위를 향하도록 놓인 경우 H, 뒷면이 위를 향하도록 놓인 경우 T로 표시되며 이들 사이에 공백은 없다.
<출력값>
첫째 줄에 한 행 또는 한 열에 놓인 N개의 동전을 모두 뒤집는 작업들을 수행하여 뒷면이 위를 향하여 놓일 수 있는 동전의 최소 개수를 출력한다.

<문제 1286>
오민식은 문자가 쓰여 있는 직사각형을 가지고 있다.
먼저, 오민식은 이 직사각형을 2*2형태로 복사한다.
그리고 나서, 복사한 직사각형의 모든 부분 직사각형을 쓸 것이다.
예를 들면, 원래 직사각형이 다음과 같다면

OK
복사한 직사각형은 다음과 같이 될 것이다.

OKOK
OKOK
이제 모든 부분 직사각형을 써 보면 다음과 같다.

>OKOK .... OKOK OKO. .... OKO. .KOK
OKOK OKOK .... OKO. OKO. .... .KOK

.... .KOK OK.. .... OK.. .KO. ....
.KOK .... OK.. OK.. .... .KO. .KO.

.KO. ..OK ..OK .... O... .... O...
.... ..OK .... ..OK O... O... ....

.K.. .... .K.. ..O. .... ..O. ...K
.K.. .K.. .... ..O. ..O. .... ...K

.... ...K
...K ....
영식이는 모든 부분 직사각형에서 각 알파벳이 총 몇 번씩 나오는지 궁금해졌다.
민식이가 가지고 있는 문자직사각형이 주어질 때, 모든 알파벳 문자가 총 몇 번 나오는지 구하는 프로그램을 작성하시오.
위의 예제에서는 K가 40번, O가 40번 나온다.
<입력값>
첫째 줄에 N과 M이 주어진다. N과 M은 모두 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 M개의 문자가 주어진다. 모든 문자는 알파벳 대문자이다.
<출력값>
첫째 줄부터 26번째 줄 까지 A가 몇 번 나오는지, B가 몇 번 나오는지부터 Z가 몇 번 나오는지 까지 출력한다.

<문제 1287>
당신은 사칙연산을 할 줄 아는가?
식이 주어지면, 그 식을 계산 하여서 사칙연산을 할 줄 안다는 것을 보여라.
<입력값>
첫째 줄에는 계산해야 되는 식이 주어진다. (띄어쓰기 없이, 길이는 1,000자를 넘지 않는다.)
식을 구성하는 문자는 다음과 같다.

+, -, /, *, (, ), 1, 2, 3, 4, 5, 6, 7, 8, 9, 0
+, -, /, *는 모두 이항연산자로만 사용할 수 있다. 즉, (+6+3)과 같은 식은 올바르지 않은 식이다.

또한, 계산 과정 중에 소수점이 등장하지 않는다.
<출력값>
계산 결과를 10진수로 출력한다.
만약, 식이 올바르지 않아 계산할 수 없는 경우라면 "ROCK"를 띄어쓰기 없이 출력한다.

<문제 1288>
전쟁은 점점 고조되어서 국지전의 형태를 띄게 되었다. 요컨데, 여러 부근 부근에서 자잘한 전투가 계속 일어나게 된다는 것이다.
당신은 지금 국지전이 일어나고 있는 전장을 바라보고 있다. 그런데, 만약 국지전의 이길 가능성이 낮다 라면 모든 군대를 일단 회군시키고자 한다.
이길 가능성을 계산하는 방법은 다음과 같다.
n개의 군대가 있으면, 어떤 지역은 그 곳과 가장 가까운 군대에 귀속된다. 귀속된 땅의 크기가 곧 이길 확률이 되는데, 당신은 이길 확률이 얼마나 될지 알아보고 싶기 때문에 자신의 군대가 지배한 땅의 면적을 알고 싶다.
한 부대는 하나의 점으로 표현된다. 예를 들자면, 이런 소리다.

이런 모습으로 군대가 배치되어 있다면 아래와  같이 땅을 각각의 군대가 지배하게 된다.

그러면 저 면적들을 구해 각각의 국가마다 더하면 답을 구할 수 있을 것이다.
다음은 예제의 그림이다.
<입력값>
첫째 줄에 군대의 수 N과(1<=N<=100) 현재 전장의 크기인 x가 주어진다.(1<=x<=10,000) (전장은 (0,0)~(x,x)이다.) 
  두 번째 줄에서 N+1번째 줄에는 각각 군사의 위치 (a,b)와 그 군대의 국가 c가 0또는 1로 주어진다. (c = 0이면 당신의 군대고, c = 1이면 적의 군대이다.)
  입력은 모두 정수이다.
<출력값>
당신 나라의 병사들이 지배한 땅의 면적과 적나라의 병사들이 지배한 땅의 면적을 한 줄에 “%.1lf” 의 형식으로 각각 출력한다.

<문제 1289>
트리는 N개의 정점과 N-1개의 간선으로 구성된 그래프이다. 트리의 성질 중 하나는 어느 두 정점 간에도 유일하게 하나의 경로가 존재한다는 것이다.
트리의 모든 간선에 음이 아닌 정수인 가중치가 배정되었다. ‘경로의 가중치’란 경로에 해당하는 간선의 곱으로 정의된다. 또한 ‘트리의 가중치’는 트리 상에 가능한 모든 경로에 대해 ‘경로의 가중치’의 합을 의미한다. 문제는 트리가 주어졌을 때 ‘트리의 가중치’를 구하는 것이다.
<입력값>
첫째 줄에 트리의 정점의 개수 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 N-1개의 줄에 대해 각 줄에는 세 개의 정수 A, B, W(1 ≤ A, B ≤ N, 0 ≤ W ≤ 1,000)가 입력되는데 이는 A점과 B점이 연결되어 있고 이 간선의 가중치는 W라는 것을 의미한다.
<출력값>
첫째 줄에 트리의 가중치를 1,000,000,007로 나눈 나머지를 출력한다.

<문제 1290>
스타크래프트를 좋아하는 현환이는 큰 고민에 빠졌다. 상대의 배럭을 공격할 것인지, 아니면 배력에서 마린을 뽑을 것인지.
가장 처음에 현환이는 마린을 N명 가지고 있다. 보통의 스타그래프트 게임과 다르게 이번 게임은 한 턴씩 진행된다. 매 라운드마다 각각의 마린이 할 수 있는 행동은 상대편의 마린을 죽이거나, 배럭을 공격해 HP를 1 감소시키는 것이다.
상대방은 가장 처음에 마린이 하나도 없다. 상대방 배럭의 HP는 B이고, 한 턴에 U명씩 마린을 뽑는다.
한 라운드는 다음과 같은 순서로 진행된다.

현환이는 각각의 마린이 무엇을 해야할지 결정해야 한다. 즉, 상대편의 마린을 공격해서 죽이거나, 배럭을 공격해서 HP를 1 감소시킬 것인지 정해야 한다. 각 마린은 서로 다른 행동을 취할 수 있다. 만약, 상대방 배럭의 HP가 0이 되면, 배럭은 파괴된다.
현환이의 턴이 끝나면, 상대방의 턴이다. 상대방이 가지고 있는 마린의 수를 K라고 했을 때, 상대방은 현환이의 마린 K명을 죽인다.
상대방의 배럭이 아직 파괴되지 않았다면, 상대방은 마린 U명을 새로 생산한다.

현환이는 상대방의 배럭을 파괴시키고, 상대방의 마린을 모두 죽이려고 한다. 이것이 가능하다면, 현환이가 최소 몇 턴 만에 가능한지를 구하고, 불가능하면 -1을 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N B U가 주어진다. 모든 수는 5000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 상대방의 배럭을 파괴시키고, 상대방의 마린을 모두 죽이려고 할 때, 필요한 최소 턴의 수를 출력한다. 불가능한 경우에는 -1을 출력한다.

<문제 1291>
중급반을 담당하는 배성경 조교는 이 세계에 있는 모든 자연수들을 분석했다.
고대 메갈루젼 문명에서는 모든 자연수들을 네가지 방법으로 분류하는 방법을 연구했었다고 전해진다. 그 문명에서 자연수를 구분하는 방법은 다음과 같다. (원래는 고대 히브리어와 비슷한 표음문자로 7진법으로 숫자를 표기했으나 한국어 10진수 표기법에 준수하여 해석하였다.)
1은 위대한 숫자이므로 숫자 1을 혼자 한가지로 분류한다. 세상이 창조될 때, 그 한 숫자만이 존재했고 그 숫자들이 모여 다른 숫자를 이루므로 1은 위대한 숫자라는 것을 그 누구도 부인할 수 없을 것이다. 그러므로 1은 “가장 위대한” 이라는 의미의 “최고[드엔디 하크드 즈르네즈(dndhkdz rnez)]”, 혹은 최상위의 계급인 “제 1계급[즈엘드디 흐크드 우크드(zlddhkdWkd)]”이라 칭한다.
2는 태초의 짝수로, 1이 두개 모여서 만들어진 숫자이다. 그런데 고대 메갈루지안 들은 이 세계가 3가지 원소로 이루어져 있다 라고 믿었기 때문에 숫자 3은 완벽한 태초의 수라고 생각했다. 그래서 숫자 2와 3을 “정말 빠른, 최초의”라는 의미인 “태초[트브드 느므크(tdbnmc)]” 혹은 시작의 의미를 갖는 “시작의 계급[큐-커프 펠린드롬(Qkffk)]”이라고 부른다.
숫자 4는 위대한 숫자 1과 시작의 숫자 3의 합으로 “완벽하다”라는 의미를 갖는 완벽한 숫자이다. 그와 동시에, 이 완벽한 숫자와 태초의 숫자들(2와 3)의 합으로 표현되는 숫자들, 즉 6, 7, 8, 9, 10 ... 들 역시 포함해서 “처음부터 완벽했던, 태초부터 존재했던”이라는 의미인 “완전[피-얼프 에크트(perfect)]” 혹은 “신이 태초부터 완성시켜져 있었던 계급[어비스 오엘 우테(absolute)]”이라고 부른다.
그리고 그 3가지 분류방법에 모두 들어가지 않는 숫자인 5는 애초에 금지된 숫자였으나, 다음과 같은 일화에 의해서 인류와 함께 만들어 졌다고 한다.
본 내용은 뛰어난 고고학자 김형택의 “최초로 창조된 인류의 문명, 메갈루젼 역사서” 중에사 발췌한 내용이다.
애초에 5라는 숫자는 존재하지 않았다. 이 세계의 “위대한 모든 만물의 창조자 베타-이아 크주엔”이 이 세계를 창조할 때 “태초의 숫자 두개의 합, 요컨대 최초 그 이전의 최초”라는 의미를 갖는 숫자 5라는 것이 존재하게 되면 세상의 균형이 흔들릴 위험이 있었기 때문이다. 그렇기 때문에 이 세계에 5라는 숫자는 “신에게 거역하는, 신을 거스르는” 의미를 갖는 숫자로, 이 세계에서 “위대한 모든 만물의 창조자 베타-이아 크주엔”에 의해 그 숫자 자체가 불문율로 금지되어 왔다.
하지만 “위대한 모든 만물의 창조자 베타-이아 크주엔”은 이 세계가 정적이라는 생각을 하게 되었다. 자신이 모든 것을 지배하고, 자신이 모든 것을 관리하고, 이 세계는 너무나 “자연스러운”법칙에 의해 당연하게 굴러가기만 하는 것이었다.
“위대한 모든 만물의 창조자 베타-이아 크주엔”의 창조관인 “완벽한 세계”라는 것은 “변수적 불완전함”을 포함하는 것 이라고 생각한 “위대한 모든 만물의 창조자 베타-이아 크주엔”은 자신의 “자기 의자(역주:점근적으로 신의 자아, 완벽한 정신이라는 의미를 갖는다. 인간의 자아와는 약간 다른 성격의 단어이다.)‘에 거역할 수 있는, 그런 생명체를 만들기로 한다.
그래서 우리 인류가 탄생하게 되었다. 우리는 개별 독립적인 “자기 인격(역주:신의 자아보다는 보잘것 없다는 의미를 갖기 때문에 실제 메갈루젼 언어에서는 신의 의지를 나타내는 단어보다 매우 짧게 나타난다.)” 요컨대, 개인적 혹은 집단적 자기 결정력을 가지고 있다. 신은 “신에 반하는 첫 번째 생명체”라는 증거로 여짓 것 금지되어 왔던 숫자 5, 즉 다섯 개의 손가락을 우리에게 주었다. 그 때문에 인간은 신과 떨어져서 새로운 ‘생각[티-하인-케이(T-hin-k)]’과 ‘이해력[유-엔디어스-탄디(understand)]’을 얻게 되었다.
신은 우리에게 양손을 주었고, 그로 인해 자연스럽게 10진수를 이용할 것이라고 생각했을 것이다. 하지만 우리는 만들어 질 때부터 신에 반하는 존재로 만들어진 터라, 비 자연스럽게도 (여기서 저자는 매우 흥분한 듯한 필체가 보였다!) 7진수를 사용하고 있는 것이다! 매우 놀랍지 않은가? 우리 인류는 신에게 선택받았다. “위대한 모든 만물의 창조자 베타-이아 크주엔”에게 선택받은 것이다! 그 증거가 우리 손에 있다. 5개의 손가락. 바로 우리의 손가락으로부터 숫자 5가 탄생하게 된 것이다!
그렇기 때문에 숫자 5는 “인류의, 반역의”라는 의미의 “인간[트크프카(tkfka)]”혹은 “반역의 계급[케이-우드-엣타(kudeta)]”이라고 부른다.
숫자 5는 우리에게 가장 친숙한 숫자이자, 신에게는 가장 먼 거리의 숫자이다.
그렇기 때문에 메갈루지안들은 “위대한 모든 만물의 창조자 베타-이아 크주엔”에게 제물을 바칠 때에는 꼭 5명의 제사장이 똑같은 물건을 5개씩 바친다고 한다.
이것이 가지는 의미를 제사장들과 그곳의 모든 메갈루지안들은 노래로 표현한다. 그 노래를 약간 어색하지만 한국말로 옮겨보면 다음과 같다.

달이 차오른다. 가자.
달이 차오른다. 가자.
달이 차오른다. 가자.
달이 차오른다. 가자.
세상이 맨 처음 만들어지기 시작했을 때부터
만들어진 숫자 5가
매번 세상이 만들어 질 때 마다
포기했던 그 다짐을
달이 차오른다. 가자.
달이 차오른다. 가자.
아~ 아~ 아~
달은 내일이면 다 차올라.
아~아~아~
그걸 놓치면 절대로 못 가
메갈루젼 역사서(김형택 저) 중 발췌

메갈루젼 문명의 메갈루지안들은 현대인들과 사고구조가 매우 달라서 해석하는데 애를 먹고 있다. 실제로 지금 저 가사를 읽어 보어도 이해가 안되는 부분이 많다고 할 수 있다.
나중에 더 많은 메갈루젼 문명의 유물들이 발굴된다면 더 정확한 해석을 하여 그들이 어떠한 삶을 살았는지 알 수 있을 것이다.
숫자 5를 중심으로 떠오른 메갈루젼 문명의 끝은 숫자 5로 종말을 맞이했다. 메갈루젼 문명 이후에 생긴 박성원숭이와 아이들 문명의 메갈루젼 종말록에 의하면 메갈루젼 문명의 종말은 다음과 같았다고 한다.

5개의 별이 떠올랐다.
그것은 신의 세계에서 내려온,
반역의 인류에게 신이 벌을 내린다.
그 신은 그들의 신이 아니었다.
“위대한 모든 만물의 창조자 베타-이아 크주엔”
그 신이 창조했던 5의 창조물의 잔해.
메갈루젼 문명의 이단아. 그 스스로 신이 되려고 했던 자.
“5의 반역자 키엠-제인-요엉”
메갈루젼 문명의 최초왕 “키엠-재-에타오엔“ 이 스스로 잉태하여 낳은 세 번째 아들인 ”키엠-큐-오메가엔“의 부인 “카엥-미인-시그마”엔가 결혼한지 ‘리-디옹-에타엔 별’이 40번 빛난 후(역주:7진수로 55에 해당한다.)에 태어난 6번째 딸 “키엠-지-틴 입실리노”와 그녀의 신랑 “오에타-마인-스이카” 가 결혼한 후 ‘리-디옹-에타엔 별’이 5번 빛난 후 낳은 첫 번째 아들이 바로 “5의 반역자 키엠-제인-요엉”이다.
그에 의해 5개의 별의 재앙이 이루어졌다.
달이 떠올랐다. 가자.
달이 떠올랐다. 가자.
지금 떠나지 않으면 떠날 수 없었다.

종말록의 뒷 부분을 풀어 써보자면 다음과 같은 내용으로 해독할 수 있음이 자명하다.
신이 분노했다고 생각한 메갈루지안 들은 제사를 지냈으나, “반역자 키엠-제인-요엉” 가 자신을 섬기지 않는 그들에게 재앙을 내렸다 라고 생각하지는 못했다.
그 재앙이 일어난 직후, “위대한 모든 만물의 창조자 베타-이아 크주엔”은 종적을 감추었다. 자신이 어떠한 실수를 했는지 깨달았기 때문인지, 아니면 다른 이유가 있는지 우둔한 우리로써는 깨닫기 어렵지만, 위대한- 태초의 창조자인 그가 잠적을 감추었다는 것만은 분명한 사실로써 남아있다는 것이다.
하지만 그것을 모르고 있던 메갈루지안들은 계속 메갈루젼 방식의 제사를 통해 “위대한 모든 만물의 창조자 베타-이아 크주엔”을 숭배했고, 결국 이에 격분한, 스스로 신이 된 “5의 반역자 키엠-제인-요엉”에 의해서 그 찬란했던 “개차 문화”가 매우 발달했던 문명인 메갈루젼 문명은 몰락하게 된다.
그 후, “5의 반역자 키엠-제인-요엉”을 신으로 섬기는 박성원숭이와 아이들 문명이 생겨나게 되었다. 훗날 이 문명도 역시 금방 몰락하지만, 이 문명의 의의는 “메갈루젼 문명의 종말록”을 제작했다는 데에 큰 의의를 갖는다.
위에서 말했듯이 메갈루젼 문명은 자연수에 힘이 있다고 믿었고, 신이 만든 자연스러운 숫자이자 동시에 인간을 구성하는 구성물이라고 생각했다. 요컨데, 자연수가 의미를 갖는다 라는 발상은 고대에서부터 시작되어 왔다라는 소리이다.
배성경 조교는 자연수를 하나 하나 분해해서 분석하던 도중에 메갈루젼 문명과 비슷한 착안에서 시작된 자연수 분류법을 생각해 내었다.
그 분류법을 이해하기 위해서는 먼저 월드 문명의 숫자 분류, 아니 의미 부여 체계에 대해서 알아야 할 필요성이 있다.
월드 문명은 우리 현대인들과 비슷한 사고구조를 가지고 있었고, 실제로 현재 전해져 내려오는 고서들(예를 들면, 월드와 함께하는 정보올림피아드)을 통해서 그 시대에 사용했던 언어인 크올이아엔(korean)를 쉽게 해석할 수 있었기 때문이다.
월드 문명은 수를 ‘분류’했다기 보다는, 수에게 의미를 부여했다. 자연수만 분류했던 메갈루젼 문명과는 다르게 월드 문명은 0을 포함해서 의미를 부여했다.
숫자 0은 모든 것이 없다, 라는 의미로, 월드 문명에서는 “문제를 풀다 소스의 한 글자를 잘못 쓰면 받는 점수”라는 의미를 갖는다.
숫자 1은 최초의 자연수로, “자연수의 최초”라는 의미로 “임페리얼”혹은 “위대한 수”이라고 부르며, 월드어의 <위대하다>라는 의미의 단어 “오메가-오엔-씨엠”과 같은 의미를 갖는다.
숫자 2는 최초의 짝수로 “사람 둘이 모이면 스타 1:1을 할 수 있다.”라는 의미로 “starcraft number”라고 불렀다.
숫자 3은 월드 문명의 초대왕 위대한자 임페리얼이 “나와”라고 말한 뒤에 주는 시간으로, “제한된, 규약인, 제한되어 있는”이라는 의미인 Most Valuable timelimit라고 불린다.
숫자 4는 4명이 모이면 닭싸움을 한다는 숫자로, 그래서 chicken number, 혹은 꼬꼬댁수 라고 불린다.
숫자 5는 월드 문명의 초대왕 위대한자 임페리얼을 표현할 때 마지막에 오는 글자로 “위대함을 마무리한다”라는 의미로 Last grand number라고 부른다.
월드 문명의 대다수의 사람들은 미개한 문명수준과 매우 낮은 지능을 가지고 있어서 사칙연산조차 못하기 때문에 아주 극소수만 6이상에 의미를 부여했다고 알려져 있다.
고로 6이상의 의미들은 중요치 않으므로 생략하도록 하겠다. (극소수에게만 중요하다.)
배성경 조교의 숫자 분류 체계는 다음과 같다. 배성경 조교는 이면수와 임현수라는 숫자를 분류하는 방법을 생각해 내었다.
어떤 숫자가 “이면수”이기 위해서는 다음과 같은 조건을 만족해야 한다. 메갈루젼 문명의 자연수 분류방식에 있던 “신이 태초부터 완성시켜져 있었던 계급[어비스 오엘 우테(absolute)]”에 속해 있어야 하고, 각 자릿수의 합이 홀수여야 한다.
또한 어떤 숫자가 "임현수“이기 위해서는 그 숫자가 자체가 월드 문명의 chicken number 혹은 starcraft number이거나 합성수이면서 소인수 분해를 했을 때 소인수의 종류의 개수가 짝수개 이어야 한다.
조교 배성경은 자신의 이름을 역사에 남기기 위해서 이면수도, 임현수도 아닌 숫자를 “성경수”라고 정의했다.
어떤 숫자 N이 주어지면, 그 숫자를 분석한 결과를 출력하도록 한다.
만약 그 숫자가 이면수라면 “1”라고 출력하고, 그 숫자가 임현수라면 “2”라고 출력한다. 주어진 수가 이면수도 임현수도 아닐 수 있는데 그럴 경우에는 배성경 조교가 정의한 대로 “3”를 출력한다. 혹은, 그 숫자가 이면수이면서 임현수이면 “4”를 출력하도록 한다.
<입력값>
첫째 줄에는 문제에서 주어진 방식으로 분석해야 되는 자연수 N(1 ≤ N ≤ 2,700)이 주어진다.
<출력값>
분석 결과를 첫 번째 줄에 출력한다.

<문제 1292>
동호는 내년에 초등학교를 입학한다. 그래서 동호 어머니는 수학 선행 학습을 위해 쉽게 푸는 문제를 동호에게 주었다.
이 문제는 다음과 같다. 1을 한 번, 2를 두 번, 3을 세 번, 이런 식으로 1 2 2 3 3 3 4 4 4 4 5 .. 이러한 수열을 만들고 어느 일정한 구간을 주면 그 구간의 합을 구하는 것이다.
하지만 동호는 현재 더 어려운 문제를 푸느라 바쁘기에 우리가 동호를 도와주자.
<입력값>
첫째 줄에 구간의 시작과 끝을 나타내는 정수 A, B(1 ≤ A ≤ B ≤ 1,000)가 주어진다. 즉, 수열에서 A번째 숫자부터 B번째 숫자까지 합을 구하면 된다.
<출력값>
첫 줄에 구간에 속하는 숫자의 합을 출력한다.

<문제 1293>
어떤 지역에서는 N 종류의 생물이 모여서 살고 있다. 이 중 두 종류의 생물 사이에 잡아먹고 먹히는 관계가 성립할 수 있는데, 잡아먹는 쪽을 포식자라고 하며 먹히는 쪽을 피식자라 한다. 이러한 관계가 여러 생물들 사이에서 이어지면 사슬과 같은 천적 관계를 형성하게 된다. 이것이 바로 먹이연쇄이다.

먹이연쇄는 "먹이"의 형태로 태양에너지가 생물의 몸속으로 차례차례 전송되어 가는 과정이다. 다른 생물이 아닌 태양에너지를 에너지원으로 삼아 무기물에서 유기물을 합성하는 생물을 생산자라고 하고, 다른 생물을 먹어 에너지원으로 삼는 생물을 소비자라고 한다.
이 지역에서는 N종류의 생물이 안정적인 먹이 사슬을 이루며 평화롭게 살고 있었지만, 최근 생산자들이 중금속에 오염되면서 생태계가 위험에 처했다. 이 생태계의 최종 소비자는 사람이기 때문에, 사람들은 생존에 위협을 느끼기 시작했고, 과연 이 오염된 생태계에서 사람이 생존해 갈 수 있는 지 궁금해 하기 시작했다.
사람들은 편의를 위해 생물들에 1~N-1까지의 번호를 붙였고, 사람은 N번 생물이다. 이 생태계에 속한 생물들은 생존을 위해 다음과 같은 조건을 따른다.
- i번 생물이 살아가기 위해선 다른 생물로부터 C[i]kcal이상의 칼로리를 섭취해야 한다. 생산자는 태양에너지로부터 에너지를 얻으므로 C[i]가 0이다.
- i번 생물에 H[i]ppm을 초과하여 중금속이 쌓이면 i번 생물은 멸종하고, 다른 생물들은 i번 생물을 먹을 수 없다.
- 먹이를 먹을 때는 필요한 칼로리를 섭취하면서도 축적되는 중금속은 가장 적어지도록 먹이를 먹는다.
i번 생물이 다른 생물에게 먹혔을 때는 일정하게 E[i]kcal의 칼로리를 낸다. 다른 생물로부터 칼로리를 섭취했다고 i번 생물의 칼로리가 높아지지는 않는다고 하자.
  그렇지만 중금속은 생산자로부터 소비자로 농축되어 가며, 포식자가 중금속을 오염된 피식자를 먹으면 피식자에 쌓여 있던 중금속은 배출되지 않고 그대로 포식자에게 쌓여 간다.
  입력에 생물의 크기가 주어지지는 않지만, 모든 생물들은 자기보다 크기가 작은 생물들만을 먹을 수 있다고 가정한다. 즉, 두 생물이 서로 천적관계에 있을 수도 없고, i번 생물이 j번 생물을 먹고 j번 생물이 k번 생물을 먹을 수 있는데, k번 생물이 다시 i번 생물을 먹는다거나 하는 일은 존재할 수 없다.
  각 종류의 생물들은 포식자가 충분히 먹고도 멸종되지 않을 정도로 충분히 많고, 포식자는 한 종류의 피식자를 여러 마리 섭취하여 필요한 칼로리를 얻을 수도 있다고 하자.
현재는 중금속 오염이 생산자에게만 진행되었고, 멸종되지 않은 생산자들은 자신이 버틸 수 있는 중금속의 최대량, 즉 H[i]만큼 중금속이 농축된 상태이다. 사람들은 이 상태로 생물농축이 계속해서 진행되었을 때 인간이 과연 멸종할 지, 멸종하지 않는다면 중금속이 체내에 얼마나 농축될지를 알고 싶다.
<입력값>
첫째 줄에 생물 종의 수 N이 주어진다. (1≤N≤1,000) 이어서 N개의 줄에 걸쳐 세 자연수 C[i], H[i], E[i]가 주어지는 데, C[i](1≤C[i]≤10,000)는 i번 생물이 섭취해야 할 칼로리를, H[i](1≤H[i]≤10,000)는 i번 생물이 섭취할 수 있는 최대 중금속 양을, E[i]는 다른 생물이 i번 생물을 먹었을 때 얻을 수 있는 칼로리를 가리킨다.
다음 줄에는 천적관계의 수 M이 주어진다. (1≤M≤10,000) 이어서 M개의 줄에 걸쳐 각 줄에 N 이하의 서로 다른 두 자연수가 "a b"의 형태로 주어지는데, 이는 a번 생물이 b번 생물에게 먹힌다는 것을 의미한다.
<출력값>
첫째 줄에 N번 생물, 즉 사람이 생존할 수 있는지를 yes나 no로 출력한다. 생존할 수 있다면 yes를, 생존할 수 없다면 no를 출력하면 된다.
만약 생존할 수 있다면 두 번째 줄에 중금속이 최소 얼마나 오염되어 있을 지를 출력한다.

<문제 1294>
오민식은 단어 N개를 이용해서 문자열 W를 만들려고 한다.
일단 오민식은 각각의 문자열을 적절히 쪼갠다. 그 다음에 쪼갠 문자열을 모두 이어붙여서 W를 만든다. 단, 한 문자열을 쪼개서 나온 조각의 순서는 유지해야 한다.
예를 들어, 오민식이 {YOUNGSIK, DONGHO, BAEKJOON} 총 3개를 가지고 있었다면, 오민식은 자기 마음대로 {YOUNG, SIK, DO, NG, HO, BA, E, K, JOO, N}과 같이 쪼갠 다음, 아래와 같이 YOUNGDOBAESIKNGKJOOHON을 만들 수 있다.

YOUNG     SIK
     DO      NG    HO
       BAE     KJOO  N
----------------------
YOUNGDOBAESIKNGKJOOHON

오민식이 만들 수 있는 문자열 중에 사전순으로 가장 앞서는 것을 출력하시오.
<입력값>
첫째 줄에 단어의 개수 N이 주어진다. N은 최대 20이다. 둘째 줄부터 N개의 줄에 단어가 주어진다. 단어는 최대 1000글자이고, 공백은 없이 알파벳 대문자로만 구성되어 있다.
<출력값>
문제의 오민식이 만들 수 있는 문자열 중에 사전순으로 가장 앞서는 것을 출력한다.

<문제 1295>
건축회사 “네모”는 사각형을 주제로 건물을 설계하는 회사로 유명하다. 현재 “네모”에서 설계하고 있는 건물의 각 층의 외벽은 직사각형으로 만들어져 있으며, 각 층의 내부 사무실은 여러 개의 직사각형을 외벽의 내부에 그렸을 때 만들어지는 도형으로 설계하고 있다.
예를 들어, 아래 <그림 1>은 이런 방법으로 설계된 건물의 어떤 층의 평면도를 나타낸다. 이 평면도의 가장 바깥 사각형은 그 층의 외벽을 나타내는 사각형이며, 그 내부는 그림에서와 같이 네 개의 사각형에 의하여 7개의 사무실로 나누어져 있다.

<그림 1>
각 건물 층의 외벽을 나타내는 사각형과 그 내부 사무실을 설계할 여러 개의 사각형이 주어졌을 때, 이 평면도에서 만들어지는 사무실의 개수와 가장 큰 사무실의 크기를 계산하는 프로그램을 작성하시오. 단, 모든 사각형의 변은 좌표축에 평행하다고 가정한다.
예를 들어, 위 <그림 1>과 같은 설계도에 의하여 만들어진 사무실 중에서 가장 큰 사무실의 공간은 <그림 2>에서 빗금으로 표시된 공간이다.

<그림 2>
<입력값>
첫째 줄에 사각형의 개수 N (2≤N≤50,000)이 주어진다. 둘째 줄부터 한 줄에 하나씩 사각형의 왼쪽 위 꼭짓점의 좌표와 오른쪽 아래 꼭짓점의 좌표를 나타내는 네 개의 정수 x1, y1, x2, y2(0≤x1<x2≤1,000,000,000, 0≤y2<y1≤1,000,000,000)가 주어진다. 사각형의 왼쪽 위 꼭짓점의 좌표는 (x1, y1)이며, 오른쪽 아래 꼭짓점의 좌표는 (x2, y2)이다. 입력에서 주어지는 사각형 중의 하나는 다른 모든 사각형을 포함하는 외벽을 나타내는 사각형이다. 모든 사각형의 꼭짓점의 x-좌표는 서로 다르며, 또한 y-좌표도 서로 다르다.
<출력값>
첫째 줄에 입력에서 주어진 사각형에 의하여 만들어지는 사무실의 개수와 가장 큰 사무실의 크기를 나타내는 두 개의 정수를 한 개의 빈칸을 사이에 두고 출력한다. 사무실의 개수는 1,000,000개 이하이며 가장 큰 사무실의 크기는 4,200,000,000 이하이다.

<문제 1296>
오민식은 자기가 좋아하는 여자 N명 중에 한 명과 함께 데이트하러 나가고 싶어한다.
하지만 N명 모두를 사랑하는 오민식에게는 한 명을 선택하고 나머지 여자를 버리는 것은 슬픈 결정이기 때문에 누구를 선택해야 할지 고민에 빠졌다.
마침 오민식은 사랑계산기를 얻었다. 사랑계산기는 두 사람의 이름을 이용해서 두 사람이 성공할 확률을 계산해 준다. 사랑계산기는 다음과 같이 작동한다.

L = 두 사람 이름에서 등장하는 L의 개수
O = 두 사람 이름에서 등장하는 O의 개수
V = 두 사람 이름에서 등장하는 V의 개수
E = 두 사람 이름에서 등장하는 E의 개수

위의 개수를 모두 계산 한 후에 확률 계산은 다음과 같이 한다.
((L+O)*(L+V)*(L+E)*(O+V)*(O+E)*(V+E)) mod 100
오민식의 영어 이름과 나머지 여자들의 이름이 주어졌을 때, 오민식과 성공할 확률이 가장 높은 여자의 이름을 출력하는 프로그램을 작성하시오. 여러명일 때에는 알파벳으로 가장 앞서는 이름을 출력하면 된다.
<입력값>
첫째 줄에 오민식의 영어 이름이 주어진다. 둘째 줄에는 좋아하는 여자가 몇 명인지 N이 주어지고, 셋째 줄부터 N개의 줄에 여자의 이름이 하나 씩 주어진다. N은 50보다 작거나 같고, 모든 이름은 알파벳 대문자로만 구성되어 있고 모두 길어야 20글자이다.
<출력값>
오민식이 선택한 여자의 이름을 출력한다.

<문제 1297>
김탑은 TV를 사러 인터넷 쇼핑몰에 들어갔다. 쇼핑을 하던 중에, TV의 크기는 그 TV의 대각선의 길이로 나타낸 다는 것을 알았다. 하지만, 김탑은 대각선의 길이가 같다고 해도, 실제 TV의 크기는 다를 수도 있다는 사실에 직접 TV를 보러갈걸 왜 인터넷 쇼핑을 대각선의 길이만 보고있는지 후회하고 있었다.
인터넷 쇼핑몰 관리자에게 이메일을 보내서 실제 높이와 실제 너비를 보내달라고 했지만, 관리자는 실제 높이와 실제 너비를 보내지 않고 그것의 비율을 보내왔다.
TV의 대각선 길이와, 높이 너비의 비율이 주어졌을 때, 실제 높이와 너비의 길이를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 TV의 대각선 길이, TV의 높이 비율, TV의 너비 비율이 공백 한 칸을 사이에 두고 주어진다. 대각선 길이는 5보다 크거나 같고, 1,000보다 작거나 같은 자연수, 높이 비율은 1보다 크거나 같고, 99보다 작거나 같은 자연수 너비 비율은 2보다 크거나 같고, 100보다 작거나 같은 자연수이다. 너비 비율은 항상 높이 비율보다 크다.
<출력값>
첫째 줄에 TV의 높이와 TV의 너비를 공백 한 칸을 이용해서 구분지은 후 출력한다. 만약, 실제 TV의 높이나 너비가 소수점이 나올 경우에는 그 수보다 작으면서 가장 큰 정수로 출력한다. (예) 1.7 -> 1

<문제 1298>
어느 날 모든 학생들은 한 명이 한개의 노트북을 가지고 공부하던 도중, 자리를 바꾸다가 그만 노트북이 뒤섞이고 말았다. 대다수의 학생들은 자신의 노트북을 잘 알고 있어서 자신의 노트북을 받을 수 있었지만, 애석하게도 N명의 학생들이 정확히 자신의 노트북이 어떤것인지 알지 못했다. 왜냐하면 그들은 노트북을 구입한게 바로 어제였기 때문이다.
어차피 새것인 노트북, 바뀐들 어떠하랴.
그들에게 자신의 노트북이라고 생각되는 노트북들을 얘기해 보라고 했다.
이번에는 정말 신기하게도 그들 각각이 노트북을 여러개 선택한 것이었다! “이것 아니면 이것 아니면 이것 아니면 이것 일거 같아요”라카더라.
우리의 목적은 이들의 요구를 가장 많이 만족시키는 것이다.
요컨대, 자신이 자신의 것 같다라고 얘기한 노트북을 갖는 사람을 최대화 하라는 소리다.
<입력값>
첫째 줄에는 노트북이 섞인 날 어제 노트북을 구입한 사람의 수 N(1 ≤ N ≤ 100)과 노트북 예상의 개수 M(0 ≤ M ≤ 5,000) 주어진다.
둘쨋줄에서 M+1번째 줄 까지는 각각 한 줄마다 a b가 주어지는데, 이는 a번 사람이 b번 노트북을 자신의 것이라고 생각한다는 의미를 갖는다.
노트북과 사람의 번호는 1보다 크거나 같고, N보다 작거나 같다. 두 사람 또는 두 노트북이 같은 번호를 갖는 경우는 없다.
<출력값>
최대로 만족될 수 있는 사람 수를 출력한다.

<문제 1299>
전쟁은 막바지에 치달았다.
당신은 적국의 수도 앞까지 왔다. 전쟁은 거의 승리했다라고 생각했고, 총공격 명령을 내릴 시기를 잡고있던 도중 충격적인 소식을 알게된다.
바로 이렇게 간단히 수도까지 올 수 있었던 것은 승리하고 있던게 아니라, 적의 유인책이었던 것이다.
그 사실을 알고 당신은 군대를 재정비하기 위해서 잠시 군대를 돌려 자신의 국가로 돌아가기로 했다.
그런데 적국의 군대가 만약 군대가 돌아가는 길목에 있다 라면 매우 곤란해 질 수 있다.
적은 분명 지리를 매우 잘 알고 있으므로 (왜냐하면 이곳은 적국이니까.) 분명 우리가 최단거리로 우리 국가로 돌아가는 길목을 막을 것이 분명했다.
하지만 우리는 적의 군대를 피해서 가야만 한다.
도시와 도시를 잇는 도로들이 주어지면, 도로에 매복하는 적을 만나지 않으면서 적국의 수도인 1번 도시로부터 국경도시인 N번 도시까지 가는 경로들 중에 가장 짧은 경로의 길이를 출력하여라.
단, 적은 무조건 우리 군대가 최단경로로 올 것이라 생각하고 어떠한 최단거리로 가도 무조건 막을 수 있는 도로에만 매복할 것이다.
적이 막을 가능성이 있는 모든 도로를 피해서 간다고 할 때, 가장 짧은 경로의 길이를 출력하라.
<입력값>
첫째 줄에는 도시의 수 N(1<=N<=1,000)과 도시를 잇는 도로의 수 M(0<=M<=5,000) 주어진다. 둘째 줄에서 M+1번째 줄 까지는 각각 한 줄마다 a b c가 주어지는데, 이는 a번 도시와 b번 도시를 잇는 도로가 존재하며, 걸리는 시간이 c라는 소리다.
<출력값>
도로에 매복하는 적을 만나지 않으면서 적국의 수도인 1번 도시로부터 국경도시인 N번 도시까지 가는 경로들 중에 가장 짧은 경로의 길이를 출력하여라.

<문제 1300>
세준이는 크기가 N×N인 배열 A를 만들었다. 배열에 들어있는 수 A[i][j] = i×j 이다. 이 수를 일차원 배열 B에 넣으면 B의 크기는 N×N이 된다. B를 오름차순 정렬했을 때, B[k]를 구해보자.
배열 A와 B의 인덱스는 1부터 시작한다.
<입력값>
첫째 줄에 배열의 크기 N이 주어진다. N은 105보다 작거나 같은 자연수이다. 둘째 줄에 k가 주어진다. k는 min(109, N2)보다 작거나 같은 자연수이다.
<출력값>
B[k]를 출력한다.

<문제 1301>
다솜이는 자신의 목걸이를 구슬을 이용해서 만들려고 한다. 다솜이는 구슬을 N종류 가지고 있다. 서로 다른 종류의 구슬은 색이 다르다. 다솜이는 구슬을 실에 껴서 목걸이를 만들려고 한다. 무작정 껴도 상관없겠지만, 워낙 미적감각이 뛰어난 다솜이는 임의의 연속된 3개의 구슬의 색을 모두 다르게 하려고 한다.
예를 들어, 다솜이가 1번 구슬을 2개, 2번 구슬을 1개, 3번 구슬을 1개 가지고 있다고 하자. 1번 구슬이 초록, 2번 구슬이 파랑, 3번 구슬이 빨강이라고 하면, 연속된 3개의 구슬이 같은 색이면 안되기 때문에, 초록구슬을 반드시 목걸이의 끝에 있어야 한다. 따라서 다솜이가 목걸이를 만들 수 있는 방법의 경우의 수는 초록-빨강-파랑-초록 또는 초록-파랑-빨강-초록 총 2가지이다.
반드시 가지고 있는 모든 구슬을 이용해야 하며, 목걸이는 원형이 아니라 직선이다. 다시말하면, 처음 구슬과 마지막 구슬은 이어져있는 것이 아니다.
다솜이가 목걸이를 만들 수 있는 방법의 경우의 수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 다솜이가 가지고 있는 구슬의 종류 N이 주어진다. N은 3보다 크거나 같고, 5보다 작거나 같다. 둘째 줄부터 N개의 줄에 각각의 구슬이 총 몇 개 있는 지주어진다. 첫째 줄에는 1번 구슬, 둘째 줄에는 2번 구슬, 이런 형식이다. 각각의 구슬은 10개보다 작거나 같은 자연수이다. 그리고, 구슬의 총 개수의 합은 35를 넘지 않는다.
<출력값>
첫째 줄에 다솜이가 목걸이를 만들 수 있는 방법의 경우의 수를 출력한다.

<문제 1302>
김형택은 탑문고의 직원이다. 김형택은 계산대에서 계산을 하는 직원이다. 김형택은 그날 근무가 끝난 후에, 오늘 판매한 책의 제목을 보면서 가장 많이 팔린 책의 제목을 칠판에 써놓는 일도 같이 하고 있다.
오늘 하루 동안 팔린 책의 제목이 입력으로 들어왔을 때, 가장 많이 팔린 책의 제목을 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 오늘 하루 동안 팔린 책의 개수 N이 주어진다. 이 값은 1,000보다 작거나 같은 자연수이다. 둘째부터 N개의 줄에 책의 제목이 입력으로 들어온다. 책의 제목의 길이는 50보다 작거나 같고, 알파벳 소문자로만 이루어져 있다.
<출력값>
첫째 줄에 가장 많이 팔린 책의 제목을 출력한다. 만약 가장 많이 팔린 책이 여러 개일 경우에는 사전 순으로 가장 앞서는 제목을 출력한다.

<문제 1303>
전쟁은 어느덧 전면전이 시작되었다. 결국 전투는 난전이 되었고, 우리 병사와 적국 병사가 섞여 싸우게 되었다.
그러나 당신의 병사들은 하얀 옷을 입고, 적국의 병사들은 파란옷을 입었기 때문에 서로가 적인지 아군인지는 구분할 수 있다.
문제는, 같은 팀의 병사들은 모이면 모일수록 강해진다는 사실이다.
N명이 뭉쳐있을 때는 N^2의 위력을 낼 수 있다. 과연 지금 난전의 상황에서는 누가 승리할 것인가? 단, 같은 팀의 병사들이 대각선으로만 인접한 경우는 뭉쳐 있다고 보지 않는다.
<입력값>
첫째 줄에는 전쟁터의 가로 크기 N, 세로 크기 M(1 ≤ N, M ≤ 100)이 주어진다. 그 다음 두 번째 줄에서 M+1번째 줄에는 각각 (X, Y)에 있는 병사들의 옷색이 띄어쓰기 없이 주어진다. 모든 자리에는 병사가 한 명 있다. (B는 파랑, W는 흰색이다.)
<출력값>
첫 번째 줄에 당신의 병사의 위력의 합과 적국의 병사의 위력의 합을 출력한다.

<문제 1304>
김형택이 통치하는 빅뱅국은 N개의 도시로 이루어져 있다. 김형택은 초창기에는 탑시, 지용시, 지드래곤시, 승리시, 대성시, 태양시와 같은 이름을 붙였지만, 옆 나라 소시국 (국왕 : 오민식)의 도시 이름을 이길 수 없어서 도시의 이름을 1번부터 N번까지로 바꿨다.
김형택의 국가에는 두 가지 종류의 도로가 있는데, 하나는 일반 도로이고, 또 다른 하나는 고속 도로이다. 고속 도로는 N-1개가 있으며, 1번에서 2번으로 가는 도로, 2번에서 3번으로 가는 도로, i번에서 i+1번으로 가는 도로, N-1번에서 N번으로 가는 도로와 같이 총 N-1개가 있다. 그리고, 몇 개의 일반 도로가 따로 있을 수 있다.
김형택은 이 나라를 몇 개의 지역으로 나누려고 한다. 그리고, 가능하면 많은 지역을 만들려고 한다. 각각의 지역은 모두 같은 수의 도시를 가지고 있어야 하고, 모든 도시는 단 하나의 지역에 속해야 한다. 지역으로 나눌 때에는 다음과 같은 조건을 만족해야 하는데, 지역 A와 지역 B가 다른 지역이라고 가정할 때, A에 속해 있는 어떤 도시에서 B에 속해 있는 어떤 도시로 가는 경로가 있다면, B에 속해 있는 어떤 도시에서 A에 속해 있는 어떤 도시로 가는 경로는 없어야 한다.
입력으로 도시의 개수 N개와 일반 도로의 개수 M개와 그 도로가 주어졌을 때, 김형택이 나눌 수 있는 지역의 개수의 최댓값을 구하는 프로그램을 작성하시오. (일반 도로도 도로다. 고속 도로도 도로다.)
<입력값>
첫째 줄에 도시의 개수 N과 일반 도로의 개수 M이 주어진다. 둘째 줄부터 한 줄에 하나씩 일반 도로의 정보가 주어진다. 일반 도로의 정보는 S E와 같이 주어지며, S에서 E로 가는 일반 도로라는 뜻이다. N은 3,000보다 작거나 같은 자연수이다. M은 1,000보다 작거나 같은 자연수이다.
<출력값>
김형택이 나눌 수 있는 지역의 최댓값을 출력한다.

<문제 1305>
세준이는 길 한가운데에서 전광판을 쳐다보고 있었다. 전광판에는 광고가 흘러나오고 있었다. 한참을 전광판을 쳐다본 세준이는 이 광고가 의미하는 것이 무엇인지 궁금해지기 시작했다.
전광판에는 같은 내용의 문구가 무한히 반복되어 나온다. 또, 전광판의 크기는 전광판에서 한번에 보이는 최대 문자수를 나타낸다. 만약 전광판의 크기가 L이라면, 한번에 L개의 문자를 표시할 수 있는 것이다.
광고업자는 최대한의 광고효과를 내기 위해서 길이가 N인 광고를 무한히 붙여서 광고한다.
예를 들어, 광고 업자 백은진이 광고하고 싶은 내용이 aaba 이고, 전광판의 크기가 6이라면 맨 처음에 보이는 내용은 aabaaa 이다. 시간이 1초가 지날 때마다, 문자는 한 칸씩 옆으로 이동한다. 따라서 처음에 aabaaa가 보였으면 그 다음에는 abaaab가 보인다. 그 다음에는 baaaba가 보인다.
세준이가 어느 순간 전광판을 쳐다봤을 때, 그 때 쓰여 있는 문자가 입력으로 주어졌을 때, 가능한 광고의 길이중 가장 짧은 것을 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 광고판의 크기 L이 주어지고, 둘째 줄에 현재 광고판에 보이는 문자열이 주어진다.
<출력값>
첫째 줄에 가능한 광고의 길이중 가장 짧은 것의 길이를 출력한다.

<문제 1306>
홍준이는 러너이다. 그런데 어쩌다 보니 아무리 뛰어도 뛰어도 속도가 변하지 않는다. 1초에 딱 1칸을 움직인다.
그런데 홍준이가 뛰는 코스는 광고판으로 가득하다. 광고판은 빛의 세기가 다른데, 홍준이는 자신이 볼 수 있는 광고판들 중에서 가장 강렬한 빛의 광고판만이 눈에 들어온다.
홍준이는 눈이 안좋기 때문에 빛의 세기가 강한 지점에서는 안경을 쓰고 뛰려한다. 그래서 알아야 할 것이, 뛰어가면서 보이는 광고판의 빛의 세기를 알고 싶다.
홍준이가 뛰어갈 때, 1초마다 보이는 광고판의 빛의 세기를 출력하여라.
<입력값>
첫째 줄에는 뛰는 코스의 길이, 즉 칸수 N과 홍준이의 시야의 범위 M이 주어진다. 시야가 M이라고 하면 현재 위치에서 앞뒤로 M-1칸까지 광고판이 보이는 것이다. (1 ≤ M ≤ N ≤ 1,000,000) 두 번째 줄에는 각각 칸에 있는 광고판들의 빛의 세기가 주어진다. 빛의 세기는 1,000,000을 넘지 않는 자연수이다.
홍준이는 언제나 광고판을 2M-1개 보면서 뛰고 싶기 때문에(중심으로) M번째 칸에서 뛰기 시작해서 N-M+1번째 칸에서 멈춘다고 가정하자.
<출력값>
뛰면서 보이는 광고판의 세기를 출력한다.

<문제 1307>
마방진이란 N*N의 격자의 각 칸에 1부터 N*N까지의 정수를 정확히 하나씩 채웠을 때, 모든 가로줄, 세로줄, 대각선의 합이 같은 배치를 말한다.
예를 들면, 다음은 3*3 마방진 중 하나이다. 가로줄, 세로줄, 대각선의 합이 모두 15로 같다는 것을 알 수 있다.

N이 주어졌을 때 N*N 마방진을 하나 구해 보자.
<입력값>
첫째 줄에 자연수 N이 주어진다. (3 ≤ N ≤ 300)
<출력값>
N*N 크기의 마방진을 아무거나 출력한다.

<문제 1308>
캠프에 오게 된 송유진은 캠프가 너무 지루해서 오늘로부터 캠프가 끝날 때 까지 며칠이나 남았는지 알아보고 싶었다. 그런데 캠프는 비상식적으로 길지도 몰라서 (윤년을 포함할지도 모른다) 손으로 하나하나 세기에는 힘들어 보였다.
더욱 정확한 계산을 위해, 유진이는 윤년이 정해지는 기준을 찾아보았고, 그것은 다음과 같았다.

서력기원 연수가 4로 나누어떨어지는 해는 우선 윤년으로 한다. (2004년, 2008년, …)
100으로 나누어떨어지는 해는 평년으로 한다. (2100년, 2200년, …)
400으로 나누어떨어지는 해는 다시 윤년으로 한다. (1600년, 2000년, …)

그런데 캠프가 너무 길 경우, 사춘기인 유진이는 캠프에 무단으로 빠질지도 모른다.
<입력값>
첫째 줄에 오늘의 날짜가 주어지고, 두 번째 줄에 D-Day인 날의 날짜가 주어진다. 날짜는 연도, 월, 일순으로 주어지며, 공백으로 구분한다. 입력 범위는 1년 1월 1일부터 9999년 12월 31일 까지 이다. 오늘의 날짜는 항상 D-Day보다 앞에 있다.
<출력값>
오늘부터 D-Day까지 x일이 남았다면, "D-"를 출력하고 그 뒤에 공백 없이 x를 출력한다. 만약 캠프가 천년 이상 지속된다면 (오늘이 y년 m월 d일이고, D-Day가 y+1000년 m월 d일과 같거나 늦다면) 대신 "gg"를 출력한다. 오늘이 2월 29일인 경우는 주어지지 않는다.

<문제 1309>
어떤 동물원에 가로로 두칸 세로로 N칸인 아래와 같은 우리가 있다.

이 동물원에는 사자들이 살고 있는데 사자들을 우리에 가둘 때, 가로로도 세로로도 붙어 있게 배치할 수는 없다. 이 동물원 조련사는 사자들의 배치 문제 때문에 골머리를 앓고 있다.
동물원 조련사의 머리가 아프지 않도록 우리가 2*N 배열에 사자를 배치하는 경우의 수가 몇 가지인지를 알아내는 프로그램을 작성해 주도록 하자. 사자를 한 마리도 배치하지 않는 경우도 하나의 경우의 수로 친다고 가정한다.
<입력값>
첫째 줄에 우리의 크기 N(1≤N≤100,000)이 주어진다.
<출력값>
첫째 줄에 사자를 배치하는 경우의 수를 9901로 나눈 나머지를 출력하여라.

<문제 1310>
캠프가 시작된 지도 벌써 12일이 지났다.  이제 캠프의 반이 지났을 뿐인데, 학생들은 벌써 운동부족을 호소하고 있다.
선생님은 학생들에게 달리기 시합을 시키기로 결정하고, 달리기 시합에서 1등을 한 사람은 훼밀리마트에 데려가기로 했다. 적절한 운동장을 찾고 있던 중, 숙소 근처에서 널찍한 운동장을 발견했다. 그 곳에는 가느다란 기둥이 N개 꽂혀 있었다.
달리기 코스는 한 기둥에서 시작하여 다른 기둥까지 직선코스이고 코스 내에 다른 기둥이 포함되어도 상관하지 않는다. 학생들을 운동시키는 것이 이 시합의 목적이므로, 최대한 멀리 떨어져 있는 두 기둥으로 지표를 잡으려고 한다.
이 숙소에서 나가 달리기를 하고 싶다면 이 문제를 풀어야 한다. N개의 기둥의 좌표가 주어졌을 때, 가장 멀리 떨어진 두 기둥 사이의 거리의 제곱을 출력하는 프로그램을 작성하라.
<입력값>
첫째 줄에 기둥의 개수 N(1≤N≤100,000)이 주어지고, 이어서 N줄에 걸쳐 각 기둥의 좌표를 나타내는 정수 두 개가 주어진다. 좌표의 절댓값의 범위는 50,000을 넘을 수 없다.
<출력값>
첫째 줄에 가장 먼 기둥 사이의 거리를 제곱하여 출력한다.

<문제 1311>
N명의 사람과 N개의 일이 있다. 각 사람은 일을 하나 담당해야 하고, 각 일을 담당하는 사람은 한 명 이어야 한다. 또한, 모든 사람은 모든 일을 할 능력이 있다.
사람은 1번부터 N번까지 번호가 매겨져 있으며, 일도 1번부터 N번까지 번호가 매겨져 있다.
Dij를 i번 사람이 j번 일을 할 때 필요한 비용이라고 했을 때, 모든 일을 하는데 필요한 비용의 최솟값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 사람과 일의 수 N (1 ≤ N ≤ 20)이 주어진다. 둘째 줄부터 N개의 줄에는 D의 내용이 주어진다. 비용은 10,000보다 작거나 같은 자연수이다.
<출력값>
모든 일을 하는데 필요한 비용의 최솟값을 출력한다.

<문제 1312>
피제수(분자) A와 제수(분모) B가 있다. 두 수를 나누었을 때, 소숫점 아래 N번째 자리수를 구하려고 한다. 예를 들어, A=3, B=4, N=1이라면, A÷B=0.75 이므로 출력 값은 7이 된다.
<입력값>
첫 번째 줄에 A와 B(1≤A, B≤100,000), N(1≤N≤1,000,000)이 공백을 경계로 주어진다.
<출력값>
A÷B를 했을 때, 소숫점 아래 N번째 수를 출력한다.

<문제 1314>
여러 명의 탐험가들이 어두운 동굴의 입구에 서있다. 이 사람들은 모두 동굴을 통과해서 출구에 다 같이 서 있으려고 한다. 불행하게도 여러 상황이 겹쳐서 다 같이 동굴을 통과하는 것이 불가능하게 되었다. 따라서, 작은 그룹으로 나눠서 동굴을 통과해야 한다. 그리고, 지도는 단 한 개 뿐인데, 동굴을 지도 없이 다닌다는 것은 불가능하다. 따라서 동굴 안에 있는 그룹은 그 그룹 내에 있는 한 명이 지도를 가지고 있어야 한다.
탐험가 그룹이 동굴에 들어가서, 출구를 향해 갈 때, 낡은 다리를 건너야 한다. 그룹에 있는 모든 사람은 반드시 동시에 다리를 건너야 한다. 낡은 다리는 B 킬로그램까지 지탱할 수 있다. 그걸 넘으면 붕괴할 것이다.
탐험가는 혼자서 동굴에 들어 갈 수 있다. 또, 두 명 또는 그 이상이 그룹으로 같이 동굴에 들어갈 수 있는데, 이때 그룹 내에 존재하는 각각의 탐험가는 그룹원 중 적어도 한 명은 믿어야 한다.
탐험가는 모두 다른 속도로 걷는다. 그러나 그들이 동굴에 들어갔을 때는 모두 같은 속도로 걸어야 한다. 따라서, 탐험가 그룹이 동굴에 들어갔을 때는, 그 그룹에서 가장 느린사람의 속도로 다같이 걷게 된다.
 
탐험가들이 모두 동굴을 통과하는데 걸리는 시간의 최솟값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 탐험가의 수 N이 주어진다. N은 13보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 각각의 탐험가의 무게와 걷는 시간이 주어진다. 두 수는 모두 1,000보다 작거나 같은 자연수이다. 그 다음 줄부터 N개의 줄에는 탐험가들 사이의 신뢰표가 주어진다. 이 신뢰표에서 i번째 줄 j번째 열이 의미하는 것은 탐험가 i번이 탐험가 j를 신뢰하는지 안 하는지이다. 여기에서는 Y또는 N만이 들어오며, i번째 줄 i번째 행은 항상 Y이다. 꼭 대칭일 필요는 없다. 그리고 마지막 줄에는 다리가 지탱할 수 있는 무게의 한계 B가 주어진다.
<출력값>
첫째 줄에 탐험가가 모두 다리를 건너는데 걸리는 시간의 최솟값을 출력한다. 탐험가가 모두 다리를 건널 수 없을 때는 -1을 출력한다.

<문제 1315>
준규는 새 RPG 게임을 시작했다. 이 게임에서 캐릭터는 2가지 스탯을 가지고 있다. 하나는 힘(STR)이고, 다른 하나는 지력(INT)이다. 캐릭터를 생성했을 때, 두 스탯은 모두 1이다.
게임에는 총 N개의 퀘스트가 있다. i번째 퀘스트를 깨려면 캐릭터의 힘이 STR[i]보다 크거나 같거나, 지력이 INT[i]보다 크거나 같아야 한다. 이 퀘스트를 깨면, 스탯을 올릴 수 있는 포인트를 PNT[i]개 만큼 얻게 된다.
모든 퀘스트는 단 한 번만 깰 수 있으며, 퀘스트를 깨는 순서는 준규가 마음대로 정할 수 있다. 또, 퀘스트 보상으로 얻게되는 포인트로 준규 마음대로 스탯을 올릴 수 있다.
준규가 깰 수 있는 퀘스트 개수의 최댓값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 퀘스트의 개수 N이 주어진다. N은 50보다 작거나 같은 자연수이다.
둘째 줄부터 N개의 줄에 STR[i], INT[i], PNT[i]가 주어진다. 이 숫자는 모두 1,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 준규가 깰 수 있는 퀘스트 개수의 최댓값을 출력한다.

<문제 1316>
그룹 단어란 단어에 존재하는 모든 문자에 대해서, 각 문자가 연속해서 나타나는 경우만을 말한다. 예를 들면, ccazzzzbb는 c, a, z, b가 모두 연속해서 나타나고, kin도 k, i, n이 연속해서 나타나기 때문에 그룹 단어이지만, aabbbccb는 b가 떨어져서 나타나기 때문에 그룹 단어가 아니다.
단어 N개를 입력으로 받아 그룹 단어의 개수를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 단어의 개수 N이 들어온다. N은 100보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 단어가 들어온다. 단어는 알파벳 소문자로만 되어있고 중복되지 않으며, 길이는 최대 100이다.
<출력값>
첫째 줄에 그룹 단어의 개수를 출력한다.

<문제 1317>
그룹 단어란 1316번 문제에 설명이 되어 있다.
1316번 문제가 너무 쉬워서 분노한 김지민은 단어 하나를 찢어버렸다. 그리고 나서 그 앞에 앉아있는 장엄지는 이 단어를 다시 붙여서 그룹 단어로 만들려고 한다.
김지민이 조각내 버린 단어가 임의의 순서로 주어진다. 즉, 조각낸 부분 별로 입력이 주어질 때, 원래 단어를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 김지민이 단어를 나눈 조각의 개수 N이 주어진다. N은 100보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 각 부분이 주어진다. 각 부분은 최대 20글자이고, 알파벳 소문자이다.
<출력값>
첫째 줄에 원래 단어를 출력한다. 만약 원래 단어로 가능한 것이 여러 개일 경우에는 -_-를 출력한다. 만약 만들 수 없다면 gg를 출력한다.

<문제 1318>
포커는 자신이 가진 패들로 족보에 맞는 카드를 가진 사람들 끼리 누가 더 높은 족보를 가졌나 대결하는 게임이다.
족보를 약한 순서대로 나열하면 다음과 같다.

탑: 다른 족보가 없을 때 가장 높은 카드 한 장을 탑이라고 한다.
원페어: 동일한 숫자의 카드가 2개 있을 때.
투페어: 동일한 숫자의 카드가 2개 있는 게 두 쌍이 있을 때.
트리플: 동일한 숫자의 카드가 3개 있을 때.
스트레이트: 5개의 연속된 숫자가 있을 때.
빽스트레이트: A,2,3,4,5인 스트레이트.
마운틴: A,K,Q,J,10인 스트레이트.
플러쉬: 같은 문양의 카드가 5장 있을 때.
풀하우스: 트리플 + 원페어(서로 다른 카드로)
포카드: 같은 숫자의 카드가 4장 있을 때.
스트레이트 플러쉬: 같은 문양인 숫자가 연속된 5장의 카드.
로얄 스트레이트 플러쉬: A,2,3,4,5인 스트레이트 플러쉬.

여기 52장의 카드가 있다. (트, 끌, 삽, 달 4가지 문양에 각각 A,2,3,4,5,6,7,8,9,10,J,Q,K의 카드가 있음.)
그런데, 이번에는 포커의 룰이 six포커다! 즉 6장을 받았을 때 족보가 만들어지는 확률을 계산해야 한다.
단, 카드의 일부분이 높은 족보를 만든다면, 그보다 낮은 족보의 카드는 무시된다. 요컨데, 12개의 족보가 나올 확률의 합은 1이라는 것이다.
이때, 각각의 족보가 나올 확률을 구하시오.
<입력값>
없다.
<출력값>
각각의 족보가 나올 확률을 순서대로 출력하여라. 한줄마다 a/b꼴의 분수로 출력한다.

<문제 1319>
장엄지는 과일밭을 소유하고 있었다. 하지만 장엄지가 어디론가 떠나는 바람에 김지민과 임한수가 그 밭을 가지게 되었다. 과일밭은 평면으로 표현되며 과일나무는 점 하나로 표현된다.
김지민과 임한수는 과일밭을 직선을 이용해서 나누려고 한다. 단, 직선 위에는 나무가 있으면 안 된다. 이렇게 되면 김지민은 과일밭의 한 쪽을 가지게 되고, 임한수는 다른 한 쪽을 가지게 된다.
두 사람은 모두 과일 나무를 이용해서 이윤을 창출하려고 하기 때문에, 모든 나무에 각각의 가치를 매겼다. 공평하게 밭을 나누기 위해서 김지민이 가지고 있는 나무의 가치의 합과 임한수 것의 차이를 최소로 하려고 한다.
나무의 위치가 주어졌을 때, 김지민과 임한수가 가지고 있는 나무의 가치 차이의 최솟값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 나무의 개수 N이 주어진다. 100개보다 작거나 같은 자연수이고 1은 아니다. 둘째 줄부터 N개의 줄에 나무의 좌표와 가치가 주어진다. 좌표는 중복되지 않으며, 좌표는 1,000보다 작거나 같은 음이 아닌 정수이고, 가치는 1,000,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 김지민이 가지고 있는 나무의 가치의 합과 임한수가 가지고 있는 나무의 가치의 합의 차이의 최솟값을 출력한다.

<문제 1321>
캠프 내내 그랬듯이, 여전히 옆 나라와의 전쟁이 한창이다.
전쟁에는 N개의 부대가 투입되었는데, 전쟁이 장기전이 되다 보니 군사의 적절한 배치를 위해 각 부대에 군인이 늘어나기도 하고 줄어들기도 하고 있다.
행정의 편의를 위해 각 군인들에겐 번호가 붙어 있는데, 군인들은 1번 부대부터 군번순서대로 차례차례 배치된다. 예를 들어 1번 부대에 4명, 2번 부대에 3명, 3번 부대에 7명의 군인이 있다면 군번이 6번인 군인은 2번 부대에 배치되게 된다.
문제는 어떤 부대의 인원이 늘어나거나 줄어들었을 때 i번 군인이 어디에 배치되는지 인데, 이럴 때에는 군인도 군번도 처음부터 다시 배치하게 된다. 위의 예에서와 같이 1번 부대에 4명, 2번 부대에 3명, 3번 부대에 7명의 군인이 있었는데, 1번 부대에서 3명의 감원이 일어난다면, 6번 군인은 3번 부대에 재배치 받게 된다.
전쟁 때는 부대의 감원과 증원이 많아 군사 재배치도 자주 일어나게 되는데, 이렇게 자주 배치가 바뀌자 군인들은 자기가 도대체 어떤 부대에 속하는 지 헷갈리게 되었다. 다행히도 바뀐 군번은 다들 정확하게 숙지하고 있다.
부대의 개수 N과 각 부대에 속해 있는 군인의 수가 N개 주어질 때, 부대의 감원과 증원을 한 후, 혹은 그 중에 군번 i번의 군인이 몇 번 부대에 속하는 지를 물어봤을 때, 그 질문에 대답을 해 줄 수 있는 프로그램을 작성하시오.
i번 부대에 증원이나 감원을 할 때엔 "1 i a"의 형태로 명령이 주어지고, 이는 i번 부대에 a명을 더한다는 뜻이다. 감원을 할 때엔 a가 0보다 작은 수로 주어진다. 감원을 해서 부대의 인원수가 0보다 작아지는 입력은 들어오지 않는다. a는 절댓값이 1보다 크거나 같고, 3,000보다 작거나 같은 정수이다.
군번 i번의 군인이 어떤 부대에 배치 받았는지 알고 싶을 때는 "2 i"의 형태로 명령이 주어지고, 이런 명령을 받았을 때는 i번 군인이 몇 번 부대에 배치 받았는지를 출력해야 한다. i는 전체 군인 수보다 작거나 같은 자연수이다.
<입력값>
첫째 줄에 부대의 개수 N(1 ≤ N ≤ 500,000)이 주어지고, 이어서 각 부대의 군사 수를 나타내는 정수가 N개 주어진다. 각 부대의 군사 수는 1000보다 작거나 같은 자연수이다. 그 다음 줄에 명령의 개수 M(1 ≤ M ≤ 10,000)개가 주어지고, 이어서 M줄에 걸쳐 명령이 주어진다.
<출력값>
질문한 군인이 몇 번 부대에 배치 받았는지를 한 줄에 하나씩 출력한다.

<문제 1322>
두 자연수 X와 K가 주어진다. 그러면, 다음 식을 만족하는 K번째로 작은 자연수 Y를 찾아야 한다.
X + Y = X | Y
|는 비트 연산 OR이다.
<입력값>
첫째 줄에 X와 K가 주어진다. X와 K는 2,000,000,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 X + Y = X | Y를 만족하는 K번째 작은 Y를 출력한다. 정답은 int 범위를 넘어갈 수 있다.

<문제 1323>
영훈이는 태형이에게 어떤 수 N과 K를 주었다.
태형이는 N을 종이에 쓰기 시작했다. 태형이는 자신이 이 수를 몇 번 써야 그 수가 K로 나누어지는지 궁금해지기 시작했다.
N=10일 때, 이 수를 한 번 쓰면 10이고, 두 번 쓰면 1010이고, 세 번쓰면 101010이고,... 이런식이다.
어떤 수 N과 K가 주어졌을 때, N을 몇 번 써야 K로 나누어 떨어지는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N과 K가 주어진다. N은 1,000,000,000보다 작거나 같은 자연수이다. K는 100,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 몇 번 써야하는지 그 최솟값을 출력한다. 만약 아무리 써도 불가능할 경우에는 -1을 출력한다.

<문제 1324>
당신은 게임을 하다 걸려서 사회봉사를 해야 한다. 당신은 2일 동안 길 하나의 쓰레기를 주으려 한다. “이런 젠장”
어떻게 줍냐면, 무게가 증가되는 순서대로 줍는다. 그런데 문제는 가방이 고물이라 한번 물건을 넣으면 그 크기에 맞게 가방이 변형되어 버린다는 것이다. 그러면 당신은 그 가방에는 딱 크기가 맞는 쓰레기만 넣을 수 있다.
요컨데, 첫날 줍는 쓰레기랑 둘째 날 줍는 쓰레기가 같아야 한다는 것이다.
당신은 최대한 많이 쓰레기를 모으고 싶다. 그런데 당신이 첫째 날 어떤 가방에 아무 쓰레기도 담지 않았다면 옆집 거지 친구 오민식이 그 가방을 빼앗아간다.
당신은 특유의 예지력으로 오늘과 내일, 길거리에 쓰레기가 어떤 식으로 놓여있을지 안다.
당신은 하루마다 최대 몇 개의 쓰레기를 주울 수 있는가?
<입력값>
첫 번째 줄에는 쓰레기의 개수 N이 주어진다. (N ≤ 1,000) 두 번째 줄에는 첫날 쓰레기의 양이 위치 순서대로 각각 N개 주어진다. 세 번째 줄에는 둘째 날 쓰레기의 양이 위치 순서대로 주어진다. 당신은 아침마다 1번 쓰레기가 있는 위치에서 출발하며, 쓰레기를 줍고 나면 뒤로 돌아가서 쓰레기를 주울 수 없다. 쓰레기의 양은 50,000보다 작거나 같은 자연수이다.
<출력값>
하루 마다 주울 수 있는 쓰레기의 개수의 최대를 출력한다.

<문제 1325>
해커 김지민은 잘 알려진 어느 회사를 해킹하려고 한다. 이 회사는 N개의 컴퓨터로 이루어져 있다. 김지민은 귀찮기 때문에, 한 번의 해킹으로 여러 개의 컴퓨터를 해킹 할 수 있는 컴퓨터를 해킹하려고 한다.
이 회사의 컴퓨터는 신뢰하는 관계와, 신뢰하지 않는 관계로 이루어져 있는데, A가 B를 신뢰하는 경우에는 B를 해킹하면, A도 해킹할 수 있다는 소리다.
이 회사의 컴퓨터의 신뢰하는 관계가 주어졌을 때, 한 번에 가장 많은 컴퓨터를 해킹할 수 있는 컴퓨터의 번호를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에, N과 M이 들어온다. N은 10,000보다 작거나 같은 자연수, M은 100,000보다 작거나 같은 자연수이다. 둘째 줄부터 M개의 줄에 신뢰하는 관계가 A B와 같은 형식으로 들어오며, "A가 B를 신뢰한다"를 의미한다. 컴퓨터는 1번부터 N번까지 번호가 하나씩 매겨져 있다.
<출력값>
첫째 줄에, 김지민이 한 번에 가장 많은 컴퓨터를 해킹할 수 있는 컴퓨터의 번호를 오름차순으로 출력한다.

<문제 1326>
개구리가 일렬로 놓여 있는 징검다리 사이를 폴짝폴짝 뛰어다니고 있다. 징검다리에는 숫자가 각각 쓰여 있는데, 이 개구리는 매우 특이한 개구리여서 어떤 징검다리에서 점프를 할 때는 그 징검다리에 쓰여 있는 수의 배수만큼 떨어져 있는 곳으로만 갈 수 있다.
이 개구리는 a번째 징검다리에서 b번째 징검다리까지 가려고 한다. 이 개구리가 a번째 징검다리에서 시작하여 최소 몇 번 점프를 하여 b번째 징검다리까지 갈 수 있는지를 알아보는 프로그램을 작성하시오.
<입력값>
첫째 줄에 징검다리의 개수 N(1≤N≤10,000)이 주어지고, 이어서 각 징검다리에 쓰여 있는 N개의 정수가 주어진다. 그 다음 줄에는 N보다 작거나 같은 자연수 a, b가 주어지는 데, 이는 개구리가 a번 징검다리에서 시작하여 b번 징검다리에 가고 싶다는 뜻이다. 징검다리에 쓰여있는 정수는 10,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 개구리가 a번 징검다리에서 b번 징검다리로 최소 몇 번 점프하여 갈 수 있는 지를 출력하시오. a에서 b로 갈 수 없는 경우에는 -1을 출력한다.

<문제 1327>
홍준이는 소트 게임을 하려고 한다. 소트 게임은 1~N으로 이루어진 N자리의 순열을 이용한다. 이 게임에선 2보다 크거나 같고 N보다 작거나 같은 수 K가 주어진다.
홍준이가 어떤 수를 뒤집는다고 하면, 그 수부터, 오른쪽으로 총 K개의 수를 뒤집는 것이다.
예를 들어 순열이 5 4 3 2 1 이었고, 여기서 K가 3일 때, 4를 뒤집으면 5 2 3 4 1이 된다. (뒤집는 다는 소리는 순서를 역순으로 바꾼다는 것)
반드시 K개의 수를 뒤집어야하기 때문에, 처음 상태에서 2나 1을 선택하는 것은 불가능하다.
홍준이는 입력으로 들어온 순열을 오름차순으로 만들려고 한다. 오름차순으로 만들면 게임이 끝난다.
홍준이가 게임을 빨리 끝내려고 할 때, 수를 최소 몇 개 선택해야 하는지 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 순열의 크기 N과 K가 주어진다. N은 2보다 크거나 같고, 8보다 작거나 같다. 둘째 줄에 순열에 들어가는 수가 주어진다.
<출력값>
첫째 줄에 정답을 출력한다. 만약 오름차순으로 만들 수 없으면 -1을 출력한다.

<문제 1328>
상근이가 살고있는 동네에는 빌딩 N개가 한 줄로 세워져 있다. 모든 빌딩의 높이는 1보다 크거나 같고, N보다 작거나 같으며, 같은 높이를 가지는 빌딩은 없다. 상근이는 학교 가는 길에 가장 왼쪽에 서서 빌딩을 몇 개 볼 수 있는지 보았고, 집에 돌아오는 길에는 가장 오른쪽에 서서 빌딩을 몇 개 볼 수 있는지 보았다.
상근이는 가장 왼쪽과 오른쪽에서만 빌딩을 봤기 때문에, 빌딩이 어떤 순서로 위치해있는지는 알 수가 없다.
빌딩의 개수 N과 가장 왼쪽에서 봤을 때 보이는 빌딩의 수 L, 가장 오른쪽에서 봤을 때 보이는 빌딩의 수 R이 주어졌을 때, 가능한 빌딩 순서의 경우의 수를 구하는 프로그램을 작성하시오.
예를 들어, N = 5, L = 3, R = 2인 경우에 가능한 빌딩의 배치 중 하나는 1 3 5 2 4이다.
<입력값>
첫째 줄에 빌딩의 개수 N과 가장 왼쪽에서 봤을 때 보이는 빌딩의 수 L, 가장 오른쪽에서 봤을 때 보이는 빌딩의 수 R이 주어진다. (1 ≤ N ≤ 100, 1 ≤ L, R ≤ N)
<출력값>
첫째 줄에 가능한 빌딩 순서의 경우의 수를 1000000007로 나눈 나머지를 출력한다.

<문제 1329>
어떤 0~9로만 이루어진 문자열이 있다.
당신은 이 문자열을 잘라서 증가 수열을 만드는데, 마지막 숫자를 최소화 하고 싶다.
만약 마지막 숫자가 같다면 맨 처음 숫자가 가장 큰 수열을 출력하고, 만약 첫 번째 숫자도 같다면 두 번째 숫자 ... 즉 앞에서부터 숫자가 큰 수열을 출력한다.
이 문제에서는 숫자가 0으로 시작할 수 있다.
<입력값>
0~9로만 이루어진 문자열이 주어진다. 문자열의 길이는 80을 넘지 않는다.
<출력값>
문자열을 “,”로 끊어서 출력한다.

<문제 1330>
두 정수 A와 B가 주어졌을 때, A와 B를 비교하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 A와 B가 주어진다. A와 B는 공백 한 칸으로 구분되어져 있다.
<출력값>
첫째 줄에 다음 세 가지 중 하나를 출력한다.

A가 B보다 큰 경우에는 '>'를 출력한다.
A가 B보다 작은 경우에는 '<'를 출력한다.
A와 B가 같은 경우에는 '=='를 출력한다.

<문제 1331>
나이트 투어는 체스판에서 나이트가 모든 칸을 정확히 한 번씩 방문하며, 마지막으로 방문하는 칸에서 시작점으로 돌아올 수 있는 경로이다. 다음 그림은 나이트 투어의 한 예이다.

영식이는 6×6 체스판 위에서 또 다른 나이트 투어의 경로를 찾으려고 한다. 체스판의 한 칸은 A~F 중의 알파벳 하나와 1~6 중의 숫자 하나로 나타낼 수 있다. 영식이의 나이트 투어 경로가 주어질 때, 이것이 올바른 것이면 Valid, 올바르지 않으면 Invalid를 출력하는 프로그램을 작성하시오.
<입력값>
36개의 줄에 나이트가 방문한 순서대로 입력이 주어진다.
<출력값>
첫째 줄에 문제의 정답을 출력한다.

<문제 1332>
유진이의 선생님은 유진이에게 몇 개의 문제를 풀라고 주었다. 유진이는 반드시 문제 1번을 먼저 풀어야 한다. 만약에 A번 문제를 풀었을 때, 유진이는 A+1번 문제를 풀거나, A+1번 문제를 건너뛰고 A+2번 문제를 푸는 것도 가능하다. 따라서, 1, 3, 4, 6과 같이 문제를 푸는 것은 가능하지만, 1, 3, 5, 8과 같이 문제를 푸는 것은 불가능하다.
유진이는 문제를 풀면서 흥미를 느낀다. 입력으로 주어지는 P배열은 유진이가 각 문제를 풀 때 느끼는 흥미도를 수치화 한 값이다.
유진이의 선생님은 유진이의 흥미도가 특정 범위내에 들면 문제를 푸는 것을 중지시키려고 한다. 만약 유진이가 지금까지 푼 문제의 흥미도의 최댓값과, 최솟값의 차이가 V보다 크거나 같으면 문제를 푸는 것을 중지하게 된다. 만약 이런 일이 절대 일어나지 않으면, 유진이는 문제를 다 풀게 된다. 유진이가 풀어야 하는 최소 문제수를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 문제의 개수 N과 V가 주어진다. N은 10,000보다 작거나 같은 자연수, V도 10,000보다 작거나 같은 자연수이다. 둘째 줄에 유진이가 느끼는 흥미도가 주어진다. 이 값은 문제 1번부터 주어지고, 1,000보다 작거나 같은 자연수 또는 0이다.
<출력값>
풀어야하는 문제의 최솟값을 출력한다.

<문제 1333>
얼마전, Day Of Mourning의 새 앨범이 나왔고, 강토는 이 앨범을 들으려고 한다.
이 앨범에는 총 노래가 N곡이 들어있고, 모든 노래의 길이는 L초이다. 그리고, 노래와 노래 사이에는 5초 동안 아무 노래도 들리지 않는 조용한 구간이 있다.
강토가 앨범의 첫 곡을 듣는 순간이 0초이다. 그리고 그 0초부터 강토의 전화벨이 울리기 시작한다. 전화벨은 D초에 1번씩 울리며, 한 번 울릴 때 1초동안 울린다.
강토는 락 스피릿을 진심으로 느끼기 위해서 볼륨을 매우 크게 하고 듣기 때문에, 노래가 나오는 중에는 전화벨 소리를 듣지 못한다.
만약, 전화벨이 노래가 시작되는 순간 울린다면, 강토는 전화를 받지 못한다. 또, 전화벨이 노래가 끝나는 순간 같이 끝난다면, 강토는 전화를 받을 수 없다.
강토는 앨범을 1번만 듣는다. 즉, 모든 앨범 수록곡을 다 듣고 난 후에는 전화벨을 들을 수 있다.
강토가 전화벨을 들을 수 있는 가장 빠른 시간을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N, L, D가 공백을 사이에 두고 주어진다. 모든 수는 1,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 강토가 전화벨을 들을 수 있는 가장 빠른 시간을 출력한다.

<문제 1334>
팰린드롬 수는 앞으로 읽어도, 뒤로 읽어도 같은 숫자이다. 101, 4, 6666와 같은 숫자는 팰린드롬 수이고, 10, 564, 15452와 같은 숫자는 아니다.
어떤 수 N이 주어질 때, N보다 큰 팰린드롬 수 중에서 가장 작은 수를 출력한다.
<입력값>
첫째 줄에 N이 주어진다. N은 최대 50자리인 양수이다. 첫 숫자는 0이 아니다.
<출력값>
첫째 줄에 문제의 정답을 출력한다.

<문제 1337>
올바른 배열이란 어떤 배열 속에 있는 원소 중 5개가 연속적인 것을 말한다. (연속적인 것이란 5개의 수를 정렬했을 때, 인접한 수의 차이가 1인 것을 말한다.)
예를 들어 배열 {6, 1, 9, 5, 7, 15, 8}은 올바른 배열이다. 왜냐하면 이 배열 속의 원소인 5, 6, 7, 8, 9가 연속이기 때문이다.
배열이 주어지면, 이 배열이 올바른 배열이 되게 하기 위해서 추가되어야 할 원소의 개수를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 배열의 크기 N이 주어진다. N은 10,000보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 배열의 원소가 한 줄에 하나씩 주어진다. 원소는 1,000,000,000보다 작거나 같은 음이 아닌 정수이다. 두 개 이상의 원소가 같은 경우는 없다.
<출력값>
첫째 줄에 입력으로 주어진 배열이 올바른 배열이 되게 하기 위해서 추가되어야할 원소의 최소 개수를 출력한다.

<문제 1338>
당신은 한 개의 알 수 없는 수를 알아내야만 한다. "이런 젠장"
어쨌든 당신은 그 수를 알아내야만 한다. 당신에게 주어지는 정보는 다음과 같다.

그 수가 있을 수 있는 범위
그 수를 x로 나눈 나머지, 즉 그 수를 qx + y(0 ≤ y < |x|) 꼴로 나타냈을 때 y의 값

이때, 당신은 그 수가 무엇인지 추측해야 한다.
<입력값>
첫 번째 줄에는 수가 있을 수 있는 범위의 양끝 값을 의미하는 두 개의 수가 주어진다.
두 번째 줄에는 나누는 수 x와 나머지 y가 주어진다.
주어지는 모든 수는 -231 이상 231 - 1 이하의 정수이다.
<출력값>
첫째 줄에 추측한 수를 출력한다. 만약 정확히 한 개로 추측할 수 없다면 Unknwon Number를 출력한다.

<문제 1339>
민식이는 수학학원에서 단어 수학 문제를 푸는 숙제를 받았다.
단어 수학 문제는 N개의 단어로 이루어져 있으며, 각 단어는 알파벳 대문자로만 이루어져 있다. 이때, 각 알파벳 대문자를 0부터 9까지의 숫자 중 하나로 바꿔서 N개의 수를 합하는 문제이다. 같은 알파벳은 같은 숫자로 바꿔야 하며, 두 개 이상의 알파벳이 같은 숫자로 바뀌어지면 안 된다.
예를 들어, GCF + ACDEB를 계산한다고 할 때, A = 9, B = 4, C = 8, D = 6, E = 5, F = 3, G = 7로 결정한다면, 두 수의 합은 99437이 되어서 최대가 될 것이다.
N개의 단어가 주어졌을 때, 그 수의 합을 최대로 만드는 프로그램을 작성하시오.
<입력값>
첫째 줄에 단어의 개수 N(1 ≤ N ≤ 10)이 주어진다. 둘째 줄부터 N개의 줄에 단어가 한 줄에 하나씩 주어진다. 단어는 알파벳 대문자로만 이루어져있다. 모든 단어에 포함되어 있는 알파벳은 최대 10개이고, 수의 최대 길이는 8이다. 서로 다른 문자는 서로 다른 숫자를 나타낸다.
<출력값>
첫째 줄에 주어진 단어의 합의 최댓값을 출력한다.

<문제 1340>
문빙이는 새해를 좋아한다. 하지만, 이제 새해는 너무 많이 남았다. 그래도 문빙이는 새해를 기다릴 것이다.
어느 날 문빙이는 잠에서 깨면서 스스로에게 물었다. “잠깐, 새해가 얼마나 남은거지?”
이 문제에 답하기 위해서 문빙이는 간단한 어플리케이션을 만들기로 했다. 연도 진행바라는 것인데, 이번 해가 얼마나 지났는지를 보여주는 것이다.
오늘 날짜가 주어진다. 이번 해가 몇%지났는지 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 Month DD, YYYY HH:MM과 같이 주어진다. Month는 현재 월이고, YYYY는 현재 연도이다. 숫자 네자리이다. DD, HH, MM은 모두 2자리 숫자이고, 현재 일, 시, 분이다.
Month는 January, February, March, April, May, June, July, August, September, October, November, December 중의 하나이고, 연도는 1800보다 크거나 같고, 2600보다 작거나 같다. 항상 올바른 날짜와 시간만 입력으로 주어진다.
<출력값>
첫째 줄에 문제의 정답을 출력한다. 절대/상대 오차는 10-9까지 허용한다.

<문제 1341>
영식이와 민식이는 케이크를 나누어 먹으려고 한다. 일단 영식이가 절반을 먹고, 민식이가 남은 절반을 먹는다. 또 계속 이렇게 절반을 먹고 한다. 이렇게 무한번 하고 나면 결국 케이크를 다 먹게 된다. 표로 만들어 보면 다음과 같다.



영식
민식




1/2
1/4


1/8
1/16


1/32
1/64


1/128
1/256


...
...



위와 같이 먹게 되면 영식이는 항상 민식이의 두 배를 먹게 되므로 케이크의 2/3을 먹게 되고, 민식이는 1/3을 먹게 된다.
케이크를 재미있게 먹기 위해서 여러 가지 패턴을 만들기로 했다. 그렇게 되면 영식이가 먹게되는 케이크는 달라지게 된다. 만약 “영식,민식,영식”과 같이 먹게되면 다음과 같이 먹는다.
이렇게 되면 영식이는 5/7을 먹게 된다.
영식이가 먹게되는 케이크의 양이 분수로 주어진다. 그때, 패턴을 출력하는 프로그램을 작성하시오.



영식
민식
영식




1/2
1/4
1/8


1/16
1/32
1/64


1/128
1/256
1/512
<입력값>
첫째 줄에 a와 b가 주어진다. a와 b는 a/b에서 분자와 분모다. b는 1보다 크거나 같고, 263-1보다 작거나 같은 자연수이고, a는 0보다 크거나 같고, b보다 작거나 같은 정수이다. a와 b는 서로소이다.
<출력값>
첫째 줄에 먹는 패턴을 출력한다. 패턴은 영식은 *로, 민식은 -로 출력한다. 만약, 패턴의 길이가 60 이하인 것이 없으면 -1을 출력한다. 가능한 패턴이 여러 가지이면 짧은 것을 출력한다.

<문제 1342>
민식이와 준영이는 자기 방에서 문자열을 공부하고 있다. 민식이가 말하길 인접해 있는 모든 문자가 같지 않은 문자열을 행운의 문자열이라고 한다고 한다. 준영이는 문자열 S를 분석하기 시작했다. 준영이는 문자열 S에 나오는 문자를 재배치하면 서로 다른 행운의 문자열이 몇 개 나오는지 궁금해졌다. 만약 원래 문자열 S도 행운의 문자열이라면 그것도 개수에 포함한다.
<입력값>
첫째 줄에 문자열 S가 주어진다. S의 길이는 최대 10이고, 알파벳 소문자로만 이루어져 있다.
<출력값>
첫째 줄에 위치를 재배치해서 얻은 서로 다른 행운의 문자열의 개수를 출력한다.

<문제 1343>
민식이는 다음과 같은 폴리오미노 2개를 무한개만큼 가지고 있다. AAAA와 BB
이제 '.'와 'X'로 이루어진 보드판이 주어졌을 때, 민식이는 겹침없이 'X'를 모두 폴리오미노로 덮으려고 한다. 이때, '.'는 폴리오미노로 덮으면 안 된다.
폴리오미노로 모두 덮은 보드판을 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 보드판이 주어진다. 보드판의 크기는 최대 500이다.
<출력값>
첫째 줄에 사전순으로 가장 앞서는 답을 출력한다. 만약 덮을 수 없으면 -1을 출력한다.

<문제 1344>
홍준이는 축구 경기를 보고 있다. 그러다가 홍준이는 역시 두 팀 중 적어도 한 팀이 골을 소수로 득점할 확률이 궁금해 졌다. 축구 경기는 90분동안 이루어지고, 분석을 쉽게하기 위해서 경기를 5분 간격으로 나눴다. 처음 간격은 처음 5분이고, 두 번째 간격은 그 다음 5분, 그리고 이런식으로 나눈다. 경기가 진행되는 동안 각 간격에서 A팀이 득점할 확률과 B팀이 득점할 확률이 주어진다. 그리고, 각 간격에서 두 팀은 각각 많아야 한 골을 득점할 수 있다. 경기가 끝난 후 적어도 한 팀이 골을 소수로 득점할 확률을 구하시오.
<입력값>
첫째 줄에 A팀이 득점할 확률, 둘째 줄에 B팀이 득점할 확률이 퍼센트 단위로 주어진다. 퍼센트 단위로 주어지는 확률은 모두 0보다 크거나 같고 100보다 작거나 같은 정수이다.
<출력값>
첫째 줄에 적어도 한 팀이 골을 소수로 득점할 확률을 출력한다. 정답과의 절대/상대 오차가 10-6이내인 경우에 정답이다.

<문제 1345>
수학에서 등차수열은 두 개의 연속된 숫자의 차이가 항상 일정한 수열이다. 예를 들어, 3 5 7 9 11 13은 차이가 2인 등차수열이다. 등차수열은 An = A0+n*d와 같이 표현할 수 있다.
수열 S가 주어진다. 수열 Si = ⌊Ai+1⌋이다. 그리고, 감소하지 않는 수열이다. ⌊x⌋는 x보다 작거나 같은 정수 중 가장 큰 값이다. 예를 들어 ⌊3.4⌋ = 3, ⌊0.6⌋ = 0, ⌊-1.2⌋ = -2, ⌊-0.6⌋ = 1이다.
수열 A는 A0+i*d와 같이 정의할 수 있다. 가능한 d의 값 중 가장 작은 값을 구하는 프로그램을 작성하시오. d는 0 이상이다.
<입력값>
첫째 줄에 주어지는 수열 S의 개수 N과 A0이 주어진다. 둘째 줄에 S0부터 SN-1까지 주어진다. N은 0보다 크거나 같고, 50보다 작거나 같은 자연수이고, 나머지 수는 모두 절댓값이 106보다 작거나 같은 정수이다.
<출력값>
첫째 줄에 가능한 d중 최솟값을 출력한다. 절대/상대 오차는 10-9까지 허용한다. 만약, 그러한 것이 없을 때는 -1을 출력한다.

<문제 1346>
기훈이는 각각 계단에 몇 개의 사탕이 놓여있는 계단을 찾았다. 기훈이는 가능하면 많은 사탕을 모으려고 한다. 각각의 계단은 이차원 평면에서 x축에 평행하고 양의 y좌표 값을 갖는 직선으로 표현될 수 있다. 계단은 모두 겹치지 않으며, 같은 끝점을 갖는 계단은 없다.
기훈이가 계단위에 있을 때, 기훈이는 계단의 양 끝으로 자유롭게 움직일 수 있고, 계단 위의 사탕을 모두 모을 수 있다. 기훈이는 계단 위의 한 점에서 (끝 점도 포함) 다른 계단 위의 한 점으로 점프 할 수 있다. 단, 그 때 두 점 사이의 거리가 K보다 작거나 같아야 한다. 그리고, 기훈이는 y좌표가 현재와 같거나 큰 곳으로만 이동할 수 있다.
기훈이는 좌표 (0, 0)에서 시작한다. 그리고 첫 번째 점프를 위해서 자유롭게 이동할 수 있다. 기훈이가 모을 수 있는 사탕 개수의 최댓값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 주어지는 계단의 개수 N과 K가 주어진다. 둘째 줄부터 N개의 줄에 각 계단의 정보가 주어진다. 계단의 정보는 계단 위의 사탕 개수, 가장 왼쪽 점의 X좌표, Y좌표, 계단의 길이와 같이 주어진다. N은 100보다 작거나 같은 자연수이고, X와 Y좌표는 10,000보다 작거나 같은 자연수이다. 계단의 길이는 최대 1,000인 자연수이고, 사탕은 9,999를 넘지 않는 양의 정수 또는 0이다. K는 10,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 기훈이가 모을 수 있는 사탕 개수의 최댓값을 출력한다.

<문제 1347>
홍준이는 미로 안의 한 칸에 남쪽을 보며 서있다. 미로는 직사각형 격자모양이고, 각 칸은 이동할 수 있거나, 벽을 포함하고 있다. 모든 행과 열에는 적어도 하나의 이동할 수 있는 칸이 있다. 홍준이는 미로에서 모든 행과 열의 이동할 수 있는 칸을 걸어다녔다. 그러면서 자신의 움직임을 모두 노트에 쓰기로 했다. 홍준이는 미로의 지도를 자기 노트만을 이용해서 그리려고 한다.
입력으로 홍준이가 적은 내용이 주어진다. 문자열로 이루어져 있으며, 모든 문자 하나는 한 번의 움직임을 말한다. ‘F’는 앞으로 한 칸 움직인 것이고, ‘L'과 ’R'은 방향을 왼쪽 또는 오른쪽으로 전환한 것이다. 즉, 90도를 회전하면서, 위치는 그대로인 것이다.
<입력값>
첫째 줄에 홍준이가 적은 내용의 길이가 주어진다. 길이는 0보다 크고, 50보다 작다. 둘째 줄에 그 내용이 주어진다.
<출력값>
첫째 줄에 미로 지도를 출력한다. ‘.’은 이동할 수 있는 칸이고, ‘#’는 벽이다.

<문제 1348>
세준 주차장은 R*C크기의 직사각형 모양이다. 세준 주차장에는 N개의 차와, M개의 주차 구역이 있다. 그리고, 모든 차는 주차 구역에 주차하려고 한다. 교통 제한 때문에, 차는 주차장의 경계와 평행하게만 움직일 수 있고, 모든 차는 1초에 한 칸씩 움직일 수 있다.
보통 모든 차는 현재 위치에서 가장 가까운 위치에 있는 주차 구역에 주차를 하려고 한다. 하지만, 다음과 같이 생긴 주차장이라면 현재 위치에서 가장 가까운 위치에 주차하는 것이 비효율적이다.

.C.....P.X...
XX.......X..P
XX.....C.....
(‘C’는 차이고, 'P‘는 주차 구역, 'X'는 벽이고, '.'은 빈 공간이다.)
만약 아래에 있는 차가 현재 위치에서 가장 가까운 곳에 주차를 한다면, 왼쪽 위에 있는 차는 가장 오른쪽에 있는 주차 구역에 주차를 해야 할 것이다. 이렇게 되면, 그 차가 주차하기 까지 14라는 시간이 걸린다. 하지만, 만약 아래에 있는 차가 오른 쪽에 있는 주차 구역에 주차를 하게 된다면, 두 차가 주차하기 까지 6이라는 시간이 걸린다.
현재 주차장의 모양과, 차의 위치, 주차 구역의 위치가 주어졌을 때, 모든 차가 주차하는데 걸리는 시간의 최솟값을 구하는 프로그램을 작성하시오. 차는 매우 작기 때문에, 한 칸에 여러 대의 차가 동시에 들어갈 수 있다. 차는 빈 공간과, 주차 구역만 통과할 수 있지만, 벽은 통과할 수 없다.
만약 모든 차가 주차하는 것이 불가능하다면, -1을 출력한다.
<입력값>
첫째 줄에 주차장의 세로 크기 R과 가로 크기 C가 주어진다. R과 C의 크기는 50보다 작거나 같다. 둘째 줄부터 R개의 줄에는 주차장의 정보가 주어진다. 주차장의 정보는 왼쪽에 나와있는 예와 같으며, 차의 개수와, 주차 구역의 개수는 모두 0보다 크거나 같고 100을 넘지 않는다.
<출력값>
첫째 줄에 모든 차가 주차하는데 걸리는 시간의 최솟값을 출력한다. 차가 없는 경우는 0을 출력한다.

<문제 1349>
머나먼 곳에 건축가들만 사는 나라가 있다. 그들은 이미 몇 개의 도시를 만들었다. 그리고 그 도시중 몇 개는 양방향 도로로 연결되어 있다. 또 모든 도시는 몇 개의 집이 있다. 모든 집에는 한 명의 건축가만 살 수 있다.
이 나라는 두 개의 건설 작업을 하려고 한다.
첫 번째 작업은 새로운 양방향 도로를 짓는 것인데, 이때 모든 도시는 다른 도시로 가는 경로가 모두 있어야 한다. 두 도시 사이에 도로를 지을 때는 두 도시에 사는 모든 건축가들이 참여한다. 그리고, 각각의 건축가는 R이란 돈을 내야 한다.
두 번째 작업은 새로운 집을 짓는 것이다. 이때 이 작업이 끝난 후에 각 도시에 있어야 하는 집의 개수가 주어진다. 이때는 그 도시의 건축가와 이웃한 도시의 모든 건축가가 참여한다. 그리고, 모든 건축가는 H[i] (i번도시에 집을 짓는데 드는 비용)을 내야 한다. 두 도시가 도로로 직접 연결되어 있을 때 이웃이라고 한다. 집을 짓게되면 그 즉시 새로운 건축가가 살게 된다.
두 작업을 마치는데 드는 비용의 최솟값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 도시의 개수 N이 주어진다. 둘째 줄에는 현재 각 도시에 있는 집의 개수가 1번 도시부터 차례대로 주어진다. 셋째 줄에는 두 번째 작업이 끝난 후 각 도시에 있어야 하는 집의 개수가 1번 도시부터 차례대로 주어진다. 넷째 줄에는 각 도시에 집을 짓는데 드는 비용이 1번 도시부터 주어진다. 넷째 줄부터 N개의 줄에는 도로가 주어진다. 도로는 인접행렬과 같은 형태로 주어지고, Y는 도로가 있는 것, N은 도로가 없는 것이다. 마지막 줄에는 도로를 짓는데 드는 비용 R이 주어진다. N은 50보다 작거나 같은 자연수이고, 그 이외의 모든 숫자는 100,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 두 작업을 마치는데 드는 비용의 최솟값을 출력한다.

<문제 1350>
어떤 파일 시스템에는 디스크 공간이 파일의 사이즈와 항상 같지는 않다. 이것은 디스크가 일정한 크기의 클러스터로 나누어져 있고, 한 클러스터는 오직 한 파일만 이용할 수 있기 때문이다.
예를 들어, 클러스터의 크기가 512바이트이고, 600바이트 파일을 저장하려고 한다면, 두 개의 클러스터에 저장하게 된다. 두 클러스터는 다른 파일과 공유할 수 없기 때문에, 디스크 사용 공간은 1024바이트가 된다.
파일의 사이즈와 클러스터의 크기가 주어질 때, 사용한 디스크 공간을 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 파일의 개수 N이 주어진다. N은 1,000보다 작거나 같은 자연수이다. 둘째 줄에는 파일의 크기가 공백을 사이에 두고 하나씩 주어진다. 파일의 크기는 1,000,000,000보다 작거나 같은 음이 아닌 정수이다. 마지막 줄에는 클러스터의 크기가 주어진다. 이 값은 1,048,576보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 사용한 디스크 공간을 출력한다.

<문제 1351>
무한 수열 A는 다음과 같다.

A0 = 1
Ai = A⌊i/P⌋ + A⌊i/Q⌋ (i ≥ 1)

N, P와 Q가 주어질 때, AN을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 3개의 정수 N, P, Q가 주어진다.
<출력값>
첫째 줄에 AN을 출력한다.

<문제 1352>
Ideal String은 첫 문자의 인덱스를 1이라고 했을 때, 문자열에서 각각의 문자에 대해 그 문자가 가장 먼저 나타난 것의 인덱스만큼 그 문자가 나타나는 문자열이다.
예를 들어, BAOOOA는 Ideal String이다. 그 이유는 B는 1번 등장하고, A는 2번, O는 3번 등장하기 때문이다.
문자열의 길이 N이 주어졌을 때, 길이가 N인 가장 빠른 Ideal String을 출력하는 프로그램을 작성하시오. 만약 그런 문자열이 없을 때는 -1을 출력한다.
<입력값>
첫째 줄에 N이 주어진다. N은 100보다 작거나 같다.
<출력값>
첫째 줄에 정답을 출력한다.

<문제 1353>
음이 아닌 수의 리스트가 있을 때, 그 리스트에 있는 수의 합이 S이고, 곱이 P일 때, 만족하는 리스트라고 한다.
S와 P가 주어졌을 때, 가능한 만족하는 리스트의 크기중 최소를 출력한다. 리스트의 크기란 그 리스트에 있는 수의 개수를 말한다. 만약 그러한 것이 없다면 -1을 출력한다.
리스트에는 정수가 아닌 수가 포함될 수도 있다.
<입력값>
첫째 줄에 S와 P가 주어진다. S와 P는 1,000,000,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 정답을 출력한다.

<문제 1354>
무한 수열 A는 다음과 같다.

Ai = 1 (i ≤ 0)
Ai = A⌊i/P⌋-X + A⌊i/Q⌋-Y (i ≥ 1)

N, P, Q, X, Y가 주어질 때, AN을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 5개의 정수 N, P, Q, X, Y가 주어진다.
<출력값>
첫째 줄에 AN을 출력한다.

<문제 1355>
지민이는 어제 컨닝으로 3등을 했다. 따라서 김샘은 지민이에게 케이크를 주려고 했지만, 막상 주려니 너무 아까워서 정사각형 모양의 구멍을 낸 후에 주었다. 따라서 케이크를 위에서 보면 정사각형모양 안에 정사각형 구멍이 있는 꼴이 되었다.
두 정사각형의 중심은 좌표 (0, 0)이고, 모든 변은 x축 또는 y축에 평행하다.
지민이는 케이크를 친구들과 함께 먹기 위해 자르려고 한다. 일단 수평으로 H번 자르고, 수직으로 V번 자르려고 한다. 수평으로 자를 때는 x축과 평행하면서 (0, H[i])를 지나게 자르고, 수직으로 자를 때는 y축과 평행하면서 (V[i],0)을 지나게 자른다. 모든 커팅은 무한한 길이를 가진다.
케이크의 크기가 주어진다. 이 크기는 케이크의 한 변의 길이의 절반이다. 그리고, 구멍의 크기가 주어진다. 마찬가지로 구멍의 한 변의 길이의 절반이다. 지민이가 케이크를 자른 후에 케이크가 총 몇 조각 나는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 케이크의 크기 구멍의 크기가 주어진다. 이 값은 2보다 크거나 같고 100보다 작거나 같으며, 구멍의 크기는 케이크의 크기보다 작다. 둘째 줄에는 수평으로 자른 횟수가 주어지고, 셋째 줄에는 그 횟수만큼 H[i] (문제 설명에 나온 좌표)가 주어진다. 넷째 줄에는 수직으로 자른 횟수가 주어지고 그 다섯째 줄에는 그 횟수만큼 V[i]가 주어진다. 자른 횟수의 제한은 50보다 작거나 같은 자연수 또는 0이다. 횟수가 0일 때는 각각 셋째 줄 또는 다섯째 줄에 아무 숫자도 주어지지 않는다.
<출력값>
첫째 줄에 조각의 개수를 출력한다.

<문제 1356>
유진수는 어떤 수를 10진수로 표현한 뒤 그 수를 두 부분으로 나눴을 때, 앞부분 자리수의 곱과 뒷부분 자리수의 곱이 같을 때를 말한다.
예를 들어, 1221은 유진수이다. 12와 21로 나눴을 때, 앞부분 자리수의 곱 1*2는 뒷부분 자리수의 곱 2*1과 같기 때문이다. 1236도 마찬가지로 유진수이다. 하지만, 1234는 아니다. 수를 나눌 때 항상 연속된 자리수를 나눠야하고, 각 부분에 적어도 한자리는 있어야 한다.
예를 들어, 12345는 총 4가지 방법으로 나눌 수 있다. 1-2345, 12-345, 123-45, 1234-5 어떤 수 N이 주어질 때, 이 수가 유진수인지 아닌지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 수 N이 주어진다. 이 수는 2,147,483,647보다작거나 같은 자연수이다.
<출력값>
첫째 줄에 N이 유진수이면 YES, 아니면 NO를 출력한다.

<문제 1357>
어떤 수 X가 주어졌을 때, X의 모든 자리수가 역순이 된 수를 얻을 수 있다. Rev(X)를 X의 모든 자리수를 역순으로 만드는 함수라고 하자. 예를 들어, X=123일 때, Rev(X) = 321이다. 그리고, X=100일 때, Rev(X) = 1이다.
두 양의 정수 X와 Y가 주어졌을 때, Rev(Rev(X) + Rev(Y))를 구하는 프로그램을 작성하시오
<입력값>
첫째 줄에 수 X와 Y가 주어진다. X와 Y는 1,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 문제의 정답을 출력한다.

<문제 1358>
지난주에, 민식주식회사는 IIHF(International Ice Hockey Federation)로부터 긴급한 전화를 받았다.
IIHF는 같은 팀이 링크안에 너무 많으면 알람이 울리는 시스템을 설치해달라고 요청했다. 시스템은 다음과 같이 3개의 부분으로 이루어진다.

디지털카메라가 링크의 사진을 매 1초마다 찍는다.
디지털카메라가 찍은 사진에서 각 선수의 위치를 뽑아낸다.
하키 링크 안에 같은 팀 선수가 총 몇 명인지 계산한다.

하키 링크는 (X, Y)가 가장 왼쪽 아래 모서리인 W * H 크기의 직사각형과, 반지름이 H/2이면서 중심이 (X, Y+R), (X+W, Y+R)에 있는 두 개의 원으로 이루어져 있다. 아래 그림을 참고한다.
선수들의 위치가 주어질 때, 링크 안 또는 경계에 있는 선수가 총 몇 명인지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 수 W H X Y P가 주어진다. P는 선수의 수이다. W와 H는 100보다 작거나 같은 자연수이고, H는 짝수이다. X와 Y는 절댓값이 100보다 작거나 같은 정수이다. P는 최대 100인 자연수이다. 둘째 줄부터 P개의 줄에 각 선수들의 x좌표와 y좌표가 주어진다. 이 좌표는 절댓값이 300보다 작거나 같은 정수이다.
<출력값>
첫째 줄에 링크 안에 있는 선수의 수를 출력한다.

<문제 1359>
어제, 지민이는 몰래 리조트에 갔다가 입구에 걸려있는 복권 광고를 하나 보았다.
“1부터 N까지의 수 중에 서로 다른 M개의 수를 골라보세요. 저희도 1부터 N까지의 수 중에 서로 다른 M개의 수를 고를건데, 적어도 K개의 수가 같으면 당첨입니다.!”
지민이는 돌아오면서 자신이 복권에 당첨될 확률이 궁금해졌다.
지민이가 복권에 당첨될 확률을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N M K가 주어진다. N은 2보다 크거나 같고, 8보다 작거나 같은 자연수이고, M은 1보다 크거나 N-1보다 작거나 같은 자연수이다. K는 1보다 크거나 같고 M보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 지민이가 복권에 당첨될 확률을 출력한다. 절대/상대 오차는 10-9까지 허용한다.

<문제 1360>
민식이는 다음과 같이 두 개의 명령만 지원하는 새로운 텍스트 에디터를 만들었다.

“type c" : 현재 글의 가장 뒤에 문자 c를 추가한다.
“undo t" : 이전 t초동안 수행된 작업을 역순으로 되돌린다.

처음 텍스트 에디터는 비어있다.
예를 들어, 다음과 같은 명령을 진행했다고 하자.

1초 : type a
2초 : type b
3초 : type c
5초 : undo 3

3초가 끝날 때, 텍스트는 "abc"이다. 5초때, 이전 3초동안 한 작업을 역순으로 되돌려야 한다. c는 지워지고, b도 지워질 것이다. 따라서 a만 남는다.
되돌리기가 되돌리기 될 수도 있다.
예를 들어

1초 : type a
2초 : type b
3초 : undo 2
4초 : undo 2

2초일 때, 텍스트는 “ab"이다. 3초때 모든 것이 되돌리기 되므로 텍스트는 빈 텍스트가 되고, 4초때 3초때 되돌리기 한 것이 되돌리기 되고, 2초때 type b한 것이 지워진다. 따라서 텍스트는 ”a"가 된다.
명령과 수행한 시간이 주어질 때, 마지막에 남은 텍스트를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 명령의 개수 N이 주어진다. 둘째 줄부터 N개의 줄에 명령과 수행한 시간이 주어진다. 항상 시간이 오름차순으로 주어지고, type c에서 c는 알파벳 소문자, undo t에서 t는 1보다 크거나 같고 10^9보다 작거나 같은 자연수이다. N은 100보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 모든 명령을 수행한 후에 남아있는 텍스트를 출력한다.

<문제 1361>
두 개의 문자열 S1과 S2가 주어진다. 각각의 문자열은 몇 개의 알파벳 대문자와 하나의 별표(*)가 있다.
별표를 알파벳 대문자로 이루어진 문자열로 대체해서 (빈 문자열로 대체하는 것도 가능) 두 문자열을 같게 만들어야 한다.
가능한 문자열 중 최소 길이인 문자열을 출력하는 프로그램을 작성하시오. 만약 불가능할 때는 -1을 출력한다.
<입력값>
첫째 줄에 문자열 S1, 둘째 줄에 문자열 S2가 주어진다. 문자열의 길이는 100보다 작거나 같은 자연수이다. 각각의 문자열은 0개 이상의 알파벳 대문자와 하나의 별표(*)로 이루어져 있다.
<출력값>
첫째 줄에 가능한 문자열 중 최소길이인 것을 출력한다. 만약 불가능할 때는 -1을 출력한다.

<문제 1362>
당신은 게임으로 펫을 기르고 있습니다. 이 펫은 웃는 표정, 슬픈 표정을 가지고 있으며, 만약 죽는다면 '드러눕습니다.'
펫에게는 적정 체중이 있습니다. 펫의 실제 체중이 적정 체중의 1/2배를 초과하면서 적정 체중의 2배 미만이라면 펫은 행복합니다. 펫의 실제 체중이 0 이하일 경우 펫은 사망하게 되며, 그 외의 경우 펫은 슬픕니다.
당신은 콘솔을 통해 펫에게 아래의 두 가지 작용을 할 수 있습니다.

'E'와 숫자를 입력해 펫을 운동시킬 수 있습니다. 입력된 숫자(n)만큼의 시간(분; minute)이 지나면 펫의 실제 체중이 n 감소합니다.
'F'와 숫자를 입력해 펫에게 먹이를 줄 수 있습니다. 입력된 숫자(n)만큼 펫에게 먹이를 주면 펫의 실제 체중이 n 증가합니다.

각 작용에 입력할 수 있는 숫자는 1 이상, 999 이하의 정수입니다. 매 작용이 끝날 때마다 펫은 자신의 상태를 표시하며, 펫이 중간에 죽는다면 이후의 작용은 무시됩니다.
<입력값>
입력은 번호를 가진 시나리오들로 구성됩니다. 시나리오는 1번부터 시작되며 1씩 증가합니다.
적정 체중(o)와 실제 체중(w)가 한 줄에 입력됨으로써 시나리오가 시작됩니다(10 ≤ o, w ≤ 1000). 그 다음 줄부터 펫에 가할 작용이 한 줄에 하나씩 주어지며, "# 0"을 마지막 줄로 하여 시나리오가 종료됩니다. "# 0"은 처리하지 않습니다.
펫에게 가할 각 작용은 'E' 또는 'F'로 시작하며, 공백을 두고 숫자 n (1 ≤ n ≤ 999)이 주어집니다.
모든 시나리오가 끝나면 "0 0"이 입력되며, "0 0"은 처리하지 않습니다.
<출력값>
각 시나리오에 대하여, 시나리오 번호와 모든 작용이 완료된 후 펫의 상태를 공백으로 구분하여 한 줄씩 출력합니다.

행복한 경우, ":-)"을 출력합니다.
슬픈 경우 ":-("을 출력합니다.
사망한 경우 "RIP"를 출력합니다.

<문제 1363>
지성이는 매우 운이 좋게도 "Goggle"이라는 회사에 일하게 되었다. 그는 자신에게 주어진 첫 번째 임무를 멋있게 수행함으로써 자신의 능력을 보여주고 싶었다. 그의 첫 번째 임무는 효율적인 검색 엔진을 구성하는 것이었다. 그는 검색엔진에 사용되는 서로 다른 k개의 A1, A2, ..., Ak 정수로 구성된 key를 받았다. 
사용자는 검색엔진에 자신이 검색하고자 하는 1 이상 n 이하인 수 s를 입력한다. 지성이는 곰곰이 생각한 끝에 이진탐색트리를 이용하여 이 임무를 수행하기로 결정했다.
이진트리는 하나의 노드에서 이것과 연결된 자식이 0, 1, 2개로 구성된 트리이다. 그리고 서브트리와 연결된 노드를 루트라 한다. 만약 우리가 이 노드 상에 key 값을 넣는다면 각각의 노드는 서로 다른 key 값을 가지게 될 것이다. 
이진탐색트리란 자신의 왼쪽과 오른쪽 서브트리가 모두 이진탐색트리이고 왼쪽 서브트리의 모든 노드의 key 값이 루트의 key 값보다 작고 오른쪽 서브트리의 모든 key 값이 루트의 key 값보다 큰 이진 트리를 말한다.

트리(a)는 1, 3, 7, 11의 key 값으로 구성된 이진트리라는 것을 알 수 있다. 위의 세 개의 트리 중 이진탐색트리인 것은 (b)와 (c)이다. 그리고 트리(a),(b)의 루트는 1이고 트리(c)의 루트는 7이라는 것을 알 수 있다.
이진탐색트리에서의 탐색 방식은 아래의 순서를 따른다.

루트에서부터 시작한다.
만약 사용자가 입력한 s가 현재 노드의 key값과 일치한다면 key 값을 찾은 것이고 아니라면 step 3으로 넘어간다.
만약 s가 현재 노드의 key값보다 작으면 왼쪽서브트리로, 크다면 오른쪽 서브트리로 이동한다. (만약 이동한 서브트리가 비었다면 key값은 찾지 못한 것으로 종료된다.) step 2로 이동한다.

이 이진탐색트리의 효율성은 1부터 n까지 각각의 수들을 검색할 때의 횟수의 총 합으로 따지며 이 값이 작을수록 효율성이 높다고 한다. 트리(c)를 검색엔진으로 사용했을 때 n이 11일 경우 각각의 수들에 대한 횟수가 아래 표로 나타나있다.



key
1
2
3
4
5
6
7
8
9
10
11


횟수
2
3
3
3
3
3
1
2
2
2
2



우리가 해야 할 일을 지성이를 도와주어진 n에 대해 총 합이 가장 작게 되는 이진탐색트리를 찾는 것이다. 단, key 값의 최댓값은 n보다 항상 작거나 같다고 하자.위의 표에서 횟수의 총 합은 26이 되고 이 트리의 효율성은 26으로 판정된다.
<입력값>
첫 번째 줄에 n (1 ≤ n ≤ 10,000,000)이 입력된다. 두 번째 줄에는 key의 개수인 k (k ≤ 300)가 입력되고 그 아래로 k개의 줄에 차례대로 Ai (1 ≤ Ai ≤ 10,000,000)의 값이 입력된다.
<출력값>
효율성이 가장 좋은 이진탐색트리에 대한 총합을 출력한다.

<문제 1364>
육각형 블록들로 이루어진 RPG 세계가 있다. 그 세계에 나라를 세우려고 하는 군주 캐릭터 송유진은 일반 블록을 울타리 블록으로 바꿀 수 있는 아이템을 N개 가지고 있다. 유진이가 이 N개의 아이템을 이용해서 점령할 수 있는 최대의 영토의 넓이를 구해보자. 울타리 안에 둘러싸인 블록들은 당연히 넓이에 포함 시키고, 울타리를 세운 블록도 넓이에 포함을 시킨다. 울타리는 항상 이어져 있어야 하며, 맵의 넓이는 무한하다.
<입력값>
첫 줄에는 송유진이 가지고 있는 아이템의 수 N(1≤N≤1,000,000)이 주어진다.
<출력값>
N개의 아이템을 이용하여 점령할 수 있는 최대의 블록 수를 출력한다.

<문제 1365>
공화국에 있는 유스타운 시에서는 길을 사이에 두고 전봇대가 아래와 같이 두 줄로 늘어서 있다. 그리고 길 왼편과 길 오른편의 전봇대는 하나의 전선으로 연결되어 있다. 어떤 전봇대도 두 개 이상의 다른 전봇대와 연결되어 있지는 않다.

문제는 이 두 전봇대 사이에 있는 전깃줄이 매우 꼬여 있다는 점이다. 꼬여있는 전깃줄은 화재를 유발할 가능성이 있기 때문에 유스타운 시의 시장 임한수는 전격적으로 이 문제를 해결하기로 했다.
임한수는 꼬여 있는 전깃줄 중 몇 개를 적절히 잘라 내어 이 문제를 해결하기로 했다. 하지만 이미 설치해 놓은 전선이 아깝기 때문에 잘라내는 전선을 최소로 하여 꼬여 있는 전선이 하나도 없게 만들려고 한다.
유스타운 시의 시장 임한수를 도와 잘라내야 할 전선의 최소 개수를 구하는 프로그램을 작성하시오.
<입력값>
첫 줄에 전봇대의 개수 N(1 ≤ N ≤ 100,000)이 주어지고, 이어서 N보다 작거나 같은 자연수가 N개 주어진다. i번째 줄에 입력되는 자연수는 길 왼쪽에 i번째 전봇대와 연결된 길 오른편의 전봇대가 몇 번 전봇대인지를 나타낸다.
<출력값>
전선이 꼬이지 않으려면 최소 몇 개의 전선을 잘라내야 하는 지를 첫째 줄에 출력한다.

<문제 1366>
음악에서 음표는 다음과 같이 12개의 이름이 있다. 오름차순으로 A, A#, B, C, C#, D, D#, E, F, F#, G, G# 이다.
이 음은 이것보다 더 높아질 때, 낮아질 때, 모두 이 순서대로 다시 반복되기 때문에, G#보다 한음 높은 음은 A이고, B보다 다섯 음 낮은 음은 F#이다. 따라서, 어떤 음에서 12음 떨어진 음은 항상 자기 자신이 된다. 이 문제에서 같은 이름을 가지고 있으면, 옥타브와 상관없이 같은 음으로 생각한다.
기타는 여러 개의 줄을 가지고 있는 악기이고, 각 줄은 12개의 음 중 하나로 튜닝되어 있다. 각 줄에서 나는 소리를 열린 음이라고 한다. 줄의 아래에는 프렛이 있는데, 프렛은 1번 프렛부터 차례때로 번호가 있다. 프렛을 누르게 되면 줄의 음이 변하게 된다. 어떤 줄의 i번을 누르게 되면, 그 줄의 열린 음보다 i만큼 높은 음이 울린다.
예를 들어, 어떤 줄의 열린 음이 C#일 때, 3번 프렛을 누르고 그 줄을 친다면 E가 소리난다.
코드는 동시에 치는 음의 집합이다. 기타에서 코드를 치기 위해서, 각 줄은 코드에 있는 음 중 하나의 음을 반드시 소리 내야 한다. 그리고 코드에 있는 음 모든 음이 소리 나야 한다.
각 코드를 치는 방법은 여러 가지가 있다. 민식이는 코드를 치는 난이도를 손을 얼마나 뻗느냐로 매기려고 한다. 프렛을 누른 줄 중 가장 높은 프렛의 번호에서 가장 낮은 프렛의 번호를 뺀 후에 1을 더하면 그것이 그 코드의 난이도이다. 이때, 반드시 프렛을 누른 줄만 계산에 포함시켜야 한다. 따라서, 프렛을 누르지 않은 열린 줄의 경우에는 코드의 난이도에 영향을 미치지 않는다. 만약 어떤 코드가 프렛을 누르지 않고 칠 수 있다면, 그 코드의 난이도는 0이 된다.
기타의 줄의 개수 N과, 각 줄이 무슨 음으로 튜닝되어 있는지가 주어진다. 그 때, 코드를 구성하는 음이 주어질 때, 그 코드의 가능한 난이도 중 최솟값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N과 M이 주어진다. N은 기타의 줄의 개수이고, M은 코드를 구성하는 음의 개수이다. 둘째 줄에는 각 줄이 무슨 음으로 튜닝되어 있는지 N개의 음이 주어지고, 셋째 줄에는 각 코드를 구성 하는 M개의 음이 주어진다. 코드를 구성하는 음은 중복되지 않으며, 음은 모두 문제의 초반에 나온 12개의 음만 주어진다. (N,M<=6)
<출력값>
첫째 줄에 가능한 난이도 중 최솟값을 출력한다.

<문제 1367>
Tablature (타브 악보)는 프렛이 있는 현악기를 연주할 때, 많이 쓰는 악보이다. 각 줄은 줄을 의미하고, 줄에 쓰여 있는 숫자는 그 줄을 연주 하기 위해서 눌러야 하는 프렛의 번호를 의미한다.

------------
-3----------
-------0----
---2--------
-------0----
------------
가장 윗 줄은 첫 번째 줄이다. 그 밑은 둘째 줄이고, 그런 식으로 계속 된다.  타브 악보는 왼쪽부터 오른쪽으로 읽는다. i번째 열은 시간 i에 연주하는 음이다. 위의 예제에서 0번 열은 아무 숫자가 안 쓰여 있다. 따라서 아무 음도 연주하지 않는다. 시간 1에는 2번 줄의 3번 프렛을 잡고 그 줄을 연주한다. 시간 3에는 4번 줄의 2번 프렛을 잡고 그 줄을 연주하며, 마지막으로 시간 7에 두 개의 음표를 코드로 동시에 연주해야 한다. 숫자 0은 프렛을 누르지 않고 연주하는 것을 의미한다. 이것을 열린 줄이라고 말하며, 위의 예에서 셋째 줄, 다섯째 줄을 동시에 연주하면 된다.
모든 열린 줄은 다른 음정을 가지고 있다. 예를 들어, 보통 기타 튜닝에선 첫 번째 줄의 음정이 두 번째 줄보다 5 반음 높다. 그리고, N번 프렛을 잡고 연주했을 때, 그 줄의 열린 음의 음정보다 N반음 높은 음이 연주된다.
악기 A (예를 들어 기타)로 연주 하는 타브 악보가 주어진다. 하지만, 이것을 악기 B (예를 들어 만돌린)로 연주하려고 한다. 그리고 지금 현재 악기 A와 악기 B의 열린 음의 음정을 모두 알고 있다.
모든 악기는 35프렛을 가지고 있다. 따라서 타브 악보에 쓰여 있는 숫자는 0~9 그리고, A~Z이다. A~Z는 10~35에 해당한다.
이 문제는 원래 타브 악보를 악기 B를 위한 타브 악보로 바꾸는 프로그램을 작성하는 것이다. 다른 악기는 서로 다른 음역대를 가지고 있기 때문에, 원래 노래를 조옮김해서 악보로 작성해야 한다. 따라서 이것 때문에 D가 주어진다. 따라서, 악보 B를 위한 타브 악보를 만들 때, 모든 음을 D만큼 반음을 올려서 작성해야 한다. D가 음수일 때는 D만큼 반음을 내리는 것이다.
가끔 악보를 바꾸는데 여러 가지 방법이 있을 수도 있다. 이때는 가장 높은 열린 음으로 연주할 수 있는 줄을 선택해야 한다. 만약 그런 줄이 여러 개 있을 때는, 가장 아래에 있는 줄을 선택한다. (줄은 위에서부터 아래까지 적혀있다.)
코드는 위와 같이 한 음 한 음에 대한 규칙과 같은 규칙을 적용하면 된다. 하지만, 반드시 가장 높은음, 그 다음으로 높은음, 이와 같이 순서를 정해서 악보에 적어야 한다. 각각의 줄은 단 하나의 음만 낼 수 있다. 따라서 코드에 있는 음을 악보에 적을 때는, 사용 안 한 줄만 고려하면 된다. 만약 그 코드를 칠 수 없을 때는, 그 열 전체를 x로 표시한다.
<입력값>
첫째 줄에 타브 악보의 줄의 개수 N과 열의 개수 M이 주어진다. N과 M은 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 M개의 문자가 주어진다. 타브 악보가 N개의 줄이 있기 때문에, 악기 A는 줄이 A개이다. 따라서 그 다음 줄에는 1번 줄부터 그 줄의 음정이 주어진다. 음정은 절댓값이 50보다 작거나 같은 정수이다. 그 다음 줄에는 악기 B의 줄의 개수 K가 주어진다. 그 다음 줄에는 악기 B의 1번 줄부터 그 줄의 음정이 주어진다. 마지막 줄에는 D가 주어진다. D는 절댓값이 50보다 작거나 같은 정수이다.
<출력값>
K개의 줄에 정답을 출력한다.

<문제 1368>
선주는 자신이 운영하는 N개의 논에 물을 대려고 한다. 물을 대는 방법은 두 가지가 있는데 하나는 직접 논에 우물을 파는 것이고 다른 하나는 이미 물을 대고 있는 다른 논으로부터 물을 끌어오는 법이다.
각각의 논에 대해 우물을 파는 비용과 논들 사이에 물을 끌어오는 비용들이 주어졌을 때 최소의 비용으로 모든 논에 물을 대는 것이 문제이다.
<입력값>
첫 줄에는 논의 수 N(1 ≤ N ≤ 300)이 주어진다. 다음 N개의 줄에는 i번째 논에 우물을 팔 때 드는 비용 Wi(1 ≤ Wi ≤ 100,000)가 순서대로 들어온다. 다음 N개의 줄에 대해서는 각 줄에 N개의 수가 들어오는데 이는 i번째 논과 j번째 논을 연결하는데 드는 비용 Pi,j(1 ≤ Pi,j ≤ 100,000, Pi,j = Pj,i, Pi,i = 0)를 의미한다.
<출력값>
첫 줄에 모든 논에 물을 대는데 필요한 최소비용을 출력한다.

<문제 1369>
가로 N칸, 세로 N칸으로 되어 있는 정사각형 모양의 배열이 있고, 배열의 각 칸에는 음이 아닌 정수가 하나씩 적혀져 있다. 우리는 이 배열의 배열값을 다음과 같이 찾고자 한다.
배열의 왼쪽 위 칸인 (1, 1)에서 오른쪽 아래 칸인 (N, N)으로의 이동을 생각할 수 있다. 이동할 때는 반드시 현재 위치의 아래 칸이나, 현재 위치의 오른쪽 칸으로만 이동할 수 있다. 물론, 배열 밖으로 나갈 수는 없다. 또한 하나의 제약이 더 있는데, 그 칸에 적혀져 있는 정수가 0인 경우에는 그 칸으로 이동할 수 없다.
이렇게 (1, 1)에서 (N, N)까지 이동하는 경로는 여러 가지가 있을 수 있다. 우리는 이러한 각각의 경로에 대해서 경로값을 정의할 수 있는데, 이동하면서 거쳐 온 2N-1개의 칸에 적혀 있는 모든 정수의 곱을 이 경로의 경로값으로 정의한다. 예를 들어 N=3이고 배열이 아래와 같은 모양이라고 할 때, 거쳐 온 칸에 적혀 있는 정수가 1, 2, 3, 5, 8이 되도록 이동했다면 이 경우 경로값은 240(=1×2×3×5×8)이 된다.

주어진 배열에서 (1, 1)부터 (N, N)까지 이동하는 경로는 매우 많을 수 있으므로, 경로값 또한 다양하게 나타날 수 있다. 이러한 모든 경로값 중에서, 경로값을 나타내는 자연수의 끝자리 0의 개수가 가장 적을 때, 그 0의 개수를 이 배열의 배열값으로 정의한다. 위 배열의 경우 1, 4, 6, 7, 8의 경로로 이동하면 경로값이 1344(=1×4×6×7×8)이 되므로, 이 경우가 끝자리 0의 개수가 가장 적은 경우이다. (240은 끝자리 0의 개수가 1개이므로 0개보다 많다) 따라서 위 배열의 배열값은 0이 된다.
배열이 주어지면 그 배열의 배열값을 계산하는 프로그램을 작성하시오. 항상 (1, 1)에서 (N, N)으로 이동하는 경로가 존재하는 데이터만이 입력으로 들어온다.
<입력값>
첫째 줄에 배열의 크기를 나타내는 자연수 N(2≤N≤1,000)이 주어진다. 둘째 줄부터 N개의 줄에 걸쳐 배열에 적힌 수를 나타내는 정수가 각각 N개씩 빈 칸을 사이에 두고 들어온다. 입력되는 정수는 음 아닌 정수로 그 크기는 1,000,000을 넘지 않는다.
<출력값>
첫째 줄에 이 배열의 배열값을 출력한다.

<문제 1370>
화계라는 것은 불로써 적을 공격하는 계략을 이야기한다. 예를 들자면, 적벽대전에서 바람의 방향을 이용해서 조조군의 방심을 이용했다는 제갈량의 지혜처럼, 화계라는 것은 전쟁에 사용되면 매우 좋은 효과를 본다는 것 만은 확실하다고 알 수 있다. 물론, 그것을 사용하기에는 여러 가지 제약이 따르지만.
요컨데, 불로는 사람을 죽이기 쉽다는 소리다.
그래서 당신은 적군이 있는 곳에 불을 지르려 했다.
그런데 웬걸, 적군은 우리가 화계를 쓸 줄 알고 나무가 없는 곳에 진을 쳤다는 사실을 알았다!
그렇다면 어떻게 해야 할까? 그래. 수계를 쓰자.
N*N크기의 맵이 있다. 적군은 (x,y)에 있고, 우리는 1,1에서 물을 흘린다. 만약 어떤 곳에 물이 있다고 가정하자. 그런데 네 방향중에 더 낮은 (물로 채워진 높이 포함) 곳이 있다면, 그곳을 향해 물이 흐른다.
물은 안정화가 될 때 까지 흐르게 된다. (안정화라는 말은, 어떠한 위치의 물도 다른 방향으로 흐르지 않는다는 의미이다.)
당신은 적군이 있는 곳에 높이 k이상의 물을 채우기 위해서는 얼마의 물이 필요한지 계산하는 것이다.
<입력값>
첫째 줄에는 문제에서 맵의 크기를 나타내는 정수 N(<=400)과 적군이 있는 곳에 채워야 되는 물의 높이 k(<=1,000,000)가 주어진다. 두 번째 줄에는 적군이 있는 위치 x y가 주어진다. 세 번째 줄에서 N+2번째 줄에는 각각 땅이 파여져 있는 깊이가 주어진다. 깊이의 양은 1,000,000을 넘지 않는다.
<출력값>
흘려야 되는 물의 양을 출력한다.

<문제 1371>
영어에서는 어떤 글자가 다른 글자보다 많이 쓰인다. 예를 들어, 긴 글에서 약 12.31% 글자는 e이다.
어떤 글이 주어졌을 때, 가장 많이 나온 글자를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄부터 글의 문장이 주어진다. 글은 최대 5000글자로 구성되어 있고, 공백, 알파벳 소문자, 엔터로만 이루어져 있다. 그리고 적어도 하나의 알파벳이 있다.
<출력값>
첫째 줄에 가장 많이 나온 문자를 출력한다. 여러 개일 경우에는 알파벳 순으로 앞서는 것부터 모두 공백없이 출력한다.

<문제 1372>
영어 대문자로만 이루어진 단어 N개가 주어졌을 때, 이 단어를 모두 부분문자열로 하면서 길이가 가장 짧은 것을 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 단어의 개수 N(1 ≤ N ≤ 12)이 주어진다. 둘째 줄부터 N개의 줄에 단어가 한 줄에 하나씩 주어진다. 단어의 길이는 50보다 작거나 같다.
<출력값>
첫째 줄에 정답을 출력한다. 만약 답이 여러 개일 경우에는 사전순으로 앞서는 것을 출력한다.

<문제 1373>
2진수가 주어졌을 때, 8진수로 변환하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 2진수가 주어진다. 주어지는 수의 길이는 1,000,000을 넘지 않는다.
<출력값>
첫째 줄에 주어진 수를 8진수로 변환하여 출력한다.

<문제 1374>
N개의 강의가 있다. 우리는 모든 강의의 시작하는 시간과 끝나는 시간을 알고 있다. 이때, 우리는 최대한 적은 수의 강의실을 사용하여 모든 강의가 이루어지게 하고 싶다.
물론, 한 강의실에서는 동시에 2개 이상의 강의를 진행할 수 없고, 한 강의의 종료시간과 다른 강의의 시작시간이 겹치는 것은 상관없다. 필요한 최소 강의실의 수를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 강의의 개수 N(1≤N≤100,000)이 주어진다. 둘째 줄부터 N개의 줄에 걸쳐 각 줄마다 세 개의 정수가 주어지는데, 순서대로 강의 번호, 강의 시작 시간, 강의 종료 시간을 의미한다. 강의 번호는 1부터 N까지 붙어 있으며, 입력에서 꼭 순서대로 주어지지 않을 수 있으나 한 번씩만 주어진다. 강의 시작 시간과 강의 종료 시간은 0 이상 10억 이하의 정수이라고 가정한다.
<출력값>
첫째 줄에 필요한 최소 강의실 개수를 출력한다.

<문제 1375>
모두에게 속여왔지만 사실 김지민은 한국의 최고령이다.
지민이는 자신이 나이가 가장 많다는 사실을 알고있지만, 다른 사람들의 나이는 몇 살인지 알지 못한다.
하지만 지민이에게는 최고령자로써의 특별한 능력이 있어서 어떤 두 사람을 보면 누가 더 나이가 많은지 알 수 있다.
이 사기적인 능력을 언제나 사용하면 좋겠지만, 지민이가 너무 늙은 나머지 여러 번 사용하면 힘에 부치기 때문에 m번만 사용하려고 한다.
n명의 사람들이 있다. 지민이는 이 사람들 중에서 두 명을 뽑아 나이를 비교하는 것을 m번 할 수 있다.
그 이후, 어떤 두 사람사이의 나이 관게를 파악하고자 한다. 만약 민식이보다 유진이가 나이가 높고 유진이보다 지민이가 나이가 높다면 민식이보다 지민이가 나이가 높다는 것을 알 수 있을것이다.
우리는 위와 같은 방법을 이용해서, 두 사람의 나이를 비교하고 싶다.
<입력값>
첫째 줄에는 사람들의 수N(<=1,000,000)과 지민이의 사기적인 능력의 사용횟수 M(<=1,000,000)이 주어진다. 두 번째 줄부터 M+1번째 줄 까지는 a b의 형태로 a와 b의 나이를 비교했을 때 a가 더 늙었다 라는 의미가 주어진다. 이름의 길이는 6byte이하이다.
  M+2번째 줄에는 궁금한 쿼리의 개수 Q(<=20)가 주어진다. M+3번째 줄에서 M+Q+2번째 줄 까지는 a b의 형태로 a와 b의 나이를 비교했을 때 누가 더 나이가 많은지 알고싶다는 의미이다.
<출력값>
Q개의 숫자로 각각 쿼리마다 나이가 더 많은 사람의 이름을 출력한다. 나이가 같거나 알 수 없다면 “gg”를 출력한다.

<문제 1376>
DFS와 BFS는 아는가? DFS는 깊이우선탐색, BFS는 넓이우선탐색이다.
이번에는 mFS! 그래, 듣도 보도 못했던 듣보잡 탐색방법인, 민식우선탐색이다.
민식이는 DFS를 할 줄 모르기 때문에 다음과 이 탐색방법을 만들어냈다.
이 탐색방법을 설명하자면 다음과 같다.
기본틀은 DFS와 완전히 동일하다. 그런데 한가지 다른 점이 있다면, 한 점에서 다른 정점을 방문할 때 순서가 다르다. 현재 점에서 방문할 수 있는 정점(갈 수 있으면서 방문한 적 없는 정점들)들이 홀수개면 그 정점 번호들의 중간값인 정점으로 방문을 시작하고, 짝수개면 가장 작은 정점 번호로 방문을 시작한다.
당신의 임무는, 1번 정점에서 출발하여 민식우선탐색을 하는 순서를 찍는 것이다.
<입력값>
첫째 줄에는 정점의 개수 N(<=100,000)과 간선의 개수 M(<=1,000,000)이 주어진다. 두 번째 줄부터 M+1번째 줄 까지는 a b의 형태로 a와 b가 간선으로 연결되어 있다는 의미의 입력이 들어온다. 모든 간선은 양방향이다.
<출력값>
민식우선탐색의 순서를 출력한다.

<문제 1377>
영식이는 다음과 같은 버블 소트 프로그램을 C++로 작성했다.

bool change = false;
for (int i=1; i<=n+1; i++) {
    change = false;
    for (int j=1; j<=n-i; j++) {
        if (a[j] > a[j+1]) {
            change = true;
            swap(a[j], a[j+1]);
        }
    }
    if (change == false) {
        cout << i << '\n';
        break;
    }
}

위 소스에서 n은 배열의 크기이고, a는 수가 들어있는 배열이다. 수는 배열의 1번방부터 채운다.
위와 같은 소스를 실행시켰을 때, 어떤 값이 출력되는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N이 주어진다. N은 500,000보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 A[1]부터 A[N]까지 하나씩 주어진다. A에 들어있는 수는 1,000,000보다 작거나 같은 자연수 또는 0이다.
<출력값>
정답을 출력한다.

<문제 1378>
지민이는 길이가 N인 큰 수를 가지고 있다.
지민이는 이 수에 공백을 적절히 넣어서 오름차순 순열로 만들려고 한다. (같은 수는 안 되고, 0으로 시작하는 수도 된다)
만약 수를 나누는 방법이 여러 가지가 있으면, 가장 마지막 수를 최소로 하려고 한다. 그래도 여러 가지 방법이 있을 때에는, 첫 번째 원소를 최대로, 그래도 같으면, 두 번째 원소를 최대로 하려고 한다. 이렇게 계속 ...
지민이가 구한 오름차순 수열의 모든 원소를 곱해서 1,000,000,003으로 나눈 값을 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 수가 주어진다. 이 수의 길이는 최대 2500이다.
<출력값>
첫째 줄에 곱을 1,000,000,003으로 나눈 값을 출력 한다.

<문제 1379>
N개의 강의가 있다. 우리는 모든 강의의 시작하는 시간과 끝나는 시간을 알고 있다. 이때, 우리는 최대한 적은 수의 강의실을 사용하여 모든 강의가 이루어지게 하고 싶다.
물론, 한 강의실에서는 동시에 2개 이상의 강의를 진행할 수 없고, 한 강의의 종료시간과 다른 강의의 시작시간이 겹치는 것은 상관없다. 필요한 최소 강의실 수 K와, 각 강의마다 강의실을 배정하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 강의의 개수 N(1≤N≤100,000)이 주어진다. 둘째 줄부터 N개의 줄에 걸쳐 각 줄마다 세 개의 정수가 주어지는데, 순서대로 강의 번호, 강의 시작 시간, 강의 종료 시간을 의미한다. 강의 번호는 1부터 N까지 붙어 있으며, 입력에서 꼭 순서대로 주어지지 않을 수 있으나 한 번씩만 주어진다. 강의 시작 시간과 강의 종료 시간은 0 이상 10억 이하의 정수이라고 가정한다.
<출력값>
첫째 줄에 필요한 최소 강의실 개수 K를 출력한다. 둘째 줄부터 N개의 줄에 걸쳐 각 강의에 배정할 강의실 번호를 순서대로 출력한다. 편의상 강의실 번호는 1, 2, ..., K 로 매긴다.

<문제 1380>
파스칼 고등학교에 다니는 많은 여학생들은 규정에 없는 귀걸이를 착용한 채 도망다닙니다. Sneddon 교감선생님은 흔들거리는 긴 빨간 귀걸이들을 볼때마다 압수합니다.
교감선생님은 귀걸이를 압수당한 여학생들을 숫자를 매겨 리스트를 작성하고 있습니다. 그리고 압수한 귀걸이 뒤쪽에 여학생 번호와 마음대로 선택한 'A' 또는 'B'를 함께 적어두었습니다.
모든 정규 일과와 방과후 수업의 감금이 끝나면, 여학생들은 교감선생님을 찾아와 귀걸이를 돌려받습니다. 불행하게도 어느 날, 교감선생님은 귀걸이가 든 봉투를 잃어버렸고, 하나를 끝내 찾지 못했습니다.
귀걸이를 받지 못해 화난 소녀의 이름을 교감선생님께 알려주세요.
<입력값>
입력은 번호를 가진 시나리오들로 구성됩니다. 시나리오 번호는 1부터 순서대로 증가하고, 각 시나리오는 아래의 내용을 포함합니다.

한 줄에 귀걸이를 압수당한 여학생의 수, n (1 ≤ n ≤ 100)이 주어집니다.
다음 n줄에 걸쳐 여학생들의 이름(최대 60자)이 주어집니다.
다음 2n − 1줄에 여학생 번호와 'A' 또는 'B'가 공백을 사이에 두고 주어집니다. 번호는 교감선생님의 여학생 이름 리스트와 순서가 일치합니다. 즉, 1은 첫 번째로 압수당한 여학생입니다. 여학생 번호는 최대 2번 등장하며, 두 번째로 등장할 때는 첫 번째 경우와 다른 'A' 또는 'B'가 뒤에 적힙니다.
	번호가 처음 등장하는 것은 압수되었음을, 두 번째로 등장하는 것은 돌려받았음을 의미합니다.

'0'을 마지막 줄로 하여 입력이 종료됩니다. '0'은 처리하지 않습니다.
<출력값>
시나리오 번호와 귀걸이를 돌려받지 못한 여학생의 이름을 공백으로 구분하여 한 줄씩 출력하십시오.

<문제 1381>
요구르트 여러개가 모두 유통기한이 1/15이다! 고로 임현수는 이 요구르트들을 모두 먹어 치우려고 한다.
문제는 혼자서 요구르트를 먹는데에는 한계가 있다라는 사실이다. 하지만 임현수는 언제나 요구르트를 먹을 때 마다 ‘언젠가는 배터지게 요구르트를 먹어서, 얼만큼 먹을 수 있나 알아보고 싶다’라는 소망을 가지고 있었기에 그에게 있어서 이번 일은 기회가 아닐 수 없다.
총 n개의 요구르트가 있다. 임현수는 이 요구르트 들을 모두 마시고 싶다. 그런데 알고보니 요구르트들의 무게가 미묘하게 달랐다. 임현수는 이 중에서 k개의 요구르트를 먹고 싶다.
문제는 애석하게도 요구르트에는 불량품일 확률이 있다. 만약 불량품을 마신다면 임현수는 정신을 잃고 지민이를 납치할 것이다.
하지만 그 확률이 매우 미미하기 때문에 임현수는 그저 가장 많은 요구르트를 마시고 싶다.
하지만, 지민이는 민식이꺼다.
민식이는 지민이를 뺏기기 싫기 때문에 임현수에게 “n개중에 k개를 마실 때 가장 많은 양의 요구르트를 마시면서 지민이가 납치될 확률이 가장 적은” 요구르트 집합을 주기로 했다.
이때, 지민이가 납치될 확률을 구하여라.
<입력값>
첫째 줄에는 요구르트의 개수 n(1 ≤ n ≤ 1,000,000)과 먹고싶은 요구르트의 개수 k(1 ≤ k ≤ n)가 주어진다. 2번째 줄에서 n+1번째 줄에는 각각의 줄마다 i번째 요구르트의 양 Ui(1 ≤ Ui ≤ 1,000,001)과 그 요구르트가 불량품일 확률 Pi %(0 ≤ Pi ≤ 10)가 주어진다. 모든 입력은 정수로 주어진다.
<출력값>
지민이가 납치될 %확률을 “.3lf"의 형태로 출력한다. 만약 지민이가 납치될 확률이 소수점 4째자리에서 반올림해서 0.001미만 이라면 “GG”를 출력한다.

<문제 1384>
Misfits 아카데미는 문제아들을 위한 치유 시간을 도입했습니다. 그 중 한 가지 활동은 아이들이 타인에 대해 예의를 갖출 수 있도록 고안되었으며, 내용은 아래와 같습니다.
아이들은 원형으로 앉은 뒤 종이 위에 자신의 이름을 적습니다. 다음 각자의 종이를 자기 왼편으로 전달합니다. 종이를 전달받았으면, 종이 맨 위에 쓰인 이름을 가진 아이에 대해 좋은 메시지를 써줍니다. "너는 멋져.", "도와줘서 고마워"같은 말들을요. 메시지는 종이 아래쪽에 적으며, 적은 뒤에는 종이를 접어 가립니다. 다음으로 종이를 왼편으로 넘기고 같은 활동을 반복합니다. 자신의 이름이 맨 위에 적힌 종이를 받으면 활동을 종료하고 각자 다른 아이들이 자기에게 남긴 메시지들을 읽어봅니다.
하지만 가끔 "넌 너무 말이 많아.", "니 옷 후져."처럼 제멋대로 글을 쓰는 아이들이 있습니다. 이런 글을 읽게 되면 기분이 좋지 않겠죠? 이런 말을 한 아이를 알려주세요!
<입력값>
입력은 번호를 가진 그룹들로 이루어져 있습니다. 그룹의 번호는 1부터 시작하며 1씩 증가합니다. 각 그룹의 입력은 참여한 아이들의 수 n(5 ≤ n ≤ 20)이 한 줄에 주어지면서 시작됩니다. 다음 n 줄에 걸쳐 위 활동을 끝마친 종이 n장이 입력됩니다. n 줄의 순서는 아이들이 앉아있고 종이를 넘기던 순서와 같습니다. 예를 들어 첫 번째 줄에 해당하는 아이는 두 번째 줄에 해당하는 아이에게 종이를 넘겼고, 마지막 줄에 해당하는 아이는 첫 번째 줄에 해당하는 아이에게 종이를 넘겼습니다.
각 줄은 종이 맨 위의 이름으로 시작합니다. 다음으로 공백을 사이에 두고 종이에 적힌 메시지가 종이 위에서부터 아래로 순서대로 쓰입니다. 문제를 간단하게 하기 위해 좋은 메시지는 'P'로, 나쁜 메시지는 'N'으로 표기합니다. 이름은 60글자 이하의 알파벳 소문자 또는 대문자로 이루어져 있습니다.
마지막 줄에 '0'이 입력되면서 입력이 종료됩니다. '0'은 처리하지 않습니다.
<출력값>
그룹 번호를 "Group 1"과 같이 출력함으로써 출력을 시작합니다. 그 다음 줄부터 누가(A) 누구(B)에게 나쁜 말을 했는지 "A was nasty about B"로 한 줄씩 출력합니다. 나쁜 말이 여러 개라면, 입력받은 순서대로─첫 번째 종이부터, 왼쪽에서 오른쪽으로─출력합니다. 아무도 나쁜 말을 하지 않았다면 "Nobody was nasty"를 출력합니다.
각 그룹을 빈 줄로 구분합니다.

<문제 1385>
지민이는 벌집에 빠졌다. 출구가 어디에 있는지는 아는데, 어떻게 가야 하는지를 모른다.
그곳에 있는 벌들에 의하면 방의 번호는 다음과 같이 붙는다.

지민이는 지금 a번 방에 있다. b번 방이 출구인데 어떻게 이동해야 할까? 집에는 민식이가 기다리고 있기 때문에, 가장 빠르게 탈출하기 위해 최단거리로 움직이고 싶다.
<입력값>
첫째 줄에는 당신이 있는 방의 번호 a와 출구가 있는 방의 번호 b가 주어진다.1 ≤ a, b ≤ 1,000,000)
<출력값>
첫째 줄에 탈출을 위해 최단거리로 지나는 방의 번호를 공백으로 구분해 출력한다.

<문제 1387>
크기가 N*M인 배열 A와 배열 B가 주어진다. 또, 배열 A와 B에는 0과 1로만 이루어져 있다. 세준이는 배열 A를 교환만으로 배열 B로 만들려고 한다. 한 번의 교환은 두 개의 인접한 원소를 바꾸는 것이다. 인접한 것은 수직, 수평, 대각선으로 인접한걸 의미하고 각각의 칸은 총 8개의 인접한 칸을 가지고 있다. (모서리에 있는 칸, 꼭짓점에 있는 칸은 제외)
하지만, 교환에 제약이 있는데 (i,j)칸은 총 C[i][j]번만 교환에 이용할 수 있다. 배열 A를 배열 B로 만드는데 드는 교환의 최솟값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 배열의 크기 N과 M이 주어진다. N과 M은 20보다 작거나 같다. 둘째 줄부터 N개의 줄에 배열 A가 주어지고 그 다음에는 배열 B 그 다음에는 배열 C가 주어진다.. 배열 C의 원소는 0보다 크거나 같고 9보다 작거나 같다.
<출력값>
첫째 줄에 배열 A를 배열 B로 만드는데 드는 교환의 최솟값을 출력한다. 만약 바꿀 수 없으면 -1을 출력한다.

<문제 1388>
형택이는 건축가이다. 지금 막 형택이는 형택이의 남자 친구 기훈이의 집을 막 완성시켰다. 형택이는 기훈이 방의 바닥 장식을 디자인했고, 이제 몇 개의 나무 판자가 필요한지 궁금해졌다. 나무 판자는 크기 1의 너비를 가졌고, 양수의 길이를 가지고 있다. 기훈이 방은 직사각형 모양이고, 방 안에는 벽과 평행한 모양의 정사각형으로 나누어져 있다.
이제 ‘-’와 ‘|’로 이루어진 바닥 장식 모양이 주어진다. 만약 두 개의 ‘-’가 인접해 있고, 같은 행에 있다면, 두 개는 같은 나무 판자이고, 두 개의 ‘|’가 인접해 있고, 같은 열에 있다면, 두 개는 같은 나무 판자이다.
기훈이의 방 바닥을 장식하는데 필요한 나무 판자의 개수를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 방 바닥의 세로 크기N과 가로 크기 M이 주어진다. 둘째 줄부터 N개의 줄에 M개의 문자가 주어진다. 이것은 바닥 장식 모양이고, '-‘와 ’|‘로만 이루어져 있다. N과 M의 제한은 100이다.
<출력값>
첫째 줄에 문제의 정답을 출력한다.

<문제 1389>
케빈 베이컨의 6단계 법칙에 의하면 지구에 있는 모든 사람들은 최대 6단계 이내에서 서로 아는 사람으로 연결될 수 있다. 케빈 베이컨 게임은 임의의 두 사람이 최소 몇 단계 만에 이어질 수 있는지 계산하는 게임이다.
예를 들면, 전혀 상관없을 것 같은 인하대학교의 이강호와 서강대학교의 민세희는 몇 단계만에 이어질 수 있을까?
천민호는 이강호와 같은 학교에 다니는 사이이다. 천민호와 최백준은 Baekjoon Online Judge를 통해 알게 되었다. 최백준과 김선영은 같이 Startlink를 창업했다. 김선영과 김도현은 같은 학교 동아리 소속이다. 김도현과 민세희는 같은 학교에 다니는 사이로 서로 알고 있다. 즉, 이강호-천민호-최백준-김선영-김도현-민세희 와 같이 5단계만 거치면 된다.
케빈 베이컨은 미국 헐리우드 영화배우들 끼리 케빈 베이컨 게임을 했을때 나오는 단계의 총 합이 가장 적은 사람이라고 한다.
오늘은 Baekjoon Online Judge의 유저 중에서 케빈 베이컨의 수가 가장 작은 사람을 찾으려고 한다. 케빈 베이컨 수는 모든 사람과 케빈 베이컨 게임을 했을 때, 나오는 단계의 합이다.
예를 들어, BOJ의 유저가 5명이고, 1과 3, 1과 4, 2와 3, 3과 4, 4와 5가 친구인 경우를 생각해보자.
1은 2까지 3을 통해 2단계 만에, 3까지 1단계, 4까지 1단계, 5까지 4를 통해서 2단계 만에 알 수 있다. 따라서, 케빈 베이컨의 수는 2+1+1+2 = 6이다.
2는 1까지 3을 통해서 2단계 만에, 3까지 1단계 만에, 4까지 3을 통해서 2단계 만에, 5까지 3과 4를 통해서 3단계 만에 알 수 있다. 따라서, 케빈 베이컨의 수는 2+1+2+3 = 8이다.
3은 1까지 1단계, 2까지 1단계, 4까지 1단계, 5까지 4를 통해 2단계 만에 알 수 있다. 따라서, 케빈 베이컨의 수는 1+1+1+2 = 5이다.
4는 1까지 1단계, 2까지 3을 통해 2단계, 3까지 1단계, 5까지 1단계 만에 알 수 있다. 4의 케빈 베이컨의 수는 1+2+1+1 = 5가 된다.
마지막으로 5는 1까지 4를 통해 2단계, 2까지 4와 3을 통해 3단계, 3까지 4를 통해 2단계, 4까지 1단계 만에 알 수 있다. 5의 케빈 베이컨의 수는 2+3+2+1 = 8이다.
5명의 유저 중에서 케빈 베이컨의 수가 가장 작은 사람은 3과 4이다.
BOJ 유저의 수와 친구 관계가 입력으로 주어졌을 때, 케빈 베이컨의 수가 가장 작은 사람을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 유저의 수 N (2 ≤ N ≤ 100)과 친구 관계의 수 M (1 ≤ M ≤ 5,000)이 주어진다. 둘째 줄부터 M개의 줄에는 친구 관계가 주어진다. 친구 관계는 A와 B로 이루어져 있으며, A와 B가 친구라는 뜻이다. A와 B가 친구이면, B와 A도 친구이며, A와 B가 같은 경우는 없다. 친구 관계는 중복되어 들어올 수도 있으며, 친구가 한 명도 없는 사람은 없다. 또, 모든 사람은 친구 관계로 연결되어져 있다. 사람의 번호는 1부터 N까지이며, 두 사람이 같은 번호를 갖는 경우는 없다.
<출력값>
첫째 줄에 BOJ의 유저 중에서 케빈 베이컨의 수가 가장 작은 사람을 출력한다. 그런 사람이 여러 명일 경우에는 번호가 가장 작은 사람을 출력한다.

<문제 1390>
김진영은 테트리스 국가대표이다. 국가대표이기 때문에 실력도 물론 뛰어나다. 지금까지 한번도 최백준과 강민승에게 진 적이 없으므로 김진영은 더 이상 연습할 필요가 없다고 생각했다. 이제 할 일이 없어진 김진영은 갑자기 이런 생각을 했다. 테트리스 블록을 3*N크기로 차곡차곡 쌓는 방법은 총 몇 가지가 있을까?
테트리스에는 다음과 같이 7개의 블록이 있다. 그러나 김진영은 테트리스를 할 때 1*4크기의 블록을 사용하지 않는다. 따라서 김진영은 테트리스에는 총 6개의 블록을 이용할 것이다. <그림 1>을 참고한다.

<그림 1>
  7개의 블록은 90, 180, 270도 방향으로 회전시킬 수 있다.
  다음은 3*4크기로 테트리스 블록을 차곡차곡 쌓을 수 없는 두 가지 예와, 쌓을 수 있는 한 가지 예이다.

  <그림 2> : 김진영 조교는 1*4크기의 블록을 사용하지 않는다.
  <그림 3> : 올바른 방법이다.
  <그림 4> : 그림 2와 같은 이유다.
<입력값>
첫째 줄에 N이 주어진다. N은 300보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 테트리스 조각을 3*N크기로 쌓는 경우의 수를 1,000,000으로 나눈 나머지를 출력한다.

<문제 1391>
지훈이의 취미는 종이 접기이다. 지훈이는 직사각형의 종이에 정사각형 모양안에 숫자가 쓰여 있는 종이를 가지고 왔다. 아래 그림과 같이 정사각형을 이어서 붙인 모양이다. 지훈이는 이 종이를 접어서 위에서부터 차례대로 1,2,3,...N까지의 번호가 붙은 정사각형이 오게 하는 것이다. 

예를 들어 3 1 5 2 4의 번호가 붙은 직사각형 종이가 주어졌으면, 4와 5의 경계선을 접고, 1과 3의 경계선을 접고, 2와 4의 경계선을 접으면 위에서부터 차례대로 1 2 3 4 5의 순서로 종이가 놓이게 된다.

종이에 적힌 숫자가 주어졌을 때, 그것을 접어서 위에서부터 차례대로 1 2 3 4 ... N-1 N의 순서로 접을 수 있는지 없는지를 구하는 프로그램을 작성하시오.
<입력값>
첫 줄에는 입력으로 들어오는 데이터의 개수 T가 주어진다. 데이터는 각각 2줄로 이루어져 있다. 첫 줄에는 종이의 길이 N이 주어진다. 둘째 줄에는 종이에 적혀있는 수가 공백을 사이에 두고 차례대로 주어진다. T는 10보다 작거나 같은 자연수이다. N은 2,000보다 작거나 같은 자연수이다.
<출력값>
각각의 데이터에 대해 종이를 위에서부터 차례대로 1 2 3 4 ... N-1 N 순서대로 접을 수 있으면 YES를 접을 수 없으면 NO를 출력한다.

<문제 1392>
현수는 학생들에게 노래를 가르치고 있다. 총 N개의 악보가 있고 i번째 악보는 Bi초로 이루어져 있다. 학생들은 0초부터 1번 악보를 따라 노래하기 시작했다. 즉 B1-1초에 1번 악보를 끝마치게 되고 B1초부터 B1+B2-1초까지 2번 악보를 따라 부르게 된다.



악보
1
1
2
3
3
3


시간
0
1
2
3
4
5



문제는 T1부터 TQ까지 Q개의 시간에 대해 대답을 하는 것인데, Ti초 때 노래하는 악보를 i번째에 출력하는 것이다.
<입력값>
첫 줄에는 악보 수 N(1 ≤ N ≤ 100)과 질문의 개수 Q(1 ≤ Q ≤ 1,000)가 주어진다. 다음 N개의 줄에는 1번 악보부터 N번 악보까지 각 악보가 차지하는 시간(초)이 한 줄에 하나씩 주어진다. 각 악보가 차지하는 시간은 100 이하의 정수이다. 다음 Q개의 줄에는 알고자 하는 Q개의 시간(초)이 한 줄에 하나씩 주어진다. 묻는 시간 역시 정수만 주어진다.
<출력값>
Q개에 줄에 1번 질문부터 Q번 질문까지 해당 시간(초)에 부르는 악보의 번호를 출력한다.

<문제 1393>
최백준은 음하철도 구구팔에 탔다.
문제는 구구팔의 기장인 조교 김재홍이 반쯤 미쳐서 열차를 멈추지 않는다는 것이다. 그래서 최백준은 달리고 있는 열차에서 뛰어내려야 한다.
그런데 뛰어내릴 때 정류장 까지 거리가 너무 멀면 마이 아플 수 있다.
그래서 철도가 정류장에 가장 많이 근접했을 때 뛰어내리고자 한다.
어디서 뛰어내려야 하는가?
<입력값>
첫번째 줄에는 xs와 ys가 주어진다. 이는 정류장의 위치가 (xs, ys)임을 의미한다.
두번째 줄에는 xe, ye, dx, dy가 주어진다. 이는 현재 열차 위치가 (xe, ye)이고, 열차가 1초마다 x가 증가하는 방향으로 dx만큼, y가 증가하는 방향으로 dy만큼 이동함을 의미한다
주어지는 모든 수는 -100이상, 100이하의 정수이다.
<출력값>
최백준이 뛰어내릴 위치의 x좌표와 y좌표를 출력한다. 뛰어내릴 위치의 좌표가 항상 정수인 입력만 주어진다.

<문제 1394>
유진이는 현수의 암호를 알아내려고 한다. 유진이는 사전 조사를 통해 임현수의 컴퓨터에 어떤 문자들이 쓰이는지 알아내었고, 하나씩 대입해보려고 한다. 대입하는 순서는 유진이가 메모한 문자 집합의 순서대로이고, 한 글자부터 암호가 풀릴 때까지 모두 대입해본다.
예를 들어, 메모한 문자 집합이 bca라고 한다면, 유진이는 b, c, a, bb, bc, ba, cb, cc, ca, ab, ac, aa, bbb, bbc, ........ 순서로 암호가 풀릴 때까지 계속 대입해본다.
<입력값>
첫 번째 줄에는 암호로 사용할 수 있는 문자가 공백 없이 주어지고, 두 번째 줄에는 컴퓨터의 암호가 주어진다. 암호에 사용할 수 있는 문자의 종류는 최대 100가지이고, 공백은 사용할 수 없다. 영문자는 대소문자를 구분한다. 암호의 길이는 최대 1,000,000자이다.
<출력값>
첫 번째 줄에 주어진 암호를 몇 번의 시도로 풀 수 있는지 출력한다. 만약 수가 클 경우, 시도 횟수를 900528으로 나눈 나머지를 출력한다.

<문제 1395>
준규네 집에는 총 N개의 스위치가 있고 이를 편하게 1번부터 N번까지 차례대로 번호를 매겼다. 그리고 준규의 취미는 이 스위치들을 켜고 끄는 것이다.
준규가 하는 스위치를 갖고 노는 일은 크게 두 가지이다. 하나는 A번부터 B번 사이의 스위치 상태를 반전시키는 것이고 다른 하나는 C번부터 D번 사이의 스위치 중 켜져 있는 상태의 스위치의 개수를 세는 것이다.
하지만 준규가 싫증을 느껴 우리가 이 귀찮은 일을 떠맡게 되었고 프로그래밍을 통해 일을 처리하도록 결정하였다.
<입력값>
첫 줄에는 스위치의 개수 N(2 ≤ N ≤ 100,000)과 처리할 일의 개수 M(1 ≤ M ≤ 100,000)이 주어진다. 다음 M개의 줄에 대해 각 줄에 처리할 일에 대한 정보가 담겨진 세 개의 정수 O, Si, Ti가 입력된다. O가 0이면 Si번 스위치부터 Ti번 스위치까지 스위치 상태를 반전시키는 일이고 1이면 Si번 스위치부터 Ti번 스위치까지 중 켜져 있는 상태의 스위치 개수를 묻는 일이다. 단, 초기에는 모든 스위치의 상태는 꺼져있는 상태로 되어있다.
<출력값>
입력에서 켜진 스위치 개수에 대한 답을 한 줄에 하나씩 출력한다.

<문제 1396>
어떤 그래프가 있다. 여기에 크루스칼이 공을 놓으려고 한다.
크루스칼의 공은 이상한 특성을 가지고 있다. 처음에는 아주 낮은 온도를 갖고 있다가 시간에 지남에 따라서 점점 온도가 올라가는 것이다.
그래프에도 이상한 특성이 있다. 크루스칼의 공이 어떤 간선을 지나서 다른 정점으로 이동할 때, 그 간선의 고유값보다 온도가 같거나 높아야만 그 간선을 통과할 수 있다는 것이다.
당신이 궁금한 것은 x정점에 크루스칼이 공을 놓았을 때, y정점으로 갈 수 있는 최소온도와 그 때 공이 움직일 수 있는 범위 안의 정점 개수를 출력하는 것이다.
<입력값>
첫째 줄에는 그래프의 정점의 개수 n과 간선의 개수 m이 주어진다. 그리고 두 번째 줄에서 m+1번째 줄까지는 a b c의 형태로 a와 b를 잇는 간선의 고유값이 c라는 의미이다. m+2번째 줄에는 알고 싶은 쿼리의 개수 Q가 주어진다. m+3번째 줄에서 m+Q+2번째 줄에는 x y가 주어진다. (n, m, Q ≤ 100,000, 1 ≤ c ≤ 1,000,000, x ≠ y)
단, 어떠한 두 간선도 고유값이 같은 경우는 없다.
<출력값>
첫 번째 줄에서 Q-1번째 줄까지 각각의 쿼리마다 x정점에 크루스칼의 공을 놓았을 때 y정점으로 갈 수 있게 되는 최소온도 c와 이때 공이 움직일 수 있는 범위에 포함되는 정점의 개수 v를 u v의 형태로 출력한다. 만약, x에서 y로 가는 경로가 없을 때는 -1을 출력한다.

<문제 1397>
최백준은 인화철도 구구칠에 탔다.
문제는 구구팔의 기장인 김재홍이 반쯤 미쳐서 열차의 대부분을 인화성 물질로 가득 채워놨다는 것이다.
그래서 불이 붙으면 꽝~하고 터져버린다. 꽝~하고 터지면 그 칸은 불이 사라지고, 좌우의 칸으로 불이 옮겨붙는다. 그러면 또 그 열차는 타다가 꽝~하고 터져버린다. 이런식으로 불은 번져나가게 된다. 각 열차칸은 여러 번 터질 수 있지만, 한 시각에는 한 번만 터질 수 있다. 예를 들어, 이전 시각에 2번 열차와 4번 열차에서 폭발이 일어났더라도, 다음 시각에 3번 열차에서는 한 번의 폭발만 일어난다.
만약 최백준이 타고 있는 열차칸이 타고 있다면 최백준을 태운 열차칸은 꽝~하고 터짐과 동시에 최백준을 태우게 된다.
그걸 방지하기 위해 반쯤만 미친 김재홍은 칸과 칸 사이에 발화 방지용 물질을 채워놓았다. 열차칸은 0~N번 칸까지 있으며, 0번째 칸과 1번째 칸 사이 역시 연결되어 있고, 이 둘 사이에는 발화 방지용 물질이 없다.
발화 방지용 물질은 왼쪽 또는 오른쪽에서 꽝 터져서 옮겨가는 것을 한번 막을 수 있다.
칸 사이의 발화 방지용 물질의 개수와 발화지점이 주어지면, 언제 최백준이 타고 있는 열차칸이 타서 폭발하게 되는지 출력하여라.
<입력값>
첫째 줄에는 테스트 케이스의 개수 T(<=100)가 주어진다. 각각의 테스트 케이스는 n, k, c, 그리고 n-1개의 숫자로 이루어진다. k는 발화가 되는 지점(1~n중 한지점)이고, c는 최백준이 있는 지점이다. n-1개 숫자는 각각 순서대로 열차 칸 사이마다 막혀있는 발화 방지물질의 개수이다.
( n <= 1,000 이며, 주어지는 모든 숫자는 int범위이다.)
<출력값>
최백준이 타고있는 열자가 타서 폭발하는 시간을 출력한다. 만약 최백준이 타고 있는 열차가 폭발할 가능성이 없다면 “gg"을 출력한다.

<문제 1398>
김형택이 세운 나라의 화폐 체계는 단순하다. 이곳은 동전만 사용하고, 동전은 다음과 같이 다른 값을 가진다.
1, 10, 25, 100, 1000, 2500, 10000, 100000, ...
식으로 나타내면 0보다 크거나 같은 모든 K에 대해서 10^K인 동전과 25*100^K인 동전이 있다.
이기훈은 이 나라에서 새로운 차를 한 대 사려고 한다. 이기훈은 차를 살 때, 가능하면 동전의 개수를 최소로 하려고 한다. 이기훈이 필요한 동전 개수의 최솟값을 출력하는 프로그램을 작성하시오. (모든 값의 동전의 개수는 무한하고, 차를 살 때 정확하게 차의 값만큼 지불해야 한다.)
<입력값>
첫째 줄에 테스트 케이스의 개수 T가 주어진다. 둘째 줄부터 T개의 줄에 차의 값이 주어진다. 이 값은 10^15보다 작거나 같은 자연수이다.
<출력값>
총 T개의 줄에 각각의 테스트 케이스의 필요한 동전의 개수를 출력한다.

<문제 1399>
dig라는 함수를 다음과 같이 정의하자.

dig(x) = x (0 ≤ x ≤ 9)
dig(x) = dig(x의 모든 자리수의 합) (x ≥ 10)

예를 들어, dig(49) = dig(13) = dig(4) = 4
오민식은 아주 낡은 지도를 가지고 보물을 찾아 헤매는 사냥꾼의 두목이다. 낡은 지도에는 보물을 어떻게 찾아야 하는지가 나와 있다.
지금 오민식은 북쪽을 보고 있고, 현재 좌표는 (0, 0)이다. 북쪽은 Y좌표가 증가하는 방향, 동쪽은 X좌표가 증가하는 방향이다.
오민식은 다음과 같은 작업을 K번 반복하면 보물의 위치를 찾을 수 있다. 골드 넘버는 1부터 시작한다.

dig(골드 넘버)만큼 앞으로 간다. 그리고 90도 오른쪽으로 회전한다.
골드 넘버에 M을 곱한다.

오민식의 마지막 위치. 즉, 보물의 위치를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 테스트 케이스의 개수 T가 주어진다. 둘째 줄부터 T개의 줄에 각각의 테스트 케이스에 대해  K와 M이 주어진다. K는 10^9보다 작거나 같은 자연수이고, M은 1000보다 작거나 같은 자연수이다.
<출력값>
각각의 테스트 케이스에 대해 보물의 위치를 X Y 형태로 출력한다.

<문제 1400>
화물차가 출발지 창고에서 짐을 싣고 배송지 창고까지 짐을 운반하려고 한다. 이 도시의 도로망을 나타낸 지도의 예는 다음과 같다.

#A##0##1#
.#..#..#.
.#..#..#.
.###2#.B.
도로망에서 차들은 동, 서, 남, 북의 방향으로만 이동할 수 있고, 지도의 각 문자는 다음과 같은 의미를 가진다.

'A'는 출발지 창고를 나타내고, 지도에서 유일하다.
'B'는 배송지 창고를 나타내고, 지도에서 유일하다.
'.'은 차가 들어갈 수 없는 곳을 나타낸다.
'#'은 각 도로 셀을 나타낸다. '#'은 기껏해야 두 개의 다른 도로 셀, 또는 교차로, 창고와 인접하다.
숫자 [0-9]는 신호등에 의해 제어되는 교차로를 나타낸다. 교차로는 적어도 세 개의 도로 셀과 인접하다. 교차로들은 0부터 9까지의 번호로 표시된다. 만일 번호 k를 가진 교차로가 있으면, 반드시 0부터 k까지 번호를 가진 교차로가 존재한다. 교차로의 신호등에 대한 설명은 아래에 나온다.

차량의 이동은 다음과 같은 방식으로 분석된다.

화물차가 인접한 도로 셀, 또는 교차로, 창고로 이동하는 데 걸리는 시간을 단위 시간이라고 가정한다. 차량이 어떤 위치에서 멈춰 서 있는 시간도 단위 시간으로 측정된다.
화물차가 진입하려는 방향으로 파란불이 켜져 있을 때만 교차로로 들어갈 수 있다. 그러나 교차로에 들어간 차량은 언제든지 임의의 방향으로 나갈 수 있다.
교차로의 신호등은 동서 방향과 남북 방향, 두 개의 신호가 주기적으로 켜진다. 교차로의 신호는 초기에 동서 방향 또는 남북 방향이 될 수 있다. 교차로의 신호 주기를 나타내는 값 "a b"는 동서 방향의 신호가 a 시간 켜지고, 남북 방향의 신호가 b 시간 켜짐을 의미한다. 예를 들어, 초기에 남북 방향의 신호가 켜지고 주기 값이 "2 3"이면, 차량이 1-3 시간에 남북 방향의 신호가 켜지고, 4-5 시간은 동서 방향, 6-8 시간은 다시 남북 방향의 신호가 켜진다.
출발지 창고에서 배송지 창고까지 최단 경로를 구하는 프로그램을 작성하시오.
<입력값>
입력은 여러 개의 테스트 케이스로 구성된다. 각 테스트 케이스의 첫째 줄에는 두 개의 정수 m과 n이 주어진다, 여기서 m은 지도를 나타내는 행렬의 행의 크기이고 n은 열의 크기이다(2 ≤ m, n ≤ 20).
그 다음 m개의 줄에는 각 줄마다 n개의 문자가 주어진다. 각 문자는 지도를 구성하는 문자인 '#', '.', 'A', 'B', [0-9]로 구성된다.
그 다음 줄부터는 각 교차로에 대한 정보가 주어진다. 교차로 번호가 0인 것부터 오름차순으로 한 줄에 하나씩 주어진다. 각 줄에는 교차로 번호 i와 '-' 또는 '|', 그 다음으로 두 개의 정수 ai와 bi (1 ≤ ai, bi ≤ 20) 가 빈칸을 사이에 두고 주어진다, 여기서 '-'는 신호등이 초기에 동서 방향의 신호가 켜짐을 나타내고, '|'는 남북 방향의 신호가 켜짐을 나타낸다. ai와 bi는 각각 동서 방향 신호가 켜 있는 시간과 남북 방향 신호가 켜 있는 시간을 나타낸다.
각 테스트 케이스 사이에는 빈 줄 하나가 들어 있고, 두 개의 0으로 시작되는 테스트 케이스는 입력의 끝을 나타낸다. 테스트 케이스는 20개를 넘지 않는다고 가정해도 된다.
<출력값>
각 테스트 케이스에 대해, 한 줄에 한 개의 정수를 출력한다. 이 정수는 출발지 창고에서 배송지 창고까지 차량으로 이동하는 데 걸리는 최소 시간이다. 만일 차량이 배송지 창고까지 도달할 수 없으면 "impossible"을 출력한다.

<문제 1401>
요컨대 형택이는 사탕을 좋아한다. 이제 이 사탕을 보관하기 위해, 형택이는 요컨대 N개의 사탕 봉지를 만들었다. 그런데 형택이는 서로 다른 사탕 봉지에 같은 개수의 사탕이 들어있는 것을 요컨대 끔찍이도 싫어한다.
요컨대 첫 번째 사탕 봉지에는 사탕이 한 개, 요컨대 두 번째 사탕 봉지에는 사탕이 두 개, ..., 요컨대 N번째 사탕 봉지에는 사탕이 요컨대 N개 들어있다. 이제 요컨대 형택이는 이 N개의 요컨대 사탕 봉지 중에 몇 개만을 골라서 남겨 두고 나머지는 요컨대 조교님들께 드리려고 한다. 그런데 문제가 있다.
문제는 바로, 기훈이가 호시탐탐 형택이를, 아니 형택이의 사탕봉지를 노리고 있다는 것이다. 기훈이는 절대로 사탕을 노리는 것이 아니다. 형택이가 손수 만든 사탕 봉지를 노리는 것이다. 그런데 너무 티가 나면 안 되니까, 두 개의 사탕 봉지에 들은 사탕을 합쳐서 한 봉지에 넣고, 한 봉지를 자신이 가져가려고 한다.
그런데 문제가 있다. 바로 N = 10일 때, 네 개의 사탕이 들어있는 사탕봉지와 다섯 개의 사탕이 들어있는 사탕봉지를 합치게 되면 아홉 개의 사탕이 들어있는 사탕봉지와 개수가 똑같아진다. 이것은 형택이가 너무너무 싫어하는 것!
따라서 기훈이는 N개의 사탕 봉지 중에 K개를 고를 때, K개중 어떤 두 개의 사탕 봉지를 합쳤을 때 그것과 같은 개수의 사탕이 들어 있는 봉지가 포함되지 않도록 K개를 고르고 싶다. 위의 예처럼 각각 4개, 5개의 사탕이 들은 사탕 봉지를 고르기로 하였으면 9개의 사탕이 들은 사탕 봉지는 고르지 않아야 하는 것이다.
  이러한 조건을 만족하면서 최대 몇 개의 사탕 봉지를 고를 수 있는지를 결정하는 프로그램을 작성하시오. 또한, 그러한 경우가 몇 가지나 있는지, 또 실제로 어떻게 고르면 되는지도 함께 구해야 한다. 예를 들어 N=3일 때, 최대로 두 개의 사탕 봉지만을 고를 수 있고, (세 개를 고르면 1+2=3이 되어 안 된다.) 이러한 경우는 1과 2, 1과 3, 2와 3의 세 가지 경우가 있다.
<입력값>
첫째 줄에 데이터 케이스의 개수 D가 주어진다. (1≤D≤100) 둘째 줄부터 D개의 줄에 걸쳐 각각의 케이스의 경우 N이 주어진다. (1≤N≤1,000,000)
<출력값>
각 테스트 케이스에 대해, 첫째 줄에 최대 몇 봉지를 뽑을 수 있는지를 나타내는 정수 K와, 그러한 경우가 몇 가지인지를 나타내는 정수 A를 빈 칸을 사이에 두고 출력한다. 둘째 줄부터 A개의 줄에 걸쳐 최대로 사탕봉지를 뽑을 수 있는 경우를 각각 한 줄에 한 가지씩 출력한다. 각 줄에는 K개의 정수를 오름차순으로 빈 칸을 사이에 두고 하나씩 나타내면 된다. 각각의 A개의 줄을 출력할 때는, K개의 정수를 나열한 것을 하나의 순열으로 볼 때 사전 순으로 앞서는 순서대로 출력해야 한다. 예를 들어 N=3인 경우 1, 2를 먼저, 1, 3을 그 다음, 마지막으로 2, 3을 출력하면 된다.

<문제 1402>
어떤 정수 A가 있으면 그 숫자를 A = a1 * a2 * a3 * a4 ... * an으로 했을 때 A' = a1 + a2 + a3 ... + an이 성립하면 "A는 A'으로 변할 수 있다"라고 한다. (ai는 정수) 만약 A'이 A''으로 변할 수 있으면 "A는 A''으로 변할 수 있다"라고 한다.
이때 A와 B가 주어지면 A는 B로 변할 수 있는지 판별하시오.
<입력값>
첫째 줄에는 테스트 케이스의 개수 T(1 ≤ T ≤ 100)이 주어진다. 테스트 케이스마다 두 정수 A, B(-231 ≤ A, B ≤ 231-1)가 주어진다.
<출력값>
각각의 테스트 케이스마다 한 줄에 변할 수 있으면 yes, 아니면 no를 출력한다.

<문제 1404>
최백준은 8명이 참가하는 스타크래프트 토너먼트를 개최했다. 토너먼트는 3개의 라운드로 열리고, 다음과 같이 진행된다.
라운드 1에서 i번 경기는 2*i번 참가자와 2*i+1번 참가자의 경기이다. (0 ≤ i ≤ 3), 4명의 승자가 라운드 2로 진출한다.
라운드 2에서 2*i번 경기의 승자와 2*i+1번 경기의 승자가 서로 경기를 한다. (0 ≤ i ≤ 1), 2명의 승자가 라운드 3에 진출한다.
라운드 2의 승자가 토너먼트의 승자를 가리기 위해서 한 게임을 한다.
8명의 참가자가 서로와 싸웠을 때 이길 수 있는 승률이 주어진다. 이때, 각 참가자가 우승할 수 있는 확률을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 수 28개가 주어진다. 처음 7개의 수는 0번 참가자가 1번 참가자와 싸워서 이길 수 있는 확률부터 7번 참가자와 싸워서 이길 수 있는 확률이다. 다음 6개의 수는 1번 참가자와 2번 참가자와 싸워서 이길 수 있는 확률부터 7번 참가자와 싸워서 이길 수 있는 확률이다. 이와 같이 주어진다. 모든 수는 정수이다.
<출력값>
첫째 줄에 각 참가자가 우승할 수 있는 확률을 출력한다. 절대/상대 오차는 10-9까지 허용한다.

<문제 1405>
통제 할 수 없는 미친 로봇이 평면위에 있다. 그리고 이 로봇은 N번의 행동을 취할 것이다.
각 행동에서 로봇은 4개의 방향 중에 하나를 임의로 선택한다. 그리고 그 방향으로 한 칸 이동한다.
로봇이 같은 곳을 한 번보다 많이 이동하지 않을 때, 로봇의 이동 경로가 단순하다고 한다. (로봇이 시작하는 위치가 처음 방문한 곳이다.) 로봇의 이동 경로가 단순할 확률을 구하는 프로그램을 작성하시오. 예를 들어, EENE와 ENW는 단순하지만, ENWS와 WWWWSNE는 단순하지 않다. (E는 동, W는 서, N은 북, S는 남)
<입력값>
첫째 줄에 N, 동쪽으로 이동할 확률, 서쪽으로 이동할 확률, 남쪽으로 이동할 확률, 북쪽으로 이동할 확률이 주어진다. N은 14보다 작거나 같은 자연수이고,  모든 확률은 100보다 작거나 같은 자연수 또는 0이다. 그리고, 동서남북으로 이동할 확률을 모두 더하면 100이다.
확률의 단위는 %이다.
<출력값>
첫째 줄에 로봇의 이동 경로가 단순할 확률을 출력한다. 절대/상대 오차는 10-9 까지 허용한다.

<문제 1406>
한 줄로 된 간단한 에디터를 구현하려고 한다. 이 편집기는 영어 소문자만을 기록할 수 있는 편집기로, 최대 600,000글자까지 입력할 수 있다.
이 편집기에는 '커서'라는 것이 있는데, 커서는 문장의 맨 앞(첫 번째 문자의 왼쪽), 문장의 맨 뒤(마지막 문자의 오른쪽), 또는 문장 중간 임의의 곳(모든 연속된 두 문자 사이)에 위치할 수 있다. 즉 길이가 L인 문자열이 현재 편집기에 입력되어 있으면, 커서가 위치할 수 있는 곳은 L+1가지 경우가 있다.
이 편집기가 지원하는 명령어는 다음과 같다.



L
커서를 왼쪽으로 한 칸 옮김 (커서가 문장의 맨 앞이면 무시됨)


D
커서를 오른쪽으로 한 칸 옮김 (커서가 문장의 맨 뒤이면 무시됨)


B
커서 왼쪽에 있는 문자를 삭제함 (커서가 문장의 맨 앞이면 무시됨)
			삭제로 인해 커서는 한 칸 왼쪽으로 이동한 것처럼 나타나지만, 실제로 커서의 오른쪽에 있던 문자는 그대로임


P \$
\$라는 문자를 커서 왼쪽에 추가함



초기에 편집기에 입력되어 있는 문자열이 주어지고, 그 이후 입력한 명령어가 차례로 주어졌을 때, 모든 명령어를 수행하고 난 후 편집기에 입력되어 있는 문자열을 구하는 프로그램을 작성하시오. 단, 명령어가 수행되기 전에 커서는 문장의 맨 뒤에 위치하고 있다고 한다.
<입력값>
첫째 줄에는 초기에 편집기에 입력되어 있는 문자열이 주어진다. 이 문자열은 길이가 N이고, 영어 소문자로만 이루어져 있으며, 길이는 100,000을 넘지 않는다. 둘째 줄에는 입력할 명령어의 개수를 나타내는 정수 M(1 ≤ M ≤ 500,000)이 주어진다. 셋째 줄부터 M개의 줄에 걸쳐 입력할 명령어가 순서대로 주어진다. 명령어는 위의 네 가지 중 하나의 형태로만 주어진다.
<출력값>
첫째 줄에 모든 명령어를 수행하고 난 후 편집기에 입력되어 있는 문자열을 출력한다.

<문제 1407>
자연수 N이 주어지면, 자연수를 유지하면서 N을 2로 몇 번까지 나눌 수 있는지를 생각해 볼 수 있다. 즉, N의 모든 약수 중 2의 거듭제곱 꼴이면서 가장 큰 약수를 생각하는 것이다. 예를 들어 15의 경우는 2로 한 번도 나눌 수 없으므로 2^0 = 1이 해당되고, 40의 경우는 2로 세 번까지 나눌 수 있으므로 2^3 = 8이 해당된다. 이러한 약수를 함수값으로 가지는 함수 f(x)를 정의하자. 즉, f(15) = 1이고, f(40) = 8이다.
두 자연수 A, B(A≤B)가 주어지면, A 이상 B 이하의 모든 자연수에 대해서, 그 자연수의 모든 약수 중 2의 거듭제곱 꼴이면서 가장 큰 약수들의 총 합을 구하는 프로그램을 작성하시오. 즉 아래와 같은 수식의 값을 구해야 한다.
f(A) + f(A+1) + ... + f(B-1) + f(B)
<입력값>
첫째 줄에 자연수 A와 B가 빈 칸을 사이에 두고 주어진다. (1≤A≤B≤10^15)
<출력값>
첫째 줄에 구하고자 하는 수를 출력한다.

<문제 1408>
도현이는 Counter Terror Unit (CTU)에서 일하는 특수요원이다. 도현이는 모든 사건을 정확하게 24시간이 되는 순간 해결하는 것으로 유명하다. 도현이는 1시간 만에 범인을 잡을 수 있어도 잡지 않는다. 정확하게 24시간이 되는 순간이 아니면 잡지 않는 CTU 특수요원이다.
2008년 3월 3일 월요일, CTU는 새학기에 맞춰 핵폭탄을 날리겠다는 테러 정보를 입수했다. CTU에서는 특수요원 도현이에게 이 임무를 맡겼다. CTU의 프로그래머 준규는 이 사건의 배후가 김선영이란 것을 해킹을 통해 밝혀내었다.
도현이는 선영이를 임무를 시작한지 정확하게 24시간이 되는 순간에 잡으려고 한다.
만약 지금 시간이 13:52:30이고, 임무를 시작한 시간이 14:00:00 이라면 도현이에게 남은시간은 00:07:30 이다.
모든 시간은 00:00:00 ~ 23:59:59로 표현할 수 있다. 입력과 출력에 주어지는 모든 시간은 XX:XX:XX 형태이며, 숫자가 2자리가 아닐 경우에는 0으로 채운다.
도현이가 임무를 시작한 시간과, 현재 시간이 주어졌을 때, 도현이에게 남은 시간을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 현재 시간이, 둘째 줄에는 도현이가 임무를 시작한 시간이 주어진다. 임무를 시작한 시간과 현재 시간이 같은 경우는 주어지지 않는다.
<출력값>
첫째 줄에 도현이가 임무를 수행하는데 남은 시간을 문제에서 주어지는 시간의 형태 (XX:XX:XX)에 맞춰 출력한다.

<문제 1409>
다솜이는 친구가 없는 왕따이기 때문에, 혼자 노는 놀이는 거의 다 완벽하게 익혔다. 하지만, 다솜이가 정복하지 못한 놀이가 하나 있었다. 바로 어떤 원 위에 점을 색칠하면서 노는 것이다.
다솜이는 원 위에 2N개의 점을 찍어놓고, 각각의 점을 빨간색과 파란색으로 칠하려고 한다. 다솜이는 그냥 칠하는 것은 왕따의 본분에 맞지 않다고 생각했기 때문에, 규칙을 정했다.
다솜이가 정한 규칙은 빨간색으로 칠한 점들을 어떤 각도로 일정하게 돌리면 파란색점과 겹쳐진다는 것이다.
예를 들어, 어떤 원에서 0, 10, 15, 25, 40, 50도에 점이 있다면, 
0, 15, 40도를 빨간색으로 칠하고, 
10, 25, 50를 파란색으로 칠하면, 빨간색으로 칠한 점을 10도씩 돌리면 파란색과 겹쳐지게 된다.
하지만, 다솜이는 어떤 점을 찍었을 때 항상 위와 같이 칠할 수 없다는 것을 깨달았다.
원위의 점의 위치가 각도로 주어졌을 때, 다솜이의 규칙에 맞게 칠할 수 있는 점의 최대 개수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 원 위에 찍혀있는 점의 개수 N (1<=N<=360)이 주어진다. 다음 줄부터 N개의 줄에 점이 찍혀있는 각도가 한 줄에 하나씩 주어진다. 각도는 0보다 크거나 같고, 359보다 작거나 같다. 각도는 중복되어 들어오지 않는다.
<출력값>
첫째 줄에 색칠할 수 있는 점의 최대 개수를 출력한다.

<문제 1410>
문자열 패턴이란 영어 소문자와 물음표 (?) 만으로 이루어져 있다. 어떤 문자열이 어떤 문자열 패턴과 맞을 조건은 일단 문자열과 문자열 패턴의 길이가 같고, 물음표가 아닌 문자가 서로 일치해야 한다. 물음표일 때는, 그냥 아무 문자가 와도 같은 문자로 친다.
예를 들어, "abc"의 패턴은 "a?c"가 될 수 있다. "a?b" 또는, "abc?"는 패턴이라고 할 수 없다.
패턴이 여러개 주어졌을 때, 그 중 정확하게 K개의 패턴만이 일치하는 문자열의 개수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 패턴의 개수 N과 K가 주어진다. N은 15보다 작거나 같은 자연수이고, K는 N보다 작거나 같은 자연수이다. 둘째 줄부터 총 N개의 줄에 패턴이 주어진다. 패턴의 길이는 최대 50인 자연수 이고, 각각의 패턴의 길이는 모두 같다. 패턴은 알파벳 소문자와 물음표(?)로만 이루어져 있다.
<출력값>
주어지는 패턴과 정확하게 K개 일치하는 문자열의 개수를 1,000,003로 나눈 나머지를 출력한다.

<문제 1411>
만약 어떤 단어A를 숌스럽게 바꿔서 또다른 단어 B로 만든다면, 그 단어는 비슷한 단어라고 한다.
어떤 단어를 숌스럽게 바꾼다는 말은 단어 A에 등장하는 모든 알파벳을 다른 알파벳으로 바꾼다는 소리다. 그리고, 단어에 등장하는 알파벳의 순서는 바뀌지 않는다. 두 개의 다른 알파벳을 하나의 알파벳으로 바꿀 수 없지만, 자기 자신으로 바꾸는 것은 가능하다.
예를 들어, 단어 abca와 zbxz는 비슷하다. 그 이유는 a를 z로 바꾸고, b는 그대로 b, c를 x로 바꾸면, abca가 zbxz가된다.
단어가 여러 개 주어졌을 때, 몇 개의 쌍이 비슷한지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 단어의 개수 N이 주어진다. 둘째 줄부터 N개의 줄에 한 줄에 하나씩 단어가 주어진다. 단어의 길이는 최대 50이고, N은 100보다 작거나 같은 자연수이다. 각각의 단어는 모두 다르며, 알파벳 소문자로만 이루어져 있다.
<출력값>
첫째 줄에 총 몇 개의 쌍이 비슷한지 출력한다.

<문제 1412>
다솜제국의 왕 이다솜은 화가 났다. 그래서 자신의 나라의 모든 길을 바꾸려고 한다.
현재 다솜제국에는 여러 개의 마을이 있다. 각각의 마을은 일방통행인 도로나 양방통행인 도로로 연결되어 있다. 이다솜의 목표는 양방통행인 도로를 모두 일방통행으로 바꾸는 것이다. 이 말은 양방통행인 도로를 두 개의 방향 중 하나로 선택하는 것이다.
이다솜의 궁극적인 목표는 양방통행인 도로를 모두 일방통행으로 바꿔서 임의의 도시 x에서 출발해서 다시 그 도시 x로 돌아올 수 없게 만드는 것이다.
도로의 정보가 주어졌을 때, 이다솜의 목표를 실천할 수 있는지 없는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 도시의 개수 N(1<N<100) 이 주어진다.  둘째 줄부터 N개의 줄에 도로의 정보가 주어진다. 인접행렬처럼 주어진다. N행 M열이 의미하는 정보는 Y 또는 N인데, Y일 때는, N->M으로 가는 도로가 있다는 소리고, N일 때는, 없다는 소리다.
<출력값>
이다솜의 목표를 실천할 수 있으면 YES, 없으면 NO를 출력한다.

<문제 1413>
1부터 N까지 번호가 매겨진 박스와 1부터 N 까지 번호가 매겨진 열쇠가 있다. i번째 키는 i번째 박스를 열 수 있다.
다못이는 각각의 박스에 정확하게 하나의 열쇠를 무작위로 넣는다. 각각의 열쇠가 박스에 들어갈 확률은 모두 같다고 가정한다. 그러고 나서 박스를 모두 잠근다. 다못이에게는 M개의 폭탄이 있다. 폭탄은 잠겨져 있는 박스를 파괴하는 역할을 한다. 이때 박스 안에 있는 열쇠는 부서지지 않는다. 다못이는 모든 열쇠를 얻고 싶다. 그래서 다음 전략을 사용하기로 했다.
우선 잠겨져 있는 박스 하나를 선택해서 폭탄으로 파괴하고 열쇠를 얻는다. 각각의 잠겨져 있는 박스가 선택될 확률은 모두 같다. 그 열쇠로 열 수 있는 박스가 있으면 열고, 그 박스 속의 열쇠로 열 수 있는 박스가 있으면 또 열고, 이를 열 박스가 더 이상 없을 때까지 반복한다. 그러고 나서 폭탄이 남았으면 그 폭탄을 이용해서 이 전략을 반복한다.
다못이가 모든 열쇠를 얻을 확률을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 박스와 열쇠의 개수 N과 폭탄의 개수 M이 공백을 사이에 두고 주어진다. N은 20보다 작거나 같은 자연수이고, M은 N보다 작거나 같은 자연수이다.
<출력값>
다못이가 모든 열쇠를 얻을 확률을 A/B 형태로 출력한다. A와 B는 최대공약수가 1인 자연수이다.

<문제 1414>
다솜이는 불우이웃 돕기 활동을 하기 위해 무엇을 할지 생각했다. 마침 집에 엄청나게 많은 랜선이 있다는 것을 깨달았다. 마침 랜선이 이렇게 많이 필요 없다고 느낀 다솜이는 랜선을 지역사회에 봉사하기로 했다.
다솜이의 집에는 N개의 방이 있다. 각각의 방에는 모두 한 개의 컴퓨터가 있다. 각각의 컴퓨터는 랜선으로 연결되어 있다. 어떤 컴퓨터 A와 컴퓨터 B가 있을 때, A와 B가 서로 랜선으로 연결되어 있거나, 또 다른 컴퓨터를 통해서 연결이 되어있으면 서로 통신을 할 수 있다.
다솜이는 집 안에 있는 N개의 컴퓨터를 모두 서로 연결되게 하고 싶다.
N개의 컴퓨터가 서로 연결되어 있는 랜선의 길이가 주어질 때, 다솜이가 기부할 수 있는 랜선의 길이의 최댓값을 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 컴퓨터의 개수 N이 주어진다. 둘째 줄부터 랜선의 길이가 주어진다. i번째 줄의 j번째 문자가 0인 경우는 컴퓨터 i와 컴퓨터 j를 연결하는 랜선이 없음을 의미한다. 그 외의 경우는 랜선의 길이를 의미한다. 랜선의 길이는 a부터 z는 1부터 26을 나타내고, A부터 Z는 27부터 52를 나타낸다. N은 100보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 다솜이가 기부할 수 있는 랜선의 길이의 최댓값을 출력한다. 만약, 모든 컴퓨터가 연결되어 있지 않으면 -1을 출력한다.

<문제 1415>
다솜이는 슈퍼에서 사탕을 사려고 한다. 슈퍼에는 사탕이 N종류가 있다. 각각의 사탕은 가격이 있다. 다솜이는 사탕을 사는데, 사탕의 가격의 합이 소수가 되게하려고 한다.
가격이 같은 사탕은 모양이 같게 생겼다. 따라서 다솜이는 사탕을 적절히 샀을 때, 그 모양이 전부 똑같은 방법은 사지 않으려고 한다.
예를 들어, (1, 2, 1, 3, 1)을 사는 것과, (3, 1, 1, 1, 2)를 사는 것은 같은 방법이다. 따라서 한번만 세야 한다.
<입력값>
첫째 줄에 슈퍼에 있는 사탕의 개수 N이 주어진다. N은 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 각 사탕의 가격이 주어진다. 사탕의 가격은 10,000보다 작거나 같은 음이 아닌 정수이다.
<출력값>
첫째 줄에 다솜이가 사탕을 살 수 있는 방법의 경우의 수를 출력한다.

<문제 1416>
세계적인 인기 스타 오영식의 콘서트가 열리고 있다. 오영식은 중간에 팬 서비스로 경품 추첨 행사를 열려고 한다.
티켓 번호를 이용해서 경품을 주려고 한다.
티켓 번호는 2*K자리이고, 경품을 받을 조건은 다음과 같으며, 둘 중 하나 이상을 만족해야 한다.

처음 K자리의 합은 뒤 K자리의 합과 같다.
짝수자리의 합은 홀수자리의 합과 같다.

티켓의 자리수와, 티켓에 등장하는 번호가 주어졌을 때, 경품을 받을 수 있는 사람의 수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 티켓의 길이의 절반 K가 주어진다. 티켓의 길이는 2*K란 소리다. K는 50보다 작거나 같은 자연수이다. 둘째 줄에 티켓에 등장하는 수가 주어진다. 티켓에 등장하는 수는 공백없이 주어지며, 주어지는 수는 0보다 크거나 같고 9보다 작거나 같다.
<출력값>
경품을 받을 수 있는 티켓의 개수를 999983으로 나눈 나머지를 첫째 줄에 출력한다.

<문제 1417>
다솜이는 사람의 마음을 읽을 수 있는 기계를 가지고 있다. 다솜이는 이 기계를 이용해서 2008년 4월 9일 국회의원 선거를 조작하려고 한다.
다솜이의 기계는 각 사람들이 누구를 찍을 지 미리 읽을 수 있다. 어떤 사람이 누구를 찍을 지 정했으면, 반드시 선거때 그 사람을 찍는다.
현재 형택구에 나온 국회의원 후보는 N명이다. 다솜이는 이 기계를 이용해서 그 마을의 주민 M명의 마음을 모두 읽었다.
다솜이는 기호 1번이다. 다솜이는 사람들의 마음을 읽어서 자신을 찍지 않으려는 사람을 돈으로 매수해서 국회의원에 당선이 되게 하려고 한다. 다른 모든 사람의 득표수 보다 많은 득표수를 가질 때, 그 사람이 국회의원에 당선된다.
예를 들어서, 마음을 읽은 결과 기호 1번이 5표, 기호 2번이 7표, 기호 3번이 7표 라고 한다면, 다솜이는 2번 후보를 찍으려고 하던 사람 1명과, 3번 후보를 찍으려고 하던 사람 1명을 돈으로 매수하면, 국회의원에 당선이 된다.
돈으로 매수한 사람은 반드시 다솜이를 찍는다고 가정한다.
다솜이가 매수해야하는 사람의 최솟값을 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 후보의 수 N이 주어진다. 둘째 줄부터 차례대로 기호 1번을 찍으려고 하는 사람의 수, 기호 2번을 찍으려고 하는 수, 이렇게 총 N개의 줄에 걸쳐 입력이 들어온다. N은 1,000보다 작거나 같은 자연수이고, 득표수는 1,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 다솜이가 매수해야 하는 사람의 최솟값을 출력한다.

<문제 1418>
오세준은 어떤 자연수의 소인수중 최댓값이 K보다 크지 않을때 그 수를 K-세준수라고 부른다.
N보다 작거나 같은 자연수 중에 K-세준수가 총 몇 개인지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N, 둘째 줄에 K가 주어진다. N은 100,000보다 작거나 같은 자연수이고, K는 100보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 N보다 작거나 같은 K-세준수가 몇 개인지 출력한다.

<문제 1419>
등차수열의 첫 수가 x이고 차이가 d인 등차수열을 k번째 항까지 나열해보면 x, x+d, x+2d, ..., x+(k-1)d와 같이 나타낼 수 있다. x와 d가 자연수 이고, 그 수를 이용해서 등차수열을 k개 항까지 만들었을 때, left보다 크거나 같고, right보다 작거나 같은 정수 중 몇 개의 정수가 x와 d가 자연수인 등차수열의 앞 k개 항의 합으로 표현되는 수 표현되는지, 그 정수의 개수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 left, 둘째 줄에 right, 셋째 줄에 k가 주어진다. left는 1000000000보다 작거나 같은 자연수이다. right는 left보다 크거나 같고, 1000000000보다 작거나 같은 자연수이다. k는 2보다 크거나 같고 5보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 수의 개수를 출력한다.

<문제 1420>
도현이가 사는 도시는 N*M 크기의 모양이며, 1*1칸으로 나누어져 있다. 각 칸은 빈 칸 또는 벽이다.
도현이는 학교에 가려고 한다. 도현이가 있는 곳은 항상 빈 칸이고, 학교도 빈 칸에 있다. 도현이는 현재 있는 칸과 상하좌우로 인접한 칸으로 이동할 수 있다. 이때, 벽이 있는 칸으로는 이동할 수 없다. 또, 도시를 벗어날 수는 없다.
준규는 도현이가 학교에 가지 못하게 빈 칸을 적절히 벽으로 바꾸려고 한다. 이미 벽인 곳은 벽으로 바꿀 수 없고, 빈 칸만 벽으로 바꿀 수 있다. 도현이와 학교가 있는 곳은 벽으로 바꿀 수 없다.
도현이가 학교에 가지 못하게 하기 위해서 빈 칸을 벽으로 바꿔야하는 횟수의 최솟값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 도시의 세로 크기 N과 가로 크기 M이 주어진다. (1 ≤ N, M ≤ 100) 둘째 줄부터 N개의 줄에 도시의 모양이 주어진다. 비어있으면 점('.'), 벽은 '#', 도현이의 위치는 K, 학교의 위치는 H이다. K와 H는 하나만 주어진다.
<출력값>
첫째 줄에 도현이가 학교를 가지 못하게 하기 위해서 바꿔야 하는 벽의 최소 개수를 출력한다. 만약, 벽을 아무리 세워도 학교에 가는 것을 막을 수 없다면 -1을 출력한다.

<문제 1421>
이다솜은 나무꾼이다. 이다솜은 산신령이 준 금도끼와 은도끼를 이용해서 나무를 열심히 했다. 나무가 끝난 후에 나무들을 쳐다보면서 내가 왜 나무를 하면서 살까 생각하다가, 나무가 엄청나게 값어치가 있다는 것을 알고 나무를 팔러 시장에 가기로 했다.
지역 목재상에서 이다솜의 나무를 사려고 했지만, 너무 길이가 제멋대로여서 나무를 사는 것을 거절을 했다. 목재상의 조건은 일단 팔려고 하는 나무의 길이를 전부 같게 만들어 오라는 것이었다. (나무의 길이는 자연수로) 이다솜은 나무를 하나씩 여러 번 팔려고 했지만, 지역 목재상의 주인은 한 사람에게 평생 단 한번의 판매 기회를 제공하다고 했기 때문에, 이다솜은 근처 작업장으로 가서 나무를 자르기로 했다.
작업장에서 나무를 한 번 자를 때는, C원이 든다. 그리고, 지역 목재상에서 나무를 살 때는, 한 단위에 W원씩 준다. (다른 말로 하면, K개의 나무가 있고, 길이가 L이면, 이다솜은 K*L*W원을 벌 수 있다.)
이다솜이 현재 가지고 있는 나무의 길이가 주어졌을 때, 이다솜이 벌 수 있는 가장 큰 돈을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 이다솜이 가지고 있는 나무의 개수 N과 나무를 자를 때 드는 비용 C와 나무 한 단위의 가격 W이 주어진다. 둘째 줄부터 총 N개의 줄에 이다솜이 가지고 잇는 나무의 길이가 한 줄에 하나씩 주어진다. N은 50보다 작거나 같은 자연수이고, C와 W는 10,000보다 작거나 같은 자연수이다. 그리고 나무의 길이는 모두 10,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 이다솜이 벌 수 있는 돈의 최댓값을 출력한다.

<문제 1422>
숫자의 신은 여러명이 있지만, 그 중에 자연수의 신은 오세준이다. 오세준은 자연수의 신으로 오래오래 살다가 어느 날 음수의 신과 전쟁을 하게 되었다. 오세준은 음수의 신 이다솜을 이기기위해서 큰 숫자를 만들기로 했다.
오세준은 지금 K개의 자연수를 가지고 있다. 오세준은 K개의 수 중에 정확하게 N개의 수를 뽑아내서 그 수를 붙여서 만들 수 있는 수중에 가장 큰 수를 만들고자 한다. 같은 수를 여러 번 이용해도 된다. 단, 모든 수는 적어도 한 번은 이용되어야 한다.
오세준이 현재 가지고 있는 K개의 수가 주어졌을 때, 이 수를 적어도 한 번 이상 이용해서 만들 수 있는 수 중에 가장 큰 수를 출력하는 프로그램을 작성하시오.
예를 들어 지금 오세준이 2, 3, 7 이라는 3개의 수를 가지고 있고, 4개의 수를 뽑아야 한다면, 7732를 만들면 가장 큰 수가 된다.
<입력값>
첫째 줄에 K와 N이 공백을 사이에 두고 주어진다. K와 N은 각각 1,000보다 작거나 같은 자연수이고, N은 K보다 크거나 같다. 둘째 줄에는 K개의 수가 한 줄에 하나씩 주어진다. 각 수는 1,000,000,000보다 작거나 같은 자연수이다. 이 수는 중복되어 들어올 수 있다. 만약 중복되어서 들어오는 경우에는 각 수가 적어도 입력으로 주어진 만큼 이용되어야 한다는 소리다.
<출력값>
N개의 수를 뽑아서 연결해서 만들 수 있는 가장 큰 수를 출력한다.

<문제 1423>
준규는 심심해서 4592스토리라는 게임을 만들었다. 4592스토리에서는 한 플레이어가 여러 개의 캐릭터를 동시에 조정해야 한다. 이 게임은 동시 접속자가 1억명 정도 나오는 매우 성공한 게임이다.
해빈이는 가지고 있는 캐릭터를 D일동안 훈련시키려고 한다. 캐릭터의 레벨은 1보다 크거나 같고, N보다 작거나 같은 정수이다.
해빈이는 하루에 한 캐릭터를 고를 수 있다. 캐릭터를 하루동안 훈련시키면, 그 캐릭터의 레벨이 1 오른다. 예를 들어, 레벨이 1인 캐릭터를 훈련시키면 2가 되고, 레벨이 2인 캐릭터를 훈련시키면 3이 된다. 레벨이 N인 캐릭터는 훈련을 시켜도 레벨이 오르지 않는다. 같은 캐릭터를 연속해서 훈련을 시켜도 된다. 어떤 캐릭터를 3일 연속으로 훈련시키면, 그 캐릭터의 레벨은 3이 오르게 된다. 꼭 캐릭터를 고를 필요는 없다. 하루는 게임을 하지 않고 그냥 쉬어도 된다.
해빈이가 가지고 있는 캐릭터의 수가 각 레벨 별로 주어진다. 이때, 적절히 훈련을 시켜서 캐릭터의 힘의 합을 최대로 만드는 프로그램을 작성하시오.
예를 들어, 레벨이 5까지 있고, 레벨이 1, 2, 3, 4, 5인 캐릭터를 각각 1, 2, 3, 4, 5마리 가지고 있는 경우를 생각해보자. 또, 레벨이 1, 2, 3, 4, 5인 캐릭터의 힘이 각각 1, 2, 3, 4, 5인 경우이다. 가장 처음에 해빈이가 가지고 있는 캐릭터의 힘의 합은 1*1 + 2*2 + 3*3 + 4*4 + 5*5 = 55가 된다. 10일동안 적절히 훈련시키면 힘의 합 65를 만들 수 있다.
해빈이가 가지고 있는 캐릭터의 수가 각 레벨별로 주어지고, 각 레벨에 해당하는 힘이 주어졌을 때, D일동안 훈련시켜서 얻을 수 있는 캐릭터의 힘의 합 중 최댓값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 캐릭터의 최대 레벨 N(1 ≤ N ≤ 50)이 주어진다. 둘째 줄에는 해빈이가 가지고 있는 캐릭터의 수가 각 레벨 별로 주어진다. 셋째 줄에는 캐릭터의 힘(1 ≤ 힘 ≤ 1,000,000)이 각 레벨 별로 주어진다. 넷째 줄에는 훈련시킬 수 있는 기간인 D (1 ≤ D ≤ 100)가 주어진다.
<출력값>
첫째 줄에 D일동안 훈련시켜서 얻을 수 있는 캐릭터의 힘의 합 중 최댓값을 출력한다.

<문제 1424>
인기 펑크 락밴드 SHOM은 새 앨범을 내기로 했다. SHOM의 새 앨범에는 총 N개의 노래가 들어간다. SHOM은 요번 앨범에는 새로운 시도를 했는데, 앨범에 수록되는 모든 노래의 길이가 모두 같다.
시디 한 장에는 C초만큼의 노래를 저장할 수 있다.
숌은 N개의 곡을 모두 앨범에 넣고 싶은 욕망이 있었기 때문에, N개의 곡을 몇 장의 씨디로 나누어야 할지 궁금해졌다. 하지만, 가격을 위해 시디의 개수를 최소화하고 싶었다.
하지만, SHOM의 보컬 이다솜은 자신의 미신 때문에, 절대로 시디에 녹음되는 노래의 개수가 13으로 나누어 떨어지면 안 된다는 조건을 걸었다.
시디에 노래를 두 곡이상 수록할 때, 어떤 노래와 어떤 노래 사이에는 1초의 공백이 반드시 필요하다.
SHOM의 새 앨범은 총 몇 장으로 발매될지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 노래의 개수 N이 주어진다. 이 값은 100,000보다 작거나 같은 자연수이다. 둘째 줄에는 노래의 길이 L이 주어진다. 이 값은 초 단위이다. 셋째 줄에는 한 시디의 용량 C가 초 단위로 주어진다. C는 10,000보다 작거나 같은 자연수이고, L은 C보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 시디가 총 몇 장 필요한지 출력한다.

<문제 1425>
원숭이는 나무에 산다. 원숭이의 나라는 2차원의 정수좌표로 나타낼 수 있다.
땅은 X축에 있고, 나무는 모두 X축의 정수좌표에 심어져 있다. 나무는 수직으로만 자라고, 이 나라에서 나무는 밑으로도 자란다.
원숭이는 나무에서 위아래로만 이동할 수 있다. 원숭이도 나무에서 떨어질 수 있기 때문에, 나무에서 나무로 점프하는 위험한 행동은 하지 않는다. 그리고 땅에서는 좌우로 이동하거나, 나무를 탈 수 있다.
원숭이들을 서로 다른 좌표에 위치해 있다. 원숭이들의 거리는 다음과 같이 구한다.

만약 두 원숭이가 같은 X좌표에 있다면 (같은 나무에 있다면) 두 원숭이의 거리는 Y좌표의 차이이다. (파란색 그림)
만약 두 원숭이가 다른 X좌표에 있다면 (다른 나무에 있다면) 두 원숭이의 거리는 땅과 원숭이 1 사이의 거리 + 땅과 원숭이 2 사이의 거리 + 그들의 X좌표의 차이 이다. (초록색, 분홍색 그림)


원숭이들의 왕 엔토피아는 원숭이들의 생활을 좀 더 편하게 해주기 위해서 땅을 옮기려고 한다.
엔토피아는 각 원숭이들의 거리의 최댓값을 최소화하려고 한다.
땅을 옮길때는 Y=N과 같이 X축에 수평인 방향으로만 옮길 수 있다. 땅을 옮기지 않을 수도 있다. 이때, N은 항상 정수이어야 한다.
원숭이의 위치가 주어졌을 때, 땅을 옮기거나 옮기지 않아서 원숭이들의 거리의 최댓값의 최솟값을 출력한다.
<입력값>
첫째 줄에 원숭이가 몇 마리 있는 지 주어진다. 원숭이는 적어도 2마리는 존재하며, 100마리를 넘지 않는다. 둘째 줄에 각 원숭이들의 좌표가 주어진다. 원숭이들의 좌표는 X좌표 Y좌표 순으로 주어진다. 좌표의 절댓값은 1,000,000,000보다 작거나 같다.
<출력값>
첫째 줄에 원숭이들의 거리의 최댓값의 최솟값을 출력한다.

<문제 1426>
세준이는 N장의 카드를 가지고 있다. 각각의 카드에는 숫자가 쓰여져 있고, 문자도 하나 쓰여져 있다. 그리고, 세준이는 카드를 넣을 수 있는 통을 하나 가지고 있다.
세준이는 카드를 아무렇게나 통에 넣고는 했는데, 어느 날 다솜이가 세준이의 카드 통에 숫자를 써놓고 도망갔다.
세준이는 정말 화가 나서 숫자를 지우고 싶었지만, 지우는 방법을 몰라서 새로운 규칙을 만들어서 카드를 통에 넣으려고 한다.
카드를 통에 넣는 방법은 다음과 같다. 일단 카드 한 장을 고른다. 그리고 카드에 쓰여져 있는 번호보다 작거나 같은 통에 카드를 넣는다.
이렇게 카드를 넣는 방법은 여러 가지가 존재한다. 하지만 세준이는 앞에서부터 차례대로 카드에 쓰여져 있는 문자를 문자열로 만들어서 그 문자열이 가장 사전 순으로 앞서는 문자열을 알고 싶어한다.
예를 들면, 카드가 세 장이 있다. (1, A), (2, B), (3, C)가 있다.
  그리고 통에 쓰여져 있는 숫자는 2 2 1  이다.
  그럼 일단 첫 번째 통에 2번 카드를 넣고, 두 번째 통에 3번 카드를 넣고, 세 번째 통에 1번 카드를 넣으면, 문자열은 BCA가 돼서 규칙에 맞게 넣으면서 가장 사전순으로 빠른 문자열이 나온다.
세준이가 가지고 있는 카드와 통에 쓰여져 있는 숫자가 주어졌을 때, 사전순으로 가장 빠른 문자열을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 세준이가 가지고 있는 카드의 개수 N이 주어진다. 이 값은 1,000보다 작거나 같은 자연수이다. 둘째 줄에는 세준이가 가지고 있는 카드의 정보가 한 줄에 하나씩 주어진다. 카드의 정보는 숫자와 문자 하나가 공백을 사이에 두고 주어진다. 숫자는 1,000보다 작거나 같은 자연수이고, 문자는 알파벳 대문자이다. 마지막 줄에는 통에 쓰여져 있는 숫자가 공백을 사이에 두고 주어진다. 이 값은 1,000보다 작거나 같다.
<출력값>
첫째 줄에 사전순으로 제일 빠른 문자열을 출력한다. 만약 규칙대로 통에 넣을 수 없으면 -1을 출력한다.

<문제 1427>
배열을 정렬하는 것은 쉽다. 수가 주어지면, 그 수의 각 자리수를 내림차순으로 정렬해보자.
<입력값>
첫째 줄에 정렬하고자하는 수 N이 주어진다. N은 1,000,000,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 자리수를 내림차순으로 정렬한 수를 출력한다.

<문제 1428>
다솜이는 엄청나게 큰 종이를 가지고 있다. 다솜이는 종이를 XY좌표로 생각한다. 그리고, 그 종이에 선을 N개 그었다. 선을 N개를 그리고 나서 종이를 본 후에 다솜이는 지금 내부에 선분이 없는 볼록 다각형이 총 몇 개가 있는지 궁금해졌다.
다솜이가 그은 선의 시작점과 끝점의 좌표가 주어졌을 때, 다각형이 총 몇 개 있는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 선의 개수 N이 주어진다. N은 100보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 선분의 정보가 시작점X 시적점Y 끝점X 끝점Y와 같이 주어진다. 모든 좌표는 -10,000보다 크거나 같고, 10,000보다 작거나 같은 자연수이다. 그리고, 모든 선분은 중복되지 않는다. 시작점과 끝점이 같은 경우는 없다.
<출력값>
첫째 줄에 다각형의 개수를 출력한다.

<문제 1429>
항승이네 마을에서 결혼이란 일반적인 결혼과는 약간 다르다. 항승이네 마을에서 결혼이란 한 명의 남편과 여러 명의 부인, 또는 여러 명의 남편과 한 명의 부인을 의미한다.
항승이네 마을에 남자가 총 N명, 여자가 총 M명 있다. 어떤 남자와 어떤 여자가 결혼을 하려면, 서로가 서로에게 호감이 있어야 한다.
항승이가 마을의 촌장으로써 할 일은 남자와 여자를 결혼을 시키는 것인데, 가능한 결혼의 개수를 최소화시키는 것이다. 모든 사람은 반드시 하나의 결혼을 해야만 한다. 즉, 결혼을 하지 않는 경우는 없다. 그 때 가능한 결혼의 수의 최솟값을 구하는 프로그램을 작성하시오. 모든 사람이 결혼을 할 수 없는 경우에는 -1을 출력한다.
<입력값>
첫째 줄에 N과 M이 주어진다. N과 M은 12보다 작거나 같은 자연수이다. 둘째 줄부터 총 N개의 줄에는 i번 남자와 1,2,3,...M번 여자가 호감이 있으면 1 없으면 0이 주어진다.
<출력값>
첫째 줄에 결혼의 개수의 최솟값을 출력한다. 만약 모든 사람이 결혼을 할 수 없으면 -1을 출력한다.

<문제 1430>
다솜이는 누구나 쉽게 게임을 만들 수 있도록 하기 위해 Microsoft에서 출시한 XNA Game Studio Express를 가지고 게임을 만들었다.
다솜이의 게임은 적의 공격에 대비해서 도시를 방어하는 게임이다. 도시에는 탑이 N개가 있다. 각각의 탑은 X-Y좌표 평면위에 존재한다. 또, 탑은 맨 처음에 D의 에너지를 가지고 있고, 탑의 사정거리는 R이다.
탑 주변에 적이 나타나면, 탑은 적을 다음과 같은 방법으로 공격할 수 있다.
일단, 탑은 자신의 에너지를 재분배할 수 있다. 만약 서로 다른 두 탑의 거리가 R보다 작거나 같다면, 둘 중에 한 탑은 다른 탑에게 에너지를 자기가 가지고 있는 한도내에서 자유롭게 전송할 수 있다. 하지만, 에너지를 전송할 때는, 절반을 잃는다. (탑 1이 탑 2에게 에너지를 10 전송하면, 탑 1은 에너지를 10을 잃고, 탑 2는 에너지를 5 얻는다.)
탑이 적을 공격할 때는, 적과 탑의 거리가 R보다 작거나 같아야한다. 탑에서 적을 공격할 때는, 자신의 모든 에너지를 적을 공격하는데 쓴다. 이때 적이 받는 데미지는 에너지의 양과 같다.
적이 받을 수 있는 에너지의 최댓값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 탑의 개수 N, 사정 거리 R, 초기 에너지 D, 적의 X좌표 X, 적의 Y좌표 Y가 주어진다. 둘째 줄부터는 탑의 위치가 한 줄에 하나씩 X좌표 Y좌표 순으로 주어진다. N은 100보다 작거나 같은 자연수이고, R은 5,000보다 작거나 같은 자연수, D는 1,000보다 작거나 같은 자연수이다. 모든 X좌표와 Y좌표는 1,000보다 작거나 같은 음이 아닌 정수이다. 탑의 위치가 같은 경우는 없고, 적과 탑의 위치가 같은 경우도 입력으로 주어지지 않는다.
<출력값>
첫째 줄에 적이 받는 데미지의 최댓값을 소수점 셋째 자리에서 반올림 한 값을 출력한다.

<문제 1431>
다솜이는 기타를 많이 가지고 있다. 그리고 각각의 기타는 모두 다른 시리얼 번호를 가지고 있다. 다솜이는 기타를 빨리 찾아서 빨리 사람들에게 연주해주기 위해서 기타를 시리얼 번호 순서대로 정렬하고자 한다.
모든 시리얼 번호는 알파벳 대문자 (A-Z)와 숫자 (0-9)로 이루어져 있다.
시리얼번호 A가 시리얼번호 B의 앞에 오는 경우는 다음과 같다.

A와 B의 길이가 다르면, 짧은 것이 먼저 온다.
만약 서로 길이가 같다면, A의 모든 자리수의 합과 B의 모든 자리수의 합을 비교해서 작은 합을 가지는 것이 먼저온다. (숫자인 것만 더한다)
만약 1,2번 둘 조건으로도 비교할 수 없으면, 사전순으로 비교한다. 숫자가 알파벳보다 사전순으로 작다.

시리얼이 주어졌을 때, 정렬해서 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 기타의 개수 N이 주어진다. N은 1,000보다 작거나 같다. 둘째 줄부터 N개의 줄에 시리얼 번호가 하나씩 주어진다. 시리얼 번호의 길이는 최대 50이고, 알파벳 대문자 또는 숫자로만 이루어져 있다. 시리얼 번호는 중복되지 않는다.
<출력값>
첫째 줄부터 차례대로 N개의 줄에 한줄에 하나씩 시리얼 번호를 정렬한 결과를 출력한다.

<문제 1432>
N개의 정점이 있는 그래프가 주어지면, 다음과 같은 방법에 의해서 정점의 번호를 다시 매기고 싶다.
모든 그래프의 번호는 1보다 크거나 같고 N보다 작거나 같은 번호를 가져야 한다.
만약 V1에서 V2로 연결된 간선이 있다면, V2의 번호는 V1보다 커야 한다.
위와 같은 조건을 이용해서 그래프의 번호를 다시 매긴 후에, 1번 정점의 새로 고친 번호를 M1, 2번 정점의 새로 고친 번호를 M2, ..., N번 정점의 새로 고친 번호를 MN이라고 하면, N개의 수열이 만들어진다.
이 수열을 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 정점의 개수 N이 주어진다. 둘째 줄부터 N개의 줄에는 인접행렬 형식으로 입력이 주어진다. 0은 연결되지 않았음을 의미하고, 1은 연결되었다는 것을 의미한다. N은 300보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 수열의 각 원소를 차례대로 공백을 사이에 두고 출력한다. 만약 그래프의 번호를 수정할 수 없다면 -1을 출력한다. 답이 여러 개일 경우에는 사전 순으로 제일 앞서는 것을 출력한다.

<문제 1433>
화학에서 말하는 솔루션은 컴퓨터 프로그래밍에서 말하는 솔루션과 다른 의미를 가지고 있다.
x리터의 어떤 물질을 (100-x)리터의 물에 넣으면 어떤 물질의 x% 솔루션을 얻는다고 한다. (한국어로 x% 용액)
다솜이는 같은 물질의 용액을 담고 있는 N개의 병을 가지고 있다. 각각의 병에는 몇 리터가 들어있고, 몇 % 용액인지 이름표가 붙어있다.
다솜이는 N개의 병의 용액을 몇 개 골라서 한 병에 모아서 (빈 병이 아니라 N개의 병 중에 하나) M% 용액을 만들려고 한다. M% 용액을 최대 몇 리터 얻을 수 있는지 구하는 프로그램을 작성하시오. (꼭 전부 섞을 필요는 없다. 약간만 섞어도 됨)
<입력값>
첫째 줄에 다솜이가 가지고 있는 병의 개수 N과 만들고자 하는 용액의 농도 M이 주어진다. N은 1,000보다 작거나 같은 자연수이다. 둘째 줄부터 한 줄에 하나씩 각각의 병의 정보가 주어진다. 병의 정보는 몇%용액인지와 용액의 양 이 공백을 사이에 두고 주어진다. 용액의 양은 1,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 M% 용액을 최대 몇 L만들 수 있는지 최댓값을 출력한다. 절대/상대 오차는 10-2까지 허용한다.

<문제 1434>
빈 박스 N개가 한 줄로 놓여져 있고, 박스에 책 M개를 넣으려고 한다. 박스는 1번부터 N번까지 번호가 매겨져 있고, 책도 1번부터 M번까지 번호가 매겨져 있다. 다음은 책을 박스에 넣는 방법이며, 가장 처음에는 1번 박스의 앞에 있고, 손에는 1번 책을 들고 있다.

현재 책이 현재 박스에 들어가지 않으면, 3번으로 간다. 아니면 2번으로 간다.
현재 책을 현재 박스에 넣는다. 다음 책을 손에 집고 1번으로 간다.
현재 박스를 다른 쪽으로 치운 다음에, 테이프로 못 열게 봉인한다. 다음 박스를 앞으로 가져오고 1번으로 간다.

i번 박스의 용량은 Ai이고, j번 책의 크기는 Bj이다. 책의 크기와 박스에 들어있는 책의 크기의 합이 박스의 용량을 넘지 않으면 책을 박스에 넣을 수 있다.
위의 방법대로 책을 넣었을 때, 전체 박스의 낭비된 용량의 합을 구하는 프로그램을 작성하시오. 박스의 낭비된 용량은 박스의 용량에서 박스에 들어있는 책의 크기의 합을 뺀 값이다.
입력으로 주어진 박스와 책의 순서를 변경하면 안된다.
<입력값>
첫째 줄에 박스의 개수 N, 책의 개수 M이 주어진다. 둘째 줄에는 박스의 용량 A1, A2, ..., AN이 주어지고, 셋째 줄에는 B1, B2, ..., BM이 주어진다.
<출력값>
첫째 줄에 전체 박스의 낭비된 용량의 합을 출력한다.

<문제 1435>
네 점의 거리의 차가 주어지면, 그러한 거리의 차이를 만족하는 네 점이 공간에 존재하는지 없는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 1번 점과 1번 점의 거리, 1번 점과 2번 점의 거리, 1번 점과 3번 점의 거리, 1번 점과 4번 점의 거리가 공백을 사이에 두고 주어진다. 둘째, 셋째, 넷째 줄도 첫째 줄과 같이 주어진다. 둘째 줄은 2번 점과의 거리, 셋째 줄은 3번 점과의 거리, 넷째 줄은 4번 점과의 거리가 주어진다.
<출력값>
입력으로 주어진 점이 존재하면 YES, 존재하지 않으면 NO를 출력한다.

<문제 1436>
666은 종말을 나타내는 숫자라고 한다. 따라서, 많은 블록버스터 영화에서는 666이 들어간 제목을 많이 사용한다. 영화감독 숌은 세상의 종말 이라는 시리즈 영화의 감독이다. 조지 루카스는 스타워즈를 만들 때, 스타워즈 1, 스타워즈 2, 스타워즈 3, 스타워즈 4, 스타워즈 5, 스타워즈 6과 같이 이름을 지었고, 피터 잭슨은 반지의 제왕을 만들 때, 반지의 제왕 1, 반지의 제왕 2, 반지의 제왕 3과 같이 영화 제목을 지었다.
하지만 숌은 자신이 조지 루카스와 피터 잭슨을 뛰어넘는다는 것을 보여주기 위해서 영화 제목을 좀 다르게 만들기로 했다.
종말의 숫자란 어떤 수에 6이 적어도 3개이상 연속으로 들어가는 수를 말한다. 제일 작은 종말의 숫자는 666이고, 그 다음으로 큰 수는 1666, 2666, 3666, .... 과 같다.
따라서, 숌은 첫 번째 영화의 제목은 세상의 종말 666, 두 번째 영화의 제목은 세상의 종말 1666 이렇게 이름을 지을 것이다. 일반화해서 생각하면, N번째 영화의 제목은 세상의 종말 (N번째로 작은 종말의 숫자) 와 같다.
숌이 만든 N번째 영화의 제목에 들어간 숫자를 출력하는 프로그램을 작성하시오. 숌은 이 시리즈를 항상 차례대로 만들고, 다른 영화는 만들지 않는다.
<입력값>
첫째 줄에 숫자 N이 주어진다. N은 10,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 N번째 영화의 제목에 들어간 수를 출력한다.

<문제 1437>
음이 아닌 정수 N을 한 개 이상의 음이 아닌 정수의 합으로 나타낼 때, 이를 "N을 분해한다"라고 부르자.
예를 들어, 4 = 1+1+1+1 = 1+1+2 = 1+3 = 2+2 = 4 로 나눌 수 있다.
분해 곱이란 N을 분해해서 나타난 수들을 전부 곱한 것을 의미한다. N=4일 때, 분해 곱은 다음과 같다.

4 = 1+1+1+1, 곱 : 1×1×1×1 = 1
4 = 1+1+2, 곱 : 1×1×2 = 2
4 = 1+3, 곱 : 1×3 = 3
4 = 2+2, 곱 : 2×2 = 4
4 = 4, 곱 : 4

N이 주어졌을 때, 그 수의 분해 곱의 최댓값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 음이 아닌 정수 N이 주어진다. N은 1,000,000보다 작거나 같다.
<출력값>
첫째 줄에 입력으로 주어진 수의 분해 곱의 최댓값을 10,007로 나눈 나머지를 출력한다.

<문제 1438>
현수는 어떤 좌표 평면에 점을 N개 찍었다. 신기하게도, 모든 점은 음이 아닌 정수 좌표에만 찍혔다.
현수는 직사각형을 하나 그리려고 하는데, 직사각형의 꼭짓점은 모두 정수 좌표이고, 모든 변이 X축과 Y축에 평행한 직사각형을 그리려고 한다. 또, 직사각형의 내부에 현수가 찍은 점이 적어도 N/2개가 들어있는 직사각형을 그리려고 한다. 점이 직사각형의 변 위에 놓여져 있는 것은 내부에 있는 것이 아니다.
이러한 직사각형 중에 넓이가 가장 작은 직사각형의 넓이를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 점의 개수 N이 주어진다. N은 항상 짝수이며, 100보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 현수가 찍은 점의 정보가 X좌표 Y좌표 순으로 들어온다. 각각의 좌표는 10,000보다 작거나 같은 음이 아닌 정수이다. 모든 점은 중복되지 않는다.
<출력값>
첫째 줄에 현수가 만든 직사각형 중 가장 넓이가 가장 작은 것의 넓이를 출력한다.

<문제 1439>
다솜이는 0과 1로만 이루어진 문자열 S를 가지고 있다. 다솜이는 이 문자열 S에 있는 모든 숫자를 전부 같게 만들려고 한다. 다솜이가 할 수 있는 행동은 S에서 연속된 하나 이상의 숫자를 잡고 모두 뒤집는 것이다. 뒤집는 것은 1을 0으로, 0을 1로 바꾸는 것을 의미한다.
예를 들어 S=0001100 일 때,

전체를 뒤집으면 1110011이 된다.
4번째 문자부터 5번째 문자까지 뒤집으면 1111111이 되어서 2번 만에 모두 같은 숫자로 만들 수 있다.

하지만, 처음부터 4번째 문자부터 5번째 문자까지 문자를 뒤집으면 한 번에 0000000이 되어서 1번 만에 모두 같은 숫자로 만들 수 있다.
문자열 S가 주어졌을 때, 다솜이가 해야하는 행동의 최소 횟수를 출력하시오.
<입력값>
첫째 줄에 문자열 S가 주어진다. S의 길이는 100만보다 작다.
<출력값>
첫째 줄에 다솜이가 해야하는 행동의 최소 횟수를 출력한다.

<문제 1440>
다솜이는 타임머신을 타고 8364년으로 갔다. 다행히 지구는 평화롭다.
다솜이는 2008년으로 돌아가기 전에 시계를 샀다. 다솜이는 시계를 볼 줄 모르기 때문에, 디지털 시계를 샀다. 디지털 시계는 HH:MM:SS와 같은 모양으로 시간을 나타내 준다. 그리고 앞에서부터 차례대로 HH는 시, MM은 분, SS는 초를 나타낸다.
다솜이는 8364년에는 2008년과 같은 방법으로 시간을 나타내는지 모른다. 2008년엔 시:분:초를 나타내는지만, 8364년엔 분:시:초로 나타낼지도 모른다.
다행히 시는 01부터 12, 분은 00부터 59, 초는 00부터 59를 나타낸다.
다솜이의 시계에 쓰여 있는 숫자가 주어졌을 때, 이 시간을 읽을 수 있는 가능한 방법의 수를 출력하는 프로그램을 작성하시오. 나타내는 시간이 같더라도, 시, 분, 초를 읽을 수 있는 위치가 다르면 다른 방법으로 센다. 또한, 방법의 수가 0일 수도 있다.
예를 들어, 21:23:01 은 21분 23초 01시 로 읽을 수도 있지만, 21초 23분 01시로 읽을 수도 있다.
<입력값>
첫째 줄에 시간이 주어진다. 시간은 DD:DD:DD와 같은 꼴로 주어진다. 항상 8자리(:도 포함)로만 들어오며, D는 0-9 사이의 숫자이다.
<출력값>
첫째 줄에 시간을 읽을 수 있는 가능한 방법의 수를 출력한다.

<문제 1441>
어떤 숫자 배열 A가 주어지면, L보다 크거나 같고, R보다 작거나 같은 자연수 중에, A에 속해있는 원소 중 적어도 하나로 나누어지는 수의 개수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 A의 크기 N과 L, R이 주어진다. N은 18보다 작거나 같은 자연수이고, L은 1,000,000,000보다 작거나 같은 자연수, R은 L보다 크거나 같고, 1,000,000,000보다 작거나 같은 자연수이다. 둘째 줄에 A에 속하는 원소가 들어온다. 각 원소는 공백을 사이에 두고 구분되어 있고, 원소는 1,000,000,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 L보다 크거나 같고, R보다 작거나 같은 자연수 중에, A에 속해있는 원소 중 적어도 하나로 나누어지는 수의 개수를 출력한다.

<문제 1442>
어떤 수를 이진수로 나타냈을 때, 적어도 3개의 연속되는 수가 있을 때, 그 숫자를 멋진 수라고 한다. 예를 들어, 8 (1000), 15 (1111)와 같은 수는 멋진 수 이지만, 27(11011)은 멋진 수가 아니다.
입력으로 L과 R이 주어졌을 때, L보다 크거나 같고, R보다 같거나 작은 수 중에 멋진 수가 총 몇개 있는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 L과 R이 주어진다. R은 0보다 크거나 같고, 2147483647보다 작거나 같은 자연수이고, L은 0보다 크거나 같고, R보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 입력으로 주어진 범위내에 멋진 수가 몇개있는지 출력한다.

<문제 1443>
다솜이의 보물 1호는 계산기이다. 어느 날 계산기를 떨어뜨리게 되었고, 계산기가 망가지게 되었다. 계산기는 이제 D자리까지 밖에 나타나지 않는다. 다솜이는 이 계산기를 이용해서 재미있는 일을 해보려고 한다.
가장 처음에 계산기에 표시되어 있는 수는 1이다. 다솜이는 계산기에서 정확하게 P번 만큼의 곱셈을 하려고 한다. 한번의 곱셈에 다솜이는 화면에 나와있는 수에 2와 9를 포함해서 그 사이에 있는 자연수를 곱하려고 한다. 수를 곱한 결과는 반드시 D자리 이하여야 한다. 다솜이가 P번의 곱셈을 해서 구할 수 있는 가장 큰 수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 다솜이의 계산기가 표시할 수 있는 자리수 D와 다솜이가 하려고하는 연산의 수 P가 주어진다. D는 2보다 크거나 같고, 8보다 작거나 같은 자연수이고, P는 30보다 작거나 같은 음이아닌 정수이다.
<출력값>
첫째 줄에 다솜이가 만들 수 있는 가장 큰 수를 출력한다. 만약 P번의 연산을 수행했을 때 나오는 결과가 모두 D자리를 넘어간다면 -1을 출력한다.

<문제 1444>
과학자들은 기원전 찬란한 문명의 꽃을 이루었던 숌이라는 나라에 대한 관심을 가지고 있다. 과학자들은 마침내 2008년 숌이라는 나라의 언어인 숌어를 찾아내었다.
숌어는 두 종류의 상형문자를 쓰는데, 하나는 알파벳 대문자와 정말 비슷하게 생겼고, 또다른 하나는 알파벳 소문자와 정말 비슷하게 생겼다. 따라서 그냥 알파벳 대문자와 소문자라고 말하기로 했다.
숌어로 문장을 쓸 때는, 인접한 단어끼리는 서로 다른 타입이어야 한다. 각기 다른 타입이 서로 번갈아가면서 나와야 한다. 예를 들면, AaAbBaAcCaAa는 맞는 문장이지만, ACbD는 틀린 문장이다.
과학자들은 숌어에도 단어가 있다는 사실을 깨달았다. 단어는 항상 두글자이고, 서로 다른 타입의 쌍으로 나타낸다는 것을 알았다. 예를 들면, Aa, bB, bC는 올바른 단어이지만, AA, aa, BE와 같은 것은 올바르지 않은 단어이다.
더욱 놀라운 사실은, 숌이란 나라에 사는 사람은 아이큐가 최소 430이기 때문에, 단어를 겹쳐서 써도 다 알아듣는다는 것이다. 따라서, AaAbB는 Aa aA bB를 이용해서 만들 수 있는 문장이다.
위와 같은 사실 때문에, 어떤 문장을 만들 수 있는 경우의 수가 많다는 사실을 알았다.
AaAbBaAcCaAa라는 문장이 있을 때, 이 문장은 Aa, aA, bB, cC 라는 4개의 단어를 가지고 만든 문장이다.

어떤 문장이 있을 때, 최소 몇 개의 단어를 이용해야 다시 이 문장을 만들 수 있는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 문장이 주어진다. 문장의 길이는 최대 3,000이다. 문장은 알파벳으로만 이루어져있고, 항상 대문자와 소문자가 번갈아가면서 나온다.
<출력값>
첫째 줄에 필요한 단어의 최솟값을 출력한다.

<문제 1445>
일요일 아침에 형택이는 Maroon5의 Sunday Morning이란 노래를 들으면서 여자친구와의 로맨틱한 여행을 떠나기로 했다. 형택이는 이것저것 환상에 빠져있다가, 계획을 세우는데 실패했다. 따라서, 주위에 있는 숲을 같이 탐험하기로 했다.
깊은 숲속에는 정말 아름다운 꽃이 하나있다. 형택이는 여자친구의 마음을 감동시키기 위해서, 꽃을 보여주면서 자신의 마음을 전해주려고 급하게 계획했다.
불행하게도, 사람들이 숲에다 쓰레기를 버려서 형택이의 계획은 정말 망가지기 직전이다.
형택이는 그동안 여자친구와 사귀면서 2가지 깨달은 것이 있는데, 한 가지는 쓰레기를 통과해서 지나가는 것을 정말 싫어하는 것이고, 쓰레기를 따라 옆을 지나가는 것도 정말 불편하게 느낀다는 것이다.
형택이는 방금 쓰레기가 어디에있는지 조사를 마쳤다. 입력으로 숲의 지도가 주어진다. S는 형택이와 여자친구의 데이트 시작장소를  나타내고, F는 꽃이 있는 위치를 나타내고, g는 쓰레기가 있는 위치를 나타낸다. 그리고 .은 아무것도 없는 깨끗한 칸이다.
형택이의 목표는 S에서 F까지 가는데, 쓰레기로 차있는 칸을 되도록이면 적게 지나가는 것이다. 형택이와 여자친구는 한 번에 한 칸 움직일 수 있다. 가로 or 세로로 한 칸 움직일 수 있다. 만약 되도록 적게 지나가는 경우의 수가 여러개라면, 쓰레기 옆을 지나가는 칸의 개수를 최소로 해서 지나려고 한다. 만약 어떤 칸이 비어있는데, 인접한 칸에 쓰레기가 있으면 쓰레기 옆을 지나는 것이다. 그리고, S와 F는 세지 않는다.
<입력값>
첫째 줄에 숲의 세로 크기 N과 가로 크기 M이 주어진다. N과 M은 3보다 크거나 같고, 50보다 작거나 같은 자연수이다. 둘째 줄부터 숲의 지도가 주어진다. 숲의 지도는 S, F, g, . 만으로 이루어져 있다. S는 반드시 모서리에 위치해 있고, F는 모서리에 위치해있지 않다. 그리고 S와 F는 반드시 하나만 주어진다.
<출력값>
첫째 줄에 형택이와 여자친구가 가장 최적의 방법으로 숲을 지났을 때, 지나가는 쓰레기의 최소 개수를 출력하고, 공백으로 구분 한 후에 쓰레기 옆을 지나가는 칸의 개수를 출력한다.

<문제 1446>
매일 아침, 세준이는 학교에 가기 위해서 차를 타고 D킬로미터 길이의 고속도로를 지난다. 이 고속도로는 심각하게 커브가 많아서 정말 운전하기도 힘들다. 어느 날, 세준이는 이 고속도로에 지름길이 존재한다는 것을 알게 되었다. 모든 지름길은 일방통행이고, 고속도로를 역주행할 수는 없다.
세준이가 운전해야 하는 거리의 최솟값을 출력하시오.
<입력값>
첫째 줄에 지름길의 개수 N과 고속도로의 길이 D가 주어진다. N은 12 이하이고, D는 10,000보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 지름길의 시작 위치, 도착 위치, 지름길의 길이가 주어진다. 모든 위치와 길이는 10,000보다 작거나 같은 음이 아닌 정수이다. 지름길의 시작 위치는 도착 위치보다 작다.
<출력값>
세준이가 운전해야하는 거리의 최솟값을 출력하시오.

<문제 1447>
수빈이는 2차원 세계에 살고있는 농부이다. 수빈이가 심은 농작물은 모두 x축 위(y 좌표가 0인 곳)에 심어져 있다. 내일은 수빈이의 농작물에 매우 해로운 비가 내린다고 한다. 비는 Y축에 평행한 방향으로 계속해서 내린다. 모든 x(정수가 아닐 수도 있다)에 대해서, 비는 (x, 0)을 향해서 떨어지게 된다.
수빈이는 농작물을 보호하기 위해 땅 위에 보호 천막을 설치했다. 보호 천막은 x축에 평행한 선분으로 나타낼 수 있으며, 두꼐는 무시할 수 있다. 비가 천막에 떨어졌을 때, 비는 양 끝 점중 가까운 점을 향해서 흘러간다. 비가 끝 점에 도착하면, 그 점부터 다시 아래로 내리게 된다. 만약, 비가 천막의 가운데에 떨어졌다면, 비는 양 끝점을 향해 나누어진 상태로 흐르게 된다. 두 천막이 끝점을 공유하는 경우에는 천막 하나와 같이 행동한다.
각각의 보호 천막은 (bi, yi), (ei, yi)를 잇는 선분으로 나타낼 수 있다. B를 bi중에서 최솟값, E를 ei중에서 최댓값이라고 하자. 수빈이의 농작물이 (B, 0), (E, 0) 구간에 심어져있다고 할 때, 이 구간에 포함되는 모든 식물을 보호하기 위해 더 설치해야 하는 보호 천막 길이의 합을 구하는 프로그램을 작성하시오. 가능한 방법이 여러 가지인 경우에는 합이 최소인 것을 구한다.
보호 천막은 x축에 평행하고, y좌표는 양수이어야 한다. 또, 정수 좌표를 끝점으로 가져야 하며, 길이는 양수이어야 한다.
<입력값>
첫째 줄에 이미 쳐져있는 보호 천막의 개수 N(1 ≤ N ≤ 25)이 주어진다. 그 다음 N개의 줄에는 보호 천막의 정보가 bi, ei, yi 형식으로 주어진다. (0 ≤ bi, ei ≤ 10, 1 ≤ yi ≤ 100,000) 보호 천막이 겹쳐있는 경우는 없다. 단, 끝 점이 겹치는 경우는 있다.
<출력값>
첫째 줄에 수빈이가 모든 농작물을 보호하기 위해서 새로 설치해야하는 보호 천막 길이의 합의 최솟값을 출력한다.

<문제 1448>
세준이는 N개의 빨대를 가지고 있다. N개의 빨대 중에 3개의 빨대를 선택했을 때, 이 빨대로 삼각형을 만들 수 있다면, 세 변의 길이의 합의 최댓값을 구하고 싶다.
<입력값>
첫째 줄에 빨대의 개수 N이 주어진다. N은 3보다 크거나 같고, 1,000,000보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 빨대의 길이가 한 줄에 하나씩 주어진다. 빨대의 길이는 1,000,000보다 작거나 같다.
<출력값>
첫째 줄에 삼각형 세 변의 길이의 합의 최댓값을 출력한다. 만약 삼각형을 만들 수 없으면 -1을 출력한다.

<문제 1449>
항승이는 품질이 심각하게 나쁜 수도 파이프 회사의 수리공이다. 항승이는 세준 지하철 공사에서 물이 샌다는 소식을 듣고 수리를 하러 갔다.
파이프에서 물이 새는 곳은 신기하게도 가장 왼쪽에서 정수만큼 떨어진 거리만 물이 샌다.
항승이는 길이가 L인 테이프를 무한개 가지고 있다.
항승이는 테이프를 이용해서 물을 막으려고 한다. 항승이는 항상 물을 막을 때, 적어도 그 위치의 좌우 0.5만큼 간격을 줘야 물이 다시는 안 샌다고 생각한다.
물이 새는 곳의 위치와, 항승이가 가지고 있는 테이프의 길이 L이 주어졌을 때, 항승이가 필요한 테이프의 최소 개수를 구하는 프로그램을 작성하시오. 테이프를 자를 수 없고, 테이프를 겹쳐서 붙이는 것도 가능하다.
<입력값>
첫째 줄에 물이 새는 곳의 개수 N과 테이프의 길이 L이 주어진다. 둘째 줄에는 물이 새는 곳의 위치가 주어진다. N과 L은 1,000보다 작거나 같은 자연수이고, 물이 새는 곳의 위치는 1,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 항승이가 필요한 테이프의 개수를 출력한다.

<문제 1450>
세준이는 N개의 물건을 가지고 있고, 최대 C만큼의 무게를 넣을 수 있는 가방을 하나 가지고 있다.
N개의 물건을 가방에 넣는 방법의 수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N과 C가 주어진다. N은 30보다 작거나 같은 자연수이고, C는 10^9보다 작거나 같은 음이아닌 정수이고. 둘째 줄에 물건의 무게가 주어진다. 무게도 10^9보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 가방에 넣는 방법의 수를 출력한다.

<문제 1451>
세준이는 N*M크기로 직사각형에 수를 N*M개 써놓았다.
세준이는 이 직사각형을 겹치지 않는 3개의 작은 직사각형으로 나누려고 한다. 각각의 칸은 단 하나의 작은 직사각형에 포함되어야 하고, 각각의 작은 직사각형은 적어도 하나의 숫자를 포함해야 한다.
어떤 작은 직사각형의 합은 그 속에 있는 수의 합이다. 입력으로 주어진 직사각형을 3개의 작은 직사각형으로 나누었을 때, 각각의 작은 직사각형의 합의 곱을 최대로 하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 직사각형의 세로 크기 N과 가로 크기 M이 주어진다. 둘째 줄부터 직사각형에 들어가는 수가 가장 윗 줄부터 한 줄에 하나씩 M개의 수가 주어진다. N과 M은 100보다 작거나 같은 자연수이고, 직사각형엔 적어도 3개의 수가 있다. 또, 직사각형에 들어가는 수는 한 자리의 숫자이다.
<출력값>
세 개의 작은 직사각형의 합의 곱의 최댓값을 출력한다.

<문제 1452>
숌 크로스워드 퍼즐은 검정칸으로 칠해져 있고 그렇고 그런 크로스워드 퍼즐을 약간 변형한 것이다. 숌 크로스워드 퍼즐은 영어 단어 4개가 주어졌을 때, 아래 규칙을 모두 만족하는 크로스워드 퍼즐을 총 몇 개 만들 수 있는지 구하는 퍼즐이다.
숌 크로스워드 퍼즐의 규칙은 다음과 같다.
1. 모든 네 개의 단어는 정확하게 한 번 크로스워드 퍼즐에 등장해야 한다.
  2. 네 개의 단어중 두 개는 반드시 가로로 쓰여야 한다. (왼쪽에서 오른쪽으로)
  3. 네 개의 단어중 두 개는 반드시 세로로 쓰여야 한다. (위쪽에서 아래쪽으로)
  4. 가로로 쓰여진 모든 단어는 세로로 쓰여진 모든 단어와 교차해야 한다. (정확하게 하나의 단어를 공유)
  5. 세로로 쓰여진 모든 단어는 가로로 쓰여진 모든 단어와 교차해야 한다. (정확하게 하나의 단어를 공유)
  6. 가로로 쓰여진 모든 단어는 적어도 하나의 빈 행으로 구분되어야 한다.
  7. 세로로 쓰여진 모든 단어는 적어도 하나의 빈 열으로 구분되어야 한다.
이러한 규칙으로 여러 개의 크로스워드 퍼즐을 만들 수 있는데, 이때 두 크로스워드 퍼즐이 서로 다를 조건은 가장 왼쪽에 쓰여진 글자를 0번으로 하고, 가장 위쪽에 쓰여진 글자를 0번으로 해서 모든 단어의 상대적인 위치가 같으면 같은 글자로 친다.
예를 들어, 단어가 zaxb, axc, cxd, bxdy라고 하면, 두 가지 크로스워드 퍼즐을 만들 수 있다.
           z
zaxb       axc
 x x       x x
 cxd       bxdy
   y
<입력값>
네 개의 단어가 한 줄에 하나씩 입력으로 주어진다. 각 단어의 길이는 3보다 크거나 같고 15보다 작거나 같다.
<출력값>
첫째 줄에 경우의 수를 출력한다.

<문제 1453>
세준이는 피시방에서 아르바이트를 한다. 세준이의 피시방에는 1번부터 100번까지 컴퓨터가 있다.
들어오는 손님은 모두 자기가 앉고 싶은 자리에만 앉고싶어한다. 따라서 들어오면서 번호를 말한다. 만약에 그 자리에 사람이 없으면 그 손님은 그 자리에 앉아서 컴퓨터를 할 수 있고, 사람이 있다면 거절당한다.
거절당하는 사람의 수를 출력하는 프로그램을 작성하시오. 자리는 맨 처음에 모두 비어있고, 어떤 사람이 자리에 앉으면 자리를 비우는 일은 없다.
<입력값>
첫째 줄에 손님의 수 N이 주어진다. N은 100보다 작거나 같다. 둘째 줄에 손님이 들어오는 순서대로 각 손님이 앉고 싶어하는 자리가 입력으로 주어진다.
<출력값>
첫째 줄에 거절당하는 사람의 수를 출력한다.

<문제 1454>
세비 게임은 여섯 면의 주사위 다섯 개를 이용해서 하는 게임이다. 세비 게임은 둘이서 한다.
일단 플레이어 1이 주사위 다섯 개를 모두 던진다. 그 다음에 플레이어 2가 플레이어 1이 던진 주사위 다섯 개 중 적어도 두 개를 골라서 플레이어 1이 다시 던지게 한다. 그러고 나면 플레이어 1은 플레이어 2가 골라준 주사위를 다시 던지게 된다.
점수를 매기는 방법은 다음과 같다.

세비 : 5개의 주사위가 모두 같은 숫자를 보여줄 때
세비스트레이트 : 5개의 주사위의 숫자가 연속될 때 (예, 1 2 3 4 5 or 2 3 4 5 6)
스트레이트 : 5개의 주사위 중에 4개의 주사위가 연속될 때
풀 하우스 : 5개의 주사위 중 3개의 주사위가 같은 숫자를 나타내고, 또 다른 2개의 주사위가 같은 숫자를 나타낼 때 예) (1 3 1 1 3), (2 2 2 2 2)

입력으로 위의 점수가 주어지고, 플레이어 1이 던진 주사위가 주어지면, 플레이어 2가 적어도 두 개 이상의 주사위를 선택했을 때, 플레이어 1이 다시 주사위를 던져서 얻을 수 있는 점수의 기댓값을 가장 낮게 만드는 프로그램을 작성하시오.
<입력값>
첫째 줄에 세비 세비스트레이트 스트레이트 풀하우스의 점수가 주어진다. 둘째 줄에 플레이어 1이 던져서 나온 주사위의 눈이 주어진다. 점수는 10000보다 작은 음이 아닌 정수이고, 주사위의 눈은 1부터 6사이의 수이다.
<출력값>
첫째 줄에 다시 던져야하는 주사위의 개수를 출력한 후에 둘째 줄에는 플레이어 2가 선택한 주사위의 번호를 오름차순으로 출력한다. 주사위의 번호는 입력으로 주어진 순서대로 1부터 5이다. 만약 기댓값이 같다면 사전순으로 앞서는 것을 출력한다.

<문제 1455>
세준이는 동전 뒤집기를 하려고 한다. 세준이는 동전을 N*M개 가지고 있다. 동전은 세로로 N개, 가로로 M개 크기의 직사각형에 차곡차곡 놓여져 있다.
동전의 앞면을 0이라고 하고 뒷면을 1이라고 했을 때, 세준이는 모든 동전을 뒤집어서 앞면으로 만들려고 한다.
세준이가 (a,b)칸을 뒤집으려고 한다면, (i,j) (1<=i<=a, 1<=j<=b)의 조건을 만족하는 a*b개의 동전이 한번에 모두 뒤집힌다. (i는 위에서부터 위치의 위치이고, j는 왼쪽에서 부터의 위치이다.)
세준이가 뒤집어야하는 동전의 개수를 출력하시오. (a,b)칸을 선택해서 a*b개가 뒤집혔다면, 동전을 뒤집은 횟수는 a*b가 아니라 1이다.
<입력값>
첫째 줄에 세로크기 N과 가로크기 M이 주어진다. N과 M은 100보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 M개의 동전 상태가 주어진다.
<출력값>
첫째 줄에 세준이가 동전을 뒤집는 횟수를 출력한다.

<문제 1456>
어떤 수가 소수의 N제곱(N ≥ 2) 꼴일 때, 그 수를 거의 소수라고 한다.
A와 B가 주어지면, A보다 크거나 같고, B보다 작거나 같은 거의 소수가 몇 개인지 출력한다.
<입력값>
첫째 줄에 왼쪽 범위 A와 오른쪽 범위 B가 공백 한 칸을 사이에 두고 주어진다. A의 범위는 10^14보다 작거나 같은 자연수이고, B는 A보다 크거나 같고, 10^14보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 총 몇 개가 있는지 출력한다.

<문제 1457>
0보다 큰 정수 K가 M보다 작은 약수이지만, M이 K^N으로 나누어떨어지지 않을 때, K를 M의 멋진 약수라고 한다. d(M)을 M의 멋진 약수의 개수라고 했을 때, d(A) + d(A+1) + ... + d(A+B)를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 세 개의 정수 A B N이 들어온다. A는 1보다 크거나 같고 10^6보다 작거나 같은 자연수이고, B는 1보다 크거나 같고 10^7보다 작거나 같은 자연수이고, N은 2보다 크거나 같고 10보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 답을 출력한다. 정답은 항상 2147483647보다 작거나 같다.

<문제 1458>
세준이는 종이1과 종이2가 있다. 종이1의 크기가 N1 * M1이고, 종이2의 크기는 N2 * M2이다. 각각의 종이는 빈칸과 빈칸이 아닌 칸이 있는데, 빈칸은 .으로 빈칸이 아닌 칸은 X로 표시한다. 세준이는 종이1과 종이2를 겹쳐서 (겹치지 않아도 된다.) X로만 이루어진 직사각형을 가장 크게만들려고 한다. 종이1과 종이2는 각각을 90도 단위로 회전시키는 것도 가능하고, 뒤집는 것도 가능하다.
종이1과 종이2를 적절히 겹쳐서 X로 이루어진 직사각형 넓이의 최대를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 종이1의 크기 N1과 M1가 입력으로 들어온다. 그 뒤 N1줄에 종이의 정보가 들어오고, 종이2의 정보도 이와 마찬가지로, N1+2번째 줄부터 들어온다. (1 ≤ N1, M1, N2, M2 ≤ 50)
<출력값>
첫째 줄에 X로 이루어진 가장 큰 직사각형의 넓이를 출력한다.

<문제 1459>
세준이는 학교에서 집으로 가려고 한다. 도시의 크기는 무한대이고, 도시의 세로 도로는 모든 정수 x좌표마다 있고, 가로 도로는 모든 정수 y좌표마다 있다. 세준이는 현재 (0, 0)에 있다. 그리고 (X, Y)에 위치한 집으로 가려고 한다. 세준이가 걸을 수 있는 방법은 두가지 인데, 하나는 도로를 따라서 가로나 세로로 한 블록 움직여서 이번 사거리에서 저 사거리로 움직이는 방법이고, 블록을 대각선으로 가로지르는 방법이 있다.
세준이가 집으로 가는데 걸리는 최소시간을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 집의 위치 X Y와 걸어서 한 블록 가는데 걸리는 시간 W와 대각선으로 한 블록을 가로지르는 시간 S가 주어진다. X와 Y는 1,000,000,000보다 작거나 같은 음이 아닌 정수이고, W와 S는 10,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 세준이가 집에가는데 걸리는 최소시간을 출력한다.

<문제 1460>
진욱이는 N*N 크기의 정사각형 농장을 가지고 있다. 농장은 1*1크기의 칸으로 나누어져 있고, 각 칸은 한 종류의 과일이 심어져 있다. 가장 처음에 농장에는 모두 0번 과일만 심어져 있다. 
진욱이는 총 씨앗을 M번 뿌리려고 한다. 이때, 씨앗을 뿌리는 방벙은 네 정수 X, Y, L, F로 나타낼 수 있다. 여기서 (X, Y)는 정사각형의 왼쪽 위 모서리 좌표이고, L은 정사각형 변의 길이, F는 씨앗의 종류이다. 만약, 씨를 이미 뿌린 곳에 또 뿌리는 경우에는, 원래 심어져있던 씨가 없어지고, 새로운 씨가 심어지게 된다. 가장 왼쪽 위 모서리의 좌표는 (0, 0)이다.
진욱이는 군대에 입대하기 전에 준규에게 농장의 일부를 주고 가려고 한다. 준규가 정사각형 모양으로 농장을 가져갈 수 있다. 이때, 정사각형에 포함된 과일의 종류는 최대 두 종류이어야 하고, 0번 과일은 가져갈 수 없다.
준규가 가져갈 수 있는 가장 넓은 농장의 넓이를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 농장의 크기 N(1 ≤ N ≤ 1,000)과 씨앗을 뿌린 횟수 M(1 ≤ M ≤ 50)이 주어진다.
둘째 줄부터 M개의 줄에는 씨를 뿌린 방법이 주어진다. 각각의 줄은 X, Y, L, F로 이루어져 있다. (0 ≤ X, Y ≤ N-1, 1 ≤ X+L, Y+L ≤ N, 0 ≤ F ≤ 7)
<출력값>
준규가 가져갈 수 있는 가장 넓은 정사각형의 넓이를 출력한다.

<문제 1461>
세준이는 도서관에서 일한다. 도서관의 개방시간이 끝나서 세준이는 사람들이 마구 놓은 책을 다시 가져다 놓아야 한다. 세준이는 현재 0에 있고, 사람들이 마구 놓은 책도 전부 0에 있다. 각 책들의 원래 위치가 주어질 때, 책을 모두 제자리에 놔둘 때 드는 최소 걸음 수를 계산하는 프로그램을 작성하시오. 세준이는 한 걸음에 좌표 1칸씩 가며, 책의 원래 위치는 정수 좌표이다. 책을 모두 제자리에 놔둔 후에는 다시 0으로 돌아올 필요는 없다. 그리고 세준이는 한 번에 최대 M권의 책을 들 수 있다.
<입력값>
첫째 줄에 책의 개수 N과, 세준이가 한 번에 들 수 있는 책의 개수 M이 주어진다. 둘째 줄에는 책의 위치가 주어진다. N은 10,000보다 작거나 같은 자연수이고, M은 10,000보다 작거나 같다. 책의 위치는 0이 아니며, 그 절댓값이 10,000보다 작거나 같다.
<출력값>
첫째 줄에 정답을 출력한다.

<문제 1462>
도현이는 TV 퀴즈쇼에 참가했다. 도현이는 총 N개의 문제를 풀어야 하고, 1번부터 차례대로 풀어야 한다.
도현이는 미리 해킹을 통해 모든 문제의 정답을 알고있다. 따라서, 각 문제에 대해서 정답을 맞출지 안 맞출지를 결정할 수 있다.
정답을 맞추면 코인 1개와 그 문제에 해당하는 점수를 받게되고, 맞추지 못하면 지금까지 가지고 있던 모든 코인을 빼앗기고, 그 문제에 해당하는 점수를 감점받는다. 
만약, 코인을 M개를 모은다면, 그 문제에 해당하는 보너스 점수를 획득하고 코인을 모두 반납한다.
도현이가 얻을 수 있는 최대 점수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 문제의 개수 N과 보너스 점수를 얻는데 필요한 코인의 개수 M이 주어진다. (1 ≤ N, M ≤ 500,000)
둘째 줄에는 각 문제에 해당하는 점수가 1번 문제부터 주어지고, 셋째 줄에는 각 문제에 해당하는 보너스 점수가 1번 문제부터 주어진다. 모든 점수는 10,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 도현이가 얻을 수 있는 최대 점수를 출력한다.

<문제 1463>
정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.

X가 3으로 나누어 떨어지면, 3으로 나눈다.
X가 2로 나누어 떨어지면, 2로 나눈다.
1을 뺀다.

정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.
<입력값>
첫째 줄에 1보다 크거나 같고, 106보다 작거나 같은 정수 N이 주어진다.
<출력값>
첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.

<문제 1464>
세준이는 어떤 문자열 S를 뒤집으려고 한다. 문자열을 뒤집는 방법은 문자열의 길이를 N이라고 하자. i만큼을 뒤집는다는 소리는 그 문자열의 처음부터 정확하게 i개의 문자를 역순으로 뒤집는 것이다. 세준이는 1부터 N까지 수를 차례대로 생각한다. 그리고, 뒤집을지 안 뒤집을지 선택할 수 있다.
예를 들어, S="BCDAF" 이고, 세준이가 길이 1만큼을 뒤집지 않고, 길이 2만큼도 뒤집지 않고 세준이가 길이 3만큼을 뒤집는다고 하면 문자열은 DCBAF가 된다. 다시 여기서 4만큼 뒤집으면 ABCDF가 된다. 그리고, 마지막으로 길이를 5만큼 뒤집지 않으면 주어진 문자열 S를 사전순으로 가장 앞서게 만들 수 있다.
문자열 S가 주어졌을 때, 위와같은 뒤집기 방법으로 만들 수 있는 문자열 중 사전순으로 제일 앞서는 것을 출력하시오.
<입력값>
첫째 줄에 문자열 S가 주어진다. 문자열의 길이는 최대 10,000이다. 알파벳 대문자만 들어온다.
<출력값>
첫째 줄에 사전순으로 가장 앞서는 정답을 출력한다.

<문제 1465>
어떤 배열 A가 주어졌을 때, 이 배열과 크기가 같고, 배열에 속하는 모든 원소 X가 low <= X <= high이며, 새로 바꾼 배열을 B라고 했을 때, A[i]와 B[i]의 비트 차이가 최소인 배열 B를 출력하는 프로그램을 작성하시오.
만약 B가 여러개일 경우에는 사전순으로 먼저오는 것을 출력한다.
어떤 수 a와 b의 비트 차이를 계산하는 방법은, a를 이진수로 바꾸고, b도 이진수로 바꾼다. 만약 두 수의 길이가 서로 다르다면, 길이가 같아질 때 까지 짧은 이진수의 왼쪽에 0으로 채운다. 그 뒤에 각자리의 비트가 차이나는 것의 개수를 채우면 된다.
<입력값>
첫째 줄에 첫째 줄에 A의 크기 N과 low high가 입력으로 들어온다. low는 2147483647보다 작거나 같은 음이 아닌 정수이고, high는 2147483647보다 작거나 같고, low보다 크거나 같은 음이 아닌 정수이다. N은 50보다 작거나 같은 자연수이다. 둘째 줄에는 배열 A의 원소가 입력으로 들어온다. 각 원소는 2147483647보다 작거나 같은 음이 아닌 정수이다.
<출력값>
첫째 줄에 배열 B의 원소를 공백을 사이에 두고 출력한다.

<문제 1466>
세준이는 N*M크기의 그림을 그리려고 하는데 1*1크기의 정사각형마다 색을 다르게 칠한다. 세준이는 흰색과 검정색만을 이용하는데, 흰색을 . 검정색을 #이라고 한다.
만약 두 개의 검정색 칸이 서로 공통된 변을 공유하고 있다면, 두 칸은 직접 연결되어 있는 것이다. 두 개의 검정색 칸 A와 B가 간접적으로 연결되어 있다는 말은, A=P1 -> P2 -> ... -> Pk=B로 가는 경로가 있을 때 (Pi와 Pi+1은 직접 연결되어 있을 때) 간접적으로 연결되어 있다고 한다.
세준이의 그림에는 검정색 그룹이 몇 개 있는데, 그 그룹 속에 있는 모든 한 쌍의 검정색 칸은 직, 간접적으로 연결되어 있어야 한다. 다른 그룹과 연결되어 있는 것이 있으면 안 된다.
세준이의 그림에 존재하는 검정색 그룹의 특징은 그 그룹속의 모든 쌍의 경로의 길이가 그 쌍의 Manhattan Distance와 같다.
Manhattan Distance란 어떤 두 칸 A(Xa, Ya)와 B(Xb, Yb)가 있을 때, 두 칸의 거리는 |Xa-Xb| +|Ya-Yb|이다.
세준이가 그림을 다솜이에게 자랑을 하려고 보냈으나, 통신오류로 그림의 검정 칸중 일부가 흰색으로 변했다.
다솜이는 전송받은 그림을 고쳐서 원래 그림으로 만들려고 한다. 다솜이가 세준이의 그림의 특징을 지키면서 원래 그림으로 만들 때, 고쳐야 하는 칸의 회수를 최소로 하려고 한다.
다솜이가 고친 세준이의 원래 그림을 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 그림의 세로크기 N과 가로크기 M이 들어온다. 둘째 줄부터 N개의 줄에 그림이 들어온다. (1 ≤ N, M ≤ 50)
<출력값>
세준이의 원래 그림을 첫째 줄부터 N개의 줄에 걸쳐 출력한다. 최소로 고치는 원래 그림은 유일하다.

<문제 1467>
세준이는 N자리의 수를 가지고 있다. 세준이는 N자리의 수가 너무 커서 부담을 느낀 나머지 숫자를 몇 개 지워서 이 수를 줄이기로 했다.
숫자를 지울 때는 같은 숫자가 여러 번 등장하더라도 그 중 하나만 지운다. 예를 들어 12534에서 5를 지우면 1234가 되고, 1253452에서 5를 지우면 123452나 125342 둘 중 하나로 만들 수 있다.
세준이는 숫자들을 지웠을 때 결과로 나올 수 있는 수가 한 가지가 아니라는 것을 알고, 남은 수를 가장 크게 만들려고 한다.
세준이가 가지고 있는 수와 지울 숫자들이 주어졌을 때, 남은 수를 가장 크게 만드는 프로그램을 작성하시오.
<입력값>
첫째 줄에 세준이가 가지고 있는 N자리의 수가 주어진다. N은 1,000보다 작거나 같은 자연수이다.
둘째 줄에 세준이가 지울 숫자들이 공백 없이 주어진다. 지울 숫자의 개수는 N보다 작으며, 항상 주어진 숫자들을 전부 지울 수 있다고 가정한다.
<출력값>
첫째 줄에 남은 수를 가장 크게 만들어서 출력한다.

<문제 1468>
2008년 4월 9일 수요일은 대한민국의 제 18대 국회의원 선거이기도 하지만, 모의고사를 보는 날이다.
이미 Marking 2.0이란 채점프로그램을 만든 사람은 이번 모의고사를 위해 Marking 2.0을 인터넷 버전으로 수정했다. Marking 2.0의 인터넷 버전은 이미 우리가 예전에 보던 PKU나 UVA와 비슷한 온라인 채점 사이트이다.
하지만, 학생들이 인터넷을 이용해서 딴짓을 할 가능성이 있기 때문에, 내부 그래프를 이용하려고 한다. 따라서, 조교는 랜선을 이용해서 서로의 노트북을 연결하려고 한다.
현재 학생은 총 N명이 있다. N명의 학생과 1명의 조교를 랜선으로 연결하려고 한다. 단 이때, 사이클을 형성하면 안 된다. 그리고, 모든 학생들의 컴퓨터에는 반드시 홀수개의 랜선이 달려야 한다.
학생의 수가 주어졌을 때, 가능한 그래프의 경우를 구하는 프로그램을 작성하시오.
5명의 학생일 때는, 다음과 같은 그래프가 존재한다.
다음의 그림에서 C는 조교, S는 학생, 그리고 나머지는 각각의 랜선이 어떻게 연결되어있는지를 나타낸다. 

만약, 두 개의 그래프 G와 G' 이 있을 때, G의 연결을 고치지 않고, 단지 변형을 통해 G'을 만들 수 있을 때, G와 G'은 같은 그래프이다.
다시말해서, 조교를 기준으로 같은 패턴으로 연결이 되어 있으면, 그것은 같은 그래프이다.
그림으로 그렸을 때는, 다른 모양이 나오더라도, 같은 그래프일 수 는 있다.
예를 들어 다음 그래프는 서로 같다.

학생의 수 N이 주어졌을 때, 서로 다른 그래프의 경우의 수중 서로 다른 것의 개수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 학생의 수 N이 주어진다. N은 40보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 경우의 수를 출력한다.

<문제 1469>
숌은 N개의 다른 숫자로 구성되어 있는 집합 X를 만들었다. 그리고, 길이가 2*N인 숌 사이 수열 (S)을 만들려고 한다.
숌 사이 수열이란 다음과 같다.

X에 들어있는 모든 수는 숌 사이 수열 S에 정확히 두 번 등장해야 한다.
X에 등장하는 수가 i라면, S에서 두 번 등장하는 i사이에는 수가 i개 등장해야 한다.

예를 들어, 숌이 만든 집합 X가 {1,2,3}이고, 숌이 만든 숌 사이 수열이 {2 3 1 2 1 3}이라면, 일단 X에 속하는 모든 수가 S에 두 번 등장하므로 1번 조건을 만족한다. 그리고, 2와 2사이엔 수가 두 개, 1과 1사이엔 1개, 3과 3사이엔 3개가 등장하므로 조건을 만족시킨다.
집합 X가 주어졌을 때, 숌 사이 수열 S를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 X의 크기 N이 주어진다. 둘째 줄에 X에 들어가는 수가 빈칸을 사이에 두고 주어진다. X의 크기는 10보다 작거나 같은 자연수이다. X의 원소는 0보다 크거나 같고 20보다 작거나 같은 정수이다.
<출력값>
첫째 줄에 숌 사이 수열을 출력한다. 만약 여러 개일 경우 사전 순으로 가장 빠른 것을 출력한다. 만약 없을 경우에는 -1을 출력한다.

<문제 1470>
N개의 팀이 프로그래밍 올림픽에 참가했다. 각 팀은 1번부터 N번까지 번호가 매겨져 있다. 올림픽 규칙에 따라서, 올림픽은 여러 개의 경기로 이루어져 있다. 각 경기가 끝날 때마다 상위 세 팀은 순위에 따라 금, 은, 동메달을 받게 된다. 한 경기에서 동점을 기록하는 경우는 없고, 각 팀은 경기당 최대 1개의 메달을 받을 수 있다. 올림픽이 끝나면, 다음과 같은 규칙을 이용해 최종 순위를 매긴다.

두 팀의 금메달 수가 다르면, 금메달을 많이 가진 팀이 등수가 높다. 같은 경우에는 2번 규칙을 따른다.
두 팀의 은메달 수가 다르면, 은메달을 많이 가진 팀이 등수가 높다. 같은 경우에는 3번 규칙을 따른다.
두 팀의 동메달 수가 다르면, 동메달을 많이 가진 팀이 등수가 높다. 같은 경우에는 팀 번호가 작은 팀의 등수가 높다.

아직 올림픽은 끝나지 않았고, 총 L개의 경기가 남아있다. 이 상황에서 각 팀이 획득한 메달의 수가 주어진다. 1번 팀이 남은 L경기에서 모두 금메달은 딴다고 했을 때, 1번 팀이 기록할 수 있는 가장 낮은 등수를 구하는 프로그램을 작성하시오. 
가장 높은 등수는 1이고, 그 다음 등수는 2이다. 이런식으로 등수를 계산할 수 있다.
<입력값>
첫째 줄에 팀의 수 N(3 ≤ N ≤ 100)과 남은 경기 수 L(0 ≤ L ≤ 10,000)이 주어진다. 
둘째 줄부터 N개의 줄에 각 팀이 획득한 금메달, 은메달, 동메달의 개수가 1번 팀부터 순서대로 주어진다.
<출력값>
첫째 줄에 1번 팀이 기록할 수 있는 가장 낮은 등수를 출력한다.

<문제 1471>
세준이는 동그랗게 생긴 사탕 통을 가지고 있다. 그 사탕 통에는 N개의 칸이 원형으로 동그랗게 자리잡고 있으며, 1번부터 N번까지 시계방향으로 번호가 매겨져 있다.
처음에 세준이는 사탕을 아무 칸에나 넣을 수 있다. 그 다음부터는 사탕이 들어 있는 칸 번호의 각 자리 숫자의 합을 구하여, 그 값만큼 시계방향으로 이동한다. 예를 들어 123번 칸에 사탕이 있으면 6칸만큼 시계방향으로 이동한다. 사탕을 계속 이동시키다가 이전에 방문한 칸이 나오면 멈춘다. 처음에 사탕을 넣은 칸도 방문한 칸으로 취급한다.
사탕 통의 크기가 주어지면, 사탕을 적절한 칸에 넣었을 때 최대 몇 개의 칸을 방문할 수 있는지 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N이 주어진다. N은 200,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 방문할 수 있는 최대 칸의 개수를 출력한다.

<문제 1472>
세준이는 새로운 전화번호 시스템을 만들었다. 새로운 전화번호는 모두 7자리이고, 16진수로 이루어져 있다. 어떤 전화번호 A와 전화번호 B 사이의 거리는 A와 B의 각 자리가 다른 것의 개수이다. 예를 들어, 1b100fa와 11b0ffa의 거리는 3이다. 그 이유는 2번째, 3번째, 5번째 자리가 다르기 때문이다.
세준이는 사람들이 전화번호를 잘못되게 누르는 것을 방지하기 위해서, 모든 전화번호 사이의 거리는 적어도 S로 만들려고 한다. 세준이가 해야할 일은 간단하다. 새로운 전화번호가 필요할 때, 세준이는 위와 같은 규칙을 지키면서, 가능한 전화번호중 가장 크기가 작은 것을 쓰면 되는 것이다.
세준이는 정문이에게 K번째 전화번호를 주려고 한다. S와 K가 주어졌을 때, K번째 전화번호를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 S와 K가 주어진다. S는 1보다 크거나 같고, 3보다 작거나 같은 자연수이고, K는 300,000보다 작거나 같다.
<출력값>
첫째 줄에 전화번호를 출력한다. 16진수에서 나타나는 알파벳은 소문자로 출력한다.

<문제 1473>
세준이는 직사각형 모양의 미로에 갇혔다. 미로 안에는 1*1크기의 작은 방이 있다. 정사각형 모양의 각 방은 네 개의 면이 있는데, 이 네 개의 면에는 문이 있을수도 있고, 없을수도 있다. 각 방은 네 개의 타입이 있는데, A는 네 면 모두 문이 있는 것이고, B는 문이 없는 것, C는 문이 위쪽, 아래쪽에만 있는 것, D는 문이 왼쪽, 오른쪽에만 있는 것이다.
세준이는 미로를 문을 통해서 방에서 방으로 자유롭게 이동할 수 있다. 그러나, 세준이가 방 X에서 방 Y로 가려고 한다면, 방 X에도 문이 있고, 방 Y에도 문이 있어야 한다. 예를 들어, 세준이가 현재 있는 방에 문이 위쪽에 있고, 위쪽 방에 문이 아래쪽에 있으면, 세준이는 위쪽 방으로 이동할 수 있다. 만약 위쪽 방에 아래쪽으로 향하는 문이 없다면 세준이는 위쪽 방으로 갈 수 없다.
미로는 정말 단단한 벽으로 둘러쌓여 있어서, 문이 있더라도 밖으로 나갈 수 없다. 어떤 방에서 어떤 방으로 움직일 때는 1초가 걸린다.
미로에는 세준이가 자유롭게 이동할 만큼 문이 충분하지 않을 수도 있다. 따라서, 세준이는 미로를 조정할 수 있는 버튼이 있다. 이 버튼을 누르게 되면, 세준이가 현재 있는 모든 행의 방이 90도만큼 회전하고, 세준이가 현재 있는 모든 열의 방이 90도만큼 회전한다. 따라서, 세준이가 있던 방은 90도만큼 두 번 회전하기 때문에, 그대로일 것이다. 만약 어떤 방에 위쪽 문이 있었으면, 90도 회전을 해서 오른쪽 문으로 바꿀 수 있다.
버튼을 눌러서 방의 모양이 바뀌는 시간도 1초이다.
미로의 가장 위쪽에서 왼쪽에 있는 세준이가, 가장 아래쪽에서 오른쪽으로 이동하려고 할 때, 드는 시간의 최솟값을 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 미로의 세로 크기 N과 미로의 가로 크기 M이 주어진다. N과 M은 2보다 크거나 같고, 7보다 작거나 같은 자연수이다. 둘째 줄에 미로의 정보가 들어온다. 미로의 정보는 ABCD 네 개의 문자로만 이루어져 있다.
<출력값>
첫째 줄에 세준이가 이동하는 시간의 최솟값을 출력하시오. 만약 이동할 수 없으면 -1을 출력한다.

<문제 1474>
세준이는 N개의 영어 단어를 이용해 길이가 M인 새로운 단어를 만들려고 한다. 새로운 단어는 N개의 단어를 순서대로 이어 붙이고, 각 단어의 사이에 _을 넣어서 만든다. 이렇게 만든 새로운 단어의 길이가 M이 아닌 경우 _를 추가해서 길이가 M이 되게 만들어야 한다.

_는 단어와 단어 사이에만 추가할 수 있다. 따라서, 새로운 단어는 _으로 시작하거나, _로 끝날 수 없다.
단어와 단어 사이에 있는 _의 개수는 모두 같아야 한다.
	
모두 같게 만드는 것이 불가능한 경우 단어와 단어 사이에 있는 _의 개수의 최댓값과 최솟값의 차이는 1이 되어야 한다.



새로운 단어 중 사전 순으로 가장 앞서는 단어를 구해보자.
<입력값>
첫째 줄에 N과 M이 주어진다. 둘째 줄부터 N개의 줄에 단어가 한 줄에 하나씩 주어진다.
<출력값>
첫째 줄에 사전 순으로 가장 앞서는 단어를 출력한다.
알파벳 대문자, 소문자, 밑 줄의 순서는 'A' < 'B' < 'C' < ... < 'Z' < '_' < 'a' < 'b' < 'c' < ... < 'z' 이다.

<문제 1475>
다솜이는 은진이의 옆집에 새로 이사왔다. 다솜이는 자기 방 번호를 예쁜 플라스틱 숫자로 문에 붙이려고 한다.
다솜이의 옆집에서는 플라스틱 숫자를 한 세트로 판다. 한 세트에는 0번부터 9번까지 숫자가 하나씩 들어있다. 다솜이의 방 번호가 주어졌을 때, 필요한 세트의 개수의 최솟값을 출력하시오. (6은 9를 뒤집어서 이용할 수 있고, 9는 6을 뒤집어서 이용할 수 있다.)
<입력값>
첫째 줄에 다솜이의 방 번호 N이 주어진다. N은 1,000,000보다 작거나 같은 자연수 또는 0이다.
<출력값>
첫째 줄에 필요한 세트의 개수를 출력한다.

<문제 1476>
준규가 사는 나라는 우리가 사용하는 연도와 다른 방식을 이용한다. 준규가 사는 나라에서는 수 3개를 이용해서 연도를 나타낸다. 각각의 수는 지구, 태양, 그리고 달을 나타낸다.
지구를 나타내는 수를 E, 태양을 나타내는 수를 S, 달을 나타내는 수를 M이라고 했을 때, 이 세 수는 서로 다른 범위를 가진다. (1 ≤ E ≤ 15, 1 ≤ S ≤ 28, 1 ≤ M ≤ 19)
우리가 알고있는 1년은 준규가 살고있는 나라에서는 1 1 1로 나타낼 수 있다. 1년이 지날 때마다, 세 수는 모두 1씩 증가한다. 만약, 어떤 수가 범위를 넘어가는 경우에는 1이 된다.
예를 들어, 15년은 15 15 15로 나타낼 수 있다. 하지만, 1년이 지나서 16년이 되면 16 16 16이 아니라 1 16 16이 된다. 이유는 1 ≤ E ≤ 15 라서 범위를 넘어가기 때문이다.
E, S, M이 주어졌고, 1년이 준규가 사는 나라에서 1 1 1일때, 준규가 사는 나라에서 E S M이 우리가 알고 있는 연도로 몇 년인지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 세 수 E, S, M이 주어진다. 문제에 나와있는 범위를 지키는 입력만 주어진다.
<출력값>
첫째 줄에 E S M으로 표시되는 가장 빠른 연도를 출력한다. 1 1 1은 항상 1이기 때문에, 정답이 음수가 나오는 경우는 없다.

<문제 1477>
다솜이는 유료 고속도로를 가지고 있다. 다솜이는 현재 고속도로에 휴게소를 N개 가지고 있는데, 휴게소의 위치는 고속도로의 시작으로부터 얼만큼 떨어져 있는지로 주어진다. 다솜이는 지금 휴게소를 M개 더 세우려고 한다.
다솜이는 이미 휴게소가 있는 곳에 휴게소를 또 세울 수 없고, 고속도로의 끝에도 휴게소를 세울 수 없다. 휴게소는 정수 위치에만 세울 수 있다.
다솜이는 이 고속도로를 이용할 때, 모든 휴게소를 방문한다. 다솜이는 휴게소를 M개 더 지어서 휴게소가 없는 구간의 길이의 최댓값을 최소로 하려고 한다. (반드시 M개를 모두 지어야 한다.)
예를 들어, 고속도로의 길이가 1000이고, 현재 휴게소가 {200, 701, 800}에 있고, 휴게소를 1개 더 세우려고 한다고 해보자.
일단, 지금 이 고속도로를 타고 달릴 때, 휴게소가 없는 구간의 최댓값은 200~701구간인 501이다. 하지만, 새로운 휴게소를 451구간에 짓게 되면, 최대가 251이 되어서 최소가 된다.
<입력값>
첫째 줄에 현재 휴게소의 개수 N, 더 지으려고 하는 휴게소의 개수 M, 고속도로의 길이 L이 주어진다. N은 100보다 작거나 같으며, M도 100보다 작거나 같다. L은 100보다 크거나 같고, 1000보다 작거나 같은 정수이다. 모든 휴게소의 위치는 중복되지 않으며, N+M은 L보다 작다. 둘째 줄에, 휴게소의 위치가 공백을 사이에 두고 주어진다.
<출력값>
첫째 줄에 M개의 휴게소를 짓고 난 후에 휴게소가 없는 구간의 최댓값의 최솟값을 출력한다.

<문제 1478>
세준이는 생일선물로 연필세트를 받았다. 세준이는 태어나서 처음이자 마지막으로 생일선물을 받았기 때문에, 생일선물 받은 연필로 하루종일 직사각형을 그리기 시작했다.
세준이가 그린 종이는 X-Y좌표 평면으로 나타낼 수 있고, 모든 직사각형은 축에 평행하다. 그리고, 직사각형이 겹쳐져서 더 많은 직사각형을 만들 수도 있다.
세준이는 자기가 그린 직사각형으로 몇 개의 정사각형을 만들 수 있는지 궁금해졌다. 만약 세준이가 아래와 같이 직사각형을 3개 그렸다면, 정사각형은 총 14개가 나온다.

세준이가 그린 직사각형의 정보가 주어졌을 때, 정사각형의 개수를 세는 프로그램을 작성하시오.
<입력값>
첫째 줄에 직사각형의 개수 N이 주어진다. N은 100보다 작거나 같은 자연수이다. 둘째 줄부터 세준이가 그린 직사각형이 입력으로 들어온다. X1 Y1 X2 Y2와 같은 형식으로 들어오며, (X1,Y1)은 직사각형의 가장 왼쪽 아래 꼭짓점의 좌표이고, (X2,Y2)는 직사각형의 가장 오른쪽 위 꼭짓점의 좌표이다. 모든 좌표는 1000000000보다 작거나 같은 음이 아닌 정수이다.
<출력값>
첫째 줄에 정사각형의 개수를 출력한다.

<문제 1479>
어떤 문자열 S와, S의 부분문자열 a, b, c, d가 주어졌을 때, 각각의 부분문자열 a, b, c, d가 S와 어디에서 겹쳐졌는지 구해보자. 이때, S의 어떤 위치에 있는 문자가 a, b, c, d중 하나에 속했을 때, 이 문자를 가릴 수 있다고 한다. (겹치는 것도 가능하다.)
예를 들어, S = foursubstrings이고, a = our, b = s, c = ring, d = sub라고 했을 때,




			f
			

			o
			

			u
			

			r
			

			s
			

			u
			

			b
			

			s
			

			t
			

			r
			

			i
			

			n
			

			g
			

			s
			



			 
			

			o
			

			u
			

			r
			

			 
			

			 
			

			 
			

			 
			

			 
			

			 
			

			 
			

			 
			

			 
			

			 
			



			 
			

			 
			

			 
			

			 
			

			s
			

			 
			

			 
			

			 
			

			 
			

			 
			

			 
			

			 
			

			 
			

			 
			



			 
			

			 
			

			 
			

			 
			

			 
			

			 
			

			 
			

			 
			

			 
			

			r
			

			i
			

			n
			

			g
			

			 
			



			 
			

			 
			

			 
			

			 
			

			s
			

			u
			

			b
			

			 
			

			 
			

			 
			

			 
			

			 
			

			 
			

			 
			



			 
			

			+
			

			+
			

			+
			

			+
			

			+
			

			+
			

			 
			

			 
			

			+
			

			+
			

			+
			

			+
			

			 
			



가장 위의 문자열은 S이고, 그 밑에는 차례대로 a, b, c, d이다. 가장 마지막의 +는 가려진 문자를 말한다.
가려진 문자의 최솟값과 최댓값을 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 문자열 S가 주어진다. S의 길이는 2500보다 작거나 같다. 둘째 줄부터 다섯째 줄에는 부분 문자열 a, b, c, d가 한 줄에 하나씩 차례대로 주어진다. 부분문자열의 길이는 50보다 작거나 같다. 모든 문자열은 소문자로만 이루어져 있다.
<출력값>
첫째 줄에 가려지는 문자열의 개수의 최솟값과 최댓값을 공백을 사이에 두고 구분해서 출력한다.

<문제 1480>
세준이는 잘 모르겠지만, 세준이는 보석에 미쳐있다. 따라서, 숌 보석상에 있는 모든 보석을 다 훔치려고 한다. 하지만, 세준이는 보석을 다 가져올 수는 없다. 그 이유는 가방의 개수에 제한이 있고, 한 가방마다 넣을 수 있는 보석의 개수가 제한이 있기 때문이다. 세준이는 M개의 가방을 가지고 있다. 그리고 각각의 가방은 C그램의 보석을 담을 수 있다.
숌 보석상에는 보석이 N개 있다. N개의 보석의 무게가 주어졌을 때, 세준이가 훔칠 수 있는 보석의 최대 개수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 보석의 개수 N, 가방의 개수 M, 가방의 최대 한도 C가 주어진다. N은 1보다 크거나 같고, 13보다 작거나 같은 자연수이고, M은 1보다 크거나 같고, 10보다 작거나 같은 자연수이다. C는 1보다 크고, 20보다 작거나 같은 자연수이다. 둘째 줄에 보석의 무게가 하나씩 주어진다. 보석의 무게는 1보다 크거나 같고, 20보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 세준이가 가져갈 수 있는 최대 보석의 개수를 출력한다.

<문제 1481>
숌 사각형은 숫자 2개 N과 D를 가지고 시작한다.
일단 N*N크기의 정사각형을 만든다. 그리고나서 그 정사각형 안에 0보다 크거나 같고, D-1보다 작거나 같은 수로 채운다.
숌 사각형에 수를 채우는 규칙은 각 행에는 0보다 크거나 같고, D보다 작은 수가 적어도 하나는 존재해야 한다는 것이고, 각 열도 마찬가지이다.
N과 D가 주어졌을 때, 사전순으로 가장 빠른 숌 사각형을 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N과 D가 주어진다. N은 10보다 작거나 같은 자연수이고, D는 N보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 숌 사각형을 출력한다.

<문제 1482>
같은 자리 수라는 것은 어떤 수 X에 나오는 숫자가 모두 같은 횟수만큼 나오는 것이다.
예를 들어, 2008은 같은 자리 수가 아니다. 그 이유는 2는 1번, 0은 2번, 8은 1번 나와서 모두 같은 횟수만큼 나오지 않기 때문이다.
하지만, 2013은 같은 자리 수이다. 모든 수가 단 한번 씩 나오기 때문이다.
같은 자리수는 5, 239, 333888, 566353, 등등등이 있다.
어떤 수 N이 주어졌을 때, N보다 크거나 같으면서 가장 작은 같은 자리 수를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N이 주어진다. N은 10^18보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 정답을 출력한다. 답은 9223372036854775807보다 작거나 같다.

<문제 1483>
세준이는 저항을 연결하려고 한다. 세준이는 저항의 크기가 1과 2인 것을 무한대로 가지고 있다.
저항 R1, R2, R3 ,... Rn을 직렬로 연결 하면, (R1+R2+R3+...+Rn)이 되고, 병렬로 연결 하면, 1/((1/R1)+(1/R2)+(1/R3)+...+(1/Rn))이 된다.
두 수 a와 b가 주어졌을 때, 저항을 몇 개를 연결해야 a/b가 되는지 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 a와 b가 주어진다. a와 b는 50000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 필요한 저항의 최소 개수를 출력한다. 만약 필요한 저항의 수가 16개보다 크다면 -1을 출력한다.

<문제 1484>
성원이는 다이어트를 시도중이다. 성원이는 정말 정말 무겁기 때문에, 저울이 부셔졌다.
성원이의 힘겨운 다이어트 시도를 보고만 있던 엔토피아는 성원이에게 새로운 저울을 선물해 주었다.
성원이는 엔토피아가 선물해준 저울 위에 올라갔다. “안돼!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! G 킬로그램이나 더 쪘어ㅜㅠ”라고 성원이가 말했다. 여기서 말하는 G킬로그램은 성원이의 현재 몸무게의 제곱에서 성원이가 기억하고 있던 몸무게의 제곱을 뺀 것이다.
성원이의 현재 몸무게로 가능한 것을 모두 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 G가 주어진다. G는 100,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄부터 한 줄에 하나씩 가능한 성원이의 현재 몸무게를 오름차순으로 출력한다. 가능한 몸무게가 없을 때는 -1을 출력한다. 현재 몸무게는 자연수로 떨어지지 않을 수도 있는데, 이런 경우는 제외해야 한다.

<문제 1485>
네 점이 주어졌을 때, 네 점을 이용해 정사각형을 만들 수 있는지 없는지를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 네 줄로 이루어져 있으며, 점의 좌표가 한 줄에 하나씩 주어진다. 점의 좌표는 -100,000보다 크거나 같고, 100,000보다 작거나 같은 정수이다. 같은 점이 두 번 이상 주어지지 않는다.
<출력값>
각 테스트 케이스마다 입력으로 주어진 네 점을 이용해서 정사각형을 만들 수 있으면 1을, 없으면 0을 출력한다.

<문제 1486>
세준이는 등산광이다. 세준이는 높은 곳에서 도시를 내려다 보는 것을 좋아한다. 하지만, 겁이 많은 세준이는 어두워지기 전에 호텔로 내려오려고 한다.
세준이가 가려고하는 산의 지도가 입력으로 주어진다. 산의 지도를 M이라고 했을 때, M[i][j]는 (i,j)의 높이가 M[i][j]라는 것을 의미한다. 그 값이 'A'-'Z'일 때는 0-25를 뜻하는 것이고, 'a'-'z'일 때는, 26-51을 뜻한다.
세준이의 호텔은 (0,0)에 있다. 그리고, 세준이는 지금 위치에서 바로 인접한 정수 좌표 중 높이의 차이가 T보다 크지 않은 곳으로만 다닐 수 있다.
만약 세준이가 현재 위치에서 높이가 낮은 곳이나 같은 곳으로 이동한다면 시간은 1초가 걸린다. 하지만 높은 곳으로 이동한다면 두 위치의 높이의 차이의 제곱만큼 시간이 걸린다. 예를 들어 높이가 5에서 높이가 9인 곳으로 간다면, 시간은 (5-9)2=16초가 걸린다. 하지만, 높이가 9인 곳에서 5인 곳으로 간다면 시간은 1초가 걸린다.
산의 지도와, T, 그리고 어두워지는 시간 D가 주어졌을 때, 세준이가 D보다 크지 않은 시간 동안 올라갈 수 있는 최대 높이를 구하는 프로그램을 작성하시오.(세준이는 호텔에서 출발해서 호텔로 돌아와야 한다.)
<입력값>
첫째 줄에 산의 세로크기 N과 가로크기 M 그리고, T와 D가 주어진다. N과 M은 25보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 지도가 주어진다. T는 52보다 작거나 같은 자연수이고, D는 1,000,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 세준이가 갈 수 있는 가장 높은 곳의 높이를 출력한다.

<문제 1487>
세준이는 오랜 연구기간 끝에 신상품을 내놓았다. 세준이는 오랜 시간이 걸린 만큼 이 상품을 최대 이익에 팔려고 한다.
세준이는 이 상품을 사려고 하는 사람들이 총 몇 명이나 되는지 알아봤다. 무려 N명이나 살 의향을 보였다. 각각의 사람은 자기가 지불할 생각이 있는 최대 한도가 있다. 따라서, 어떤 사람이 20원까지 지불할 생각이 있는데, 세준이가 가격을 30원으로 책정하면 이 사람은 절대 안 살 것이고, 15원으로 책정하면 이 사람은 이 상품을 15원에 살 것이다. (단, 세준이가 안 팔수도 있다.)
그리고, 세준이는 각각의 사람에게 배달하는 비용이 얼마나 걸리는 지 알고 있다.
N명의 사람과, 각각의 사람이 지불할 용의가 있는 최대 금액과 배송비가 주어졌을 때, 세준이의 이익을 최대로 하는 가격을 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 세준이의 물건을 구매할 의향이 있는 사람의 수 N이 주어진다. 이 값은 1,000보다 작거나 같다. 둘째 줄부터 각 사람이 지불할 최대 금액과 배송비가 공백을 사이에 두고 주어진다. 두 값은 모두 10^6보다 작거나 같은 자연수이고, 배송비는 0이 될 수도 있다.
<출력값>
첫째 줄에 최대 이익을 만들어주는 가격을 출력한다. 이익이 최대인 가격이 여러개라면, 가장 낮은 가격을 출력한다. 또, 어떤 가격으로 팔아도 이익을 남길 수 없다면 0을 출력한다.

<문제 1488>
A와 B로만 이루어진 문자열이 다음과 같은 조건을 만족하면 숌트링이라고 부른다.
1. countA보다 작거나 같은 'A'를 포함한다.
  2. countB보다 작거나 같은 'B'를 포함한다.
  3. ‘A'로만 이루어진 모든 부분문자열의 길이는 maxA를 넘을 수 없다.
  4. ‘B'로만 이루어진 모든 부분문자열의 길이는 maxB를 넘을 수 없다.
countA, countB, maxA, maxB가 주어졌을 때, 가능한 숌트링의 길이중 최댓값을 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 countA countB maxA maxB가 주어진다. 모든 값은 1000000보다 작거나 같은 음이 아닌 정수이다.
<출력값>
첫째 줄에 숌트링의 길이의 최댓값을 출력한다.

<문제 1489>
팀 A와 B가 대결을 하려고 한다. 각 팀에 속한 사람은 다른 팀에 속한 사람과 대결을 해야 한다. 두 팀에 속한 각 사람은 대결을 한 번씩 해야 한다. 대결의 승자는 2점을 획득하고, 무승부인 경우에는 1점을 획득한다.
팀 A에 속한 사람의 능력치는 A1, A2, ..., AN이고, 팀 B에 속한 사람의 능력치는 B1, B2, ..., BN이다. 대결은 능력치가 높은 사람이 이기며, 능력치가 같은 경우 비긴다.
두 팀의 능력치가 주어졌을 때, 팀 A가 얻을 수 있는 점수의 최댓값을 구해보자.
<입력값>
첫째 줄에 팀에 속한 사람의 수 N이 주어진다. 둘째 줄에는 A1, A2, ..., AN이 주어지고, 셋째 줄에는 B1, B2, ..., BN이 주어진다.
<출력값>
첫째 줄에 팀 A가 얻을 수 있는 점수의 최댓값을 출력한다.

<문제 1490>
어떤 수 N이 주어졌을 때, N으로 시작하면서, N의 0이 아닌 모든 자리수로 나누어지는 떨어지는 수 중 가장 작은 수를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 어떤 수 N이 주어진다. N은 1000000000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 답을 출력한다.

<문제 1491>
세준이는 밑면이 N*M크기인 궁전에 산다. 세준이는 자신을 남에게 보이는 것을 싫어해서 사람들이 궁전에 자신을 보러 올 때, 되도록 많이 걷게 만들고 싶어한다. 세준이의 보안 담당 은진이는 나선을 설치하는 것을 제안했다.
방문자들은 가장 남쪽이면서 서쪽인 곳으로 들어온다. 그래서 가장 동쪽으로 계속해서 나아간다. 만약 방문자들이 벽을 만나거나 자기가 이미 지났던 칸을 만난다면 왼쪽으로 돌아서 앞으로 계속 간다.
세준이는 이 나선이 끝나는 곳에 머물고 싶어한다. 나선이 끝나는 곳의 위치를 출력하는 프로그램을 작성하시오.
N과 M이 주어졌을 때, 남서쪽 모서리는 (0,0) 남동쪽 모서리는 (N-1,0), 북동쪽 모서리는 (N-1,M-1)이다.
<입력값>
첫째 줄에 N과 M이 주어진다. N과 M은 5,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 정답을 출력한다.

<문제 1492>
N과 K가 주어졌을 때, 1K + 2K + 3K + ... + NK를 1,000,000,007로 나눈 나머지를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N과 K가 주어진다. N은 109보다 작거나 같은 자연수이고, K는 50보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 1K + 2K + 3K + ... + NK를 1,000,000,007로 나눈 나머지를 출력한다.

<문제 1493>
세준이는 length × width × height 크기의 박스를 가지고 있다. 그리고 세준이는 이 박스를 큐브를 이용해서 채우려고 한다. 큐브는 정육면체 모양이며, 한 변의 길이는 2의 제곱꼴이다. (1×1×1, 2×2×2, 4×4×4, 8×8×8, ...)
세준이가 가지고 있는 박스의 종류와 큐브의 종류와 개수가 주어졌을 때, 박스를 채우는데 필요한 큐브의 최소 개수를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 세 자연수 length width height가 주어진다.
둘째 줄에 세준이가 가지고 있는 큐브의 종류의 개수 N이 주어진다.
셋째 줄부터 총 N개의 줄에 큐브의 종류 Ai와 개수 Bi가 순서대로 주어진다. 큐브의 종류는 한 변의 길이를 나타낼 때 쓰는 2i에서 i이다.
<출력값>
첫째 줄에 필요한 큐브의 개수의 최솟값을 출력한다. 만약 채울 수 없다면 -1을 출력한다.

<문제 1494>
길이가 무한한 수열 S는 다음과 같이 정의된다.

S0 = first;
S1 = second;
Si = |Si-2 - Si-1| (i>=2)

first와 second와 질문의 개수가 주어졌을 때, 질문에 답하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 first와 second와 질문의 개수 N이 주어진다. 둘째 줄부터 N개의 줄에 질문이 주어진다. 질문이라는 것은 숫자 i로 주어지며 Si를 출력하면 되는 것이다. N은 50보다 작거나 같은 자연수이고, 이 외의 모든 수는 10^18보다 작거나 같은 수이다.
<출력값>
첫째 줄에 각 질문에 대한 Si를 출력하면 된다.

<문제 1495>
Day Of Mourning의 기타리스트 강토는 다가오는 공연에서 연주할 N개의 곡을 연주하고 있다. 지금까지 공연과는 다른 공연을 보여주기 위해서 이번 공연에서는 매번 곡이 시작하기 전에 볼륨을 바꾸고 연주하려고 한다.
먼저, 공연이 시작하기 전에 각각의 곡이 시작하기 전에 바꿀 수 있는 볼륨의 리스트를 만들었다. 이 리스트를 V라고 했을 때, V[i]는 i번째 곡을 연주하기 전에 바꿀 수 있는 볼륨을 의미한다. 항상 리스트에 적힌 차이로만 볼륨을 바꿀 수 있다. 즉, 현재 볼륨이 P이고 지금 i번째 곡을 연주하기 전이라면, i번 곡은 P+V[i]나 P-V[i] 로 연주해야 한다. 하지만, 0보다 작은 값으로 볼륨을 바꾸거나, M보다 큰 값으로 볼륨을 바꿀 수 없다.
곡의 개수 N과 시작 볼륨 S, 그리고 M이 주어졌을 때, 마지막 곡을 연주할 수 있는 볼륨 중 최댓값을 구하는 프로그램을 작성하시오. 모든 곡은 리스트에 적힌 순서대로 연주해야 한다.
<입력값>
첫째 줄에 N, S, M이 주어진다. (1 ≤ N ≤ 100, 1 ≤ M ≤ 1000, 0 ≤ S ≤ M) 둘째 줄에는 각 곡이 시작하기 전에 줄 수 있는 볼륨의 차이가 주어진다. 이 값은 1보다 크거나 같고, M보다 작거나 같다.
<출력값>
첫째 줄에 가능한 마지막 곡의 볼륨 중 최댓값을 출력한다. 만약 마지막 곡을 연주할 수 없다면 (중간에 볼륨 조절을 할 수 없다면) -1을 출력한다.

<문제 1496>
세준이는 상대방과 자유로운 기타 연주 대결을 벌이는 TV 쇼에 나갔다.
게임이 시작하기 전에 N개의 기타 케이스가 원형으로 놓여져 있다. (1 ≤ i < N에 대해 i번째 기타 케이스와 i+1번째 기타 케이스는 서로 인접해 있고, N번째와 1번째 기타 케이스도 인접해 있다.) 각각의 케이스 안에는 기타가 들어있다.
세준이와 상대방은 번갈아가며 기타를 가져간다. 두 사람은 각자의 차례에 모든 그룹에서 기타를 하나씩 골라서 꺼내 가져간다. 그룹이란 비어있지 않은 연속한 기타의 집합이다. 기타를 꺼낼 때마다, 그룹이 새로 생길 수도, 사라질 수도 있다.
이해를 돕기 위해, 다음과 같은 게임 진행을 생각해 보자. 

N = 8, 게임 시작 전 -> 현재 남은 그룹 : (1,2,3,4,5,6,7,8)
세준이가 2번 기타를 가져감 -> 현재 남은 그룹 : (1,3,4,5,6,7,8)
상대방이 7번 기타를 가져감 -> 현재 남은 그룹 : (1,8) (3,4,5,6)
세준이가 1, 4번 기타를 가져감 -> 현재 남은 그룹 : (8) (3) (5,6)
상대방이 3, 5, 8번 기타를 가져감 -> 현재 그룹 : (6)
세준이가 6번 기타를 가져감 -> 현재 그룹 : 
남은 기타가 없으므로 게임이 종료됨

세준이와 상대방은 고른 기타를 모두 버리지 않고 소중하게 놔두고 있다. 세준이는 세준이가 고른 기타의 가치의 합을 최대로 만들고 싶어한다. 기타의 개수와 가치가 주어졌을 때, 세준이가 고른 기타들의 가치의 합을 최대로 만드는 프로그램을 작성하시오. 게임은 항상 세준이가 먼저 시작하며, 두 사람은 최적의 전략을 구사한다고 가정한다.
<입력값>
첫째 줄에 기타의 개수 N이 주어진다. 기타의 개수는 100보다 작거나 같으며, 2보다 크거나 같은 자연수이다. 둘째 줄에 기타의 가치가 주어진다. 기타의 가치는 공백을 사이에 두고 구분해서 순서대로 주어지며, 10,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 답을 출력한다.

<문제 1497>
강토는 Day Of Mourning의 기타리스트로, 다가오는 공연을 준비하고 있다.
어느 날 강토의 집에 도둑이 들어서 기타를 모두 도둑맞고 말았다. 기타를 사야 한다.
강토는 공연 때 연주할 노래의 목록을 뽑아 놓았다. 하지만, 하나의 기타로 모든 곡을 연주할 수는 없다. 어떤 기타는 어떤 곡을 연주할 때, 이상한 소리가 나기 때문이다. 항상 완벽을 추구하는 강토는 이런 일을 용납하지 않는다.
최대한 많은 곡을 제대로 연주하려고 할 때, 필요한 기타의 최소 개수를 구하는 프로그램을 작성하시오.
예를 들어, GIBSON으로 1, 2, 3번 곡을 제대로 연주할 수 있고, FENDER로 1, 2, 5번 곡을 제대로 연주할 수 있고, EPIPHONE으로 4, 5번 곡을 제대로 연주할 수 있고, ESP로 1번곡을 제대로 연주할 수 있다면, 세준이는 EPIPHONE과 GIBSON을 사면 최소의 개수로 모든 곡을 연주할 수 있다.
<입력값>
첫째 줄에 기타의 개수 N과 곡의 개수 M이 주어진다. N은 10보다 작거나 같은 자연수이고, M은 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 기타의 이름과 기타가 연주할 수 있는 곡의 정보가 차례대로 주어진다. Y는 연주할 수 있는 것이고, N은 없는 것이다. 기타의 이름은 알파벳 대문자로만 이루어져 있고, 길이는 50 이하이다.
<출력값>
첫째 줄에 필요한 기타의 개수를 출력한다. 만약 연주할 수 있는 곡이 없으면 -1을 출력한다.

<문제 1498>
어떤 문자열 X를 n번 연달아 쓴 것을 (X)^n으로 나타내기로 하자. 예를 들어 (ab)^3는 ababab를 의미한다. 어떤 문자열 Y가 (X)^n 꼴로 표현될 수 있다면, 그리고 n이 1이 아니라면 Y를 주기문 이라고 한다. 예를 들어 ab는 주기문이 아니지만, abab는 (ab)^2으로 표현할 수 있으므로 주기문이 된다.
문자열 S(2 ≤ S의 길이 ≤ 1,000,000)가 주어졌을 때, S의 앞에서부터 i개의 문자가 주기문의 형태가 되는 경우를 찾으려 한다. 가능한 경우가 여럿일 경우에는 n이 최대가 되는 경우를 구하려고 한다. S는 알파벳 소문자로만 이루어져 있다.
문자열 S가 주어졌을 때, 가능한 i, n 쌍을 모두 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 문자열 S가 주어진다.
<출력값>
i가 증가하는 순서대로, i, n 값을 한 줄에 하나씩 출력한다.

<문제 1499>
세준이는 어떤 문자열의 부분 문자열을 뒤집는 연산을 할 수 있다. r(i,j)는 어떤 문자열의 I번부터 j번 문자열 까지를 뒤집는 연산이다. (0번부터 시작한다.)
어떤 문자열 A를 B로 바꾸는데 사용할 수 있는 연산은 r(i,j)만 있는데, 이 연산을 사용한 순서대로 나타낸 걸 뒤집기 수열이라고 한다.
뒤집기 수열은 다음 조건을 만족해야 한다. 뒤집기 수열이 다음과 같이 길이가 m이고 수열의 각 원소가 첫 번째 부터 r(i1,j1), r(i2,j2), ... r(im,jm) 이라면, i1<=i2<=...<=im이고, j1>=j2>=...>=jm인 조건을 만족해야 한다.
문자열 A와 B가 주어졌을 때, A를 B로 바꾸기 위한 뒤집기 연산의 최소 회수를 출력하는 프로그램을 작성하시오.
예를 들어 A = 1100이고, B=0110이면, r(0,2)를 이용하면 0110을 만들 수 있다.
<입력값>
첫째 줄에 문자열 A와 둘째 줄에 문자열 B가 주어진다. 문자열은 0과 1로만 이루어져 있고, 최대 50글자이다.
<출력값>
첫째 줄에 최소 회수를 출력한다. 만약 바꿀 수 없으면 -1을 출력한다.

<문제 1500>
세준이는 정수 S와 K가 주어졌을 때, 합이 S인 K개의 양의 정수를 찾으려고 한다. 만약 여러개일 경우 그 곱을 가능한 최대로 하려고 한다.
가능한 최대의 곱을 출력한다.
만약 S=10, K=3이면, 3,3,4는 곱이 36으로 최대이다.
<입력값>
첫째 줄에 두 수 S와 K가 주어진다. K는 20보다 작거나 같고, S는 100보다 작거나 같으며 K보다 크거나 같다.
<출력값>
첫째 줄에 정답을 출력한다. 답은 9223372036854775807보다 작다.

<문제 1501>
혹시 인터넷을 하다가, 다음과 같은 식의 문장을 본 적이 있는가?
It is itnersetnig taht pepole can raed smoe grabeld wrods.
원래의 문장은 'It is interesting that people can read some garbled words'이다. 각각의 단어들은 제일 첫 문자와 제일 끝 문자를 제외하고는 순서가 뒤섞여 있다. 한 대학에서 시행한 연구 조사 결과에 따르면, (영어 단어를 아는 사람의 경우) 첫 문자와 제일 끝 문자가 일치하고, 그 사이의 문자들은 순서가 어떻게 뒤바뀌어 있더라도 읽는 데 지장이 없다고 한다.
그렇다보니, 한 단어가 여러 단어로 해석될 수도 있다. 예를 들어 abcde와 같은 단어는, abcde, abdce, acbde, acdbe, adbce, adcbe 같은 단어들로 해석될 수도 있다. 물론 각각의 단어들이 실제로 존재하는 단어(사전에 존재하는 단어)일 경우에만 의미가 있다.
영어 문장이 주어졌을 때, 그 문장을 해석하는 방법의 경우의 수를 구하는 프로그램을 작성하시오. 각각의 단어는, 첫 글자와 끝 글자가 일치하는 다른 단어(사전에 존재하는)로 해석할 수 있다. 영어 문장은 하나 이상의 단어로 이루어져 있으며, 각 단어들은 공백으로 구분되어 있다.
<입력값>
첫째 줄에 사전에 있는 단어들의 개수 N(0 ≤ N ≤ 10,000)이 주어진다. 다음 N개의 줄에는 각 줄에 하나씩, 영어 사전에 있는 단어들이 주어진다. 각 단어의 길이는 100자를 넘지 않는다. 다음 줄에 해석할 문장의 개수 M(0 ≤ M ≤ 10,000)이 주어진다. 다음 M개의 줄에는 각 줄에 하나씩 문장이 주어진다. 각 문장의 길이는 10,000자를 넘지 않는다. 영어 단어는 알파벳 대소문자(구별됨)로만 이루어진다.
<출력값>
M개의 줄에, 각 문장을 해석하는 경우의 수를 출력한다. 답은 32-bit signed int 범위 안에 있다고 가정하자.

<문제 1502>
숫자 퍼즐은 표시된 수들을 잇는 통로를 찾는 퍼즐이다. 참가자는 표의 모든 똑같은 숫자끼리 이을 수 있는, 끊기지 않는 선을 찾아야 한다. 선들은 여러 갈래로 나눠지거나 교차할 수 없다. 그리고 숫자는 각 선의 양 끝에 있어야 한다.
그리고 선들은 모든 칸을 정확히 한 번씩만 지나야 한다.

우리는 여기에서 한 숫자는 한 쌍만 있다는 것을 알 수 있다. 그리고 표의 크기가 m x n 인 경우에, m과 n은 모두 짝수이다. 다음 그림을 보자.

상근이는 이 1 두 개가 놓여져 있는 표에서 이 퍼즐을 완성하려고 한다. 상근이를 도와 문제의 조건을 지키는 길을 찾는 프로그램을 만드시오.
<입력값>
입력의 첫 줄은 T (테스트 케이스의 수)로 이루어져 있다.
각 테스트 케이스는 표의 행의 개수 m, 열의 개수 n (2 ≤ m, n ≤ 8)이 첫 줄에 주어진다. 두 번째 줄과 세 번째 줄은 i와 j, a와 b(각 1의 위치를 나타내는 좌표)로 이루어져 있다.
<출력값>
각 테스트 케이스별로 가는 길이 없으면 -1을 출력한다. 아니면, 1을 출력한 다음 m x n 줄마다 순서대로 길이 지나는 좌표를 출력한다. 양 끝 줄에는 각 1의 위치를 출력해야 한다.

<문제 1503>
M개의 자연수로 이루어진 집합 S와 자연수 N이 주어진다.
S에 속하지 않는 자연수 x, y, z를 골라서, |N - xyz|의 최솟값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N(1 ≤ N ≤ 1,000)과 집합 S의 크기 M(0 ≤ M ≤ 50)이 주어진다. 둘째 줄에는 집합 S에 들어있는 수가 주어진다. 집합에 들어있는 수는 1,000보다 작거나 같은 자연수이고, 공백으로 구분되어져 있다. 또, 중복되는 수는 없다.
집합의 크기가 0인 경우에는 둘째 줄은 없다.
<출력값>
첫째 줄에 |N - xyz|의 최솟값을 출력한다.

<문제 1504>
방향성이 없는 그래프가 주어진다. 세준이는 1번 정점에서 N번 정점으로 최단 거리로 이동하려고 한다. 또한 세준이는 두 가지 조건을 만족하면서 이동하는 특정한 최단 경로를 구하고 싶은데, 그것은 바로 임의로 주어진 두 정점은 반드시 통과해야 한다는 것이다.
세준이는 한번 이동했던 정점은 물론, 한번 이동했던 간선도 다시 이동할 수 있다. 하지만 반드시 최단 경로로 이동해야 한다는 사실에 주의하라. 1번 정점에서 N번 정점으로 이동할 때, 주어진 두 정점을 반드시 거치면서 최단 경로로 이동하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 정점의 개수 N과 간선의 개수 E가 주어진다. (2 ≤ N ≤ 800, 0 ≤ E ≤ 200,000) 둘째 줄부터 E개의 줄에 걸쳐서 세 개의 정수 a, b, c가 주어지는데, a번 정점에서 b번 정점까지 양방향 길이 존재하며, 그 거리가 c라는 뜻이다. (1 ≤ c ≤ 1,000) 다음 줄에는 반드시 거쳐야 하는 두 개의 서로 다른 정점 번호 v1과 v2가 주어진다. (v1 ≠ v2, v1 ≠ N, v2 ≠ 1)
<출력값>
첫째 줄에 두 개의 정점을 지나는 최단 경로의 길이를 출력한다. 그러한 경로가 없을 때에는 -1을 출력한다.

<문제 1505>
세준이는 N*M크기의 전구를 가지고 있다. 이 전구는 한번 만지면 자신을 포함해서 인접한 8개 (위, 아래, 왼쪽, 오른쪽, 대각선)의 상태가 바뀐다. (켜져 있는 거 -> 꺼짐, 꺼진거 -> 켜짐)현재 전구의 상태가 주어질 때, 세준이는 불을 전부 키려고 한다. 세준이가 전구를 만져야하는 회수의 최솟값을 출력한다.
<입력값>
첫째 줄에 N과 M이 주어진다. 둘째 줄부터 N개의 줄에 상태가 주어진다. * : 켜짐, . : 꺼짐 N,M <=8
<출력값>
첫째 줄에 최솟값을 출력한다. 불가능한 경우에는 -1을 출력한다.

<문제 1506>
종욱이가 살고있는 나라에는 도시가 N개 있고, 도시의 일부는 일방 통행 도로로 연결되어 있다. 종욱이가 살고있는 나라의 대통령 욱종이는 범죄와 싸우기 위해서 일부 도시에 경찰서를 세우려고 한다. 도시 i에 경찰서를 세우는 비용은 cost[i] 이다.
도시 i에 세운 경찰서가 도시 j를 통제할 수 있으려면, i에서 j로 갔다가, 다시 돌아오는 경로가 존재해야 한다.
도로가 연결되어 있는 상태와 각 도시에 경찰서를 지을 때 필요한 비용이 주어졌을 때, 모든 도시를 통제하는데 필요한 최소 비용을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 도시의 개수 N (1 ≤ N ≤ 100)이 주어진다. 둘째 줄에 각 도시에 경찰서를 세우는데 드는 비용이 주어진다. 셋째 줄부터 도로가 연결되어 있는 상태가 한 줄에 한 줄에 하나씩 주어진다. i번째 줄의 j번째 문자가 0인 경우에는 도시 i에서 도시 j로 갈 수 없는 것이고, 1인 경우에는 갈 수 있는 것이다.
경찰서를 세우는 비용은 1,000,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 모든 도시를 통제하는데 필요한 최소 비용을 출력한다.

<문제 1507>
강호는 N개의 도시로 이루어진 나라에 살고 있다. 각 도시는 M개의 도로로 연결되어 있으며, 각 도로를 지날 때 필요한 시간이 존재한다. 도로는 잘 연결되어 있기 때문에, 도시 A에서 B로 이동할 수 없는 경우는 존재하지 않는다.
도시 A에서 도시 B로 바로 갈 수 있는 도로가 있거나, 다른 도시를 거쳐서 갈 수 있을 때, 도시 A에서 B를 갈 수 있다고 한다.
강호는 모든 쌍의 도시에 대해서 최소 이동 시간을 구해놓았다. 민호는 이 표를 보고 원래 도로가 몇 개 있는지를 구해보려고 한다.
예를 들어, 예제의 경우에 모든 도시 사이에 강호가 구한 값을 가지는 도로가 존재한다고 해도 된다. 하지만, 이 도로의 개수는 최솟값이 아니다. 예를 들어, 도시 1-2, 2-3, 1-4, 3-4, 4-5, 3-5를 연결하는 도로만 있다고 가정해도, 강호가 구한 모든 쌍의 최솟값을 구할 수 있다. 이 경우 도로의 개수는 6개이고, 모든 도로의 시간의 합은 55이다.
모든 쌍의 도시 사이의 최소 이동 시간이 주어졌을 때, 이 나라에 존재할 수 있는 도로의 개수의 최솟값과 그 때, 모든 도로의 시간의 합을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 도시의 개수 N(1 ≤ N ≤ 20)이 주어진다. 둘째 줄부터 N개의 줄에 각각의 도시 사이에 이동하는데 필요한 시간 (≤ 10,000)이 주어진다. A에서 B로 가는 시간과 B에서 A로 가는 시간은 같다. 또, A와 B가 같은 경우에는 필요한 시간은 0이다.
<출력값>
첫째 줄에 도로 개수가 최소일 때, 모든 도로의 시간의 합을 출력한다. 불가능한 경우에는 -1을 출력한다.

<문제 1508>
세준이는 세준항공으로 돈을 무지막지하게 번 뒤, 레이스 대회를 개최했다. 레이스 트랙은 길이가 N인 직선이다.
세준이는 심판 M명을 적절한 곳에 배치시키려고 한다. 심판은 아무 곳에나 배치시킬 수 있지 않다. 심판은 미리 정해진 K개의 곳에만 위치할 수 있다.
세준이는 심판을 배치할 때, 가장 가까운 두 심판의 거리를 최대로 하려고 한다.
심판을 어디에 배치시켜야 할지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N, M, K가 주어진다. N은 1,000,000보다 작거나 같은 자연수이고, M은 10,000보다 작거나 같다. 또, K는 2보다 크거나 같고, 50보다 작거나 같다. 둘째 줄에 심판이 있을 수 있는 K개의 위치가 주어진다. K개의 위치는 N보다 작거나 같은 자연수또는 0이며, 오름차순으로 주어진다.
<출력값>
첫째 줄에 심판을 어떻게 배치시켜야 가장 가까운 심판의 거리가 최대가 될 것이지 출력한다. 출력할 때는 예제와 같이 심판을 세울 곳에는 1을, 세우지 않을 곳에는 0을 출력한다. 만약 정답이 여러개일 경우에는 사전순으로 가장 늦는 것을 출력한다.

<문제 1509>
세준이는 어떤 문자열을 팰린드롬으로 분할하려고 한다. 예를 들어, ABACABA를 팰린드롬으로 분할하면, {A, B, A, C, A, B, A}, {A, BACAB, A}, {ABA, C, ABA}, {ABACABA}등이 있다.
분할의 개수의 최솟값을 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 문자열이 주어진다. 이 문자열은 알파벳 대문자로만 이루어져 있고, 최대 길이는 2,500이다.
<출력값>
첫째 줄에 팰린드롬 분할의 개수의 최솟값을 출력한다.

<문제 1510>
이등변 삼각형이란 삼각형의 두 변의 길이가 같을 때, 이등변 삼각형이라고 한다.
만약 두 삼각형이 서로 다른 꼭짓점의 위치를 가지고 있다면, 두 삼각형은 서로 다르다고 할 수 있다.
세준이는 N*M크기의 모눈종이를 가지고 있다. 이 모눈종이에서 서로 다른 이등변 삼각형을 모두 몇 개 그릴 수 있는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N과 M이 주어진다. N과 M은 200보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 서로 다른 이등변삼각형의 개수를 출력한다.

<문제 1511>
세준이는 숫자 카드를 가지고 있다. 숫자 카드를 이용해서 숫자를 만드는 세준이는 오늘은 색다르게 숫자를 만들어 보려고 한다. 숫자는 0으로 시작하면 안되고, 인접한 자리에 같은 수가 올 수는 없다.

	  세준이는 숫자 카드를 0부터 9까지 가지고 있다. 세준이가 각각의 카드를 총 몇 장 가지고 있는지 주어질 때, 세준이가 주어진 규칙을 만족하면서 만들 수 있는 최대 수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 세준이가 가지고 있는 숫자 카드의 개수가 0부터 9까지 차례대로 주어진다. 세준이가 가지고 있는 숫자 카드의 개수의 합(0~9)은 1보다 크거나 같고, 50보다 작거나 같다.
<출력값>
첫째 줄에 만들 수 있는 가장 큰 수를 출력한다.

<문제 1512>
세준이는 생물학자이다. 따라서 DNA를 가지고 연구하는 일이 많다. 어느 날 세준이는 이렇게 긴 문자열을 보는 것이 너무 지겨워서 간단하게 나타내고 싶었다.
주어진 DNA가 길이 L일 때, 주기의 길이가 P라면, 0<=i<=L-P-1 인 모든 i에 대해서 i+p에 위치에 있는 문자와 같을 때를 말한다. 예를 들어, "CATCATC", "CATCAT", "ACTAC", "ACT"는 모두 길이가 3인 주기문이다.
DNA 문자열이 주어졌을 때, 이걸 길이 M보다 작거나 같은 주기문으로 바꿀 때, 바꾸는 문자열의 개수를 최소로 하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 M이 주어진다. M은 문자열의 길이보다 작거나 같다. 둘째 줄에 문자열이 주어진다. 문자열은 ACGT로만 이루어져 있다. 문자열의 길이는 3000보다 작거나 같다.
<출력값>
첫째 줄에 바꾸는 문자열의 개수를 출력한다.

<문제 1513>
세준이는 크기가 N*M인 직사각형 도시에 살고 있다. 또, 세준이의 집은 (1, 1)에 있고, 학원은 (N, M)에 있고, 오락실이 C개 있다.
세준이의 현재 위치가 (r, c) 일 때, (r+1, c) 또는 (r, c+1)로만 이동할 수 있다. 오락실을 방문할 때는 규칙이 하나 있는데, 오락실 번호가 증가하는 순서대로 가야한다는 것이다. 2번 오락실을 먼저 가고, 그 후에 1번 오락실을 가면 안 되고, 2번 오락실을 가려면, 그 전에 아무 오락실도 가지 않거나, 1번 오락실을 방문했을 때만 가능하다.
세준이는 오락실을 K번 방문해서 학원에서 도착하는 경로의 경우의 수가 궁금해지기 시작했다. 오락실을 0개 방문했을 때부터, C개 방문했을 때 까지 경우의 수를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N M C가 주어진다. N과 M은 50보다 작거나 같은 자연수이고, C는 50보다 작거나 같은 자연수 또는 0이다. 둘째 줄부터 C개의 줄에 1번 오락실부터 C번 오락실까지 위치가 차례대로 주어진다. 오락실의 위치가 중복되는 경우는 없지만, 오락실의 위치가 (1,1) 또는 (N,M)일 수도 있다.
<출력값>
첫째 줄에 0개 방문했을 때, 1개 방문했을 때, ..., C개 방문했을 때 총 경로의 개수를 한 줄에 공백을 사이에 두고 출력한다. 경로의 개수는 1,000,007로 나눈 나머지를 출력한다.

<문제 1514>
세준이는 노트북을 누가 가져갈까봐 자물쇠로 잠가놓는다. 자물쇠는 동그란 디스크 N개로 구성되어 있다. 각 디스크에는 숫자가 0부터 9까지 숫자가 표시되어 있다. 디스크는 원형이기 때문에, 0과 9는 인접해 있다.
세준이는 한 번 자물쇠를 돌릴 때, 최대 세 칸을 시계 방향 또는 반시계 방향으로 돌릴 수 있다. 또, 최대 세 개의 인접한 디스크를 한 번에 돌릴 수 있다.
현재 자물쇠의 상태와 세준이의 비밀번호가 주어질 때, 자물쇠를 최소 몇 번 돌려야 풀 수 있는지 구하는 프로그램을 작성하시오.
자물쇠의 상태가 555이고, 세준이의 비밀번호가 464인 경우에, 각 디스크를 따로 따로 돌리면 3번 돌려야 한다. 하지만, 디스크 3개를 동시에 돌려서 444로 만들고, 2번째 디스크를 6으로 돌리면 2번만에 돌릴 수 있다.
<입력값>
첫째 줄에 세준이의 비밀번호의 길이 (자물쇠의 크기) N이 주어진다. N은 100보다 작거나 같다. 둘째 줄에 현재 자물쇠의 상태가 주어지고, 셋째 줄에 세준이의 비밀번호가 주어진다.
<출력값>
첫째 줄에 최소 몇 번을 돌려야 풀 수 있는지 구하는 프로그램을 작성하시오.

<문제 1515>
세준이는 1부터 N까지 모든 수를 차례대로 공백없이 한 줄에 다 썼다. 그리고 나서, 세준이가 저녁을 먹으러 나간 사이에 다솜이는 세준이가 쓴 수에서 마음에 드는 몇 개의 숫자를 지웠다.
세준이는 저녁을 먹으러 갔다 와서, 자기가 쓴 수의 일부가 지워져있는 모습을 보고 충격받았다.
세준이는 수를 방금 전과 똑같이 쓰려고 한다. 하지만, N이 기억이 나지 않는다.
남은 수를 이어 붙인 수가 주어질 때, N의 최솟값을 구하는 프로그램을 작성하시오. 아무것도 지우지 않을 수도 있다.)
<입력값>
첫째 줄에 지우고 남은 수를 한 줄로 이어 붙인 수가 주어진다. 이 수는 최대 3,000자리다.
<출력값>
가능한 N 중에 최솟값을 출력한다.

<문제 1516>
숌 회사에서 이번에 새로운 전략 시뮬레이션 게임 세준 크래프트를 개발하기로 하였다. 핵심적인 부분은 개발이 끝난 상태고, 종족별 균형과 전체 게임 시간 등을 조절하는 부분만 남아 있었다.
게임 플레이에 들어가는 시간은 상황에 따라 다를 수 있기 때문에, 모든 건물을 짓는데 걸리는 최소의 시간을 이용하여 근사하기로 하였다. 물론, 어떤 건물을 짓기 위해서 다른 건물을 먼저 지어야 할 수도 있기 때문에 문제가 단순하지만은 않을 수도 있다. 예를 들면 스타크래프트에서 벙커를 짓기 위해서는 배럭을 먼저 지어야 하기 때문에, 배럭을 먼저 지은 뒤 벙커를 지어야 한다. 여러 개의 건물을 동시에 지을 수 있다.
편의상 자원은 무한히 많이 가지고 있고, 건물을 짓는 명령을 내리기까지는 시간이 걸리지 않는다고 가정하자.
<입력값>
첫째 줄에 건물의 종류 수 N(1 ≤ N ≤ 500)이 주어진다. 다음 N개의 줄에는 각 건물을 짓는데 걸리는 시간과 그 건물을 짓기 위해 먼저 지어져야 하는 건물들의 번호가 주어진다. 건물의 번호는 1부터 N까지로 하고, 각 줄은 -1로 끝난다고 하자. 각 건물을 짓는데 걸리는 시간은 100,000보다 작거나 같은 자연수이다.
<출력값>
N개의 각 건물이 완성되기까지 걸리는 최소 시간을 출력한다.

<문제 1517>
N개의 수로 이루어진 수열 A[1], A[2], …, A[N]이 있다. 이 수열에 대해서 버블 소트를 수행할 때, Swap이 총 몇 번 발생하는지 알아내는 프로그램을 작성하시오.
버블 소트는 서로 인접해 있는 두 수를 바꿔가며 정렬하는 방법이다. 예를 들어 수열이 3 2 1 이었다고 하자. 이 경우에는 인접해 있는 3, 2가 바뀌어야 하므로 2 3 1 이 된다. 다음으로는 3, 1이 바뀌어야 하므로 2 1 3 이 된다. 다음에는 2, 1이 바뀌어야 하므로 1 2 3 이 된다. 그러면 더 이상 바꿔야 할 경우가 없으므로 정렬이 완료된다.
<입력값>
첫째 줄에 N(1≤N≤500,000)이 주어진다. 다음 줄에는 N개의 정수로 A[1], A[2], …, A[N]이 주어진다. 각각의 A[i]는 0≤|A[i]|≤1,000,000,000의 범위에 들어있다.
<출력값>
첫째 줄에 Swap 횟수를 출력한다

<문제 1518>
세준이는 5*5크기의 사각형에 1부터 25까지의 수를 채워넣으려고 한다. 또, 각각의 행에 대해 모든 수는 왼쪽부터 오른쪽으로 커져가는 순서로 적으려고 한다. 그런데, 어떤 칸은 이미 숫자가 채워져 있는데, 적혀 있는 수는 한 행에 하나를 넘지 않는다. 세준이는 남은 칸을 채워야 한다.
현재 5*5크기의 사각형이 주어지면 마저 채워서 출력하는 프로그램을 작성하시오.
불가능한 경우에는 -1을 출력하고, 답이 여러개인 경우에는 첫 행 첫 열이 작은 것을 출력한다. 만약 같은 경우에는 그다음 열이 작은 것을 출력하고 같을 경우에도 위와 같이 계속 해 나간다.
<입력값>
총 5개의 줄에 5개의 수가 주어진다. 빈 칸은 0으로 주어진다.
<출력값>
5개의 줄에 수를 출력한다.

<문제 1519>
게임 판에 어떤 자연수 N이 쓰여 있을 때, 두 명의 플레이어가 턴을 번갈아가면서 이 게임을 하려고 한다.
매 턴이 돌아올때마다, 플레이어는 현재 게임 판에 쓰여 있는 수의 진 부분 문자열인 양의 정수 M을 고를 수 있다. 그리고 나서 원래 수에서 M을 뺀다. 진 부분 문자열이란 자기 자신을 제외한 모든 연속된 부분 문자열을 말한다.
예를 들어, 현재 게임 판에 2309가 써있을 때, 플레이어는 2, 3, 9, 23, 30, 230, 309를 고를 수 있다. 2를 고르면, 현재 게임 판에 쓰여 있는 수는 2307이 되고, 3은 2306, ..............., 309는 2000이 된다.
만약에 플레이어가 부분 문자열을 고를 수 없게되면, 게임에서 지게된다.
입력으로 현재 게임 판에 쓰여 있는 수 N이 주어졌을 때, 플레이어 1(첫 턴을 가지는 플레이어)이 이기기 위해서 골라야 하는 수를 출력하는 프로그램을 작성하시오. 만약 여러 가지 경우가 있다면, 가장 작은 것을 출력하고, 이길 수 없다면 -1을 출력한다.
<입력값>
첫째 줄에 N이 주어진다. N은 1,000,000보다 작거나 같은 자연수이다.
<출력값>
정답을 출력한다.

<문제 1520>
여행을 떠난 세준이는 지도를 하나 구하였다. 이 지도는 아래 그림과 같이 직사각형 모양이며 여러 칸으로 나뉘어져 있다. 한 칸은 한 지점을 나타내는데 각 칸에는 그 지점의 높이가 쓰여 있으며, 각 지점 사이의 이동은 지도에서 상하좌우 이웃한 곳끼리만 가능하다.

현재 제일 왼쪽 위 칸이 나타내는 지점에 있는 세준이는 제일 오른쪽 아래 칸이 나타내는 지점으로 가려고 한다. 그런데 가능한 힘을 적게 들이고 싶어 항상 높이가 더 낮은 지점으로만 이동하여 목표 지점까지 가고자 한다. 위와 같은 지도에서는 다음과 같은 세 가지 경로가 가능하다.


지도가 주어질 때 이와 같이 제일 왼쪽 위 지점에서 출발하여 제일 오른쪽 아래 지점까지 항상 내리막길로만 이동하는 경로의 개수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 지도의 세로의 크기 M과 가로의 크기 N이 빈칸을 사이에 두고 주어진다. 이어 다음 M개 줄에 걸쳐 한 줄에 N개씩 위에서부터 차례로 각 지점의 높이가 빈 칸을 사이에 두고 주어진다. M과 N은 각각 500이하의 자연수이고, 각 지점의 높이는 10000이하의 자연수이다.
<출력값>
첫째 줄에 이동 가능한 경로의 수 H를 출력한다. 모든 입력에 대하여 H는 10억 이하의 음이 아닌 정수이다.

<문제 1521>
랜덤 소트는 어떤 순열이 주어졌을 때, i<j이면서 A[i] > A[j]인 임의의 쌍을 교환하는 것이다.
입력으로 주어진 순열을 오름차순으로 정렬할 때, 필요한 교환의 횟수의 기댓값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 순열의 크기 N이 주어진다. 둘째 줄에 순열에 들어있는 수 N개가 주어진다. 이 수는 모두 1보다 크거나 같고, N보나 작거나 같으며, 같은 수는 2번 이상 주어지지 않는다. 또, N은 8보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 필요한 교환 횟수의 기댓값을 출력한다. 정답과의 절대/상대 오차는 10-6까지 허용한다.

<문제 1522>
a와 b로만 이루어진 문자열이 주어질 때,  a를 모두 연속으로 만들기 위해서 필요한 교환의 회수를 최소로 하는 프로그램을 작성하시오.
이 문자열은 원형이기 때문에, 처음과 끝은 서로 인접해 있는 것이다.
예를 들어,  aabbaaabaaba이 주어졌을 때, 2번의 교환이면 a를 모두 연속으로 만들 수 있다.
<입력값>
첫째 줄에 문자열이 주어진다. 문자열의 길이는 최대 1,000이다.
<출력값>
첫째 줄에 필요한 교환의 회수의 최솟값을 출력한다.

<문제 1523>
세준이의 나라에는 N개의 도시가 있다. 몇몇 도시들은 양방향 도로로 서로 연결되어 있다. 그리고, 모든 도시는 서로에게 가는 경로가 존재한다.
세준이는 어느 날 이렇게 많은 도로를 관리하는 것이 너무 비싸다고 생각했기 때문에, 몇 개의 도로를 폐쇄해 버리려고 한다. 세준이는 되도록 많은 도로를 폐쇄하려고 한다. 그러나, 세준이는 모든 도시가 서로에게 가는 경로가 존재해야 한다고 생각한다.
종점이란 것은 어떤 도시가 단 하나의 도시와 연결되어 있을 때, 종점이라고 한다. 현재 도로가 연결된 상태가 주어질 때, 종점의 개수를 최대로 하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 도시의 개수 N이 주어진다. N은 15보다 작거나 같다. 둘째 줄부터 N개의 줄에 인접행렬이 주어진다.
<출력값>
종점의 최대 개수를 출력한다.

<문제 1524>
세준이와 세비는 온라인 게임을 즐겨한다. 이 온라인 게임에서는 군대를 서로 키울 수 있다. 세준이는 N명의 병사를 키웠고, 세비는 M명의 병사를 키웠다.
이제 서로 전쟁을 하려고 한다.
전쟁은 여러 번의 전투로 이루어진다. 각 전투에서 살아있는 병사중 제일 약한 병사가 죽는다. 만약 제일 약한 병사가 여러 명이고, 제일 약한 병사가 모두 같은 편에 있다면, 그 중에 한 명이 임의로 선택되어 죽는다. 하지만, 제일 약한 병사가 여러 명이고, 양 편에 모두 있다면, 세비의 제일 약한 병사 중 한 명이 임의로 선택되어 죽는다.
전쟁은 한 명의 병사를 제외하고 모두 죽었을 때 끝난다. 전쟁의 승자를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 테스트 케이스의 개수 T가 주어진다. T는 100보다 작거나 같다. 각 테스트 케이스는 다음과 같이 이루어져 있다. 첫째 줄에 N과 M이 들어오고, 둘째 줄에는 세준이의 병사들의 힘이 들어오고, 셋째 줄에는 세비의 병사들의 힘이 들어온다. 힘은 숫자이고, 숫자가 클수록 강하고, 작을수록 약하다. N과 M은 백만보다 작거나 같은 자연수이다.
또, 각 테스트 케이스는 엔터로 구분되어 있다.(예제 참고)
<출력값>
각 테스트 케이스에 대해서 한 줄에 하나씩 차례대로 승자를 출력한다. 세준이가 이기면 S를 세비가 이기면 B를 둘다 아닐 경우에는 C를 출력한다.

<문제 1525>
3×3 표에 다음과 같이 수가 채워져 있다. 오른쪽 아래 가장 끝 칸은 비어 있는 칸이다.



1
2
3


4
5
6


7
8
 



어떤 수와 인접해 있는 네 개의 칸 중에 하나가 비어 있으면, 수를 그 칸으로 이동시킬 수가 있다. 물론 표 바깥으로 나가는 경우는 불가능하다. 우리의 목표는 초기 상태가 주어졌을 때, 최소의 이동으로 위와 같은 정리된 상태를 만드는 것이다. 다음의 예를 보자.



1
 
3


4
2
5


7
8
6






1
2
3


4
 
5


7
8
6






1
2
3


4
5
 


7
8
6






1
2
3


4
5
6


7
8
 



가장 윗 상태에서 세 번의 이동을 통해 정리된 상태를 만들 수 있다. 이와 같이 최소 이동 횟수를 구하는 프로그램을 작성하시오.
<입력값>
세 줄에 걸쳐서 표에 채워져 있는 아홉 개의 수가 주어진다. 한 줄에 세 개의 수가 주어지며, 빈 칸은 0으로 나타낸다.
<출력값>
첫째 줄에 최소의 이동 횟수를 출력한다. 이동이 불가능한 경우 -1을 출력한다.

<문제 1526>
은민이는 4와 7을 좋아하고, 나머지 숫자는 싫어한다. 금민수는 어떤 수가 4와 7로만 이루어진 수를 말한다.
N이 주어졌을 때, N보다 작거나 같은 금민수 중 가장 큰 것을 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N이 주어진다. N은 4보다 크거나 같고 1,000,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 N보다 작거나 같은 금민수 중 가장 큰 것을 출력한다.

<문제 1527>
은민이는 4와 7을 좋아하고, 나머지 숫자는 싫어한다. 금민수는 어떤 수가 4와 7로만 이루어진 수를 말한다.
A와 B가 주어졌을 때, A보다 크거나 같고, B보다 작거나 같은 자연수 중에 금민수인 것의 개수를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 A와 B가 주어진다. A는 1보다 크거나 같고, 1,000,000,000보다 작거나 같은 자연수이다. B는 A보다 크거나 같고, 1,000,000,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 A보다 크거나 같고, B보다 작거나 같은 자연수 중에 금민수인 것의 개수를 출력한다.

<문제 1528>
은민이는 4와 7을 좋아하고, 나머지 숫자는 싫어한다. 금민수는 4와 7로만 이루어진 수를 말한다.
N이 주어졌을 때, N을 금민수의 합으로 나타내는 프로그램을 작성하시오. 만약 여러 가지 방법이 존재하면, 수의 개수가 적은 것을 출력한다. 그러한 방법도 여러 개일 경우에는 사전순으로 가장 앞서는 것을 출력한다. 만약 N을 금민수의 합으로 표현할 수 없다면 -1을 출력한다.
N = a1+a2+...+ak가 N = b1+b2+...+bk보다 앞선다는 것은, ai ≠ bi인 가장 작은 i에 대해 ai < bi가 성립한다는 뜻이다.
<입력값>
첫째 줄에 N이 주어진다. N은 1,000,000보다 작거나 같다.
<출력값>
첫째 줄에 정답을 공백을 사이에 두고 출력한다.

<문제 1529>
은민이는 4와 7을 좋아하고, 나머지 숫자는 싫어한다. 금민수는 어떤 수가 4와 7로만 이루어진 수를 말한다.
동민 수열은 길이가 L이고, A[0], A[1], ..., A[L-1]와 같이 생긴 수열이다. 또, 다음과 같은 성질을 가진다.

A[i]는 금민수이다. (0 ≤ i < L)
모든 i에 대해서 A[i] = Numbers[j]인 j가 적어도 하나 존재한다. (0 ≤ i < L)
모든 i에 대해서 A[i]의 마지막 자리는 A[i+1]의 첫 번째 자리와 같다. (0 ≤ i < L-1)

Numbers배열과 L이 주어졌을 때, 서로 다른 동민 수열의 개수를 1,234,567,891로 나눈 나머지를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 Numbers 배열의 크기 N과 L이 주어진다. N은 50보다 작거나 같은 자연수이고, L은 1,000,000,000보다 작거나 같은 자연수이다. 둘째 줄에 Numbers배열에 들어있는 수가 주어진다. 각각의 수는 1,000,000,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 서로 다른 동민 수열의 개수를 1,234,567,891로 나눈 나머지를 출력한다.

<문제 1530>
은민이는 4와 7을 좋아하고, 나머지 숫자는 싫어한다. 금민수는 4와 7로만 이루어진 수를 말한다.
N이 주어졌을 때, N을 금민수의 합으로 나타내는 프로그램을 작성하시오. 만약 여러 가지 방법이 존재하면, 수의 개수가 적은 것을 출력한다. 그러한 방법도 여러 개일 경우에는 사전순으로 가장 앞서는 것을 출력한다. 만약 N을 금민수의 합으로 표현할 수 없다면 -1을 출력한다.
N = a1+a2+...+ak가 N = b1+b2+...+bk보다 앞선다는 것은, ai ≠ bi인 가장 작은 i에 대해 ai < bi가 성립한다는 뜻이다.
<입력값>
첫째 줄에 N이 주어진다. N은 1,000,000,000보다 작거나 같다.
<출력값>
첫째 줄에 정답을 공백을 사이에 두고 출력한다.

<문제 1531>
세준이는 1*1크기의 그림으로 모자이크한 100*100크기의 그림을 가지고 있다. 어느 날 이 모자이크 중 일부 그림이 너무 보기 싫어서 N개의 불투명한 종이로 그림을 가리기 시작했다. 불투명한 종이로 가린다고 항상 그 그림이 안 보이는 것은 아니다. 그 그림의 현재 부분 위에 M개 이하의 종이가 올려져 있으면 그림은 그 부분에서 보이게 된다.
그림의 크기는 100*100이고, N개의 종이는 왼쪽 아래 모서리 좌표와 오른쪽 위 모서리 좌표가 입력으로 들어온다. 또, 종이가 가리는 영역에는 두 모서리의 좌표도 포함된다. 예를 들어, (1,1)부터 (2,2)를 가린다면, 총 4개의 그림이 가려진다. (1,1), (1,2), (2,1), (2,2).
100*100크기의 모자이크 중에 보이지 않는 그림의 개수를 세는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N과 M이 주어진다. N은 0보다 크거나 같고, 50보다 작거나 같다. M은 0보다 크거나 같고, 50보다 작거나 같다. 둘째 줄부터 N개의 줄에 종이의 좌표가 주어진다. 왼쪽 아래 모서리의 x, y좌표, 오른쪽 위 모서리의 x, y좌표 순으로 주어진다. 모든 좌표는 100보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 정답을 출력한다.

<문제 1532>
세준이는 현재 G1개의 금화, S1개의 은화, B1개의 동화를 가지고 있다. 세준이는 새 노트북을 사기 위해 G2개의 금화, S2개의 은화, B2개의 동화가 필요하다. 세준이는 동전을 교환하기 위해서 은행에 갔다. 은행에서는 한 번의 교환에는 다음 4가지의 종류만 있다고 했다.

세준이의 금화 1개를 은화 9개로 교환
세준이의 은화 11개를 금화 1개로 교환
세준이의 은화 1개를 동화 9개로 교환
세준이의 동화 11개를 은화 1개로 교환

세준이가 적어도 G2개의 금화, 적어도 S2개의 은화, 적어도 B2개의 동화를 가지고 있기 위해서 은행에서 해야하는 교환의 회수를 최소로 하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 G1 S1 B1이 들어오고, 둘째 줄에 G2 S2 B2가 들어온다. 모든 값은 1,000,000보다 작거나 같은 자연수이거나 0이다.
<출력값>
첫째 줄에 정답을 출력한다. 못 바꾸는 경우에는 -1을 출력한다.

<문제 1533>
세준이는 정문이를 데리러 공항으로 가기로 했다. 하지만, 방금 세준이는 정문이의 비행기가 연착된다는 전화를 받았다. 세준이는 정문이가 정확하게 몇 분 늦는지 알고 있고, 그 시간 동안 밖에서 드라이브를 하려고 한다. 정문이가 늦는 시간을 T라고 하자.
세준이는 자기가 지금 있는 위치에서부터, 공항까지 정확하게 T분만에 도착하는 경로의 개수를 구하고 싶다.
길의 정보는 인접행렬로 주어진다. A[i][j]가 0이라면 i에서 j로 가는 길이 없는 것이고, A[i][j] ≤ 5라면, 정확히 그 만큼의 시간이 걸리는 i에서 j로 가는 길이 있는 것이다.
<입력값>
첫째 줄에 교차점의 개수 N이 주어진다. N은 10보다 작거나 같고, 시작점의 위치 S와 끝점의 위치 E, 그리고 정문이가 늦는 시간 T도 주어진다. S와 E는 N보다 작거나 같은 자연수이다. T는 1,000,000,000보다 작거나 같은 자연수이다. 둘째 줄부터 길의 정보가 주어진다.
<출력값>
첫째 줄에 경로의 개수를 1,000,003로 나눈 나머지를 출력한다.

<문제 1534>
세준이는 N개의 점을 가진 볼록 다각형을 가지고 있다. 다각형을 한 번 자를 때, 반드시 점에서 점으로 자르는 것만 가능하고, 또, 하나의 다각형이 반드시 두 개로 나누어 져야 한다. 그리고, 모든 점은 구분된다고 한다.
예를 들어, 정사각형을 자르는 데는 3가지 방법이 존재한다. 두 가지는 대각선으로 자르는 방법이고, 한 가지는 자르지 않는 방법이다.
볼록 N각형을 K개의 다각형으로 자르는 경우의 수를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N과 K가 주어진다. N은 3보다 크거나 같고, 100보다 작거나 같다. K는 1보다 크거나 같고, 100보다 작거나 같다.
<출력값>
첫째 줄에 정답을 1000000000으로 나눈 나머지를 출력한다. 만약 N각형을 K개의 다각형으로 자르는 것이 불가능할 경우에는 -1을 출력한다.

<문제 1535>
세준이는 성형수술을 한 후에 병원에 너무 오래 입원해 있었다. 이제 세준이가 병원에 입원한 동안 자기를 생각해준 사람들에게 감사하다고 말할 차례이다.
세준이를 생각해준 사람은 총 N명이 있다. 사람의 번호는 1번부터 N번까지 있다. 세준이가 i번 사람에게 인사를 하면 L[i]만큼의 체력을 잃고, J[i]만큼의 기쁨을 얻는다. 세준이는 각각의 사람에게 최대 1번만 말할 수 있다.
세준이의 목표는 주어진 체력내에서 최대한의 기쁨을 느끼는 것이다. 세준이의 체력은 100이고, 기쁨은 0이다. 만약 세준이의 체력이 0이나 음수가 되면, 죽어서 아무런 기쁨을 못 느낀 것이 된다. 세준이가 얻을 수 있는 최대 기쁨을 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 사람의 수 N(<=20)이 들어온다. 둘째 줄에는 각각의 사람에게 인사를 할 때, 잃는 체력이 1번 사람부터 순서대로 들어오고, 셋째 줄에는 각각의 사람에게 인사를 할 때, 얻는 기쁨이 1번 사람부터 순서대로 들어온다. 체력과 기쁨은 100보다 작거나 같은 자연수 또는 0이다.
<출력값>
첫째 줄에 세준이가 얻을 수 있는 최대 기쁨을 출력한다.

<문제 1536>
Fall Out Boy의 Dance, Dance라는 노래를 제일 좋아하는 세준이는 댄스 파티를 계획중이다. 이 댄스 파티에는 N명의 남자와 N명의 여자가 참석할 예정이다. 댄스 파티는 몇 개의 라운드로 진행될 예정이다.
각각의 라운드에서 세준이는 2N명의 손님을 N명의 쌍으로 나누려고 한다. 모든 손님은 하나의 쌍에 속해야 하고, 각 쌍에는 남자 1명과, 여자 1명이 있어야 한다.
모든 남자들은 모든 라운드에서 다른 여자와 춤을 춰야 한다. 어떤 남자와 어떤 여자는 서로 좋아하거나 서로 싫어한다. 하지만, 댄스 파티 동안, 모든 남자들은 많아야 K번은 자기가 싫어하는 여자와 춤을 출 수 있다고 했다. 비슷하게, 여자도 많아야 K번은 자기가 싫어하는 남자와 춤을 출 수 있다.
각각의 남자와 여자가 서로 좋아하는지 아닌지 정보가 주어졌을 때, 최대 몇 라운드 까지 갈 수 있는 지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 남자의 수 N과, K가 주어진다. N은 50보다 작거나 같은 자연수이고, K는 0보다 크거나 같고 50보다 작거나 같은 자연수이다. 둘째 줄에는 첫 번째 남학생과 첫 번째 여학생이 서로 좋아하면 1, 아니면 0이 주어지고, 두 번째 여학생도 주어지고, N 번째 여학생도 주어진다. 셋째 줄에는 두 번째 남학생,,,, 과 같이 주어진다.
<출력값>
첫째 줄에 최대 몇 라운드까지 갈 수 있는지 출력한다.

<문제 1537>
양의 정수 N이 주어졌을 때, 다음과 같은 다섯 개의 함수를 정의 했다.

Sum(N)은 N의 모든 자리수를 더한 값이다.
Prod(N)은 N의 모든 자리수를 곱한 값이다.
Prod3(N)은 N의 자리수중 가장 큰 3개를 곱한 값이다. 만약 N이 3자리보다 작다면 Prod3(N) = Prod(N)이다.
Smallest(N)은 N의 가장 작은 자리수이다.
First(N)은 N의 가장 맨 앞 자리수이다.

세준이는 @라는 연산자를 새롭게 정의 했다.

X@Y = 5*Prod3(X) + First(X) * Sum(Y) + Smallest(Y)이다.

Sum(47) = 4+7 = 11
Prod(2322) = 2*3*2*2 = 24
Prod3(2322) = 3*2*2 = 12
Prod3(47) = Prod(47) = 4*7 = 28
Smallest(427) = 2
First(427) = 4
12034@217 = 5 * (4*3*2) + 1 * (2+1+7) + 1 = 131

올바른 식은 다음과 같이 재귀적으로 정의 된다.

X는 올바른 식이다.
만약, A가 올바른 식이고, B가 올바른 식이라면, A@B도 올바른 식이다.
위의 규칙에 의해서 생성되지 않은 식은 모두 올바르지 않은 식이다.

X와 G가 주어졌을 때, X를 G로 만드는 올바른 식을 구하는 프로그램을 작성하시오. 만약 불가능하다면 -1을 출력한다.
<입력값>
첫째 줄에 X와 G가 주어진다. X는 1,000,000보다 작거나 같은 자연수이고, G는 2,000,000,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 올바른 식에 들어가는 @의 최소 값을 출력한다.

<문제 1538>
세준이는 가방을 하나 가지고 있다. 이 가방 속에는 N개의 공이 들어있다. N개의 공엔 색이 칠해져 있다. 세준이는 이 가방에서 서로 다른 두 개의 공을 하나씩 차례대로 고른다. 그 후에 두 번째로 고른 공을 첫 번째로 고른 공의 색으로 색 칠한다. 그 후, 공이 마르면, 두 공을 다시 가방에 집어 넣고 섞는다.
세준이는 이 공의 색이 모두 같아지려면 몇 번을 색 칠해야 하는지 궁금해졌다.
세준이가 공을 칠해야 하는 횟수의 기댓값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 공의 개수 N(1 ≤ N ≤ 24)이 주어진다. 둘째 줄에 공에 칠해진 N개의 색이 공백없이 주어진다. 색은 알파벳 대문자(A - Z)중 하나이다.
<출력값>
첫째 줄에 세준이가 공을 색 칠하는 회수의 기댓값을 출력한다. 정답과의 절대/상대 오차는 10-8까지 허용한다.

<문제 1539>
P는 크기가 N인 배열이다. P에는 0보다 크거나 같고, N-1보다 작거나 같은 정수가 중복 없이 채워져 있다. 이진 검색 트리는 루트가 있는 이진 트리로, 각각의 노드에 정수 값이 저장되어 있는 트리이다. 이진 검색 트리를 P배열을 이용해서 만드는 법은 다음과 같다. 일단 root를 만들고 거기에 P[0]의 값을 넣은 후에 다음과 같은 과정을 거친다.

for (int i=1; i<=n-1; i++) {
    insert(root, P[i]);
}

여기서 insert함수는 다음과 같다.

void insert(Vertex V, int X) {
    if (x < V에 저장되어 있는 수) {
        if (V가 왼쪽 자식이 있으면) {
            insert(V의 왼쪽 자식, X);
        } else {
            V의 왼쪽 자식을 새로 만들고, 그 곳에 X를 저장함
        }
    } else {
        if (V가 오른쪽 자식이 있으면) {
            insert(V의 오른쪽 자식, X);
        } else {
            V의 오른쪽 자식을 새로 만들고, 그 곳에 X를 저장함
        }
    }
}

N과, 배열 P에 있는 수가 주어졌을 때, P로 이진 검색 트리를 만들었을 때, 모든 노드의 높이의 합을 출력하는 프로그램을 작성하시오. 트리의 높이는 루트에서 부터의 거리 + 1이다.
<입력값>
첫째 줄에 N이 주어진다. N은 250,000보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 P[0]부터 P[N-1]의 원소가 한 줄에 하나씩 들어온다.
<출력값>
주어진 P배열로 이진 검색 트리를 만들었을 때, 높이의 합을 출력한다. 이 값은 2^63보다 작다.

<문제 1540>
세준이는 2차원 평면에 N개의 점을 찍었다. 그리고 나서 정사각형의 개수를 세려고 한다.
정사각형의 개수란, 세준이가 찍은 서로 다른 N개의 점을 꼭짓점으로 하며, 모든 변은 축에 평행한 서로 다른 정사각형을 모두 센 것이다.
세준이는 정사각형의 개수를 최대로 하려고 한다.
N이 주어졌을 때, 정사각형의 개수의 최댓값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N이 주어진다. 이 값은 0보다 크거나 같고, 1000000보다 작거나 같은 값이다.
<출력값>
첫째 줄에 정사각형의 개수의 최댓값을 출력한다.

<문제 1541>
세준이는 양수와 +, -, 그리고 괄호를 가지고 식을 만들었다. 그리고 나서 세준이는 괄호를 모두 지웠다.
그리고 나서 세준이는 괄호를 적절히 쳐서 이 식의 값을 최소로 만들려고 한다.
괄호를 적절히 쳐서 이 식의 값을 최소로 만드는 프로그램을 작성하시오.
<입력값>
첫째 줄에 식이 주어진다. 식은 ‘0’~‘9’, ‘+’, 그리고 ‘-’만으로 이루어져 있고, 가장 처음과 마지막 문자는 숫자이다. 그리고 연속해서 두 개 이상의 연산자가 나타나지 않고, 5자리보다 많이 연속되는 숫자는 없다. 수는 0으로 시작할 수 있다. 입력으로 주어지는 식의 길이는 50보다 작거나 같다.
<출력값>
첫째 줄에 정답을 출력한다.

<문제 1542>
세준이와 다솜이는 체스를 취미로 즐긴다. 하지만, 이제 국가대표가 되어야겠다는 목표로 오늘부터 연습을 하려고 한다. 오늘은 100*100크기의 체스판에서 퀸만 가지고 공격 기술을 연습하려고 한다.
체스판 위에는 퀸이 N개 올려져 있다. 이 연습은 세준이 먼저, 그다음에 다솜이, 그리고 다시 세준이와 같이 턴을 번갈아 가면서 진행된다.
하나의 턴에 하나의 퀸을 고른 후, 옮긴다. 만약 퀸이 (x,y)에 있었다면, 퀸은 (x-k,y), (x,y-k), (x-k,y-k)중에 하나로 옮길 수 있다. (k>0) 그리고, 퀸은 다른 퀸이 있는 칸을 통과 할 수도 있고, 한 칸에 여러 퀸이 있을 수도 있다.
이 연습은 (0,0)에 퀸을 하나라도 먼저 놓는 사람이 이긴다. 세준이와 다솜이가 항상 최적의 방법으로 연습한다고 가정할 때, 승자를 출력하는 프로그램을 작성하시오.
<입력값>
5개의 게임이 입력으로 들어오며, 각각의 게임은 다음과 같이 구성되어 있다. 첫째 줄에는 체스판 위에 있는 퀸의 개수 N이 주어진다. 이 값은 50보다 작거나 같다. 둘째 줄부터 N개의 줄에는 퀸의 위치가 차례대로 X Y의 순서로 들어온다.
<출력값>
각 게임의 승자가 세준이면 S, 다솜이면 D를 출력한다.

<문제 1543>
세준이는 영어로만 이루어진 어떤 문서를 검색하는 함수를 만들려고 한다. 이 함수는 어떤 단어가 총 몇 번 등장하는지 세려고 한다. 그러나, 세준이의 함수는 중복되어 세는 것은 빼고 세야 한다. 예를 들어, 문서가 abababa이고, 그리고 찾으려는 단어가 ababa라면, 세준이의 이 함수는 이 단어를 0번부터 찾을 수 있고, 2번부터도 찾을 수 있다. 그러나 동시에 셀 수는 없다.
세준이는 문서와 검색하려는 단어가 주어졌을 때, 그 단어가 최대 몇 번 중복되지 않게 등장하는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 문서가 주어진다. 문서의 길이는 최대 2500이다. 둘째 줄에 검색하고 싶은 단어가 주어진다. 이 길이는 최대 50이다. 문서와 단어는 알파벳 소문자와 공백으로 이루어져 있다.
<출력값>
첫째 줄에 중복되지 않게 최대 몇 번 등장하는지 출력한다.

<문제 1544>
사이클 단어는 어떤 단어를 원형 모양으로 차례대로 쓴 것이다. 따라서, 어떤 단어를 이렇게 쓴 후에 임의의 단어를 고른다. 그 후에 시계방향으로 차례대로 읽으면 그 것이 단어가 된다.

	  만약에 단어 A와 단어 B가 있을 때, 단어 B를 원형으로 써서, 단어 A와 같이 읽을 수 있으면, 두 단어는 같은 단어이다.

	  따라서, picture와 turepic은 같은 단어다.

	  N개의 단어가 주어졌을 때, 서로 다른 단어가 총 몇 개인지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 단어의 개수 N이 주어진다. 둘째 줄부터 단어가 한 줄에 하나씩 주어진다. 단어는 영어 소문자로만 이루어져 있다. N은 50보다 작거나 같은 자연수이며, 단어의 길이는 최대 50이다.
<출력값>
첫째 줄에 서로 다른 단어가 몇 개인지 출력한다.

<문제 1545>
만약 어떤 문자열 P가 있을 때, P[i]와 P[n-i-1] (0<=i<(n-1)/2, n=P의 길이)이 모두 다를 때, P는 안티 팰린드롬 문자열이라고 한다. 이 말은 P와 P를 대칭한 문자열 P'가 있을 때,모든 문자가 달라야 안티 팰린드롬 문자열이란 소리다. (단, 문자열의 길이가 홀수인 경우에는, 가운데 문자는 같아도 된다) 예를 들어, "c", "cpp", "java"는 안티 팰린드롬 문자열이고, “test", "pp", ”weather"는 안티 팰린드롬 문자열이 아니다.
문자열 S가 주어졌을 때, 이 문자열을 재배치 시켜서 안티 팰린드롬 문자열을 만드는 프로그램을 작성하시오. 만약 가능한 경우가 여러 가지 있다면, 사전순으로 가장 앞서는 것을 출력하시오.
<입력값>
첫째 줄에 문자열 S가 주어진다. 이 길이는 최대 50이고, 알파벳 소문자로만 이루어져 있다.
<출력값>
첫째 줄에 정답을 출력한다. 만약 불가능한 경우에는 -1을 출력한다.

<문제 1546>
세준이는 기말고사를 망쳤다. 세준이는 점수를 조작해서 집에 가져가기로 했다. 일단 세준이는 자기 점수 중에 최댓값을 골랐다. 이 값을 M이라고 한다. 그리고 나서 모든 점수를 점수/M*100으로 고쳤다.
예를 들어, 세준이의 최고점이 70이고, 수학점수가 50이었으면 수학점수는 50/70*100이 되어 71.43점이 된다.
세준이의 성적을 위의 방법대로 새로 계산했을 때, 새로운 평균을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 시험 본 과목의 개수 N이 주어진다. 이 값은 1000보다 작거나 같다. 둘째 줄에 세준이의 현재 성적이 주어진다. 이 값은 100보다 작거나 같은 음이 아닌 정수이고, 적어도 하나의 값은 0보다 크다.
<출력값>
첫째 줄에 새로운 평균을 출력한다. 실제 정답과 출력값의 절대오차 또는 상대오차가 10-2 이하이면 정답이다.

<문제 1547>
세준이는 컵 3개를 탁자 위에 일렬로 엎어놓았다. 컵의 번호는 맨 왼쪽 컵부터 순서대로 1번, 2번 3번이고, 세준이는 이 컵을 이용해서 게임을 하려고 한다.
먼저 1번 컵의 아래에 공을 하나 넣는다. 세준이는 두 컵을 고른 다음, 그 위치를 맞바꾸려고 한다. 예를 들어, 고른 컵이 1번과 2번이라면, 1번 컵이 있던 위치에 2번 컵을 이동시키고, 동시에 2번 컵이 있던 위치에 1번 컵을 이동시켜야 한다. 이때 공은 움직이지 않기 때문에, 공의 위치는 맨 처음 1번 컵이 있던 위치와 같다.
세준이는 컵의 위치를 총 M번 바꿀 것이며, 컵의 위치를 바꾼 방법이 입력으로 주어진다. 위치를 M번 바꾼 이후에 공이 들어있는 컵의 번호를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 컵의 위치를 바꾼 횟수 M이 주어지며, M은 50보다 작거나 같은 자연수이다. 둘째 줄부터 M개의 줄에는 컵의 위치를 바꾼 방법 X와 Y가 주어지며, X번 컵과 Y번 컵의 위치를 서로 바꾸는 것을 의미한다. X와 Y의 값은 3보다 작거나 같고, X와 Y가 같을 수도 있다.
컵을 이동시킨 후에 공이 컵 바깥에 있는 경우는 없다.
<출력값>
첫째 줄에 공이 들어있는 컵의 번호를 출력한다. 공이 사라져서 컵 밑에 없는 경우에는 -1을 출력한다.

<문제 1548>
세 숫자 x, y, z가 x+y>z, x+z>y, y+z>x의 관계를 만족하면, 세 수는 삼각관계에 있다고 한다.
마찬가지로 길이가 N인 수열 B(b[0], b[1], ..., b[n-1])의 모든 b[i], b[j], b[k]가 삼각관계에 있으면 이 수열은 삼각 수열이라고 한다. 이때, i, j, k는 모두 다른 값이다.
수열 A가 주어졌을 때, 이 수열에서 적절히 몇 개의 원소를 빼서 ,이 수열을 삼각 수열로 만들려고 한다. 삼각 수열의 최대 길이를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 수열의 크기 N이 주어진다. 둘째 줄에 수열 A에 들어있는 수가 공백을 사이에 두고 주어진다. N은 최대 50이고, A에 들어있는 수는 10^9보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 가장 긴 부분 삼각 수열의 길이를 출력한다.

<문제 1549>
s(i,k)를 배열 A의 i번째 원소부터 시작하는 연속된 k개 수의 합이라고 정의하자.
s(i,k) = A[i] + A[i+1] + ... + A[i+k-1]
i+k<=j일 때, s(i,k) 와 s(j,k)의 차이 ( abs(s(i, k) - s(j, k)) )를 최소로 하는 프로그램을 작성하시오.  즉, 동일한 길이의 겹치지 않는 두 부분 수열의 차이를 최소로 하는 것이다.
<입력값>
첫째 줄에 n이 주어진다. n은 2보다 크거나 같고, 3,000보다 작거나 같은 자연수이다. 둘째 줄에는 배열 A의 원소가 A[0]부터 차례대로 주어진다. A[i] <= 1,000,000,000 인 자연수 또는 0이다.
<출력값>
첫째 줄에 값이 가장 작을 때 k를 출력하고, 둘째 줄에 차이의 최솟값을 출력한다. 만약 최솟값이 여러 개일 경우에는 k를 최대로 한다.

<문제 1550>
16진수 수를 입력받아서 10진수로 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 16진수 수가 주어진다. 이 수의 최대 길이는 6글자이다. 16진수 수는 0~9와 A~F로 이루어져 있고, A~F는 10~15를 뜻한다. 또, 이 수는 음이 아닌 정수이다.
<출력값>
첫째 줄에 입력으로 주어진 16진수 수를 10진수로 변환해 출력한다.

<문제 1551>
크기가 N인 수열 A가 주어졌을 때, 세준이는 인접한 두 원소의 차이를 이용해서 크기가 N-1인 수열 B를 만들 수 있다.
예를 들어, A = {5,6,3,9,-1} 이었을 때, B = {6-5, 3-6, 9-3, -1-9} = {1,-3,6,-10}이 된다. 다른 말로 B[i] = A[i+1]-A[i]가 된다.
수열 A가 주어졌을 때, 세준이가 위의 방법을 K번 했을 때 나오는 수열을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 수열의 크기 N과 K가 주어진다. N은 20보다 작거나 같은 자연수이고, K는 0보다 크거나 같고, N-1보다 작거나 같은 자연수이다. 둘째 줄에는 수열이 ‘,’로 구분되어 주어진다.
<출력값>
첫째 줄에 K번 변형한 수열을 ‘,’로 구분하여 출력한다.

<문제 1552>
도미노는 위와 같이 생겼다.
세준이가 가지고 있는 도미노는 약간 다르다. 세준이는 도미노를 N^2개 가지고 있다. 따라서 N=2라면, 세준이는 (1,1), (1,2), (2,1), (2,2) 이렇게 총 N^2개를 가지고 있는 것이다.
세준이는 이 도미노를 가지고 도미노미도마도라는 게임을 하려고 한다. 이 게임은 김민오가 만들었다.
이 게임에서 도미노는 N*N크기의 보드에 놓여져 있다. i번째 행, j번째 열에는 (i,j)라고 쓰여 있는 도미노가 놓여져 있다. 플레이어는 도미노를 정확하게 N개를 골라야 하는데, 선택한 도미노를 두 개가 같은 행에서 고르고, 선택한 도미노를 같은 열에서 고르면 안 된다는 조건이 있다. 또, 고른 도미노를 가지고 사이클을 만들 수 있다. 사이클을 만드는 방법은, 도미노 A와 B가 있을 때, A의 두 번째 숫자와 B의 첫 번째 수가 같으면 된다. 그리고 사이클을 이루는 첫 번째 도미노의 처음 숫자와 마지막 도미노의 둘째 숫자가 같으면 된다.
예를 들어, (1,3), (3,2), (2,4), (4,1)을 골라서 사이클을 만들 수 있다.
N개의 도미노를 고르면 이러한 사이클이 한 개 또는 그 이상의 그룹이 나온다. ( (1,1)와 같은 도미노는 자기 자신으로 사이클을 이루므로 하나의 그룹으로 친다. )
게임의 조건 중에 각 행과 열에서 중복되면 안되는 조건이 있기 때문에, 항상 사이클을 이룰 수 있다.
모든 도미노는 그 뒷면에 숫자가 쓰여 있다. 이 게임에서 점수를 계산할 때는 자기가 고른 도미노의 뒷면에 쓰여 있는 수를 모두 곱한다. 그 다음에 만약 사이클 그룹의 개수가 짝수가 되면 그 수에 -1을 곱한다.
세준이는 자기가 이 게임에서 얻을 수 있는 최대 점수와 최소 점수가 궁금해 졌다.
도미노의 개수와 도미노 뒷면에 쓰여 있는 수가 주어질 때, 세준이가 얻을 수 있는 최대 점수와 최소 점수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N이 주어진다. N은 6보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 각 도미노에 쓰여 있는 수가 주어진다. i행 j열에 쓰여 있는 수는 도미노 (i,j)의 뒷 면에 쓰여 있는 수이다. 도미노의 뒷면에는 0~9 사이의 수 (0,9 포함) 또는 A~I사이 (A,I 포함)의 문자가 써 있고, A~I의 문자가 의미하는 것은 -1부터 -9이다.
<출력값>
첫째 줄에 세준이가 얻을 수 있는 최소 점수, 둘째 줄에 세준이가 얻을 수 있는 최대 점수를 출력한다.

<문제 1553>
도미노의 크기는 1×2이고, 크기가 1×1인 칸으로 나누어져 있다. 칸은 수를 나타내며, 위와 같이 총 28가지가 있다.
크기가 8×7인 격자가 있고, 격자의 각 칸에는 정수가 하나씩 들어있다. 위의 도미노를 이용해 문제의 격자와 같은 상태를 만드는 방법의 수를 구해보자.
격자의 칸에 적힌 수는 도미노의 칸이 의미하는 수와 같아야 한다. 도미노는 회전할 수 있으며, 같은 도미노를 여러 번 사용하면 안된다.
<입력값>
총 8개의 줄에 격자의 상태가 주어진다.
<출력값>
첫째 줄에 경우의 수를 출력한다.

<문제 1554>
세준이는 황무지에 호화로운 저택을 지어서 살고 있다. 황무지에 집을 지었기 때문에, 세준이의 뒷마당에는 나무가 하나도 없었다. 따라서 세준이는 뒷마당에 나무를 심기로 했다.
세준이의 뒷마당은 W*H(가로*세로)의 직사각형 모양이다. 세준이는 T개의 나무를 심으려고 한다. 세준이는 전직 미술가이기 때문에, 미적 감각을 살려 다음과 같은 모양으로 나무를 심으려고 한다.

모든 나무는 정수 좌표에 있어야 한다.
모든 나무는 한 직선 위에 있어야 한다.
모든 나무는 위치의 차이는 적어도 D만큼 차이가 나야 한다. 


위의 그림은 10*10 크기의 뒷마당에 나무 4개를 나무들 사이의 거리 차이가 최소 2가 되게 채운 두 가지 방법이다.
W와 H와 T와 D가 주어졌을 때, 서로 다른 몇 가지 방법으로 나무를 심을 수 있는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 T W H D가 주어진다. (1<=T,D<=50, 1<=W,H<=500)
<출력값>
첫째 줄에 서로 다른 방법의 수를 1,000,000,000으로 나눈 나머지를 출력한다.

<문제 1555>
1보다 크거나 같고, 30보다 작거나 같은 수로 채워진 크기 N의 배열 A가 주어진다. 이 배열의 원소를 +, -, *, /, 괄호를 원하는 만큼 써서 식을 만들어서, 가장 큰 소수와 가장 작은 소수를 구하는 프로그램을 작성하시오.
배열 A에 있는 수는 중복될 수 있고, 모두 단 한번씩 사용해야 한다.
예를 들어, A = {1,2,3}일 때, 만들 수 있는 가장 작은 소수는 3-2+1=2 이고, 가장 큰 소수는 3*2+1=7이다. 
나눗셈의 두 피연산자는 양의 정수이며, 결과가 정수가 되는 정수 나눗셈을 사용한다.
<입력값>
첫째 줄에 A의 크기 N이 주어진다. 둘째 줄에 A에 들어있는 원소가 주어진다.
<출력값>
첫째 줄에 가장 작은 소수를 출력하고, 둘째 줄에 가장 큰 소수를 출력한다. 만약 소수를 만들 수 없으면 -1을 출력한다.

<문제 1556>
도미노는 위와 같이 생겼다.
세준이가 가지고 있는 도미노는 약간 다르다. 세준이는 도미노를 N^2개 가지고 있다. 따라서 N=2라면, 세준이는 (1,1), (1,2), (2,1), (2,2) 이렇게 총 N^2개를 가지고 있는 것이다.
세준이는 이 도미노를 가지고 도미노미도마도라는 게임을 하려고 한다. 이 게임은 김민오가 만들었다.
이 게임에서 도미노는 N*N크기의 보드에 놓여져 있다. i번째 행, j번째 열에는 (i,j)라고 쓰여 있는 도미노가 놓여져 있다. 플레이어는 도미노를 정확하게 N개를 골라야 하는데, 선택한 도미노를 두 개가 같은 행에서 고르고, 선택한 도미노를 같은 열에서 고르면 안 된다는 조건이 있다. 또, 고른 도미노를 가지고 사이클을 만들 수 있다. 사이클을 만드는 방법은, 도미노 A와 B가 있을 때, A의 두 번째 숫자와 B의 첫 번째 수가 같으면 된다. 그리고 사이클을 이루는 첫 번째 도미노의 처음 숫자와 마지막 도미노의 둘째 숫자가 같으면 된다.
예를 들어, (1,3), (3,2), (2,4), (4,1)을 골라서 사이클을 만들 수 있다.
N개의 도미노를 고르면 이러한 사이클이 한 개 또는 그 이상의 그룹이 나온다. ( (1,1)와 같은 도미노는 자기 자신으로 사이클을 이루므로 하나의 그룹으로 친다. )
게임의 조건 중에 각 행과 열에서 중복되면 안되는 조건이 있기 때문에, 항상 사이클을 이룰 수 있다.
모든 도미노는 그 뒷면에 숫자가 쓰여 있다. 이 게임에서 점수를 계산할 때는 자기가 고른 도미노의 뒷면에 쓰여 있는 수를 모두 곱한다. 그 다음에 만약 사이클 그룹의 개수가 짝수가 되면 그 수에 -1을 곱한다.
세준이는 자기가 이 게임에서 얻을 수 있는 최대 점수와 최소 점수가 궁금해 졌다.
도미노의 개수와 도미노 뒷면에 쓰여 있는 수가 주어질 때, 세준이가 얻을 수 있는 가능한 모든 점수의 합을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N이 주어진다. N은 100보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 각 도미노에 쓰여 있는 수가 주어진다. i행 j열에 쓰여 있는 수는 도미노 (i,j)의 뒷 면에 쓰여 있는 수이다. 도미노의 뒷면에는 0~9 사이의 수 (0,9 포함) 또는 A~I사이 (A,I 포함)의 문자가 써 있고, A~I의 문자가 의미하는 것은 -1부터 -9이다.
<출력값>
첫째 줄에 세준이가 얻을 수 있는 모든 점수의 합을 121547로 나눈 나머지를 출력한다.

<문제 1557>
어떤수 N이 1이 아닌 제곱수로 나누어지지 않을 때, 이 수를 제곱ㄴㄴ수라고 한다. 제곱수는 4, 9, 16, 25와 같은 것이고, 제곱ㄴㄴ수는 1, 2, 3, 5, 6, 7, 10, 11, 13, ...과 같은 수이다.
K가 주어졌을 때, K번째 제곱ㄴㄴ수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 K가 주어진다.
<출력값>
첫째 줄에 K번째 제곱ㄴㄴ수를 출력한다.

<문제 1558>
폴리라인 (Polyline)은 컴퓨터 그래픽에서 선분을 이어서 만든 도형이다. 폴리라인은 연속된 선분으로 이루어져 있는데, 폴리라인에서 모든 선분의 시작점은 바로 전 선분의 끝점과 같다.
만약, 두 개의 폴리라인이 같은 점을 공유한다면, 두 폴리라인은 같은 그림에 속한다고 말할 수 있다.
폴리라인의 정보가 주어졌을 때, 그림의 개수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 폴리라인의 개수 T가 주어진다. T개 폴리라인의 정보는 첫째 줄에 이 폴리라인을 구성하는 점의 좌표의 N이 주어지고 둘째 줄부터 좌표가 주어진다. N=1일 수도 있다. T는 1,000보다 작고, N은 500보다 작다.
<출력값>
첫째 줄에 그림의 개수를 출력한다.

<문제 1559>
MxN개의 칸으로 구성된 미로가 있다. 각 칸에는 4개의 인접한 곳으로 이동할 수 있는 문이 있다. 이 4개의 문은 한 번에 한 개만 열리며, A에서 B로 가는 문과 B에서 A로 가는 문은 별개로 작동한다. 문들의 초기 상태는 입력에서 주어지며, 1분에 한 번 시계 방향으로 90도씩 바뀐다.
미로에는 총 K개의 보물상자가 있다. 당신은 1분에 문이 열린 방향으로 한 칸 움직이거나 원하는 방향의 문이 열릴 때까지 기다릴 수 있다.
미로에서 당신이 시작하게 될 위치는 (1, 1)이며, 목표는 모든 보물 상자를 가지고 (M, N)에 도달하는 것이다. 물론 보물 상자를 전부 가지고 있지 않더라도 (M, N)에는 갈 수 있지만 미로를 탈출하기 위해서는 모든 보물 상자를 모아서 가야 한다.
이때 미로를 탈출하기 위한 최소 시간을 구하시오.
<입력값>
입력 데이터는 여러 개의 테스트 케이스로 구성되어 있다. 각각의 입력은 두 정수 M, N(2 ≤ M, N ≤ 100)으로 시작하며, 다음 M개의 줄에는 초기에 문이 열린 방향을 나타내는 N, E, S, W중 하나의 문자가 각 줄에 N개씩 주어진다.
예를 들어 칸의 위치가 (r, c)라면, N, E, S, W는 각각 (r - 1, c), (r, c + 1), (r + 1, c), (r, c - 1)로 가는 문이 열려 있다는 것을 의미한다.
이후 보물 상자의 개수인 K(1 ≤ K ≤ 8)가 주어지고, 그 다음 K개의 줄에 각각의 보물상자의 위치를 나타내는 R, C가 주어진다. 한 칸에 여러 개의 보물 상자가 있는 경우는 없으며 보물 상자의 위치가 (1, 1)이거나 (M, N)인 경우도 없다.
마지막 줄의 "0 0"은 입력의 끝을 알린다.
<출력값>
각각의 테스트 케이스에 대해 미로를 탈출하기 위한 최소 시간을 출력한다.

<문제 1560>
인간과 컴퓨터의 체스대결은 1997년부터 시작되었다.
지난 1997년 러시아의 체스마스터 게리 카스파로프(Garry Kasparov)가 IBM 수퍼컴퓨터 '딥블루(Deep Blue)'와의 대결에서 패한 후, 2002년 10월에는 세계 체스챔피언인 러시아의 블라디미르 크람니크(Vladimir Kramnik)가 독일의 수퍼컴퓨터 '딥프리츠(Deep Fritz)'와 두뇌대결을 벌여 무승부를 기록했다.
2003년 1월~2월 슈퍼컴퓨터와의 체스게임에 재도전한 게리 카스파로프(Garry Kasparov)는 이스라엘에서 만든 슈퍼컴퓨터 '딥주니어(Deep Junior)'와 6차례 경기를 펼쳐 '3대3'으로 무승부를 이루었다.
2003년 11월에도 카스파로프는 가상현실 프로그램개발 전문업체인 X3D 테크놀로지社가 개발한 컴퓨터 체스프로그램 'X3D 프리츠'와 체스경기를 펼쳤으나, 1승2무1패의 무승부로 끝났다.
하지만, 2008년 6월 모든 체스프로그램을 이기고 등장한 사람이 한국에 있었으니, 그 이름은 바로 "오세준" 이였다. 오세준은 컴퓨터와 사람을 모두 이겼으므로 더 이상 대적할 상대가 없었다.
세준이는 따분해진 나머지 갑자기 체스 판의 크기를 마음대로 조정하는 체스 판을 만들었다.
세준이는 N*N 크기의 체스 판에 과연 몇 개의 비숍 (BISHOP)을 세울 수 있는지 궁금해 졌다.
비숍 (BISHOP)은 자신의 위치에서 대각선 왼쪽 위, 대각선 왼쪽 아래, 대각선 오른쪽 위, 대각선 오른쪽 아래 () 이렇게 4방향으로 움직일 수 있는 말이다.
체스판의 크기가 주어졌을 때, 서로 잡아먹지 않게 최대로 비숍을 몇 개를 놓을 수 있는지 구하는 프로그램을 작성하시오.
<입력값>
체스판의 크기 N이 주어진다. N은 10진수로 70자리 이하인 자연수이다.
<출력값>
최대로 비숍을 몇 개 놓을 수 있는지 출력한다.

<문제 1561>
N명의 아이들이 한 줄로 줄을 서서 놀이공원에서 1인승 놀이기구를 기다리고 있다. 이 놀이공원에는 총 M종류의 1인승 놀이기구가 있으며, 1번부터 M번까지 번호가 매겨져 있다.
모든 놀이기구는 각각 운행 시간이 정해져 있어서, 운행 시간이 지나면 탑승하고 있던 아이는 내리게 된다. 놀이 기구가 비어 있으면 현재 줄에서 가장 앞에 서 있는 아이가 빈 놀이기구에 탑승한다. 만일 여러 개의 놀이기구가 동시에 비어 있으면, 더 작은 번호가 적혀 있는 놀이기구를 먼저 탑승한다고 한다.
놀이기구가 모두 비어 있는 상태에서 첫 번째 아이가 놀이기구에 탑승한다고 할 때, 줄의 마지막 아이가 타게 되는 놀이기구의 번호를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N(1 ≤ N ≤ 2,000,000,000)과 M(1 ≤ M ≤ 10,000)이 빈칸을 사이에 두고 주어진다. 둘째 줄에는 각 놀이기구의 운행 시간을 나타내는 M개의 자연수가 순서대로 주어진다. 운행 시간은 1 이상 30 이하의 자연수이며, 단위는 분이다.
<출력값>
첫째 줄에 마지막 아이가 타게 되는 놀이기구의 번호를 출력한다.

<문제 1562>
45656이란 수를 보자.
이 수는 인접한 모든 자리수의 차이가 1이 난다. 이런 수를 계단 수라고 한다.
그럼, 오늘도 역시 세준이는 0부터 9까지 모든 한 자리수가 자리수로 등장하면서, 수의 길이가 N인 계단 수가 몇 개 있는지 궁금해졌다.
N이 주어질 때, 길이가 N이면서 0에서 9가 모두 등장하는 계단 수가 총 몇 개 있는 지 구하는 프로그램을 작성하시오. (0으로 시작하는 수는 없다.)
<입력값>
첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다.

<문제 1563>
백준중학교에서는 학기가 끝날 무렵에 출결사항을 보고 개근상을 줄 것인지 말 것인지 결정한다. 이 학교는 이상해서 학생들이 학교를 너무 자주 빠지기 때문에, 개근상을 주는 조건이 조금 독특하다.
출결사항이 기록되는 출결은 출석, 지각, 결석이다.
개근상을 받을 수 없는 사람은 지각을 두 번 이상 했거나, 결석을 세 번 연속으로 한 사람이다.
한 학기가 4일이고, O를 출석, L을 지각, A를 결석이라고 했을 때, 개근상을 받을 수 있는 출결정보는

OOOO OOOA OOOL OOAO OOAA OOAL OOLO OOLA OAOO OAOA 
OAOL OAAO OAAL OALO OALA OLOO OLOA OLAO OLAA AOOO 
AOOA AOOL AOAO AOAA AOAL AOLO AOLA AAOO AAOA AAOL
AALO AALA ALOO ALOA ALAO ALAA LOOO LOOA LOAO LOAA 
LAOO LAOA LAAO
총 43가지이다.
한 학기는 N일이다. N이 주어졌을 때, 개근상을 받을 수 있는 출결정보의 개수를 세는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N이 주어진다. N은 1,000보다 작거나 같다.
<출력값>
첫째 줄에 정답을 1,000,000으로 나눈 나머지를 출력한다.

<문제 1564>
팩토리얼5란, N!의 0이 아닌 뒤 5자리를 말한다.
N이 주어졌을 때, 팩토리얼5를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 정수 N이 주어진다. N은 1,000,000보다 작거나 같다. 또, 9보다 크거나 같다.
<출력값>
첫째 줄에 N의 팩토리얼5를 계산한다.

<문제 1565>
배열 D와, 배열 M이 주어졌을 때, D에 있는 모든 수의 배수이며, M에 있는 모든 수의 약수인 수의 개수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 D의 크기와 M의 크기가 주어진다. 둘째 줄에 배열 D, 셋째 줄에 배열 M이 주어진다. D와 M의 크기는 50보다 작거나 같고, 그 속에 들어있는 수는 모두 10^9보다 작거나 같다.
<출력값>
첫째 줄에 개수를 출력한다.

<문제 1566>
정수로 이루어진 2차원 배열이 P배열이 되려면, 각각의 열에 있는 원소의 합과, 행에 있는 원소의 합이 모두 0보다 커야 한다.
예를 들어,

 2  1 -1
-1  2  2
는 P배열이지만,

 1  1 -1
-1  2  2
는 P배열이 아니다.
세준이는 어떤 행이나 열을 선택한 다음에, 그 행이나 열의 모든 원소의 부호를 바꿀 수 있다. (-1을 곱한다.) 이차원 배열이 주어졌을 때, 이 배열을 P배열로 만들기 위해서 필요한 선택의 회수의 최솟값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 배열의 행의 개수 N과 열의 개수 M이 주어진다. 둘째 줄부터 N개의 줄에 M개의 수가 주어진다. N과 M은 18보다 작거나 같고, 이차원 배열에 있는 수의 절댓값은 35보다 작거나 같다.
<출력값>
첫째 줄에 정답을 출력한다. 만약 불가능 할 때에는 -1을 출력한다.

<문제 1567>
어떤 나라는 몇 개의 도시로 이루어져 있다. 몇몇 쌍의 도시는 서로 단방향 도로로 연결되어 있다. (단방향 도로가 A->B, 그리고 B->A 이렇게 총 2가지 존재할 수도 있다.)
세준이는 N개의 도시중 하나를 골라서 출발한다. 세준이가 도로 하나를 지날 때, 하루가 걸린다. 만약 세준이가 어떤 도시에서 시작해서, 정학하게 x개의 도로를 거친 후 시작한 도시로 돌아온다면, 세준이는 길이가 x인 방학친구가 있는 것이다.
방학 문자열은 0과 1로 이루어진 무한한 문자열이다. i번째 문자는(1번부터 시작) i인 방학친구가 있으면 1, 없으면 0이다.

위과 같은 나라가 주어졌을 때, 방학 문자열은 00110111111111.........이다. 0->1->3->0은 길이가 3이고, 0->1->2->3->0은 길이가 4이고, 0->1->3->0->1->3->0은 길이가 6이다. 그런데, 이 무한한 문자열에 주기가 보인다면, 주기를 괄호로 묶어서 간단하게 표현할 수 있다. 따라서, 위의 문자열은 00110(1) 또는, 00110111(11)과 같이 나타낼 수 있지만, 가장 길이가 짧은 것을 선택하기로 한다.
도시의 정보가 주어졌을 때, 방학문자열의 길이가 가장 짧은 것을 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 도시의 개수 N이 주어진다. 둘째 줄부터 N개의 줄에 도로가 있으면 1, 없으면 0이 주어진다. (N ≤ 30)
<출력값>
첫째 줄에 정답을 출력한다.

<문제 1568>
N마리의 새가 나무에 앉아있고, 자연수를 배우기 원한다. 새들은 1부터 모든 자연수를 오름차순으로 노래한다. 어떤 숫자 K를 노래할 때, K마리의 새가 나무에서 하늘을 향해 날아간다. 만약, 현재 나무에 앉아있는 새의 수가 지금 불러야 하는 수 보다 작을 때는, 1부터 게임을 다시 시작한다.
나무에 앉아 있는 새의 수 N이 주어질 때, 하나의 수를 노래하는데 1초가 걸린다고 하면, 모든 새가 날아가기까지 총 몇 초가 걸리는지 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 새의 수 N이 주어진다. 이 값은 109보다 작거나 같다.
<출력값>
첫째 줄에 정답을 출력한다.

<문제 1569>
정사각형으로 가려지는 점이란, 어떤 점이 그 정사각형의 한 변 위에 놓여져 있을 때, 정사각형으로 가려진다고 한다.
점이 N개가 주어진다. N개의 점 모두를 가릴 수 있는 정사각형을 구하는 프로그램을 작성하시오. 정사각형의 변은 x축과 y축에 평행해야 한다.
<입력값>
첫째 줄에 N이 주어진다. 둘째 줄부터 N개의 줄에 점이 X좌표 Y좌표 순으로 주어지고, 이 값의 절댓값은 1000보다 작거나 같다. 모든 좌표는 정수이다. 같은 점이 여러 번 주어지는 경우는 없다.
<출력값>
모든 점을 가릴 수 있는 정사각형이 존재할 경우, 그 변의 길이를 첫째 줄에 출력한다. 정사각형으로 가릴 수 없는 경우에는 -1을 출력한다.

<문제 1570>
오세준은 외계 로봇이다. 오세준은 지구를 정복하기 위해서 10만년 전부터 지구에 있었고, 2008년 6월 25일까지, 조금씩 자기의 원래 모습으로 변해가고 있었다. 이정문은 이미 이 사실을 알고 오세준을 잡을 단 하나의 무기인 지뢰를 설치해 놨다. 지뢰는 준비되었다. 하지만, 문제는 오세준이 지뢰를 밟게하는 것이다. 운이 좋게도, 김형택의 도움을 받아서 이정문은 오세준의 행동 시스템을 해킹했다. 그리고, 이정문은 자기가 원하는 대로 오세준을 조정할 수 있게 되었다.
땅은 무한한 칸이 있는 좌표이다. 오세준은 현재 (SejunX, SejunY)에 있다. 그리고, 지뢰는 현재 (mineX, mineY)에 있다.
오세준의 프로그램은 간단하다. N개의 명령으로 이루어져 있다. 명령에는 2가지가 있는데

U : 오세준이 (x,y)에 있으면, (x, y+1)로 움직인다.
R : 오세준이 (x,y)에 있으면, (x+1, y)로 움직이다.

명령은 처음부터 순서대로 진행되고, 마지막 명령을 실행하고 나면, 처음 명령부터 다시 실행한다.
오세준이 지뢰를 밟으면, 오세준의 프로그램은 즉시 중지된다. 오세준이 지뢰를 밟게되는 N개의 명령을 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 명령의 길이 N과, 오세준의 위치 SejunX, SejunY, 지뢰의 위치 mineX, mineY가 주어진다. N은 50보다 작거나 같은 자연수이고, 나머지 좌표는 1000000000보다 작거나 같은 음이 아닌 정수이다.
<출력값>
첫째 줄에 오세준의 N개 명령을 출력한다. 만약 답이 여러 가지일 때는, 사전순으로 가장 앞서는 것을 출력하고, 오세준이 지뢰를 밟을 수 없다면 -1을 출력한다.

<문제 1571>
오세준의 전광판은 한 번에 N개의 문자를 표시할 수 있다. 이 전광판은 약간 독특해서 하나의 문자를 표시할 때, 원형 모양을 사용한다.
설명하기 어려워서 예를 들어 설명한다.
만약 첫 번째 원형 바퀴에 “XYZ"라고 쓰여 있고, 두 번째 바퀴에 "DEF", 세 번째 바퀴에 "OPRS"라고 쓰여 있으면,
가장 처음에 XDO가 보인다. 그 다음 1초가 진행될 때, 바퀴가 다음 문자가 보일 만큼 돌아간다. 따라서 YES란 문자가 보일 때 까지 걸리는 시간은 다음과 같다.
0 : XDO
1 : YEP
2 : ZFR
3 : XDS
4 : YEO
5 : ZFP
6 : XDR
7 : YES
따라서 7초만에 YES를 볼 수 있다.
전광판의 크기와, 각 바퀴에 쓰여 있는 문자, 그리고 오세준이 보고싶은 문자가 주어질 때, 그 문자가 뜨기까지 걸리는 시간을 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 전광판의 크기 N이 주어진다. 이 값은 50보다 작거나 같은 자연수이고, 둘째 줄부터 N개의 줄에는 각 바퀴에 쓰여 있는 글자가 주어진다. 이 글자는 대문자로만 이루어져 있고, 크기는 2보다 크고 26보다 작거나 같다. 마지막 줄에는 오세준이 보고싶어하는 문자열이 주어진다. 이 문자열의 크기는 N이고, 대문자로만 이루어져 있고, 등장하는 알파벳은 중복되지 않는다.
<출력값>
둘째 줄에 정답을 출력한다. 이 값은 9223372036854775807보다 작거나 같고, 불가능할 때는 -1을 출력한다.

<문제 1572>
중앙값이란, 수열을 정렬했고, 그 크기가 N일 때, 1부터 시작해서 (N+1)/2번째 있는 원소가 그 수열의 중앙값이다. 예를 들어, {1, 2, 6, 5, 4, 3}에서는 3이고, {11, 13, 12, 15, 14}에서는 13이다.
오세준은 1초에 온도를 하나씩 재는 온도계를 만들었다. 이 온도계에는 작은 디스플레이 창이 하나 있는데, 이 창에는 지금부터 최근 K초 까지 온도의 중앙값을 표시해 준다. (온도를 재기시작한지 K초부터 표시한다. 그 전에는 아무것도 출력되지 않는다.)
오세준은 온도를 N초동안 쟀다. 그 시간 동안 온도계의 디스플레이 창에 뜨는 숫자의 합을 구하는 프로그램을 작성하시오.
다른 말로 하면, 길이가 N인 수열이 주어진다. 이 수열은 N-K+1 개의 길이가 K인 연속된 부분 수열이 존재한다. 이 부분 수열의 중앙값의 합을 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N과 K가 주어진다. N은 250,000보다 작거나 같은 자연수이고, K는 5,000보다 작거나 같은 자연수이다. N은 항상 K보다 크거나 같다. 둘째 줄부터 N개의 수가 한 줄에 하나씩 주어진다. 입력으로 주어지는 수는 65536보다 작거나 같은 자연수 또는 0이다.
<출력값>
첫째 줄에 정답을 출력한다. 정답은 263-1보다 작거나 같다.

<문제 1573>
이진 트리는 비어있거나 루트 노드와 두 개의 이진 트리 (왼쪽 서브트리, 오른쪽 서브트리)로 구성되어 있다. 이 문제에 나오는 이진 트리의 모든 노드는 알파벳 소문자만을 가지고 있다. 만약, 이진 트리가 다음과 같은 조건을 만족한다면, 그리고 그때에만 이진 검색 트리라고 한다.
1. 노드의 왼쪽 서브트리에 있는 모든 문자는 노드에 있는 알파벳보다 사전순으로 앞이다.
  2. 노드의 오른쪽 서브트리에 있는 모든 문자는 노드에 있는 알파벳보다 사전순으로 뒤다.
다음은 4개의 노드를 가진 이진 검색 트리이다.

    c         c      a
   / \       / \      \
  b   d     a   d      c
 /           \        / \
a             b      b   d
위와 같은 이진 검색 트리를 프리오더로 트리순회 하면, cbad, cabd, acbd와 같은 문자열을 얻을 수 있다.
세준이는 N개의 노드를 가진 모든 이진 검색 트리를 만들었다. (등장하는 알파벳은 a부터 차례대로 N개) 그리고 나서, 모든 트리를 프리오더 순회한 뒤에 사전순으로 정렬했다.
N과 index가 주어질 때, index번째 N개의 노드를 가진 이진 검색 트리의 프리오더 결과를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 트리의 크기 N과 index가 주어진다. N은 19보다 작거나 같다. index는 2,000,000,000보다 작거나 같다. N=19일 때, 이진 검색 트리의 개수는 2,000,000,000보다 작다.
<출력값>
첫째 줄에 정답을 출력한다. 만약 그런 트리가 없을 때는 -1을 출력한다.

<문제 1574>
세준이는 N개의 빈 칸이 있는 R×C크기의 체스판을 가지고 있다. 빈 칸에는 룩을 놓을 수 없지만, 공격을 할 수 있는지 없는지에는 영향을 미치지 않는다. 즉, 빈 칸을 사이에 두고도 공격을 할 수 있다.
R×C크기의 체스판에 최대 몇 개의 룩을 서로 공격하지 않게 놓을 수 있는지 구하는 프로그램을 작성하시오. 룩은 자기와 같은 행 또는 열에 다른 룩이 있으면 잡을 수 있다.
<입력값>
첫째 줄에 체스판의 크기 R과 C가 주어지고, 빈 칸의 개수 N이 주어진다. 둘째 줄부터 N개의 줄에 빈 칸의 좌표가 주어진다. 좌표는 (행, 열)의 형태로 주어지고, 가장 윗 행은 1번 행이고, 가장 왼쪽 열은 1번 열이다. R과 C는 300보다 작거나 같은 자연수이고, N은 100보다 작거나 같은 음이 아닌 정수이다.
<출력값>
첫째 줄에 최대 몇 개의 룩을 놓을 수 있는지 출력한다.

<문제 1575>
세준이는 형택 대학교의 학생 상담자이다. 형택 대학교의 졸업 조건은 복잡하다. 졸업 조건은 학생마다 다르다. 졸업 조건은 다음과 같은 형태를 가지고 있다. 1, 2, 3, 4중 2개의 수업을 들어라. 학생들은 이러한 졸업 조건을 N개 가지고 있다. N개를 모든 충족시켜야 졸업할 수 있다.
그런데, 갑자기 형택 대학교의 졸업 조건이 바뀌었다. 어떤 졸업 조건을 충족시킬 때 사용한 수업은, 다른 졸업 조건을 충족시킬 수 없는 것이다.예를 들어서, “1, 2, 3중 2개의 수업을 들어라“, ”3, 4, 5중 2개의 수업을 들어라“가 있을 때, 첫 번째 조건을 충족시키는 수업이 1, 3이면, 두 번째 조건을 충족시킬 때, 3은 이용되어서 안되는 것이다.
따라서, 졸업이 다가워져서 혼란스러워진 학생들은 세준이에게 자주 찾아오기 시작했다. 세준이는 학생들이 자기를 찾아오지 않고서도 몇 개의 수업을 들어야 되는지 알 수 있게 하기 위해서 프로그램을 하나 작성했다.
정문이가 현재 들은 수업과, 졸업 조건이 주어질 때, 그 학생이 졸업하기 위해서 들어야하는 최소 수업의 개수와, 어떤 수업을 들어야 하는지 구하는 프로그램을 작성하시오.
수업은 숫자 하나로 표시되며, 1보다 크거나 같고, 100보다 작거나 같은 수 하나이다.
<입력값>
첫째 줄에 정문이가 들은 수업의 개수가 주어진다. 이 수는 0보다 크거나 같고, 100보다 작거나 같다. 둘째 줄에는 정문이가 들은 수업이 공백을 사이에 두고 주어진다. 만약 정문이가 들은 수업이 없을 때는, 이 줄은 빈 줄이다. 셋째 줄에는 정문이의 졸업 조건의 개수 N이 주어진다. 이 수는 1보다 크거나 같고 100보다 작거나 같다. 넷째 줄부터 N개의 줄에는 정문이의 졸업 조건이 한 줄에 하나씩 주어진다. 졸업 조건은 다음과 같은 형태로 주어진다. 첫 번째 숫자는 그 조건에 나타나는 수업의 개수 중 몇 개의 수업을 들어야 하는지가 주어진다. 두 번째 숫자는, 그 조건에 나타나는 수업의 개수이다. 세 번째 숫자부터는 수업의 번호가 주어진다. 예를 들어서, 1, 2, 3, 4중 2개의 수업을 들어라는 2 4 1 2 3 4와 같이 주어진다. 첫 번째 숫자와 두 번째 숫자는 100보다 작거나 같은 자연수이다. 또, 중복되는 졸업 조건은 없다.
<출력값>
첫째 줄에 정문이가 들어야 하는 수업의 개수를 출력한다. 만약 수업의 개수가 여러 개일 경우에는 수업의 개수가 가장 작은 것을 출력한다. 둘째 줄에는 정문이가 어떤 수업을 들어야 하는지 공백을 사이에 두고 출력한다. 가장 적은 수의 수업의 개수가 여러 개일 경우에는 이 수열이 사전 순으로 앞서는 것을 출력한다. 1, 2, 3, 4는 1, 2, 3, 5보다 사전 순으로 앞선다. 만약 어떻게 해도 졸업을 할 수 없을 때는, 첫째 줄에 -1을 출력한다. 또, 수업을 여러 번 들을 수는 없다.

<문제 1576>
DNA 문자열이란 A, C, T, G로만 이루어진 문자열이다. 두 개의 길이가 같은 DNA 문자열이 있을 때, 세준이는 DNA 점수를 구하려고 한다. DNA 점수란 정문이가 만든 4*4 점수판을 이용해서 구한다. 정문이는 점수판의 이름을 Score라고 했다.
DNA 점수는 두 문자열에서 같은 위치에 있는 문자를 뽑아서, 점수판을 이용해서 구한뒤 합하면 된다. 예를 들어서, 두 문자열이 ACTA와 GATC라면, 두 문자열의 DNA 점수는 Score(A, G) + Score(C, A) + Score(T, T) + Score(A, C) 이다.
하지만 아직 정문이는 점수판을 다 만들지 않았다. 점수판은 다음과 같은 규칙으로 만들어야 한다.

점수판의 모든 원소는 -10보다 크거나 같고, 10보다 작거나 같은 정수이어야 한다.
점수판은 대각선을 기준으로 대칭형태여야 한다. (Score(X, Y) = Score(Y, X))
점수판의 대각선 원소는 양수이어야 한다. (Score(X, X) > 0)
점수판에 있는 16개의 모든 원소의 합은 0이다.

길이가 같은 N개의 문자열이 주어졌을 때, 정문이는 DNA점수의 평균이 최대가 되게 점수판을 만들고 싶다. 예를 들어, N개의 문자열이 주어지면, (N*(N-1))/2개의 쌍의 DNA 점수의 평균을 최대로 해야 한다.
길이가 같은 N개의 문자열이 주어졌을 때, DNA 점수의 평균의 최댓값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 DNA 문자열의 개수 N이 주어진다. N은 100보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 문자열이 주어진다. 모든 문자열의 길이는 같으며, 길이의 최댓값은 100이다.
<출력값>
첫째 줄에 정답을 출력한다. 절대/상대 오차는 10-2까지 허용한다.

<문제 1577>
세준이가 살고 있는 도시는 신기하게 생겼다. 이 도시는 격자형태로 생겼고, 직사각형이다. 도시의 가로 크기는 N이고, 세로 크기는 M이다. 또, 세준이의 집은 (0, 0)에 있고, 세준이의 학교는 (N, M)에 있다.
따라서, 아래 그림과 같이 생겼다.

세준이는 집에서 학교로 가는 길의 경우의 수가 총 몇 개가 있는지 궁금해지기 시작했다.
세준이는 항상 최단거리로만 가기 때문에, 항상 도로를 정확하게 N + M개 거친다. 하지만, 최근 들어 이 도시의 도로가 부실공사 의혹으로 공사중인 곳이 있다. 도로가 공사 중일 때는, 이 도로를 지날 수 없다.
(0, 0)에서 (N, M)까지 가는 서로 다른 경로의 경우의 수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 도로의 가로 크기 N과 세로 크기 M이 주어진다. N과 M은 100보다 작거나 같은 자연수이고, 둘째 줄에는 공사중인 도로의 개수 K가 주어진다. K는 0보다 크거나 같고, 100보다 작거나 같은 자연수이다. 셋째 줄부터 K개 줄에는 공사중인 도로의 정보가 a b c d와 같이 주어진다. a와 c는 0보다 크거나 같고, N보다 작거나 같은 자연수이고, b와 d는 0보다 크거나 같고, M보다 작거나 같은 자연수이다. 그리고, (a, b)와 (c, d)의 거리는 항상 1이다.
<출력값>
첫째 줄에 (0, 0)에서 (N, M)까지 가는 경우의 수를 출력한다. 이 값은 0보다 크거나 같고, 2^63-1보다 작거나 같은 자연수이다.

<문제 1578>
오세준은 세계 정복을 위해 전 세계에 있는 N개의 국가를 정복했다. 세준이는 N개의 국가에 있는 사람들이 서로 친하지 않음을 깨닫고 세계 정복을 위해서라면 모든 사람들을 서로 친하게 만들어야 한다는 것을 알았다.
세준이는 전세계의 사람들을 그룹으로 나누려고 한다. 그룹을 나누는 방법에는 다음과 같은 조건이 있는데, 첫 번째는 그룹에 들어있는 사람의 수는 정확히 K명이어야 한다. 또, 각 그룹에 있는 사람들은 모두 다른 나라 소속이어야 한다는 것이다.
세준이는 N개의 국가에 살고 있는 사람의 수가 주어졌을 때, 이 사람들을 최대 몇 개의 그룹으로 나눌 수 있는지 궁금해졌다.
예를 들어, 중국에 살고 있는 사람이 4명, 캐나다에 살고 있는 사람이 4명, 폴란드, 스웨덴, 미국에 살고 있는 사람이 모두 4명이고, K가 4라면, 세준이는 최대 5개의 그룹으로 나눌 수 있다.
캐나다, 중국, 폴란드, 스웨덴
캐나다, 중국, 폴란드, 미국
캐나다, 중국, 스웨덴, 미국
캐나다, 폴란드, 스웨덴, 미국
중국, 폴란드, 스웨덴, 미국
만약 어느 그룹에도 들어가지 않는 사람이 있다면, 세준이는 이 사람들을 과감히 무시한다.
<입력값>
첫째 줄에 국가의 수 N과 K가 주어진다. N은 K보다 크거나 같고, 100보다 작거나 같은 자연수이고, K는 20보다 작거나 같은 자연수이다. 둘째 줄에는 각 나라에 살고 있는 사람의 수가 공백으로 구분해서 차례대로 주어진다. 이 수는 1000000000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 정답을 출력한다. 정답은 2^63-1보다 작거나 같다.

<문제 1579>
세준이가 좋아하는 게임의 최신 버전이 나왔다. 이 게임의 각 레벨에서 세준이는 보물을 찾아서 점수를 올려야 한다. 간단하게 보물이 있는 위치로 이동하게 되면, 그 곳에 있는 보물을 자동으로 획득하게 된다.
세준이는 게임을 쉽게 하고, 점수를 많이 얻기 위해 이미 현재 레벨의 지도를 가지고 있다. 이 지도는 세로 크기가 N이고, 가로 크기가 M이다. 또, 한 칸에 하나씩 숫자를 나타내고 있다. 여기서 나타내는 수는 그 위치에서 보물의 양이다. 또, 항상 가장 왼쪽 위의 칸에 있는 보물의 양은 0이다.
세준이는 게임을 가장 왼쪽 위의 칸에서 시작한다. 이 게임은 총 세 개의 스테이지로 구성되는데, 다음과 같은 규칙을 따라서 지나야 한다.
1) 첫 번째 스테이지에선 아래와 오른쪽으로만 이동할 수 있다. 이때, 목적지는 반드시 가장 오른쪽 아래이어야 한다.
2) 두 번째 스테이지에서는 가장 왼쪽 위로 올라가야 한다. 이때는 위와 왼쪽으로만 이동할 수 있다.
3) 세 번째 스테이지에서는 첫 번째 스테이지와 마찬가지로 가장 아래와 오른쪽으로만 이동할 수 있고, 목적지는 반드시 가장 오른쪽 아래이어야 한다.
어떤 칸을 한 번 지나갔으면, 그 때 보물은 다 가지고 와야 한다. 만약, 그 칸을 두 번째 지나갔을 때는, 보물을 얻지 못한다.
<입력값>
첫째 줄에 지도의 세로 크기 N과 가로 크기 M이 주어진다. 둘째 줄부터 N개의 줄에 M개의 수가 주어진다. N과 M은 50보다 작거나 같은 자연수이고, 각 칸에 주어지는 수는 1,000보다 작거나 같은 수이다.
<출력값>
첫째 줄에 정답을 출력한다. 정답은 2147483647보다 작거나 같다.

<문제 1580>
빈 공간, 벽, 그리고 두 명의 플레이어 A와 B의 시작지점이 주어졌을 때, A와 B가 서로의 위치를 바꾸는데 드는 턴의 최솟값을 구하는 프로그램을 작성하시오.
한 턴에 하나 또는 두 명의 플레이어는 움직일 수 있다. 한 번 움직인다는 것은 현재 위치에서 위, 왼쪽, 오른쪽, 아래, 4가지 대각선 중 하나로 이동하는 것이다. 하지만, 벽으로 이동하거나, 게임 판을 벗어나게 이동할 수는 없다. 그리고 각 턴의 마지막에 두 플레이어는 같은 곳에 있으면 안 된다. 한 턴에 두 플레이어가 서로 교차하는 경로를 가지는 것은 안 된다. 경로를 서로 교차하는 것이라는 것은 한 턴에 서로의 위치를 바꾸는 것을 의미한다.
예를 들어, A가 게임 판의 가장 왼쪽 위에 있고, B가 바로 오른쪽에 있다고 해보자. 만약, B가 왼쪽으로 움직인다면, A는 오른쪽으로 움직일 수 없다. 이때가 경로가 교차하는 것이다. 하지만, B가 왼쪽을 제외한 다른 방향으로 이동한다면, A는 오른쪽으로 이동할 수 있다.
A가 (0, 0)에 있고, B가 (0, 1)에 있을 때, A가 오른쪽 아래방향 대각선으로 움직이고, B가 왼쪽 아래방향 대각선으로 움직일 때, (0.5, 0.5)에서 만나기는 하지만, 이것은 경로가 교차하는 것이 아니다.
<입력값>
첫째 줄에 게임 판의 세로 크기 N과 가로 크기 M이 주어진다. N과 M은 20보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 게임 판의 상태가 주어진다. 빈 공간은 ., 벽은 X, A의 위치는 A, B의 위치는 B와 같이 표시된다.
<출력값>
첫째 줄에 A와 B가 서로의 위치를 바꾸는데 드는 최소 턴을 출력한다. 만약 바꿀 수 없으면 -1을 출력한다.

<문제 1581>
한국이 낳은 세계적인 락스타 락동호는 2007년 2월 1일 역대 최대 규모의 콘서트를 열었으며, 2007년 2월 11일에 자신의 음악세계를 세상에 알리고, 2007년 3월 4일에는 자신의 작곡 비법을 세계에 공개했다. 하지만, 그 후 락동호는 음악을 접고 체스에 입문하게 되었고, 그 결과 2007년 3월 31일 Heroes원정대에서는 체스 부분으로 참가하게 된다. 그 후 절대로 음악을 하지 않을 것 같았지만, 모두의 예상을 깨고, 2007년 4월 21일 월드 노래자랑으로 신이 내린 가창력으로 우승한 뒤 자취를 감추었다.
하지만 2008년 7월 13일 드디어 락동호가 컴백한다.
락동호는 지난 몇 달간 자신의 신보에 자신의 음악적 능력을 모두 담았고, 이제 몇몇 곡 중 최고의 곡만을 앨범에 담으려고 한다.
락동호는 빠르게 시작해서 빠르게 끝나는 노래를 FF개 만들었고, 빠르게 시작해서 느리게 끝나는 노래를 FS개, 느리게 시작해서 빠르게 끝나는 노래를 SF개, 그리고 느리게 시작해서 느리게 끝나는 노래를 SS개 만들었다.
락동호는 위와 같은 노래 중 총 몇 개를 자신의 새로운 앨범에 넣어야 할지 결정해야 한다. 그리고 당연히 모든 노래는 두 번 이상 앨범에 등장할 수는 없다.
하지만, 락동호는 이제 세계적인 락스타가 아니다. 따라서, 음반사의 엄청난 제한을 지켜서 앨범에 곡을 수록해야 한다. 이번 앨범으로 다시 자신의 지위를 되찾으려고 하는 락동호이기 때문에, 어쩔 수 없이 이 제한을 지키기로 했다.

빠르게 시작하는 노래는 반드시 빠르게 끝나는 노래의 바로 다음에 와야 한다.
느리게 시작하는 노래는 반드시 느리게 끝나는 노래의 바로 다음에 와야 한다.
동호가 녹음한 노래 중 빠르게 시작하는 노래가 한 개라도 있다면, 앨범의 가장 첫 곡은 빠르게 시작하는 곡이어야 한다. 만약, 빠르게 시작하는 노래가 하나도 없다면, 이 제한은 무시해도 된다.

동호는 음반사가 제한한 제한을 지킬 것이다. 하지만, 자신의 수많은 팬들에게 자신이 아직 건재하다는 것을 알리기 위해 음반에 최대한 많은 곡을 넣으려고 한다.
FF, FS, SF, SS가 주어졌을 때, 동호가 음반사의 제한을 어기지 않고, 최대 몇 곡을 실을 수 있는지 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 FF FS SF SS가 순서대로 들어온다. 모든 수는 0보다 크거나 같고, 1,000보다 작거나 같은 수이고, 적어도 하나의 수는 0보다 크다.
<출력값>
첫째 줄에 정답을 출력한다.

<문제 1582>
아티스트 이동호는 세계적인 락스타 락동호의 동생이다. 아티스트 이동호는 그림을 N*M크기의 도화지에 그린다. 이동호는 까다롭기 때문에, 도화지를 1*1크기의 작은 칸으로 쪼개서 그림을 그린다. 동호는 미리 1*1크기의 칸으로 선을 그려놓았다.
동호는 흑백을 진정한 예술이라고 생각하기 때문에, 검정색과 흰색으로만 색칠한다. 동호는 N*M개의 칸을 모두 어떤 색으로 칠할 것인지 미리 정해놓았고, 이제 동호는 자신이 개발한 신기한 붓으로 모든 칸을 칠하려고 한다.
동호의 붓은 오직 수평으로만 칠할 수 있고, 칠하는 범위는 그 수평선상에서만 무제한이다. 따라서 칠하는 범위는 정확하게 1*N(세로*가로)크기의 직사각형이 된다. 또, 정확하게 붓은 선에서 시작해서 선에서 끝난다. 이 붓은 한가지 제약이 더 있는데, 칠하기 전에는 색을 두 가지 색 중 마음대로 정할 수 있지만, 칠하는 도중에는 색을 바꿀 수 없다.
그림의 본질을 살리기 위해서 동호는 각 칸을 절대로 두 번 이상 칠하지 않는다.
예를 들어, 다음과 같은 그림은 6번 만에 칠할 수 있다.

BBBBBBBBBBBBBBB
WWWWWWWWWWWWWWW
WWWWWWWWWWWWWWW
WWWWWBBBBBWWWWW
1번째 줄, 2번째 줄, 3번째 줄을 모두 한 번 만에 칠하고, 4번째 줄은 총 3번 만에 칠할 수 있다.
동호의 그림을 시기하던 오세준은 동호의 붓을 총 K번 사용하면 부서지도록 조절해놨다.
동호는 오세준의 상식을 뛰어넘는 천재이기 때문에, 오세준이 K번 사용제한을 걸어놓은 것을 알았다. 동호는 어쩔 수 없이 현실과 타협을 하기로 결정하고, 자신이 이미 칠하려고 결정해 놓은 대로 칠하지만, 잘못 칠한 부분을 최소로 하려고 한다.
못 칠한 부분도 잘못 칠한 부분으로 친다.
그림의 크기와 K, 그리고, 동호가 원래 칠하려고 했던 그림의 정보가 주어질 때, 동호가 잘못 칠한 부분의 최솟값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 그림의 세로 크기 N과 가로 크기 M과 동호의 사용 제한 K가 주어진다. N과 M은 100보다 작거나 같은 자연수이고, K는 3000보다 작거나 같은 음이 아닌 정수이다. 둘째 줄부터 N개의 줄에 각 줄의 그림 정보가 M개 주어진다. 그림 정보는 문제에 나와있는 대로 B와 W만 주어진다.
<출력값>
첫째 줄에 정답을 출력한다.

<문제 1583>
아티스트 이동호는 자신의 그림을 창고에 보관해놓는다. 사실 아직 그림을 창고에 넣지는 않았고 앞으로 창고에 그림을 넣을 예정이다. 의 창고는 정사각형이고, 한 변이 200미터이다. 창고의 북쪽과 남쪽은 벽이다. 하지만, 서쪽과 동쪽은 전체가 미닫이문이다. 따라서, 다양한 크기의 트럭이 왔다 갔다 할 수 있다. 단, 모든 트럭의 너비는 정수미터이다. 안타깝게, 창고의 지붕은 기둥으로 지지되어져 있다. 또, 창고의 지붕은 너무 높아서 트럭이 지붕에 걸려서 못 들어가는 일은 없다.
아티스트 이동호는 최대한 큰 트럭, 즉, 너비가 큰 트럭을 창고를 통과시키려고 한다. 트럭은 창고 속에서는 방향을 바꾸지 않고, 서쪽에서 들어가서 동쪽으로 나온다.
창고에 있는 기둥의 위치가 입력으로 주어질 때, 창고를 통과할 수 있는 트럭의 크기의 최댓값을 출력하는 프로그램을 작성하시오. 또, 기둥은 무시할 수 있는 크기를 가졌다. 트럭이 기둥이나 벽을 통과하거나 스치는 것은 허용하지 않는다.
<입력값>
첫째 줄에 기둥의 개수 N이 주어진다. N은 300보다 작거나 같다. 둘째 줄부터 N개의 줄에 기둥의 위치가 주어진다. 기둥의 위치는 2개의 정수이고, 첫 번째 수는 동쪽 벽으로부터 떨어진 거리, 두 번째 수는 북쪽 벽으로부터 떨어진 거리이다. 이 수는 0보다 크거나 같고, 200보다 작거나 같다.
<출력값>
첫째 줄에 정답을 출력한다.

<문제 1584>
세준이는 위험한 지역에서 탈출하는 게임을 하고 있다. 이 게임에는 세준이가 들어갈 수 없는 죽음의 구역이 있고, 들어가서 한 번 움직일 때 마다 생명이 1씩 소모되는 위험한 구역이 있다. 그리고, 자유롭게 생명의 위협없이 움직일 수 있는 안전한 구역이 있다. (안전한 구역은 죽음의 구역과 위험한 구역을 제외한 나머지 이다.)
세준이는 (0, 0)에서 출발해서 (500, 500)으로 가야 한다. 세준이는 위, 아래, 오른쪽, 왼쪽으로만 이동할 수 있다. 현재 세준이는 (0, 0)에 있다. 그리고, 게임 판을 벗어날 수는 없다.
세준이가 (0, 0)에서 (500, 500)으로 갈 때 잃는 생명의 최솟값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 위험한 구역의 수 N이 주어진다. 다음 줄부터 N개의 줄에는 X1 Y1 X2 Y2와 같은 형식으로 위험한 구역의 정보가 주어진다. (X1, Y1)은 위험한 구역의 한 모서리이고, (X2, Y2)는 위험한 구역의 반대 모서리이다. 그 다음 줄에는 죽음의 구역의 수 M이 주어진다. 다음 줄부터 M개의 줄에는 죽음의 구역의 정보가 위험한 구역의 정보와 같이 주어진다. 주어지는 구역은 모두 겹칠 수 있으며, 서로 다른 구역이 겹칠 때는, 더 심한 구역이 해당된다. 예를 들어, 죽음+위험 = 죽음, 위험+안전 = 위험, 위험+위험 = 위험, 죽음+안전 = 죽음이다. 위험한 구역이 아무리 겹쳐도 생명은 1씩 감소된다. 생명의 감소는 구역에 들어갈 때만, 영향을 미친다. 예를 들어, (500, 500)이 위험한 구역일 때는, (500, 500)에 들어갈 때, 생명이 1 감소되지만, (0, 0)이 위험한 구역이더라도 생명은 감소되지 않는다. 마찬가지로, (0, 0)이 죽음의 구역이더라도 세준이는 이미 그 곳에 있으므로 세준이에게 영향을 미치지 않는다. N과 M은 100보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 정답을 출력한다. 만약 (500, 500)으로 갈 수 없을 때는 -1을 출력한다.

<문제 1585>
오세준이 살고 있는 도시에는 사람들의 과속문제가 심각하다. 따라서, 이 도시의 경찰서장은 동호도로에서 과속하는 사람들을 적발하라는 지시를 오세준에게 내렸다. 오세준은 두 개의 속도 측정계를 가져와서 동호도로의 시작과 끝에 설치했다. 그리고, 각각의 차가 동호도로에 들어가는 시간과, 나오는 시간을 기록했다. 오세준은 동호도로에서 과속하는 사람을 쉽게 골라낼 수 있었고, 그 사람들이 벌금을 내게 만들었다.
오세준은 다람쥐를 이용한 불법 도박에 연루된 사실이 밝혀지자 경찰서에서 잘리게 되었다. 오세준은 이대로 잘릴 수 없다고 생각해서, 들어가는 시간과 나오는 시간을 기록한 데이터를 모두 섞어버렸다. 따라서, 정문이는 어떤 들어가는 시간이 어떤 나오는 시간과 일치되는지 알아낼 수 없었다.
정문이는 올해 경찰서의 예산문제 때문에, 벌금을 어떻게든 징수해야 한다. 정문이는 들어간 시간의 정보와 나오는 시간의 정보를 가지고 있다. 그리고, 과속 기준 시간을 가지고 있다. 만약 어떤 차가, 과속 기준 시간보다 작은 시간으로 도로를 통과하면 과속으로 처리한다. (어떤 차가 아무리 빨리 달리더라도 항상 도로를 통과하는 데는 적어도 1초가 걸린다.)
정문이는 들어가는 시간이 나오는 시간보다 이르도록 두 시간을 연관시켜야 한다. 그리고 모든 시간은 단 한 번만 사용할 수 있다. 정문이가 모든 시간을 연관시키고 난 후에는, 각각의 차의 과속 여부를 판별해서 벌금을 징수할 수 있다.
만약 어떤 차가 과속을 했고, 도로를 통과하는데 걸린 시간이 S이고, 과속 기준 시간이 T이면, 정문이는 (T-S)의 제곱만큼 벌금을 징수할 수 있다. (최대 F원, F원을 넘으면 F원의 벌금이 징수된다.) 만약, 과속을 하지 않았으면, 벌금은 징수되지 않는다.
정문이가 징수할 수 있는 벌금의 최솟값과 최댓값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 차가 총 몇 대 있는지 주어진다. 이 값을 N이라고 하고, 50보다 작거나 같은 자연수이다. 둘째 줄에는 차가 동호도로에 들어가는 시간이 주어진다. 총 N개의 수가 공백 한 칸을 사이에 두고 주어진다. 셋째 줄에는 차가 동호도로에서 나오는 시간이 주어진다. 마찬가지로 N개의 수가 공백 한 칸을 사이에 두고 주어지며, 모든 시간은 0보다 크거나 같고, 1,000보다 작거나 같은 자연수이다. 넷째 줄에는 과속 기준 시간 T가 주어지고, 다섯째 줄에는 벌금의 최댓값 F가 주어진다. T는 1보다 크거나 같고 1,000보다 작거나 같은 자연수이고, F는 0보다 크거나 같고, 10,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 수 2개를 공백 한 칸으로 구분하여 출력한다. 첫 번째 수는 정문이가 징수할 수 있는 벌금의 최솟값이고, 두 번째 수는 최댓값이다. 만약, 주어진 입력으로 N개의 정보를 만들 수 없으면 -1을 출력한다.

<문제 1586>
농부 이동호는 직사각형 모양의 목장을 많이 가지고 있다. 만약 두 개의 목장이 경계를 공유한다면, 두 목장은 연결되어 있는 것이다. 단, 모서리만을 공유하는 목장은 연결되어 있는 것이 아니다. 슈퍼목장이란 연결되어 있는 목장의 최대 집합이다. 다른 말로 하면, 슈퍼 목장에 포함되어 있는 임의의 두 개의 목장은 한 목장에서 다른 목장으로 슈퍼목장을 떠나지 않는 경로가 있는 것이다. 만약, 어떤 목장이 다른 목장과 서로 연결되어 있지 않으면, 그 때는, 그 자체를 슈퍼목장으로 친다.
  123456789
  ---------
1|........6
2|11..22388
3|11..22388
4|11....3..
5|..77..344
6|99775....
7|..775....

위의 그림은 총 9개의 목장을 포함하고 있다. 그리고, 3개의 슈퍼목장이 있다. 1번 목장은 다른 목장과 경계를 공유하지 않는다. 따라서, 그 자체로 슈퍼목장이 된다. 2, 3, 4, 6, 8번 목장은 또 다른 슈퍼목장이고, 5, 7, 9번 목장은 또 다른 슈퍼목장이다. 1번 목장과 7번 목장은 모서리만을 공유하기 때문에 연결되어 있지 않은 것이다.
슈퍼목장의 불량도는 슈퍼목장을 포함하는 최소 직사각형의 면적에서 슈퍼목장의 면적을 빼면 된다. 예를 들어, 1번 목장만 가지고 있는 슈퍼목장의 불량도는 0이고, 2, 3, 4, 6, 8번 목장을 가지고 있는 슈퍼목장의 불량도는 10이고, 나머지를 가지고 있는 슈퍼목장은 불량도가 5이다.
이동호는 가지고 있는 목장 중에 하나의 목장을 팔려고 한다. 이동호는 다음 규칙 중을 이용해서 어떤 것을 팔 것인지 정하려고 한다.
1. 팔려고 하는 목장은 반드시 가장 높은 불량도를 가지는 슈퍼목장에 포함되어야 한다. 만약, 가장 높은 불량도를 가지는 슈퍼목장이 여러 개라면, 동호는 아무거나 선택한다.
2. 팔려고 하는 목장은 그것이 속해있는 슈퍼목장을 두 개 혹은 그 이상으로 분열시키면 안 된다.
3. 위의 두 조건을 만족시킨다면, 동호는 면적이 가장 작은 목장을 선택할 것이다. 만약 면적이 가장 작은 목장이 여러 개라면, 목장 번호가 작은 것을 선택한다.
목장 정보가 주어졌을 때, 동호가 팔 목장이 어떤 것인지 알아내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 목장의 개수 N이 주어진다. N은 5,000보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 목장의 정보가 1번 목장부터 차례대로 주어진다. 목장의 정보는 a b c d와 같이 생겼으며, a는 목장의 가장 왼쪽 좌표, b는 목장의 가장 오른쪽 좌표, c는 목장의 가장 위쪽 좌표, d는 목장의 가장 아래쪽 좌표이다. 좌표는 100,000보다 작거나 같은 음이 아닌 정수이고, a는 b보다 작고, c는 d보다 작다. 겹치는 목장은 없다.
<출력값>
첫째 줄에 동호가 팔 목장의 번호를 출력한다.

<문제 1587>
그래프의 최대 매칭 (Maximum Matching)은 두 간선이 같은 정점을 공유하지 않는 간선의 최대 집합을 말한다.
이분 그래프 (Bipartited Graph)는 그래프의 모든 정점을 두 집합 A와 B로 나눌 수 있는 그래프이다. 모든 간선의 끝 점은 A에 하나, B에 하나 있어야 한다. 이분 그래프에서 최대 매칭을 구하는 문제는 Maximum Flow 알고리즘을 이용해서 풀 수 있다.
거의 이분 그래프는 모든 정점이 집합 A = {A1, A2, …, AnA}와 B = {B1, B2, …, BnB}로 나누어져 있고, 모든 간선의 끝 점은 A에 하나, B에 하나있는 그래프이다. 여기까지는 이분 그래프와 동일한 모양을 갖는다. 거의 이분 그래프는 이분 그래프와 다르게 nA-1 + nB-1개의 간선을 추가로 가진다. 추가가 되는 간선은 Ai에서 Ai+1로 가는 간선 (1 ≤ i ≤ nA-1)과 Bi에서 Bi+1로 가는 간선 (1 ≤ i ≤ nB-1)이다. 따라서, 끝 점이 A에 하나, B에 하나 있는 간선의 개수를 M이라고 했을 때, 정점의 수가 nA + nB인 거의 이분 그래프의 간선의 개수는 M + nA-1 + nB-1이 된다.
거의 이분 그래프의 정점의 개수를 나타내는 nA, nB와 A와 B에 끝점을 두고 있는 간선 M개가 입력으로 주어졌을 때, 최대 매칭을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 nA와 nB가 주어진다. (1 ≤ nA, nB ≤ 1,000) 둘째 줄에는 A와 B에 끝점을 두고 있는 간선의 개수 M이 주어진다. (M ≤ 100) 셋째 줄부터 M개의 줄에는 간선의 정보가 i j와 같은 형식으로 주어지며, i는 집합 A의 정점 (Ai), j는 B의 정점 (Bj)를 의미한다.
<출력값>
첫째 줄에 입력으로 주어진 거의 이분 그래프의 최대 매칭의 수를 출력한다.

<문제 1588>
세준이는 가장 처음에 수 하나만 가지고 있는 수열을 가지고 있다. 매 초마다 1은 132로 바뀌고, 2는 211로 바뀌고, 3은 232로 바뀐다. 이런 변환은 매 초마다 동시에 일어난다. N초 후에 Left번째 수부터 Right번째 수 중에 1의 개수, 2의 개수, 3의 개수를 구하는 프로그램을 작성하시오. (Left와 Right를 셀 때, 가장 처음 수를 0번째 수, 그 다음 수를 1번째 수로 센다.)
예를 들어, 가장 처음 수가 1고, N=2이고, Left = 2, Right = 6이라고 하면, 2초 후에는 132232211이 될 것이다. 따라서 Left부터 Right까지 부분 수열은 22322이다. 따라서, 1의 개수는 0, 2의 개수는 4, 3의 개수는 1이다.
<입력값>
첫째 줄에 가장 처음에 들어있던 수가 주어진다. 이 수는 1, 2, 3중에 하나다. 둘째 줄에는 Left가 주어지고, 셋째 줄에는 Right, 넷째 줄에는 N이 주어진다. N은 0보다 크거나 같고, 20보다 작거나 같은 자연수이고, Right는 0보다 크거나 같으며, 3^N-1보다 작거나 같다. Left는 0보다 크거나 같고, Right보다 작거나 같고, Left와 Right는 모두 2147483647보다 작거나 같다.
<출력값>
첫째 줄에 1의 개수, 2의 개수, 3의 개수를 공백으로 구분하여 출력한다.

<문제 1589>
이차원 평면 상에 있는 점은 다음과 같은 규칙에 의해서 문자 하나와 대응시킬 수 있다.
(x, y)는 g[y%R][x%C]에 있는 문자와 대응된다. R은 배열의 행의 수이고, C는 열의 수이다. g는 2차원 배열이고, 크기는 R*C이다.
레이저를 (0, 0)에서 쏜다고 가정하자. 레이저가 x와 y가 모두 0보다 크거나 같은 정수 좌표를 지나갈 때, 지나간 순서대로 문자열을 만들 수 있다.
세준이는 단어를 N개 가지고 있다. 세준이는 각 단어를 부분문자열로 가지는 레이저 광선의 개수가 궁금해졌다. 단어를 부분문자열로 가진다는 말은 레이저가 지나간 순서대로 만든 길이가 무한인 문자열이 단어를 부분문자열로 포함하는 것이다.
또, 레이저는 적어도 하나의 (x, y) (0<=x<=k, 0<=y<=k, x와 y는 정수)를 지난다고 가정한다.
입력으로 주어지는 단어가 만들어지는 서로 다른 레이저 광선의 개수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 g배열의 크기 R과 C가 주어진다. R과 C는 35보다 작거나 같은 자연수이다. 둘째 줄부터 R개의 줄에는 g배열에 있는 문자가 주어진다. 문자는 알파벳 소문자이다. 다음 줄에는 단어의 개수 N이 주어진다. 다음 줄부터 N개의 줄에는 단어가 한 줄에 하나씩 주어진다. N은 25보다 작거나 같은 자연수이며, 단어는 알파벳 소문자로만 이루어져 있고, 길이는 최대 50이다. 마지막 줄에 K가 주어진다. K는 200보다 작거나 같은 자연수이다.
<출력값>
각 단어를 만드는 레이저 광선이 몇 개인지 입력 받은 순서대로 출력한다.

<문제 1590>
영식이는 민식이와 함게 고속버스를 타고 캠프를 가야 하지만, 민식이는 영식이를 깨우지 않고 혼자 버스를 타고 캠프에 가버렸다.
영식이는 혼자 고속버스터미널까지 가서 캠프에 오려고 한다. 터미널에는 캠프 장소까지 운행하는 N가지의 버스가 있다. 각각의 버스는 시작 시각, 간격, 대수의 정보를 가지고 있다. 예를 들어, 어떤 버스의 시작 시각이 특점 시점을 기준으로 10분 후이고, 간격은 10분이고, 대수가 5대이면, 이 버스는 10분, 20분, 30분, 40분, 50분에 한 대씩 출발한다.
영식이는 버스터미널에 T분에 도착했다. 영식이가 버스를 타려면 최소 몇 분을 더 기다려야 하는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 버스의 개수 N과 영식이가 버스터미널에 도착하는 시간 T가 주어진다. 둘째 줄부터 총 N개의 줄에 각 버스의 시작 시각, 간격, 대수가 공백을 사이에 두고 주어진다. 버스의 개수와 각 버스의 대수는 100,000보다 작거나 같은 자연수이며, T와 각 버스의 시작 시각과 간격은 1,000,000,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 영식이가 기다려야 하는 시간을 출력한다. 영식이가 도착하는 동시에 버스가 출발하면 정답은 0이다. 만약 버스가 없어서 캠프에 갈 수 없으면 -1을 출력한다. 정답은 231보다 작다.

<문제 1591>
길이 N인 수열의 길이 M짜리 부분수열은 모두 N-M+1개 있다. 이들이 모두 주어졌을 때, 원래의 수열을 복원하는 프로그램을 작성하시오.
부분수열은 물론 원래의 수열에서 연속된 것만 친다. 예를 들어 {1 2}는 {1 2 3}이나 {3 1 2}의 부분수열이지만, {1 3 2}의 부분수열은 아니다.
<입력값>
첫째 줄에 N(2 ≤ N ≤ 1,000), M(2 ≤ M ≤ N)이 주어진다. 다음 N-M+1개의 줄에는 각 수열이 주어진다. 각각의 수열을 이루는 수의 절댓값은 1,000,000,000을 넘지 않는다.
<출력값>
첫째 줄에 N개의 수를 빈 칸을 사이에 두고 순서대로 출력한다. 답이 여러 개인 경우는 아무 것이나 하나 출력하면 되며, 불가능한 경우는 입력으로 주어지지 않는다.

<문제 1592>
영식이와 친구들이 원형으로 모여서 시계방향으로 1부터 N까지 적혀있는 자리에 앉는다. 영식이와 친구들은 공 던지는 게임을 하기로 했다. 게임의 규칙은 다음과 같다.
일단 1번 자리에 앉은 사람이 공을 받는다. 그리고 나서 공을 다른 사람에게 던진다. 다시 공을 받은 사람은 다시 공을 던지고, 이를 계속 반복한다. 한 사람이 공을 M번 받았으면 게임은 끝난다. (지금 받은 공도 포함하여 센다.) 공을 M번보다 적게 받은 사람이 공을 던질 때, 현재 공을 받은 횟수가 홀수번이면 자기의 현재 위치에서 시계 방향으로 L번째 있는 사람에게, 짝수번이면 자기의 현재 위치에서 반시계 방향으로 L번째 있는 사람에게 공을 던진다.
공을 총 몇 번 던지는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N, M, L이 입력으로 들어온다. N은 3보다 크거나 같고, 1,000보다 작거나 같은 자연수이고, M은 1,000보다 작거나 같은 자연수이다. L은 N-1보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 공을 몇 번 던지는지 횟수를 출력한다.

<문제 1593>
마야 문자를 해독하는 일은 예상 외로 어려운 일이다. 현재에도 뜻이 완전히 밝혀진 마야 문자는 거의 없는 실정이며, 그나마 해독에 진척이 시작된 지는 30여 년도 되지 않았다.
마야 문자는 소리를 나타내는 여러 종류의 그림글자로 구성되는데, 이 글자들이 여러 위치에서 결합함으로써 단어를 형성한다.
마야 문자 해독을 어렵게 하는 요인 중 하나는 바로 단어를 읽는 순서이다. 마야 문자를 쓰는 고대인들은 단어를 기록할 때 특정한 규칙 대신, 그들이 보기에 좋게 보이도록 단어를 이루는 글자들을 아무렇게나 배열했다. 그렇기 때문에 고고학자들이 마야 기록에서 단어를 이루는 각 그림글자들의 발음을 알아내더라도 그 단어를 실제로 발음하는 방법은 정확히 알 수 없는 셈이다.
고고학자들은 W라는 특정 단어를 발굴 기록으로부터 찾고 있다. 그 단어를 구성하는 각 글자들은 무엇인지 알고 있지만, 이것이 고대 기록에 어떤 형태로 숨어 있는지는 다 알지 못한다.
W를 이루고 있는 g개의 그림문자와, 연구 대상인 벽화에 기록된 마야 문자열 S가 주어졌을 때, 단어 W가 마야 문자열 S에 들어있을 수 있는 모든 가짓수를 계산하는 프로그램을 작성하시오. 즉, 문자열  S안에서 문자열 W의 순열 중 하나가 부분 문자열로 들어있는 모든 경우의 수를 계산하라는 뜻이다.
<입력값>
첫째 줄에 고고학자들이 찾고자 하는 단어 W의 길이 g와 발굴된 벽화에서 추출한 문자열 S의 길이 |S|가 빈 칸을 사이에 두고 주어진다. (1≤g≤3000,  g≤|S|≤3,000,000) 둘째 줄에 W, 셋째 줄에 S의 실제 내용이 들어있다. 모든 문자열은 알파벳으로 이루어지며, 대소문자를 구분한다.
<출력값>
첫째 줄에 W의 순열이 S 안에 있을 수 있는 형태의 개수를 출력한다.

<문제 1594>
영식이는 민식나라에 산다. 영식이는 핸드폰을 산 기념으로 전화번호를 친구들에게 알려주기로 했다. 민식나라에서는 핸드폰 전화번호가 구분 없이 N자리로 제공된다. 영식이는 핸드폰 전화번호를 기억하기 쉽게 전화번호를 그룹지어서 알려주기로 했다. 예를 들어, 핸드폰 전화번호가 123456이면 영식이는 12-34-56, 123-456 과 같이 만들 수 있다.
그룹을 지을 때, 각각의 그룹에는 반드시 2개나 3개의 숫자가 들어가야 한다.
그룹은 총 3가지 종류의 그룹이 있다.

오 : 그룹에 들어있는 모든 숫자가 같은 숫자로 이루어진 경우다. 예를 들면 000, 77이다.
걍 : 그룹에 들어있는 숫자가 3자리 일 때, 두 숫자가 같은 경우다. 예를 들면 030, 229, 116이다.
즐 : 그룹에 들어있는 숫자가 모든 다른 경우이다. 예를 들면 123, 90이다.

전화번호에도 품질이 존재하는데, 품질의 정도는 다음과 같이 정할 수 있다. 2*(오 그룹에 들어가는 그룹의 개수) + (걍 그룹에 들어가는 그룹의 개수)
영식이의 핸드폰 전화번호가 주어졌을 때, 전화번호를 적절히 그룹으로 쪼개서, 영식이 전화번호의 품질이 최대인 전화번호를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 영식이의 전화번호가 주어진다. 영식이의 전화번호는 0, 1, 2, 3, 4, 5, 6, 7, 8, 9로만 이루어져 있으며, 전화번호의 길이는 2보다 크거나 같고, 1,000보다 작거나 같은 자연수이다.
<출력값>
영식이의 전화번호를 적절히 그룹으로 쪼개서 품질이 최대가 되는 전화번호를 출력한다. 전화번호의 각 그룹은 -로 구분된다. 만약, 품질이 최대가 되는 전화번호가 여러개일 경우에는, 사전순으로 가장 앞서는 것을 출력한다. 문자열을 비교할 때, ‘-’<‘0’<‘1’<‘2’<‘3’<‘4’<‘5’<‘6’<‘7’<‘8’<‘9’ 와 같은 순서를 따른다.

<문제 1595>
두 도시 사이에 도로를 만드는 일은 매우 비싸다. 때문에 북쪽나라는 특정 도시를 두 번 이상 지나가지 않고서 임의의 두 도시간을 이동하는 경로가 유일하도록 도로가 설계되어 있다.
또한 북쪽나라의 모든 도시는 다른 모든 도시로 이동할 수 있다고 한다. 이때, 거리가 가장 먼 두 도시 사이의 거리를 출력하는 것이 당신의 임무이다.
북쪽나라에는 최대 10,000개의 도시가 있을 수 있고, 도시는 1 부터 숫자로 이름이 매겨져 있다.
<입력값>
입력은 여러줄에 걸쳐 주어진다. 입력의 각 줄은 세 개의 양의 정수로 구성되어있는데, 각각은 차례대로 서로 다른 두 도시의 번호와 두 도시를 연결하는 도로의 길이를 의미한다. 모든 도로는 양방향으로 통행이 가능하다.
<출력값>
가장 거리가 먼 두 도시간의 거리를 나타내는 정수 하나를 출력하면 된다.

<문제 1596>
적어도 두 자리 이상의 어떤 자연수 N이 있을 때, 영식함수 F는 다음과 같이 정의할 수 있다. F(N) = 서로 인접한 자리수의 숫자의 차이를 큰 자리수부터 차례대로 쓴 수.
예를 들어, F(5913) = 482, F(1198) = 081 = 81, F(666) = 00 = 0 이다.
영식이는 영식함수를 이용해서 수열을 하나 만들 수 있는데, N, F(N), F(F(N)), .... 와 같이 한자리 숫자가 나타날 때 까지 수열을 만들 수 있다. 마지막 한자리 숫자를 숫자 N의 지문이라고 부른다.
예를 들어, N=5913일 때 얻을 수 있는 수열은 5913, 482, 46, 2 이다. 5913의 지문은 2이다.
어떤 숫자를 영식함수에 넣고 돌렸을 때, 지문이 7이 나오는 수를 행운의 수라고 한다.
A보다 크거나 같고, B보다 작거나 같은 행운의 수의 개수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 A와 B가 공백을 사이에 두고 주어진다. B는 1보다 크거나 같고, 1,000,000,000보다 작거나 같은 자연수이고, A는 1보다 크거나 같고, B보다 작거나 같은 자연수이다.
<출력값>
A보다 크거나 같고, B보다 작거나 같은 행운의 수의 개수를 출력한다.

<문제 1597>
아스키 아트란, 아스키 코드에 포함되는 문자, 기호를 사용한 그림을 말한다. 이 문제에서는 이를 좀 더 단순화한 경우를 생각해 보기로 한다.
직사각형 형태의 격자가 있다. 왼쪽 아래 꼭짓점의 좌표는 (0, 0)이고, 오른쪽 위 꼭짓점의 좌표는 (w, h)이다. 각 픽셀이란 (x, y) - (x+1, y+1) 로 이루어지는 한 변의 길이가 1인 정사각형을 말한다. (물론 여기서 0<=x<w , 0<=y<h이다.)
이러한 직사각형 격자 위에 다각형이 그려져 있다. 볼록 다각형은 아니지만, 자기 자신과 교차하거나 만나지 않는 단순 다각형이다. 이러한 다각형을 그리면 각 픽셀은 적절한 부분만 다각형 내부에 포함되게 된다. 예를 들어 아래 그림을 보자.

이제 우리는 각 픽셀을 하나의 아스키 코드 문자로 표현할 것이다. 단순히, 다각형 내부에 포함되어 있는 부분의 비율로만 판단하여, 다음과 같이 각각의 아스키 코드로 표현하기로 한다.

0%이상 25%미만 . (아스키 코드 번호 46)
25%이상 50%미만 + (아스키 코드 번호 43)
50%이상 75%미만 o (아스키 코드 번호 111)
75%이상 100%미만 \$ (아스키 코드 번호 36)
100% # (아스키 코드 번호 35)

문제에서 주어진 규칙에 따라 다각형의 아스키 아트를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 n, w, h가 빈 칸을 사이에 두고 주어진다. n은 다각형의 꼭짓점의 개수이며 w와 h는 격자의 폭과 높이이다. 이어서 n개의 줄에는 다각형을 이루는 꼭짓점이 시계방향으로 주어진다. 정수 좌표 xi와 yi로 주어진다. (0<=xi<=w, 0<=yi<=h) 주어지는 n, w, h는 모두 100 이하의 자연수이다.
<출력값>
h개 줄에 걸쳐 아스키 아트를 표현하는 w개의 문자를 출력한다.

<문제 1598>
동물원에서 막 탈출한 원숭이 한 마리가 세상구경을 하고 있다. 그 녀석은 원주 부근을 돌아다니다가 코레스코 콘도에서 아주 재밌는 놀이를 발견했다. 그 놀이의 이름은 바로 “꼬리를 무는 숫자 나열”. 이제부터 원숭이가 그토록 좋아하던 그 놀이를 파헤쳐보자.
놀이의 방법은 간단하다. 일단 4줄짜리 표에 왼쪽부터 숫자를 아래로 1부터 순서대로 적어나간다. 다음에 그 예가 잘 나타나있다.

이제 원숭이는 두 개의 자연수를 아무거나 생각한다. 그리고 숫자판에서 두 개의 자연수 사이의 직각거리를 구하면 된다. 여기서 직각거리는 동서방향거리와 남북방향거리의 합을 뜻한다.
예를 들어 저 숫자판에서 11과 33을 생각했다고 하자. 그렇다면 11과 33사이의 직각거리는 8이 된다.(동서방향거리 : 6, 남북방향거리 : 2) 다음 그림에 잘 나타나있다.

하지만 원숭이는 지금 혼란스럽다. 동물원에서 탈출한지 얼마 되지 않아서 계산을 할 수 없는 경지에 이르렀다. 여러분이 불쌍한 원숭이를 좀 도와줘야겠다. 원숭이가 생각한 두 자연수 사이의 직각거리를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 원숭이가 생각한 두 개의 자연수가 주어진다. 각 숫자는 10,000,000 이하이다.
<출력값>
첫째 줄에 원숭이가 생각한 두 개의 자연수 사이의 직각거리를 출력한다.

<문제 1599>
무엇인가를 창조하는 것은 어렵다. 오민식은 지금까지 어려운 다른나라의 언어를 쓰면서 백성들이 고통에 받는 것을 슬퍼하고 새로운 언어를 만들고자 했다. 그는 창조의 고통에 시달리던 중에 결국 오영식에게 자신의 못다 이룬 꿈을 꼭 이루어달라면서 오영식에게 창조의 임무를 넘겼다.
오영식은 자신의 형이 창조에 고통에 시달리는 모습을 보고 마음이 아파서 자신은 창조를 하지 않기로 했다. 영식이는 표절을 하기로 했는데 세계적인 추세에 맞게 영어를 표절하기로 했다.
영식이는 자신의 형의 이름을 따서 민식어라고 이름붙였다.
민식어에는 알파벳이 20개가 있다.
영어는 a b c d e f g h i j k l m n o p q r s t u v w x y z의 순서이지만, 민식어는 a b k d e g h i l m n ng o p r s t u w y의 순서이다.
민식어는 영어의 순서를 따르기는 하지만, 약간 변형시켜서 따른다. 그리고 ng는 n과 o사이에 오는 하나의 알파벳이다. ng는 무조건 이 알파벳으로 생각한다.
영식이는 사람들이 쉽게 민식어를 배울 수 있도록 민식어 사전을 만들려고 한다. 따라서 몇 개의 단어를 정렬하고자 한다. 민식어 단어가 주어졌을 때, 그것을 민식어의 순서대로 정렬하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 민식어 단어의 개수 N이 주어진다. N은 1,000보다 작거나 같은 자연수이다. 둘째 줄부터 한 줄에 하나씩 단어가 입력으로 들어온다. 단어의 길이는 최대 50자이다. 민식어에 없는 알파벳이 입력으로 주어지는 경우는 없다. 모든 단어는 중복되지 않는다.
<출력값>
첫째 줄부터 차례대로 정렬한 결과를 출력한다.

<문제 1600>
동물원에서 막 탈출한 원숭이 한 마리가 세상구경을 하고 있다. 그 녀석은 말(Horse)이 되기를 간절히 원했다. 그래서 그는 말의 움직임을 유심히 살펴보고 그대로 따라 하기로 하였다. 말은 말이다. 말은 격자판에서 체스의 나이트와 같은 이동방식을 가진다. 다음 그림에 말의 이동방법이 나타나있다. x표시한 곳으로 말이 갈 수 있다는 뜻이다. 참고로 말은 장애물을 뛰어넘을 수 있다.



 
x
 
x
 


x
 
 
 
x


 
 
말
 
 


x
 
 
 
x


 
x
 
x
 



근데 원숭이는 한 가지 착각하고 있는 것이 있다. 말은 저렇게 움직일 수 있지만 원숭이는 능력이 부족해서 총 K번만 위와 같이 움직일 수 있고, 그 외에는 그냥 인접한 칸으로만 움직일 수 있다. 대각선 방향은 인접한 칸에 포함되지 않는다.
이제 원숭이는 머나먼 여행길을 떠난다. 격자판의 맨 왼쪽 위에서 시작해서 맨 오른쪽 아래까지 가야한다. 인접한 네 방향으로 한 번 움직이는 것, 말의 움직임으로 한 번 움직이는 것, 모두 한 번의 동작으로 친다. 격자판이 주어졌을 때, 원숭이가 최소한의 동작으로 시작지점에서 도착지점까지 갈 수 있는 방법을 알아내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 정수 K가 주어진다. 둘째 줄에 격자판의 가로길이 W, 세로길이 H가 주어진다. 그 다음 H줄에 걸쳐 W개의 숫자가 주어지는데, 0은 아무것도 없는 평지, 1은 장애물을 뜻한다. 장애물이 있는 곳으로는 이동할 수 없다. 시작점과 도착점은 항상 평지이다. W와 H는 1이상 200이하의 자연수이고, K는 0이상 30이하의 정수이다.
<출력값>
첫째 줄에 원숭이의 동작수의 최솟값을 출력한다. 시작점에서 도착점까지 갈 수 없는 경우엔 -1을 출력한다.

<문제 1601>
바이너리 파워 비숍이 (x, y)에 있다면, (x + 2^k, y + 2^k), (x + 2^k, y - 2^k), (x - 2^k, y + 2^k), (x - 2^k, y - 2^k) 로 이동할 수 있으며, k는 음이 아닌 정수이다. 한 번 움직일 때 사용한 k는 다시 한 번 사용할 수 없다.
바이너리 파워 비숍이 (0, 0)에서 (x, y)로 이동하려고 한다. 이때, 방문하는 칸을 최소로 하는 프로그램을 작성하시오.
체스판의 크기는 무한대이고, 음수 좌표로도 방문할 수 있다.
<입력값>
첫째 줄에 바이너리 파워 비숍이 가고자하는 위치인 x와 y가 공백을 사이에 두고 주어진다. 두 수는 100,000,000보다 작거나 같은 자연수이다.
<출력값>
바이너리 파워 비숍이 (x, y)까지 이동할 때 방문하는 칸의 최솟값을 첫째 줄에 출력한다. 둘째 줄부터 차례대로 바이너리 파워 비숍이 거친 칸을 출력한다. 만약 이동할 수 없으면 첫째 줄에 -1을 출력한다. 방문하는 좌표를 출력할 때는, x,y 형식으로 출력해야 한다. 만약 가능한 경우의 수가 여러개이면 아무것이나 출력해도 된다.

<문제 1602>
동물원에서 막 탈출한 원숭이 한 마리가 세상구경을 하고 있다. 그러나 그는 곧 동물원 직원에게 쫓기는 신세가 되었다. 원숭이와 동물원 직원사이에 쫓고 쫓기는 추격전을 살펴보자.
원숭이가 사는 나라는 여러 개의 도시와 도시들을 연결하는 길들로 구성되어 있다. 각 길들은 두 개의 도시를 양방향으로 연결한다. 또한, 각 길은 지나갈 때마다 일정한 시간이 걸린다. 원숭이는 시작도시에서 탈출하여 도착도시까지 최대한 빠른 시간에 가야한다.
그런데 원숭이의 오랜 숙적 멍멍이가 이를 갈며 원숭이를 기다리고 있었다. 멍멍이는 원숭이가 도망가는 경로 중 시작점과 도착점을 포함한 도시 중 한 군데에서 원숭이를 괴롭히기로 계획했다. 각 도시마다 구조가 다르기 때문에 멍멍이가 원숭이를 괴롭힐 수 있는 시간이 정해져있다.
그래서 멍멍이는 원숭이가 도망가는 경로 상에 있는 모든 도시들 중에서 가장 오랜 시간동안 괴롭힐 수 있는 도시에서 괴롭히기로 계획했다. 원숭이는 멍멍이를 피할 수 없다. 피할 수 없다면 즐겨라! 시작도시와 도착도시가 주어졌을 때, 원숭이가 최대한 빨리 도망갈 수 있는 시간을 구하는 프로그램을 작성하시오.
예를 들어, A, B, C, D 4개의 도시가 있고 원숭이는 A에서 도망쳐서 D로 가려고 한다고 하자. 이때, A-B와 B-D 간의 도로의 통행시간은 각각 50 이고 A-C 와 C-D 간의 도로의 통행시간은 각각 70 이면 A-B-D 의 경로가 더 이익이다. (각각 100 과 140 의 시간이 걸린다.)
그러나, 네 도시에서 멍멍이가 원숭이를 괴롭힐 수 있는 시간이 10, 80, 20, 10 이라면 A-C-D 를 통해 가는 것이 시간을 더 줄일 수 있는 방법이다. (A-B-D 의 경우 100+80 = 180 의 시간이 걸리고, A-C-D 의 경우 140+20 = 160 의 시간이 걸린다.)
<입력값>
첫 번째 줄에는 도시의 개수 N (2 ≦ N ≦ 500) 과 도로의 개수 M (0 ≦ M ≦ 10,000), 그리고 질문의 개수 Q (0 ≦ Q ≦ 40,000) 가 주어진다.
그 다음 줄에, N개의 정수로 각 도시에서 멍멍이가 원숭이를 괴롭힐 수 있는 시간이 주어진다. 각 시간은 1이상 10,000이하의 정수이다. 그 후 M줄에 각각 3개의 정수로, 해당 도로가 잇는 두 도시의 번호 a, b (1 <= a, b <= N) 와 해당 도로의 통행시간 d 가 주어진다. 통행시간은 1이상 10,000이하의 정수이다.
그 후 Q줄에 각각 2개의 정수로, 원숭이의 출발도시와 도착도시 S, T 가 주어진다.
<출력값>
첫째 줄에 원숭이가 S 번 도시로부터 T 번 도시까지 도망가는 데 드는 최소시간을 출력한다. 만약 두 도시 간에 경로가 없을 경우, -1 을 출력한다.

<문제 1603>
영식이와 민식이는 모눈종이를 색칠하는 게임을 하기로 했다. 매 턴마다 영식이와 민식이는 비어있는 1×1 크기의 정사각형이나, 비어있는 2×2 크기의 정사각형을 색칠할 수 있다.가장 마지막에 색칠하는 사람이 이 게임의 승자가 된다.
이 게임에서 정사각형을 색칠할 때에는 조건이 한 가지 있는데, 모눈종이의 가장 위부터 차례대로 1번째 줄, 2번째 줄, 이렇게 번호를 매겼을 때, 2×2 크기의 정사각형의 위의 절반은 반드시 홀수번째 줄에 색칠해야 한다는 것이다.

초록색과 같이 칠하는 것은 가능한 방법이다.

빨간색과 같이 칠하는 것은 불가능한 방법이다.
현재 모눈종이에 색칠된 칸이 주어지고, 영식이와 민식이가 항상 최적의 방법으로 게임을 한다고 할 때, 이기는 사람을 출력하는 프로그램을 작성하시오. 영식이가 게임을 먼저 시작한다.
<입력값>
총 세 개의 테스트 케이스가 입력으로 주어진다.
각 테스트 케이스의  첫째 줄에 게임 판의 세로 크기 N과 가로 크기 M이 주어진다. N과 M은 10보다 작거나 같은 자연수이다. 둘째 줄부터 모눈종이의 정보가 주어진다. 총 N개의 줄에 M개의 문자가 주어지며, “.”은 아직 색칠되지 않은 칸, “#”은 현재 색칠이 되어있는 칸을 의미한다.
<출력값>
각 테스트 케이스마다 영식이가 이기면 Y를, 민식이가 이기면 M을 한 줄에 하나씩 출력한다.

<문제 1604>
네 꼭짓점의 좌표가 각각 (10, 10), (10, -10), (-10, -10), (-10, 10)인 정사각형이 있다.

양 끝점이 정사각형 밖에 위치한 선분들을 그려 정사각형을 여러 개의 영역으로 나눌 수 있다. 예를 들어 <그림 2>와 같이 세 개의 선분을 그리면 정사각형은 일곱 개의 영역으로 나누어진다.

셋 이상의 선분은 한 점 위에서 만나지 않으며 두 선분은 같은 직선 상에 있지 않다.
선분의 개수 N과 선분의 양 끝점의 좌표가 주어질 때 정사각형이 이들 선분들에 의해 몇 개의 영역으로 나누어지는지를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 선분의 개수 N이 주어진다. 둘째 줄부터 한 줄에 하나씩 선분의 양 끝점의 좌표를 나타내는 네 개의 정수 x1, y1, x2, y2가 주어진다. 이는 (x1, y1)와 (x2, y2)를 잇는 선분을 의미한다. N은 100이하의 자연수이고, x1, y1, x2, y2는 모두 -1000이상 1000이하의 정수이다. 모든 선분의 양 끝점은 정사각형 밖에 위치한다.
<출력값>
첫째 줄에 입력으로 주어진 선분들에 의해 정사각형이 몇 개의 영역으로 나누어지는지 출력한다.

<문제 1605>
알파벳 소문자로 이루어진 길이 L인 문자열이 있다. 이 문자열의 부분문자열 중, 적어도 한 번은 반복되는 (다시 말해서, 전체 문자열에서 두 번 이상 나타나는) 부분문자열을 '반복 부분문자열'이라고 부르자.
문자열이 주어지면, 가장 긴 '반복 부분문자열'의 길이를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 문자열의 길이 L(1 ≤ L ≤ 200,000)이 주어진다. 둘째 줄에는 문자열을 이루는 L개의 알파벳 소문자들이 띄어쓰기 없이 주어진다.
<출력값>
첫째 줄에 가장 긴 '반복 부분문자열'의 길이를 출력한다. 만일 '반복 부분문자열'이 하나도 존재하지 않는다면 0을 출력한다.

<문제 1606>
동물원에서 막 탈출한 원숭이 한 마리가 세상구경을 하고 있다. 그러다가 자신의 영원한 숙적 멍멍이가 떼돈을 벌어 잘 살고 있는 모습을 목격하게 되었다. 원숭이는 너무나 배가 아팠다. 그래서 원숭이는 멍멍이의 집에 침투해서 멍멍이의 금고를 털기로 했다.
그런데 문제가 있다. 멍멍이의 집의 구조는 하나이지만 집안의 위치를 인식하는 방법은 원숭이와 멍멍이가 다르기 때문에 원숭이는 이 문제를 적절하게 해결해야 한다. 멍멍이의 집은 육각형구조의 타일로 이루어져 있다. 원숭이와 멍멍이의 인식방법을 하나하나 살펴보자.

위 그림은 원숭이가 멍멍이네 집을 볼 때, 각 지점을 인식하는 방법이다. 가운데 점에서 1부터 번호를 붙이며 위치를 인식한다.

위 그림은 멍멍이가 멍멍이네 집을 볼 때, 각 지점을 인식하는 방법이다. 가운데 점을 (0,0)으로 두고, 각 위치마다 좌표를 붙이며 위치를 인식한다.
현재 원숭이는 멍멍이의 금고의 위치를 좌표형식(멍멍이가 인식하는 형식)으로 알고 있다. 하지만 그렇게 나타내면 원숭이가 어딘지 모르므로 원숭이가 인식할 수 있는 위치로 바꿔주어야 한다. 원숭이가 금고를 털 수 있도록 도와주는 프로그램을 작성하시오.
<입력값>
첫째 줄에 멍멍이의 금고의 위치를 나타내는 좌표가 주어진다. 각 수는 0이상 1,000,000이하의 정수이다.
<출력값>
첫째 줄에 멍멍이의 금고의 위치를 원숭이가 인식하는 방법으로 나타낸 것을 출력한다.

<문제 1607>
동물원에서 막 탈출한 원숭이 한 마리가 세상구경을 하고 있다. 그는 자신이 원래 살던 곳으로 돌아가고 싶었지만 너무 멀어서 갈 수 없었다. 그래서 그는 자신이 살던 곳의 전통방식으로 지어진 탑을 간절히 생각하며 슬픔을 달래기로 했다. 그 탑의 이름은 원숭이 타워!!
원숭이 타워는 원숭이들이 만든 것이라고는 하지만 원숭이들의 창의력이 부족하여 실제로는 하노이지방의 하노이타워를 응용하여 만든 탑이다. 이제 그 탑을 살펴보자.

위의 그림에 잘 나타나있다. 원숭이 타워가 하노이타워와 다른 점은 기둥을 네 개를 쓴다는 점이다. 이 탑의 목적은 하노이타워와 마찬가지로 디스크들을 1번 기둥에서 4번 기둥으로 모두 옮기는 것이다. 물론, 하노이타워의 규칙을 똑같이 적용해서 옮겨야 한다.
하노이타워의 규칙을 모르는 자들을 위해 하노이타워의 규칙을 설명하겠다.

작은 디스크는 항상 큰 디스크의 위에 놓여야 한다.
한 번에 딱 하나의 디스크를 다른 기둥으로 옮길 수 있다.

이제 원숭이는 머릿속으로 원숭이 타워를 생각하려 하는데 두뇌가 딸려서 잘 계산이 되지 않아 여러분에게 도움을 요청하였다. 처음에 1번기둥에 N개의 크기가 서로 다른 디스크가 쌓여있을 때, N개의 디스크를 모두 4번기둥으로 옮기는 최소회수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 디스크의 개수 N이 주어진다. N은 1,000,000 이하의 자연수이다.
<출력값>
첫째 줄에 N개의 디스크를 옮기는데 드는 최소회수를 9901로 나눈 나머지를 출력한다.

<문제 1608>
학생들은 스타 대회를 열기로 했다. 참가자는 총 N명으로 1번부터 N번까지 번호가 붙어있다. 토너먼트의 규칙은 다음과 같다. 게임이 진행되는 동안 남아있는 참가자 중 임의의 두 명을 뽑아 스타를 붙인다. 경기 후 패자는 탈락되고 승자는 계속해서 대회에 참가하게 된다. (단, 무승부는 존재하지 않는다.) 결국 N-1번의 게임을 하면 최후의 승자가 남게 되고 이 학생이 우승을 하게 된다.


참가자 중 어떤 한 학생이 다른 한 학생을 항상 이기는 천적 관계가 존재한다. 즉, 이 두 학생끼리는 경기를 펼치지 않아도 누가 이긴다는 것을 알 수 있다는 것이다. 예를 들어, 위와 같은 그래프에서 1번은 2, 3번을 항상 이긴다는 뜻이다. 하지만 1번과 4번이 경기하면 1번이 이길 수도 있고 4번이 이길 수도 있다.
N명의 참가자에 대한 천적 관계가 주어졌을 때 우승 가능성이 있는 학생들을 알 수 있다. 예를 들어, 위의 예에서 3번 학생은 1번 학생한테 항상 지지만 4번 학생과 1번 학생이 경기를 하여 1번 학생이 탈락한 후 3번 학생이 2, 4번 학생을 차례대로 이기고 우승할 수 있기 때문에 우승 가능성이 있는 학생이다.
문제는 N명의 참가자에 대한 천적 관계가 주어지면 우승 가능성이 있는 학생들을 모두 구하는 것이다.
<입력값>
첫째 줄에 참가자 수 N(1≤N≤100,000)이 주어진다. 다음 N개의 줄에 천적관계가 주어지는데 i+1번째 줄에는 i번째 학생이 항상 이기는 학생의 수 와 이 학생들의 번호가 공백으로 구분되어 증가하는 순서로 주어진다. (단, 자기 자신이 천적인 경우는 없다.) 천적 관계의 총 수는 1,000,000을 넘지 않는다.
<출력값>
첫째 줄에 우승 가능성이 있는 학생 수 w와 이 학생들의 번호를 오름차순으로 공백으로 구분하여 출력한다.

<문제 1609>
N×N 격자의 각 칸에 수가 하나씩 적혀 있는 정사각형 모양의 게임 보드가 있다. 편의상 가장 왼쪽 위 칸의 좌표를 (1, 1), 가장 오른쪽 아래 칸의 좌표를 (N, N)으로 생각한다. 첫 번째 좌표는 열 번호, 두 번째 좌표는 행 번호를 각각 나타낸다. 이 게임 보드에서 임의로 두 개의 칸을 골라 차(車)를 하나씩 놓으려고 한다. 물론 두 개의 칸은 서로 달라야 한다.
자신과 같은 열 또는 같은 행에 차(車)가 하나라도 놓여 있다면 그 칸은 "차의 공격을 받는 칸"에 해당된다. 하지만 차(車)가 직접 놓여 있는 칸은 "차의 공격을 받는 칸"에 해당되지 않는다.
게임 보드에 적혀 있는 수들이 주어지면, "차의 공격을 받는 칸"에 적혀 있는 수들의 합이 최대가 되도록 두 개의 차(車)를 배치하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N(2 ≤ N ≤ 300)이 주어진다. 이어서 N개의 줄에 걸쳐 게임 보드에 적혀 있는 수들이 한 줄에 N개씩 빈 칸을 사이에 두고 주어진다. 주어지는 수는 모두 0 이상 1,000이하의 정수이다.
<출력값>
첫째 줄에, "차의 공격을 받는 칸"에 적혀 있는 수들의 합이 최대가 되도록 두 개의 차(車)를 배치했을 때 그 최대합을 출력한다.

<문제 1610>
영식이는 숌크래프트의 프로게이머이다. 영식이는 자신의 최대 라이벌 민식이와의 피할 수 없는 승부를 대비하기 위해서 숌크래프트를 준비하기로 했다.
숌크래프트에는 유닛이 총 N개 존재하는데, 각각의 유닛은 1번부터 N번까지 차례대로 번호가 매겨져 있다. 게임의 시작은 유닛 1번 1대만 주어지고 시작한다. 이 게임에는 건물이란 개념이 없기 때문에, 유닛이 유닛을 생산한다. 유닛 1번이 유닛 2번은 만들 수 있고, 유닛 2번이 유닛 3번을 만들 수 있고, ... 유닛 i번이 유닛 i+1번을 만드는 형식이다. 이 게임에도 자원이 존재하는데, 유닛 1번이 유닛 2번을 만들 때 걸리는 시간을 Time[1]이라고 하고, 그때 드는 자원을 Cost[1]이라고 한다. 한마디로 유닛 i번이 유닛 i+1번을 만드는데 걸리는 시간은 Time[i]이고, 필요한 자원은 Cost[i]이다. 이 게임은 독특해서 유닛 번호가 높은 유닛이 유닛 번호가 낮은 유닛을 모두 이긴다. (물량 무시) 따라서 영식이는 유닛 번호 N번을 최대한 많이 뽑으려고 한다.
게임은 시작됐다. 숌크래프트에서는 시간을 정해놓고 그 시간부터 싸움을 시작한다. 민식이와의 피할 수 없는 승부까지 남은 시간 T와 현재 영식이의 자원 C가 주어졌을 때, 영식이가 뽑을 수 있는 유닛 번호 N번의 최대개수를 구하는 프로그램을 작성하시오. 자원은 더 이상 늘어나지 않는다. 주어진 자원만 쓸 수 있다. 또, 모든 활동은 동시에 일어나며, 영식이가 유닛을 선택해서 다른 유닛을 만드는 버튼을 누르는데 걸리는 시간은 0초이다. (영식이가 게임 명령을 내리는 시간은 생각하지 않는다.)
예를 들어, 유닛의 개수가 3개이고, 남은 시간이 3이고, 현재 자원이 5이고, 유닛1이 유닛2를 만드는 시간과 자원이 모두 1들고, 유닛2와 유닛3을 만드는데 시간과 자원이 모두 1이 들면, 게임이 시작하자마자 유닛1이 유닛2를 만들면, 시간1이 됐을 때, 현재 유닛은 유닛1 1마리와 유닛2 1마리이다. 시간1일 때, 유닛1이 유닛2를 만들고, 유닛2가 유닛3을 만들면, 시간2가 됐을 때 총 유닛은 유닛1 1마리, 유닛2 2마리, 유닛3 1마리이다. 여기서 유닛2 2마리가 각각 유닛3를 한 마리씩 만들면, 시간3이 되었을 때는, 유닛1 1마리, 유닛2 2마리, 유닛3 3마리가 되어, 정답은 3이 된다.
<입력값>
첫째 줄에 유닛의 개수 N이 주어진다. 유닛의 개수는 300보다 작거나 같은 자연수이다. 둘째 줄에 현재 영식이의 자원 C와 현재 남은 시간 T가 주어진다. C와 T는 300보다 작거나 같은 자연수이다. 셋째 줄부터 N-1개의 줄에 한 줄에 하나씩 Cost[i]와 Time[i]가 들어온다. 입력은 유닛 1번이 유닛 2번을 만드는데 드는 비용과 걸리는 시간, 유닛 2번이 유닛 3번을 만드는데 드는 비용과 걸리는 시간, 과 같이 순서대로 들어온다.
<출력값>
첫째 줄에 영식이가 최대로 뽑을 수 있는 유닛 N번의 개수를 출력한다.

<문제 1611>
2008년의 정월 대보름(2월 21일)이 얼마 남지 않았다. 학생들은 이를 맞아 강강술래를 하려고 한다.
강강술래는 홀수 명의 학생들이 참가하는데, 이 2K+1명의 학생들이 서로 손을 잡고 둥글게 서려고 한다. 이렇게 원을 만들게 되면 각 학생의 오른쪽과 왼쪽에는 각각 한 명씩 인접한 사람이 생기게 되고, 자연스레 두 명과 손을 잡게 된다.
강강술래를 정확히 K번 반복하면 총 2K번 다른 학생과 손을 잡을 수 있는 기회가 생긴다. 자신을 제외한 다른 학생이 총 2K명이므로, 모든 학생과 정확히 한 번씩만 손을 잡도록 강강술래를 K번 반복하고 싶다.
예를 들어 5명의 학생이 있다고 하자. 편의상 학생들의 번호를 1번부터 5번까지 매기자. 이때, 처음은 1-5-4-2-3 두 번째는 1-2-5-3-4의 순서로 둥글게 서게 되면, 모든 학생이 자신을 제외한 네 명의 학생과 각각 한 번씩 손을 잡게 된다.
학생 수 2K+1이 주어지면, 주어진 조건을 만족하도록 K번의 강강술래에서 학생들을 둥글게 세울 순서를 결정하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 학생의 수 2K+1이 주어진다. 이 수는 3 이상이고 2,399 이하인 홀수이다.
<출력값>
첫째 줄부터 K개 줄에 걸쳐 각각의 강강술래에서 학생들을 둥글게 세울 순서를 나타내는 2K+1개의 정수를 출력한다. 한 줄에는 1번부터 2K+1번까지의 학생 번호가 정확히 한 번씩만 나타나야 한다. 조건을 만족하는 답이 여러 가지가 있을 수 있으므로 아무 것이나 하나 출력하면 된다. 만일 조건을 만족시키는 해가 존재하지 않는다면 첫째 줄에 -1만을 출력하면 된다.

<문제 1612>
동물원에서 막 탈출한 원숭이 한 마리가 세상구경을 하고 있다. 이 원숭이는 수를 이리저리 가지고 노는 것을 매우 좋아한다. 그중에서도 1을 가지고 노는 것을 매우매우매우매우매우 좋아한다. 이제 원숭이가 1을 가지고 노는 법을 알아보자.
원숭이는 1만으로 이루어진 수를 매우매우매우매우매우매우매우 좋아한다. 그래서 어떤 자연수 N이 있을 때, N의 배수 중에서 1만으로 이루어진 수가 있을 까 생각하게 되었다. 그리고는 원숭이는 N의 배수 중에서 1만으로 이루어진 수중에 가장 작은 수의 자릿수가 알고 싶어졌다. 하지만 오늘도 역시 멍청한 원숭이는 스스로 계산하지 못하고 여러분에게 도움을 요청했다. 조건에 맞는 가장 작은 수의 자릿수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 자연수 N이 주어진다. N은 1이상 1,000,000이하인 자연수이다.
<출력값>
첫째 줄에 N의 배수 중에 1만으로 이루어진 수 중 가장 작은 수의 자릿수를 출력한다. 불가능한 경우는 -1을 출력한다.

<문제 1613>
역사, 그 중에서도 한국사에 해박한 세준이는 많은 역사적 사건들의 전후 관계를 잘 알고 있다. 즉, 임진왜란이 병자호란보다 먼저 일어났으며, 무오사화가 기묘사화보다 먼저 일어났다는 등의 지식을 알고 있는 것이다.
세준이가 알고 있는 일부 사건들의 전후 관계들이 주어질 때, 주어진 사건들의 전후 관계도 알 수 있을까? 이를 해결하는 프로그램을 작성해 보도록 하자.
<입력값>
첫째 줄에 첫 줄에 사건의 개수 n(400 이하의 자연수)과 알고 있는 사건의 전후 관계의 개수 k(50,000 이하의 자연수)가 주어진다. 다음 k줄에는 전후 관계를 알고 있는 두 사건의 번호가 주어진다. 이는 앞에 있는 번호의 사건이 뒤에 있는 번호의 사건보다 먼저 일어났음을 의미한다. 물론 사건의 전후 관계가 모순인 경우는 없다. 다음에는 사건의 전후 관계를 알고 싶은 사건 쌍의 수 s(50,000 이하의 자연수)이 주어진다. 다음 s줄에는 각각 서로 다른 두 사건의 번호가 주어진다. 사건의 번호는 1보다 크거나 같고, N보다 작거나 같은 자연수이다.
<출력값>
s줄에 걸쳐 물음에 답한다. 각 줄에 만일 앞에 있는 번호의 사건이 먼저 일어났으면 -1, 뒤에 있는 번호의 사건이 먼저 일어났으면 1, 어떤지 모르면(유추할 수 없으면) 0을 출력한다.

<문제 1614>
영식이는 숫자를 셀 때, 왼손을 이용한다. 엄지손가락부터 시작해서 새끼손가락까지 차례대로 하나씩 센다. 그다음에 새끼손가락까지 센 다음에는 반대로 엄지손가락으로 다시 역방향으로 센다. 영식이는 자기가 원하는 숫자가 나올 때 까지 계속해서 이 방법으로 센다. 영식이는 절대 손가락을 건너뛰지 않는다. 예를 들어 숫자 10을 셀 때는, 엄지 → 검지 → 중지 → 약지 → 새끼 → 약지 → 중지 → 검지 → 엄지 → 검지 이렇게 센다.
영식이가 손가락을 하나 다쳤다. 영식이는 오른손으로는 셀 수 없기 때문에, 왼손으로 세야 한다. 다친 손가락을 이용해서 셀 수 있는 횟수가 제한되어 있다.
영식이가 셀 수 있는 최대 숫자를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 영식이가 다친 손가락이 주어진다. 엄지부터 차례대로 1, 2, 3, 4, 5로 번호가 매겨져 있다. 둘째 줄에는 영식이가 다친 손가락으로 몇 번 셀 수 있는지 주어진다. 이 수는 1,000,000,000보다 작거나 같은 자연수 또는 0이다.
<출력값>
첫째 줄에 영식이가 셀 수 있는 수의 최댓값을 출력한다. 만약 시작도 할 수 없으면 0을 출력한다.

<문제 1615>
각각 N(1 ≤ N ≤ 2,000)개의 쌍으로 이루어진 2N개의 정점과 M(1 ≤ M ≤ N×(N-1)/2)개의 간선으로 구성된 이분그래프가 주어질 때 서로 교차하는 총 개수를 구하는 것이다.

교차 조건 : 한 독립 집합 A와 다른 독립 집합 B가 연결된 두 개의 간선을 (A1, B1), (A2, B2)라 한다면 A1 < A2, B1 > B2 또는 A1 > A2, B1 < B2를 만족한다면 두 간선을 교차한다고 한다.


예를 들어 위에 예에서 (3, 2)는 (1, 5)와 (5, 1)과 교차한다. 이 문제를 해결하는 프로그램을 작성하시오.
<입력값>
첫 줄에 N과 간선의 개수 M이 주어진다. 그 다음 줄부터 M+1번째 줄까지 두 개의 수(i, j)가 주어지는데 이는 왼쪽 그룹의 i번 정점과 오른쪽 그룹의 j번 정점을 연결하는 간선이 있다는 의미이다. 중복되는 간선이 입력으로 주어지지 않는다.
<출력값>
입력에서 주어진 간선이 교차하는 총 개수를 출력한다.

<문제 1616>
동물원에서 막 탈출한 원숭이 한 마리가 세상구경을 하고 있다. 그 원숭이는 자신의 생각을 사람들에게 전해주고 싶었지만 안타깝게도 사람들은 그의 언어를 이해하지 못했다. 그래서 그는 괴로웠다.
사람들에게 자신의 생각을 전하기 위해 그 원숭이는 새로운 언어 전달법을 개발하였다. 그것은 바로 드럼통을 이용한 것이다. 원숭이는 0부터 K-1까지의 숫자를 이해할 수 있다. 그래서 드럼통에 KM개의 칸을 만들고 그곳에 0에서 K-1사이의 수를 쓴다. 그리고 드럼통을 한 칸씩 돌리면서 원숭이가 한 번에 읽을 수 있는 M개의 칸에 적힌 수들을 메시지로 전달하면 되는 것이다. 다음 그림을 보자.

다음 그림은 K=3, M=2 인 경우이다. 처음에 읽은 메시지는 “12” 이고, 시계방향으로 한 칸 돌리면 “22” 라는 메시지를 읽게 된다. 다시 시계방향으로 한 칸 돌리면 “20” 이라는 메시지를 읽게 된다. 그런 식으로 죽 읽어나가면 위에 나타난 드럼통을 이용해서 0부터 2사이의 수를 이용해 길이가 2인 조합의 메시지를 모두 얻을 수 있다.
원숭이는 0부터 K-1의 수를 써서 길이가 M인 모든 메시지를 드럼통으로 표현하고 싶다. K와 M이 주어졌을 때, 드럼통을 돌려서 KM개의 조합을 모두 얻을 수 있는 드럼통이 존재하는지, 존재하면 드럼통을 어떤 식으로 만들어야 하는지를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 자연수 K, M이 주어진다. K는 2이상, M은 1이상인 자연수이다. 항상 KM ≤ 10,000,000을 만족한다.
<출력값>
첫째 줄에 드럼통에 적힌 KM개의 수를 순서대로 출력한다. 시계방향이던 반시계방향이던 아무 곳에서나 시작하여 순서대로 한 바퀴만 출력하면 된다. 답이 여러 개면 아무거나 하나만 출력한다. 드럼통을 만드는 것이 불가능할 경우 -1을 출력한다.

<문제 1617>
민식이는 영식이의 손가락을 부러뜨렸다. 민식이는 너무 미안한 마음에 영식이에게 자신의 미안한 마음을 담은 편지를 벽에 붙이려고 한다. 영식이와 민식이의 집은 매우 크다. 민식이의 편지는 1X1크기의 정사각형이다. 벽은 가장 왼쪽 아래를 좌표에서 원점으로 한다. X축은 왼쪽에서 오른쪽으로 양의 방향이고, Y축은 아래에서 위로 양의 방향이다.
처음에 모든 칸은 편지를 붙이지 않았다. 민식이는 편지를 다음과 같은 방법으로 붙이려고 한다. 민식이는 (x1,y1)을 왼쪽 아래로 하고, (x2,y2)를 오른쪽 위로 하는 직사각형에 편지를 붙일 것이다. 민식이는 미적감각이 뛰어난 영식이를 위해서 편지를 붙이는 총 4가지 방법중에 하나로 붙이려고 한다.

 

첫 번째 방법은 모든 칸에 전부 편지를 붙이는 방법이다.
두 번째 방법은 직사각형의 홀수 행에 모두 편지를 붙이는 방법이다.
세 번째 방법은 직사각형의 홀수 열에 모두 편지를 붙이는 방법이다.
네 번째 방법은 홀수 행이면서 홀수 열이거나, 짝수 행이면서 짝수 열인 칸에 편지를 붙이는 방법이다.

민식이가 편지를 다 붙였을 때, 벽에 편지가 총 몇 개 붙여있는지 개수를 구하는 프로그램을 작성하시오. 편지가 이미 붙어있는 칸에는 다시 편지를 붙이지 않는다.
<입력값>
첫째 줄에 직사각형의 개수 N이 주어진다. N은 100보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 직사각형의 정보가 주어진다. 직사각형의 정보는 x1 y1 x2 y2 p 와 같이 주어진다. 
(x1,y1)은 직사각형의 왼쪽 아래 점이고, (x2,y2)는 직사각형의 오른쪽 위 점이다. p는 민식이가 편지를 붙이는 방법인데, 문제에 나온 1~4중에 하나다. x1은 x2보다 반드시 작고, y1은 y2보다 반드시 작다. 그리고, x1,y1,x2,y2는 40,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 편지가 총 몇 개 붙여있는지 개수를 출력한다.

<문제 1618>
수평으로 n개, 수직으로 m개의 길이 나 있는 도시가 있다. 이 길들에 의해서, 도시는 (n+1)*(m+1)개의 소구역으로 나눠지며, 각각의 소구역에는 몇 명의 사람들이 살고있다. n=2, m=3일때의 예를 들면, 아래의 그림과 같은 구조이다.

이 길들 중 수평으로 X개, 수직으로 Y개의 길을 택해서 도시를 재조정 하려고 한다. 이렇게 될 경우, 도시는 (X+1)*(Y+1)개의 구역으로 다시 나뉜다. 이렇게 나뉘어진 구역중, 사람이 제일 많이 살고있는 구역의 사람의 수가 최소가 되도록 도시를 재조정 하려고 한다. 위의 위의 예제에서 X=1, Y=2일때의 최적해는 굵은 선과 같으며, 이때는 모든 구역의 사람의 수가 20이 된다.
  이 문제를 해결하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 두 정수 n(1<=n<20), m(1<=m<100)이 주어진다. 두 번째 줄에는 두 정수 X(1<=X<=n), Y(1<=Y<=m)이 주어진다. 다음 n+1개의 줄에는 m+1개의 자연수가 주어진다. 이 값들은 10,000이하이다. 각각의 수들 사이에는 공백이 하나씩 있다.
<출력값>
첫째 줄에는 선택한 X개의 수평선의 번호를 출력한다. 둘째 줄에는 선택한 Y개의 수직선의 번호를 출력한다. 수평선은 위에서 아래로, 수직선은 왼쪽에서 오른쪽으로 차례로 1, 2, 3의 번호를 갖는다. 세 번째 줄에는 이때 가장 많은 사람이 속해있는 구역에 속한 사람의 수를 출력한다. 각 숫자들 사이에는 1개 이상의 공백을 둔다.

<문제 1619>
2차원 평면 위에 N개의 점들이 찍혀 있다. 우리는 아래의 조건을 만족하도록 몇 개의 점을 고르려고 한다.

적어도 세 점 이상은 골라야 한다.
고른 점들 중에서 어떤 두 점을 임의로 선택해도, 선택한 두 점을 잇는 직선을 만들었을 때 이 직선을 통과하는 다른 점이 적어도 한 개 이상은 있어야 한다.
최대한 많은 점을 골라야 한다.

모든 점의 좌표가 주어졌을 때, 조건을 만족하도록 점을 골라 주는 프로램을 작성하시오.
<입력값>
첫째 줄에 점의 개수 N(3 ≤ N ≤ 1,000)이 주어진다. 이어서 둘째 줄부터 N개의 줄에 걸쳐 점의 x좌표와 y좌표를 나타내는 두 정수가 순서대로 주어진다. 주어지는 모든 좌표는 절댓값이 20,000을 넘지 않는 정수이다. 주어지는 모든 점은 서로 다르다.
<출력값>
첫째 줄에 고른 점들의 최대 개수를 출력한다. 점들을 고르는 것이 불가능한 경우 -1을 출력한다.

<문제 1620>
안녕? 내 이름은 이다솜. 나의 꿈은 포켓몬 마스터야. 일단 포켓몬 마스터가 되기 위해선 포켓몬을 한 마리 잡아야겠지? 근처 숲으로 가야겠어.
(뚜벅 뚜벅)
얏! 꼬렛이다. 꼬렛? 귀여운데, 나의 첫 포켓몬으로 딱 어울린데? 내가 잡고 말겠어. 가라! 몬스터볼~
(펑!) 헐랭... 왜 안 잡히지?ㅜㅜ 몬스터 볼만 던지면 되는 게 아닌가...ㅜㅠ
(터벅터벅)
어? 누구지?

오박사 : 나는 태초마을의 포켓몬 박사 오민식 박사라네. 다솜아, 포켓몬을 잡을 때는, 일단 상대 포켓몬의 체력을 적당히 바닥으로 만들어놓고 몬스터 볼을 던져야 한단다. 자, 내 포켓몬 이상해꽃으로 한번 잡아보렴. 포켓몬의 기술을 쓰는 것을 보고 포켓몬을 줄지 안줄지 결정을 하겠네. 자 한번 해보아라. 다솜아.
이다솜 : 이상해꽃이라...음.. 꽃이니깐 왠지 햇빛을 받아서 공격을 할 것 같은데... 음... 이상해꽃! 햇빛공격!!!
(꼬렛이 이상해꽃에게 공격을 받아 체력이 25 감소했다.)
   가라! 몬스터 볼!!!
   (꼬렛을 잡았습니다.)
   야호! 신난다. 꼬렛을 잡았다.
오박사 : 오우!! 방금 쓴 공격은 솔라빔이라고 하네.. 어떻게 공격을 한 건가? 솔라빔이란 공격에 대해서 공부를 한 건가?
이다솜 : 꽃이니깐 왠지 햇빛을 제대로 받으면 광합성을 해서 음.. 그냥 그럴 것 같아서요 ☞☜
오박사 : 다른 아이들은 넝쿨채찍이나, 나뭇잎 공격을 하는데, 다솜이는 역시 뭔가 다르구나. 그럼 나와 함께 연구소로 가자꾸나. 내가 포켓몬을 한 마리 줄 테니, 너의 꿈을 펼쳐보아라. 꿈은 이루어진단다.
이다솜 : 네! 오박사님, 고마워요.ㅜㅜ
오박사 : 가자. 나의 연구소는 너의 옆집의 아랫집이란다. 같이 가도록하자. 지금 포켓몬을 주마.
이다솜 : 네. 야호!!
'
오영식 : 어? 오박사님 얘는 누구인가요?

오박사 : 얘는 너의 라이벌이 될 친구 이다솜이라고 하네. 자, 포켓몬을 한 마리 골라보도록 해봐라 다솜아. 레이디퍼스트 네가 먼저 골라봐라.
이다솜 : 저는 생각해둔 포켓몬이 있어요. 피카츄 골라도 될까요?
오박사 : 그래 여기 피카츄가 한 마리 있단다. 피카츄를 가져가거라.
오영식 : 그럼 저는 이브이를 가져가겠어요. 그럼 나중에 보자 이다솜.
이다솜 : 그럼 꼬렛을 다시 잡으러 가야겠다. 영식아, 그리고 민식박사님 빠잉!

이다솜 : 피카츄 공격!

가라 몬스터 볼!

이다솜 : 야호! 신난다. 꼬렛을 잡았다!!!!!
이다솜 : 그럼! 일단 사천왕을 이기고 오겠어!

이다솜 : 여기가 사천왕과 대결하려면 가야하는 곳인가..

경비원 : 사천왕과 대결을 하려면, 마을의 체육관 리더를 이겨서 배지를 8개를 모아야 한다네... 배지를 모아서 오도록 하게
이다솜 : 잉ㅠㅜ... 그럼 배지부터 모아야 하는구나ㅠㅜㅠㅜ 나쁘당 그냥 좀 봐주지..
<1 년 후>
그동안의 줄거리 : 이다솜은 일단 상록 숲의 체육관 리더에게 도전을 했다. 하지만 상록숲 체육관의 리더는 실종된 상태. 따라서 회색마을부터 도전하기로 했다. 체육관의 리더를 이기면서, 로켓단을 해체시키기도 하고, 여러 가지 사건도 있었다. 결국 전설의 포켓몬도 잡고, 이제 사천왕을 이기려고 도전하기로 했다. 사천왕은 모두 가볍게 이기고, 이제 마지막 라이벌 오!영!식! 이다.

오영식 : 훗. 1년 전의 그 이다솜이 사천왕을 이기고 현재 포켓몬 마스터인 나에게 덤벼? 어디 한번 덤벼보시지.
이다솜 : 헐랭... 나를 우습게보네.... 한번 두고 보시지! 그럼 대결이닷!








이다솜 : 휴... 이겼다.
오영식 : 내가 지다니 분하다. ㅜㅜ
오박사 : 그럼 다솜아 이제 진정한 포켓몬 마스터가 되기 위해 도감을 완성시키도록 하여라. 일단 네가 현재 가지고 있는 포켓몬 도감에서 포켓몬의 이름을 보면 포켓몬의 번호를 말하거나, 포켓몬의 번호를 보면 포켓몬의 이름을 말하는 연습을 하도록 하여라. 나의 시험을 통과하면, 내가 새로 만든 도감을 주도록 하겠네.
<입력값>
첫째 줄에는 도감에 수록되어 있는 포켓몬의 개수 N이랑 내가 맞춰야 하는 문제의 개수 M이 주어져. N과 M은 1보다 크거나 같고, 100,000보다 작거나 같은 자연수인데, 자연수가 뭔지는 알지? 모르면 물어봐도 괜찮아. 나는 언제든지 질문에 답해줄 준비가 되어있어.
둘째 줄부터 N개의 줄에 포켓몬의 번호가 1번인 포켓몬부터 N번에 해당하는 포켓몬까지 한 줄에 하나씩 입력으로 들어와. 포켓몬의 이름은 모두 영어로만 이루어져있고, 또, 음... 첫 글자만 대문자이고, 나머지 문자는 소문자로만 이루어져 있어. 포켓몬 이름의 최대 길이는 20이야. 그 다음 줄부터 총 M개의 줄에 내가 맞춰야하는 문제가 입력으로 들어와. 문제가 알파벳으로만 들어오면 포켓몬 번호를 말해야 하고, 숫자로만 들어오면, 포켓몬 번호에 해당하는 문자를 출력해야해. 입력으로 들어오는 숫자는 반드시 1보다 크거나 같고, N보다 작거나 같고, 입력으로 들어오는 문자는 반드시 도감에 있는 포켓몬의 이름만 주어져. 그럼 화이팅!!!
<출력값>
첫째 줄부터 차례대로 M개의 줄에 각각의 문제에 대한 답을 말해줬으면 좋겠어!!!. 입력으로 숫자가 들어왔다면 그 숫자에 해당하는 포켓몬의 이름을, 문자가 들어왔으면 그 포켓몬의 이름에 해당하는 번호를 출력하면 돼. 그럼 땡큐~

이게 오박사님이 나에게 새로 주시려고 하는 도감이야. 너무 가지고 싶다ㅠㅜ. 꼭 만점을 받아줬으면 좋겠어!! 파이팅!!!

<문제 1622>
알파벳 소문자로 이루어진 두 문자열 a와 b에 대해, a의 부분 수열의 순열이자 b의 부분 수열의 순열이 되는 가장 긴 문자열 x를 구하여라.
<입력값>
각각의 입력은 한 쌍의 줄로 이루어져 있다.
첫 줄에는 문자열 a가 두 번째 줄에는 문자열 b가 주어진다.
각각의 문자열은 줄로 구분되며, 최대 1000개의 알파벳 소문자로 이루어졌다.
<출력값>
각각의 입력에 대해, x를 출력한다.
가능한 x가 여러 개 존재하는 경우, 사전순으로 가장 앞에 오는 것을 출력한다.

<문제 1623>
'주식회사 월드'의 조직도는 루트가 있는 트리 형태의 구조를 가지고 있다. 즉, 사장님을 트리의 루트로 하며, 직원들은 자신의 직속상관 바로 밑에 매달려 있는 형태가 된다.
김진영 부사장은 2008년 설을 맞아 '주식회사 월드'의 신년 파티를 계획 중에 있다. 단, 만일 부하직원이 자신의 직속상관과 파티에 함께 오게 되면 분위기가 경직될 수 있으므로, 파티의 분위기를 위해 부하직원과 그 직속상관은 같이 초대될 수 없도록 하려고 한다.
예를 들어 최백준 과장이 오민식, 오영식 대리의 직속상관이라고 하자, 만일 최백준 과장을 파티에 초대하려 한다면 오민식, 오영식 두 대리는 파티에 초대할 수 없다. 마찬가지로 오민식, 오영식 대리 중 어느 한 명이라도 파티에 초대하려 한다면 최백준 과장 역시 파티에 초대될 수 없다.
각 직원들의 "날라리 기질"은 평소 인사과의 관찰을 통해 회사의 데이터베이스에 기록이 되어 있다고 한다. 신년 파티의 "날라리 분위기"란 파티 참가자들의 "날라리 기질"의 합으로 정해진다.
김진영 부사장은 위의 제한을 만족시키면서 이번 신년 파티의 "날라리 분위기"를 최대화하도록 참가자 목록을 작성하려고 한다. 단, 사장의 참석 여부가 아직 불투명한 상황이기 때문에 사장이 참석하는 경우와 그렇지 않은 경우 각각에 대해 모두 참가자 목록을 결정해 줄 프로그램을 작성해야 한다. 아무도 초대하지 않는 경우 "날라리 분위기"가 최대일 수도 있다는 점에 주의한다.
<입력값>
첫째 줄에 사장을 포함한 모든 직원의 수 N이 주어진다. (2≤N≤200,000) 사장은 1번이며, 다른 직원들은 2번부터 N번까지 차례로 번호가 매겨져 있다. 둘째 줄에는 사장을 포함한 모든 직원의 "날라리 기질"을 나타내는 N개의 정수가 빈 칸을 사이에 두고 1번 직원(사장)부터 N번 직원까지 순서대로 주어진다. 주어지는 정수는 절댓값이 10,000을 넘지 않는다. 셋째 줄에는 사장을 제외한 모든 직원의 직속 상관의 번호를 나타내는 N-1개의 정수가 빈 칸을 사이에 두고 2번 직원부터 N번 직원까지 순서대로 주어진다. 주어지는 수는 물론 N 이하의 자연수이며, 항상 루트가 있는 트리 형태의 구조를 갖도록 입력이 주어진다고 가정해도 좋다.
<출력값>
첫째 줄에는 사장이 참석하는 경우와 그렇지 않은 경우의  "날라리 분위기"의 최댓값을 빈 칸을 사이에 두고 순서대로 출력한다. 둘째 줄과 셋째 줄에는 각각 사장이 참석하는 경우와 그렇지 않은 경우의 참가자 번호를 빈 칸을 사이에 두고 증가하는 순서대로 출력한다. 각 줄의 끝에는 -1을 추가로 출력해서 끝을 표시하도록 한다.

<문제 1624>
데크는 큐와 비슷하지만, 앞과 뒤 양쪽에서 자료를 넣거나 뺄 수 있는 자료구조이다.
N개의 수가 주어졌을 때, 첫 번째 수부터 마지막 수까지 순서대로 아래 세 가지 중에 한 방법을 이용해 데크에 넣어야 한다.

수를 존재하는 데크중 하나의 맨 앞에 넣는다.
수를 존재하는 데크중 하나의 맨 뒤에 넣는다.
새로운 데크를 만들어서 그 곳에 수를 넣는다.

위의 방법을 이용해서 모든 수를 적절히 데크에 넣은 다음, 모든 데크를 적절히 이어 붙여 오름차순으로 만들려고 한다. 이때, 필요한 데크 개수의 최솟값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 수의 개수 N이 주어진다. N은 1,000보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 수가 한 줄에 하나씩 주어진다. 각 수는 -1,000보다 크거나 같고, 1,000보다 작거나 같은 정수이다. 수가 중복될 수도 있다.
<출력값>
첫째 줄에 데크 소트를 할 때, 필요한 데크의 최소 개수를 출력한다.

<문제 1626>
방향성이 없는 그래프 G가 주어진다. 문제는 G의 최소 스패닝 트리보다는 크면서 가장 작은 스패닝 트리인 'The second minimum spanning tree'를 구하는 것이다.

MST와 second MST의 모습
<입력값>
첫째 줄에 그래프의 정점의 수 V(1 ≤ V ≤ 50,000)와 간선의 수 E(1 ≤ E ≤ 200,000)가 들어온다. 둘째 줄부터 E+1번째 줄까지 한 간선으로 연결된 두 정점과 그 간선의 가중치가 주어진다. 가중치는 100,000보다 작거나 같은 자연수 또는 0이고, 답은 231-1을 넘지 않는다.
정점 번호는 1보다 크거나 같고, V보다 작거나 같은 자연수이다.
<출력값>
두 번째로 작은 스패닝 트리의 값을 출력한다. 만약 스패닝 트리나 두 번째로 작은 스패닝 트리가 존재하지 않는다면 -1을 출력한다.

<문제 1627>
동물원에서 막 탈출한 원숭이 한 마리가 세상구경을 하고 있다. 그러다가 자기의 영원한 숙적인 멍멍이를 만나게 되었다. 외나무다리에서 만난 그들... 이제 둘의 피할 수 없는 결투가 펼쳐진다!!
원숭이와 멍멍이의 결투는 N칸의 게임보드에서 펼쳐진다. 처음에 N칸의 보드에는 아무것도 없다. 그리고는 둘이 번갈아가면서 각 칸에 뷁표시를 한 번씩 한다. 그러다가 연속해서 3개 이상 뷁표시를 만드는 사람이 이기게 되는 게임이다.
원숭이와 멍멍이가 처음 상태에서 어느 정도 게임을 진행하였다. 그러다 원숭이는 도저히 전략을 세울 수 없어서 여러분에게 도움을 요청하였다. 현재 원숭이차례인 게임보드의 상태가 주어졌을 때, 원숭이가 이길 수 있는지, 이길 수 있다면 이기는 방법을 구하는 프로그램을 작성하시오. 원숭이와 멍멍이는 각자 최선을 다해 결투를 벌인다.
<입력값>
첫째 줄에 게임보드의 크기 N이 주어진다. N은 3이상 3,000이하인 자연수이다. 그 다음 줄에 현재 게임보드의 상태가 주어진다. 빈칸은 ‘.’, 뷁표시는 ‘P’로 주어진다.
<출력값>
첫째 줄에 원숭이의 승패를 출력한다. 이길 수 있다면 “WINNING"을, 이길 수 없다면 "LOSING"을 출력한다. 이길 수 있다면 그 다음 줄에 이기는 방법을 출력한다. 원숭이가 현재 차례에 뷁표시를 놓아서 이길 수 있는 곳을 오름차순으로 출력한다. 이길 수 없다면 출력하지 않는다.

<문제 1628>
음 아닌 정수들로 이루어진 두 개의 집합 S와 T가 있다. S의 원소들과 T의 원소들을 짝지으려고 하는데, 다음과 같은 규칙을 만족하도록 하고 싶다.

S의 임의의 원소 s는 T의 어떤 원소와도 짝지어질 수 있다. 또한 T의 임의의 원소 t도 S의 어떤 원소와도 짝지어질 수 있다.
S의 모든 원소는 적어도 하나의 T의 원소와는 짝지어져야 하고, T의 모든 원소 역시 적어도 하나의 S의 원소와는 짝지어져야 한다.

예를 들어 S={2, 8, 9, 10, 11}, T={0, 3, 4, 6, 7, 11}을 보자. {(2, 0), (2, 3), (2, 4), (8, 6), (9, 7), (10, 11), (11, 11)}은 규칙을 만족하는 경우가 된다. 하지만 {(2, 0), (8, 3), (9, 4), (10, 6), (11, 7)}은 규칙을 만족하는 경우가 아닌데, T의 원소 11이 S의 어떤 원소와도 짝지어지지 않았기 때문이다.
각각의 짝 (a, b)의 비용이란, a와 b의 차이의 절댓값으로 정의된다. 우리는 모든 비용의 합을 최소로 하도록 S의 원소들과 T의 원소들을 짝지으려 한다. 위에서 주어진 S와 T에 대해서는 10이 최소의 비용합이 된다.
S와 T가 주어지면, 모든 비용의 합을 최소로 하도록 S의 원소들과 T의 원소들을 짝지어 주는 프로그램을 작성하시오.
<입력값>
첫째 줄에 S의 원소의 개수와 T의 원소의 개수가 빈 칸을 사이에 두고 주어진다. 둘째 줄에는 S의 원소, 셋째 줄에는 T의 원소가 첫째 줄에 주어진 개수만큼 빈 칸을 사이에 두고 증가하는 순서대로 주어진다. 각 집합의 원소의 크기는 50,000 이하의 자연수이며, 주어지는 수는 0 이상 100,000 이하의 정수이다.
<출력값>
첫째 줄에 최소의 비용합을 출력한다.

<문제 1629>
자연수 A를 B번 곱한 수를 알고 싶다. 단 구하려는 수가 매우 커질 수 있으므로 이를 C로 나눈 나머지를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 A, B, C가 빈 칸을 사이에 두고 순서대로 주어진다. A, B, C는 모두 2,147,483,647 이하의 자연수이다.
<출력값>
첫째 줄에 A를 B번 곱한 수를 C로 나눈 나머지를 출력한다.

<문제 1630>
오민식을 만족하는 수: 1보다 크거나 같고, N보다 작거나 같은 모든 자연수로 나누어 떨어지는 수.
영식이와 다솜이는 N이 주어졌을 때, 오민식을 만족하는 가장 작은 수가 궁금해졌다. 그 수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 자연수 N이 주어진다. N은 1,000,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 주어진 입력에 대해 오민식을 만족하는 가장 작은 자연수를 987654321로 나눈 나머지를 출력한다.

<문제 1631>
오영식의 보물은 베트남의 하노이에 있는 하노이 탑(Tower of Hanoi)의 모형이다. 하노이 탑은 3개의 막대로 이루어져 있다. 막대는 왼쪽부터 차례대로 A, B, C로 이름이 매겨져 있고, N개의 디스크로 이루어져있다. N개의 디스크 크기는 1부터 N으로 차례대로 이루어져있다. 처음에 모든 디스크들은 막대 A에 놓여져있다. 디스크는 크기가 큰 것이 반드시 크기가 작은 것의 밑에 있어야 한다. 따라서 처음에는 모두 막대 A의 가장 아래에 N크기의 디스크가 있고, 가장 위에는 1크기의 디스크가 있다. 디스크를 이동할 때는 한 번에 하나씩만 이동할 수 있다.
민식이는 영식이랑 같이 하노이 탑을 이동시키면서 놀고 싶었다. 마침 둘은 처음 상태에서 모든 디스크를 C로 이동시키는 게임을 너무 많이 했기 때문에, 새로운 규칙이 필요했다. 마침 민식이의 근처에 살던 다솜이는 새로운 규칙을 만들어 주었다. 일단 다솜이가 규칙에 맞게 적절히 이동한 상태를 보여준다. 그럼 두 사람이 그 상태로 최소 이동횟수로 이동시켜야 한다. 그 최소 이동횟수의 방법대로 M번 움직였을 때, 하노이탑의 상태를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 디스크의 개수 N과 움직여야하는 횟수 M이 주어진다. 둘째 줄에 이동해야하는 다솜이가 규칙에 맞게 적절히 이동한 상태가 문자열로 주어진다. 모든 문자는 A, B, C중 하나이며, 그 문자열의 0번째 원소는 1번 디스크가 있는 위치, 1번째 원소는 2번째 디스크가 있는 위치와 같은 순서이다. i번째 원소는 i+1번째 디스크가 있는 위치이다. N은 30보다 작거나 같은 자연수이고, M은 0보다크거나 같고, m보다 작거나 같은 자연수이다. m은 입력으로 주어진 상태로 만드는데 드는 최소 이동 횟수이다.
<출력값>
첫째 줄에 입력으로 주어진 것과 같은 형식으로 하노이탑의 상태를 출력한다.

<문제 1632>
동물원에서 막 탈출한 원숭이 한 마리가 세상구경을 하고 있다. 그는 수학을 매우 좋아하는 원숭이였다. 그래서 그는 N개의 직선을 가지고 기발한 문제를 생각해냈다.
문제는 이렇다. 좌표평면상에 N개의 직선과 상수 K가 주어진다. 직선은 모두 fi(x) = ai * x + bi의 꼴로 나타낼 수 있다. 그랬을 때 함수 g(x)를 {f1(x), f2(x), ..., fN(x)}의 중간값으로 정의하면, g(x) = K가 되는 x를 모두 찾는 문제이다.
<입력값>
첫째 줄에 직선의 개수 N과 상수 K가 주어진다. N은 3이상 1,000,000이하인 홀수이고, K는 -100,000이상 100,000이하인 정수이다. 그 다음 줄부터 각 줄마다 두 개의 정수 ai, bi (0 ≤ ai ≤ 1,000,000, -1,000,000 ≤ bi ≤ 1,000,000) 가 주어진다. 중복되는 직선은 없다.
<출력값>
첫째 줄에 g(x) = K 인 x의 구간의 시작과 끝을 출력한다. 각 수는 소수점 넷째자리에서 반올림하여 출력한다. 만약 x가 무한대로 발산하는 경우, 양의 무한대는 +inf, 음의 무한대는 -inf 로 출력하면 된다. g(x) = K를 만족하는 x가 존재하지 않는다면 "impossible"을 출력하면 된다. 답이 되는 구간이 1개 이하인 경우만 입력으로 들어온다.

<문제 1633>
꿍 협회는 매년 세계체스대회에 나갈 팀을 만들고 있다. 팀은 흑으로 플레이하는 15명과 백으로 플레이하는 15명, 총 30명으로 이루어진다. 꿍 협회는 가능한 최고의 팀을 만들려고 하는데 각 플레이어의 흑,백 능력치는 각각 1부터 100까지의 정수로 주어진다. 대회가 진행되는 동안 플레이어는 흑, 백 중 한 가지만으로 참여를 해야하며 팀의 전체 능력치는 흑 플레이어의 능력치를 합한것과 백 플레이어의 능력치를 합한것을 모두 더한 값이다. 어떻게 하면 꿍 협회는 가능한 높은 능력치의 팀을 만들수 있을까.
<입력값>
입력은 각 플레이어들의 능력치로 이루어진다. 각 줄은 공백으로 구분되는 두 개의 정수로 주어진다. 첫 번째 숫자는 해당 플레이어가 백으로 플레이를 할 때 능력치고 두 번째 숫자는 흑으로 플레이를 할 때의 능력치다. 최소한 30줄 이상이며 1000줄은 넘지 않는다.
<출력값>
꿍 협회가 만들 수 있는 팀 중 가장 큰 능력치를 갖는 팀의 능력치를 출력한다.

<문제 1634>
‘k-레벨 완전 이진 트리’는 모든 노드의 분지수(차수)가 0이거나 혹은 2이고, 레벨 1에 있는 노드 수가 2^0, 레벨 2에 있는 노드수가 2^1, ... , 레벨 k에 있는 노드 수가 2^(k-1)이며, 총 노드 수는 2^k-1인 이진 트리를 말한다. 두 개의 k-레벨 완전 이진 트리 T1과 T2가 있고, 각 트리의 단말 노드들, 즉 레벨 k의 노드들에 대하여 L={1,2,...,N}에 속하는 서로 다른 정수들이 할당되어 있다. 다음 조건을 만족하는 L의 부분 집합 s를 찾는 프로그램을 작성하시오.

S에 속하는 모든 쌍의 정수 x, y에 대하여 T1과 T2에서 x가 할당된 노드와 y가 할당된 노드 사이의 거리가 서로 같다. 두 노드 사이의 거리는 두 노드를 잇는 경로가 지나는 에지의 수이다.
S에 속한 원소의 수는 반드시 최대이어야 한다.


왼쪽 그림이 T1, 오른쪽 그림이 T2이다.
예를 들어, k = 4인 경우에 아래 그림과 같이 단말 노드에 정수가 할당된 두 트리 T1과 T2가 주어져 있다고 하자. 두 트리 T1과 T2의 단말 노드들에 할당된 수들을 왼쪽에서 오른쪽으로 차례대로 쓴 것이 각각 (4, 2, 1, 3, 6, 7, 5, 8)과 (2, 7, 4, 8, 3, 1, 6, 5)라고 하자. 이 경우에 구하고자 하는 답은 S = {1, 3, 7, 8}이다. 예를 들어, S에 속하는 한 쌍의 정수 3, 7에 대하여 T1과 T2에서 3이 할당된 노드와 7이 할당된 노드 사이의 거리가 6으로 서로 같다.
<입력값>
첫줄에 두 트리 T1과 T2의 레벨 k (1<=k<=12)가 주어진다. 둘째 줄에 T1의 단말 노드들에 할당된 수들이 왼쪽에서 오른쪽으로 차례로 주어진다. 셋째 줄에 T2의 단말 노드들에 할당된 수들이 왼쪽에서 오른쪽으로 차례로 주어진다.
<출력값>
첫 줄에 주어진 조건을 만족하는 최대 집합 에 속하는 원소의 수를 출력한다.

<문제 1635>
1 또는 -1로 이루어진 길이 N의 수열이 있다.예를 들어 N이 4인 경우, { -1, 1, -1, -1 } 또는 { 1, 1, -1, 1 } 등이 이에 해당된다.
수열을 이루고 있는 모든 수들의 합을 "수열값"이라고 한다. 위에서 예로 든 { -1, 1, -1, -1 } 의 수열값은 -2, { 1, 1, -1, 1 } 의 수열값은 2이다.
두 수열의 곱을 다음과 같이 정의해볼 수 있다. 수열을 이루는 수들을 차례로 곱하는 것이다. 예를 들어 { -1, 1, -1, -1 } 과 { 1, 1, -1, 1 } 의 곱은 { -1, 1, 1, -1 } 이 되는 것이다. 곱셈을 통해 만들어진 이 수열의 수열값은 0이 된다.
M개의 수열 a1,a2,...,aM이 주어졌다. 각각의 ai는 1 또는 -1로 이루어진 길이 N인 수열이다. 이때, 모든 수열 에 대해 적절히 대응되는 수열 bi를 찾아, 두 수열을 곱한 결과 나타나는 수열의 수열값이 0이 되도록 하려고 한다. 즉, ai가 { -1, 1, -1, -1 } 일 때, 위의 조건을 만족하는 bi로는 { 1, 1, -1, 1 }, { 1, -1, -1, -1 } 등이 있다.
단순히 M개의 bi를 구하는 것은 그리 어려운 일이 아니다. 따라서 우리는 N개 이하의 수열만을 가지고 모든 bi를 표현하려 한다. 즉 수열  b1,b2,..bM중 중복되는 것을 제외하고 서로 다른 것들의 개수가 N개 이하가 되도록 모든 bi들을 만들고 싶다.
M개의 수열이 주어졌을 때, N개 이하 종류의 수열을 이용하여 조건을 만족하는 bi들을 찾는 프로그램을 작성하시오. N이 홀수인 경우 수열값이 0이 되지 않으므로, N이 짝수인 경우만을 생각하기로 한다.
<입력값>
첫째 줄에 두 정수 N과 M이 빈 칸을 사이에 두고 주어진다. (2≤N≤100, N은 짝수, 1≤M≤10,000) 이어서 M개의 줄에 걸쳐 수열 a1,a2,...,aM이 한 줄에 하나씩 주어진다. 각 줄에는 1 또는 -1의 정수가 빈 칸을 사이에 두고 N개씩 주어지게 된다.
<출력값>
첫째 줄부터 M개의 줄에 걸쳐 구하고자 하는 수열 b1,b2,...,bM을 한 줄에 하나씩 출력한다. 즉 각 줄에 1 또는 -1의 정수를 빈 칸을 사이에 두고 N개씩 출력해야 한다. 반드시 N개 이하의 수열만을 가지고 모든 bi가 표현되어야 한다. 답이 여러 가지일 수 있으므로 아무 것이나 하나 출력하면 된다. 항상 가능한 경우만이 입력으로 주어진다.

<문제 1637>
동물원에서 막 탈출한 원숭이 한 마리가 세상구경을 하고 있다. 그 원숭이는 좀 특이한 원숭이였다. 어떤 것도 꿰뚫어볼 수 있는 날카로운 눈을 가진 기이한 원숭이였다. 부드러운 눈을 가진 멍멍이는 언제나 날카로운 눈을 가진 원숭이를 부러워했지만 한편으로는 매우 질투했다.
어느 날 멍멍이는 원숭이의 날카로운 눈이 너무 샘나서 원숭이를 직접 패고 싶었지만 날카로운 눈으로 찌를까봐 무서워서 때리지는 못하고 대신, 원숭이에게 문제 하나를 던져주었다. 그 문제는 다음과 같다.
정수가 여러 개 모여 있는 정수더미가 있다. 그 안에 어떤 특정한 정수 하나만 홀수개 존재하고 나머지 정수는 모두 짝수개 존재한다. 정수더미 속에서 날카로운 눈을 이용해 홀수개 존재하는 정수를 찾아야 하는 문제이다.
근데 멍멍이가 문제를 전달해 주려다가 생각해보니 정수더미 안에 정수가 적게 있으면 문제가 너무 쉬워지게 되는 것이다. 그래서 정수더미안에 정수를 무지막지하게 많이 넣기로 했다. 정수더미가 주어졌을 때, 그 안에 홀수개 존재하는 정수를 찾는 프로그램을 작성하시오.
<입력값>
첫째 줄에 입력의 개수 N이 주어진다. N은 1이상 20,000이하인 수이다. 그 다음 줄부터 N줄에 걸쳐 세 개의 정수 A, C, B가 주어지는데, 이것은 A, A+B, A+2B, ..., A+kB (단, A+kB ≦ C) 의 정수들이 정수더미 안에 있다는 것을 나타낸다. A, B, C는 1보다 크거나 같고 2,147,483,647보다 작거나 같은 정수이다. 정수더미는 N개의 입력이 나타내는 정수들을 모두 포함한다.
<출력값>
첫째 줄에 정수 두 개를 출력하는데, 첫 번째는 홀수개 존재하는 정수를 출력하고, 두 번째는 그 정수가 몇 개 들어있는지 출력한다. 만약 홀수개 존재하는 정수가 없다면 NOTHING을 출력한다.

<문제 1638>
종혁이는 (0, 0)과 (m, n)을 모서리로 하는 직사각형을 가지고 있다. 종혁이는 직사각형의 내부에 볼록 다각형을 만들고 싶은데, 볼록 다각형의 모든 점은 정수 좌표를 가져야 한다. 모든 점은 직사각형의 내부에 존재할 수도 있고, 직사각형의 경계에 존재할 수도 있다.
직사각형의 크기가 주어질 때, 종혁이가 만들 수 있는 볼록 다각형 중 점의 개수가 가장 큰 것을 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 직사각형의 크기 M과 N이 공백을 사이에 두고 주어진다. M과 N은 3보다 크거나 같고, 200보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 종혁이가 만들 수 있는 볼록 다각형중 점의 개수의 최댓값을 출력한다.

<문제 1639>
프로야구단 다숌 자이언츠에서는 야구장에 오는 손님에게 티켓을 나누어준다. 그리고 나서 그 티켓 중에 다음과 같은 규칙을 가진 티켓을 행운의 티켓이라고 하며, 그 티켓을 가진 사람들에게 상품을 나누어준다.
행운의 티켓은 정확하게 2*N자리로 이루어진 티켓이다. 왼쪽 N자리의 합과 오른쪽 N자리의 합이 일치하면 그 티켓은 행운의 티켓이라고 한다.
숌은 티켓 번호를 조작하려고 한다. 어떤 문자열이 주어지면, 그 문자열의 연속된 부분 문자열중 행운의 티켓 규칙을 만족하는 최대 부분 문자열의 길이를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 문자열 S가 주어진다. 문자열 S는 1보다 크거나 같고, 9보다 작거나 같은 수만 입력으로 들어오며, 문자열의 길이는 100보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 주어진 입력의 연속된 부분 문자열 중 행운의 티켓 규칙을 만족하는 부분 문자열의 최대 길이를 출력하시오. 찾을 수 없다면 0을 출력한다.

<문제 1640>
영식이는 밑에 슈퍼에 가서 매일매일 시도때도 없이 과자를 사먹는다. 그러다보니 자연스럽게 동전이 많아졌다. 민식이가 놀아주지않아서 자연스럽게 왕따가된 영식이는 동전들을 N×M모양으로 배열하고 뒤집는 놀이를 하려고 한다. N과 M은 모두 홀수이다.
편의상 동전의 앞면을 0, 뒷면을 1이라고 한다.
한번 뒤집기를 할 때, 영식이는 어떤 열과 행 중에 하나를 고를 수 있다. 그리고나서 뒤집는 행동을 할 때는, 고른 열이나 행에 있는 모든 동전을 뒤집어야 한다. 0은 1이 되고 1은 0이 된다는 소리다.
영식이는 동전을 열심히 뒤집어서 각 열과 행에있는 1의 개수를 모두 짝수개로 맞추려고 한다.
영식이가 동전을 뒤집어야하는 횟수의 최솟값을 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 영식이가 동전을 놓은 세로 크기 N과 가로크기 M이 주어진다. N과 M은 1,000보다 작거나 같은 홀수이다. 둘째 줄부터 총 N개의 줄에 영식이가 각각의 줄에 M개의 동전을 놓은 방법이 주어진다.
<출력값>
첫째 줄에 각각의 열과 행에 동전 뒷면의 개수를 모두 짝수로 만들려고 할 때 해야하는 행동의 최솟값을 출력한다. 만약 각각의 열과 행의 동전 뒷면의 개수를 모두 짝수로 만들 수 없다면 -1을 출력한다.

<문제 1641>
텍스트 블록에 채워진 삼각형 형태의 패턴이 나타날 수 있다. 일반적인 삼각형은 (a)와 같은 2등변 직각 삼각형이거나, (각 변은 2차원 어디에든, 어느 방향으로든 놓일 수 있다.) 
(a)
(b)와 같은 2등변 삼각형이다. (마찬가지로 각 변은 어디에든 놓일 수 있다.)

삼각형의 한 변의 길이는 2 이상이어야 한다. 하나의 글자로만 이루어진 삼각형은 삼각형으로 취급하지 않아 세지 않는다.
문제는 주어진 텍스트 블록에서 위의 조건을 만족하는 삼각형의 개수를 세는 것이다.
<입력값>
첫째 줄에 정사각형 행렬의 행의 수와 열을 수를 나타내는 정수 N(1≤N≤500)이 주어진다. 두 번째 줄부터 N+1번째 줄까지 텍스트 블록에 대한 정보를 나타내는 영문 대문자 N개로 구성된 문자열이 한 줄에 하나씩 주어진다.
<출력값>
첫째 줄에 삼각형의 총 개수를 출력한다.

<문제 1642>
강원도 횡성에는 엄청나게 큰 나무 두 개가 마주보고 있다. 이 나무의 기둥에는 수많은 구멍들이 있고, 수많은 딱따구리들이 이 구멍에서 서식하기 위해 몰려들었다. 하나의 구멍에는 한 마리의 딱따구리만이 서식할 수 있고 비어있는 구멍도 있을 수 있다. 이들 중 몇몇 두 딱따구리는 친밀한 관계를 유지하여 이들의 서식지를 왔다 갔다 한다. 하지만 딱따구리는 워낙 빨리 이동하기 때문에 충돌의 위험을 줄이기 위해 몇몇 규칙으로 딱따구리의 서식지를 배정하려 한다.⑴ 딱따구리의 이동경로는 직선이다.
⑵ 친밀한 관계를 가지는 두 딱따구리는 서로 다른 나무에 서식하고 있어야한다.
⑶ 친밀한 관계를 가지는 딱따구리의 서식지를 연결하는 선분끼리 교차하면 안 된다. (단, 끝점 즉 서식지는 공유해도 상관없다)
딱따구리는 가능한 한 낮은 곳에 위치한 구멍에서 서식하기를 원한다. 또한 각각의 나무에 있는 구멍의 수는 딱따구리의 수보다 크다. 문제는 이러한 조건을 만족하는 서식지 배정의 가짓수를 구하는 것이다.
<입력값>
첫째 줄에 새들의 숫자를 나타내는 N(1≤N≤1,000,000), 친밀한 관계를 유지하는 딱따구리 쌍의 수를 나타내는 M(1≤M≤10,000,000), 결과를 나눌 제수 K(1≤K≤2000,000)가 공백으로 구분되어 주어진다. 새들은 1번부터 N번까지 번호가 붙여져 있고 두 번째 줄부터 M+1번째 줄까지 각 줄에 친밀한 관계를 가지는 딱따구리의 번호가 공백으로 구분되어 주어진다.
<출력값>
첫째 줄에 서식지 배정의 가짓수 R을 K로 나눈 나머지를 출력한다. 서식지를 배정할 수 없는 경우는 0을 출력한다.

<문제 1643>
신기한 마이마이의 치킨박스 하나를 사면 1부터 N까지의 숫자 중 하나가 적힌 쿠폰 한 개를 준다.
해빈이는 골드치즈치킨을 매우 좋아한다. 1부터 N까지의 쿠폰들을 모두 모아야 골드치즈치킨 하나를 주문할 수 있다고 할 때, 해빈이는 신기한 마이마이의 치킨박스를 평균적으로 얼마나 많이 주문해야 하는가?
<입력값>
쿠폰에 적힐 숫자의 범위(1≤N≤22)가 여러 줄에 걸쳐서 주어진다.
<출력값>
각 입력에 대해 해빈이가 주문해야할 치킨박스의 수를 출력한다. 만약 답이 정수라면 그대로 출력한다. 답이 정수가 아니라면 정수부분을 출력하고, 공백하나를 출력한 다음, 아래에 보인 형식대로 적절히 정수를 뺀 나머지 값을 기약분수를 출력한다. 불필요한 공백은 출력하지 않는다.

<문제 1644>
하나 이상의 연속된 소수의 합으로 나타낼 수 있는 자연수들이 있다. 몇 가지 자연수의 예를 들어 보면 다음과 같다.

3 : 3 (한 가지)
41 : 2+3+5+7+11+13 = 11+13+17 = 41 (세 가지)
53 : 5+7+11+13+17 = 53 (두 가지)

하지만 연속된 소수의 합으로 나타낼 수 없는 자연수들도 있는데, 20이 그 예이다. 7+13을 계산하면 20이 되기는 하나 7과 13이 연속이 아니기에 적합한 표현이 아니다. 또한 한 소수는 반드시 한 번만 덧셈에 사용될 수 있기 때문에, 3+5+5+7과 같은 표현도 적합하지 않다.
자연수가 주어졌을 때, 이 자연수를 연속된 소수의 합으로 나타낼 수 있는 경우의 수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 자연수 N이 주어진다. (1 ≤ N ≤ 4,000,000)
<출력값>
첫째 줄에 자연수 N을 연속된 소수의 합으로 나타낼 수 있는 경우의 수를 출력한다.

<문제 1645>
서울 관악구 신림동에 살고 있는 성지의 생일이 3일 앞으로 다가왔다. (황성지 아닙니다!) 일요일에서 월요일이 되는 12시 정각, 902호에서 자음 퀴즈의 달인 성지의 생일을 기념하는 성대한 파티가 열릴 예정이다. N명의 학생이 참석하기를 원하며, 넘을 수 없는 4차원 세계에 살고 있는 성지는 물론 참석한다.
모든 학생은 자신이 파티에 초대될 것이라 굳게 믿고 있으며, 자신과 순수한 소년 성지를 제외하고 적어도 k명의 학생은 참석해야 한다고 굳게 믿고 있다.
생일빵을 두려워하기 때문일까? 띄어쓰기를 잘 못하는 성지는 가능하면 학생들을 적게 초대하고 싶다는 의사를 밝혔다. 하지만 사려깊은 성지는 학생들의 생각 (자신과 성지를 제외하고 적어도 k명의 학생은 참석해야 한다는) 을 모두 만족시키기를 원한다.
학생의 수 N과 각 학생들이 생각하는 k값이 모두 주어졌을 때, 학생들의 생각을 모두 만족시키면서 초대할 수 있는 최소의 학생 수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 학생의 수 N이 주어진다. (1≤N≤10,000) 이어서 N개 줄에 걸쳐 각 학생이 생각하는 k 값이 주어진다.
<출력값>
첫째 줄에 학생들을 만족시키면서 초대할 수 있는 최소 학생 수를 출력한다.

<문제 1646>
0번째와 1번째 피이보나치 트리는 단일 노드로 이루어져 있다. 1보다 큰 모든 i번째 피이보나치 트리는 다음과 같은 방법을 통해 만들 수 있다.
1. 새로운 노드 r을 만든다. 이 노드는 i번째 피이보나치 트리의 루트가 된다.
  2. (i-1)번째와 (i-2)번째 피이보나치 트리를 만든다.
  3. (i-2)번째 피이보나치 트리를 노드 r의 왼쪽 부분 트리로 만든다.
  4. (i-1)번째 피이보나치 트리를 노드 r의 오른쪽 부분 트리로 만든다.
피이보나치 트리의 정점의 개수는 정말 빠르게 증가한다. 예를 들어, 50번째 피이보나치 트리는 약 4*10^10개의 정점을 가지고 있다.
피이보나치 트리의 정점에 번호를 매기는 순서는 트리를 전위순회할 때 방문하는 순서대로 번호를 매긴다.
예를 들어, 3번째 피이보나치 트리는 다음과 같다.

N과 시작 위치와 도착 위치가 들어오면, N번째 피이보나치 트리에서 시작 위치에서 도착 위치로 가는 최단 경로를 구하는 프로그램을 작성하시오. 각 노드사이의 거리는 1이다.
<입력값>
첫째 줄에 N과 시작 위치와 도착 위치가 공백을 사이에 두고 주어진다. N은 50보다 작거나 같은 자연수 또는 0이다. 시작 위치와 도착 위치는 1,000,000,000보다 작거나 같으며, N번째 피이보나치 트리의 정점의 수보다 작거나 같은 자연수이다. 시작 위치와 도착 위치는 서로 다른 수이다.
<출력값>
첫째 줄에 시작 위치부터 도착 위치로 가는 최단 경로를 찾는다. L은 왼쪽 자식으로 이동하는 것이고, R은 오른쪽 자식으로 이동하는 것이고, U는 부모로 이동하는 것이다.

<문제 1647>
동물원에서 막 탈출한 원숭이 한 마리가 세상구경을 하고 있다. 그러다가 평화로운 마을에 가게 되었는데, 그곳에서는 알 수 없는 일이 벌어지고 있었다.
마을은 N개의 집과 그 집들을 연결하는 M개의 길로 이루어져 있다. 길은 어느 방향으로든지 다닐 수 있는 편리한 길이다. 그리고 각 길마다 길을 유지하는데 드는 유지비가 있다.
마을의 이장은 마을을 두 개의 분리된 마을로 분할할 계획을 가지고 있다. 마을이 너무 커서 혼자서는 관리할 수 없기 때문이다. 마을을 분할할 때는 각 분리된 마을 안에 집들이 서로 연결되도록 분할해야 한다. 각 분리된 마을 안에 있는 임의의 두 집 사이에 경로가 항상 존재해야 한다는 뜻이다. 마을에는 집이 하나 이상 있어야 한다.
그렇게 마을의 이장은 계획을 세우다가 마을 안에 길이 너무 많다는 생각을 하게 되었다. 일단 분리된 두 마을 사이에 있는 길들은 필요가 없으므로 없앨 수 있다. 그리고 각 분리된 마을 안에서도 임의의 두 집 사이에 경로가 항상 존재하게 하면서 길을 더 없앨 수 있다. 마을의 이장은 위 조건을 만족하도록 길들을 모두 없애고 나머지 길의 유지비의 합을 최소로 하고 싶다. 이것을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 집의 개수N, 길의 개수M이 주어진다. N은 2이상 100,000이하인 정수이고, M은 1이상 1,000,000이하인 정수이다. 그 다음 줄부터 M줄에 걸쳐 길의 정보가 A B C 세 개의 정수로 주어지는데 A번 집과 B번 집을 연결하는 길의 유지비가 C (1 ≤ C ≤ 1,000)라는 뜻이다.
<출력값>
첫째 줄에 없애고 남은 길 유지비의 합의 최솟값을 출력한다.

<문제 1648>
준규는 침대에 누워서 천장을 바라보고 있었다. 천장은 격자판 모양이었고, 계속해서 천장을 바라보다 보니 이런 생각이 들었다.
세로 크기가 N이고, 가로 크기가 M인 격자판을 2x1 크기의 도미노를 이용해서 빈 공간이 없도록 채우는 방법의 수는 몇일까?
아래 그림은 N = 3, M = 6인 예이다.

N과 M이 주어졌을 때, 격자판을 2x1크기의 도미노로 채우는 방법의 수를 구하는 방법을 작성하시오. 도미노는 회전시켜 1x2크기로 채울 수 있다. 도미노로 모두 채웠을 때, 빈 칸이 존재하면 안 된다.
<입력값>
첫째 줄에 격자판의 세로 크기 N과 가로 크기 M이 주어진다. (1 ≤ N, M ≤ 14)
<출력값>
첫째 줄에 주어진 격자판을 2x1크기의 도미노로 빈 공간이 없도록 채우는 방법의 수를 9901로 나눈 나머지를 출력한다.

<문제 1649>
서울에서 민승이는 택시운전을 하고 있다. 서울은 1부터 N번까지 숫자로 붙여진 N개의 교차로로 구성되어있다. 그리고 어떤 교차로들은 도로로 연결되어 있는데 이 도로는 너무 좁아서 일방통행만이 가능하다. 민승이는 오랜 택시 경험상 어떤 교차로에서 출발해서 다시 그 교차로로 돌아올 수 없고, 어떠한 교차로 사이에도 두 개 이상의 도로가 없다는 것을 알고 있다.
어느 날 교차로 A에서 민승이는 한 명의 승객을 태웠다. 그리고 그 승객은 그에게 교차로 B로 가자고 했다. 단 그는 몇몇 사람들과 미팅을 갖기 위해 드라이브 도중 교차로 C1, C2, …, Ck를 거쳐야 한다. 단 이 중간 교차로들의 방문 순서는 중요하지 않다. 민승이는 위의 드라이브 조건을 만족하는 경로가 여럿 존재한다는 것을 깨달았지만 얼마나 많은지가 궁금해졌다.
<입력값>
첫 번째 줄에 교차로의 개수인 N(1<=N<=1,000)과 도로의 개수 M이 주어진다. 그 다음 M개에 줄에는 도로의 정보를 알려주는 시작점과 끝점이 주어진다. 다음 줄에는 시작점 A와 끝점 B, 그리고 방문해야할 중간 지점의 개수 K개 주어진다. 마지막 줄에는 공백을 구분으로 C1, C2, …, Ck가 차례대로 주어진다.
<출력값>
첫 번째 줄에 조건을 만족하는 경로의 개수 S를 출력한다. (경로가 존재하지 않을 경우엔 0을 출력한다.) 단 S가 2,000,000,000이 넘는 입력은 주어지지 않는다고 가정하자.

<문제 1650>
지민이는 대지주 정문이 집에 놀러갔다. 하지만 테러리즘에 빠져있는 지민이는 가방 속에 한가득 지뢰를 들고 정문이 농장에 놀러 갔다.
이런 속마음도 모르는 정문이는 지민이에게 자신이 관리하는 N개의 농장을 관광시켜주려 한다. N개의 농장은 1번부터 N번까지 번호가 붙여져 있고 이 농장 사이에는 M개의 도로가 놓여있다.
현재 지민이와 정문이는 1번 농장에 있고 N번 농장을 방문한 다음 1번 농장으로 다시 돌아오려 한다. 그리고 방문하는 동안 지민이는 자신이 지나간 길에 지뢰를 심으려 한다.
지민이가 지뢰를 심는 사실이 발각되면 심각한 상황에 놓일 수 있기 때문에 가능한 한 빨리 농지를 관광하고 돌아오려 한다. 하지만 이미 지나간 길은 지뢰가 놓여 있기 때문에 다시 그 길을 지나가기를 원치 않는다.
지민이는 각 길마다 그 길을 지나가는 시간이 주어졌을 때 최소로 농지를 관광하고 돌아오는 시간을 알고 싶어 한다.
<입력값>
첫째 줄에는 자연수 N(3 ≤ N ≤ 1,000), M(2 ≤ M ≤ 10,000)이 주어진다. N은 농지의 개수이고 M은 도로의 개수를 나타낸다. 다음 M개의 줄에는 도로의 정보를 나타내는 세 자연수 P, Q, L(1 ≤ L ≤ 35,000)이 주어진다. 이는 P번 도시와 Q번 도시 사이에 도로가 있으며, 이를 지날 때 소요되는 시간이 L임을 의미한다.
항상 농지를 관광하고 돌아올 수 있는 경우만 입력으로 주어진다.
<출력값>
첫째 줄에 농지를 관광하는 최소 시간을 출력한다.

<문제 1651>
영식이는 민식이가 괴롭힐 때, 동생 하영이에게 문자메시지를 보내서 도움을 요청한다. 민식이는 영식이의 이러한 행동을 알아채고 영식이의 모든 문자메시지를 감시하기 시작했다. 영식이는 동생과의 문자메시지를 민식이에게 들키기 싫어서 무엇인가 비밀 코드를 만들고 싶어했다. 마침 영식이의 왼쪽, 왼쪽 자리에 앉아있는 다솜이가 새로운 문자열 인코딩 방법을 개발했다. 다솜이의 새로운 문자열 인코딩 방법으로 문자열을 코드로 변환한 것을 숌 코드라고 한다.
숌 코드는 숌 코드 인코딩방법으로 문자를 코드로 바꾼다. 인코딩 방법은 알파벳의 집합 S가 주어졌을 때, 집합에 속하는 각 알파벳이 숌 코드에 일치하는 구조로 이루어져 있다. 이때, 어떤 알파벳과 코드를 연결시켜주는 함수를 이용한다고 생각하면 쉽다. 그리고, 코드는 항상 0과 1로만 이루어져 있다. 코드가 비어있을 수도 있다.
예를 들어 S={a,b,c,d}이고, 알파벳을 코드로 바꿔주는 함수 f과 다음과 같이 정의되어있다고 할 수 있다. f(a) = 1, f(b) = 1010, f(c) = 01, f(d) = 10101
함수 f 속에는 반드시 알파벳 한 글자만 들어가는 것이 아니라, 여러 문자가 계속해서 들어갈 수 있다. 이때, 함수는 주어진 문자열을 앞에서부터 차례대로 코드로 바꿔주어 이를 합치는 형식으로 작동한다. 따라서, 위의 예제에서 f(cac) = 01101이다.
만약 어떤 코드를 두 개의 문자열로 해석할 수 있으면, 이 코드를 애매한 코드라고 한다. 영식이는 애매한 코드를 사용하지 않는다고 한다.
만약 어떤 코드를 세 개 이상의 문자열로 해석할 수 있으면, 이 코드를 정말 애매한 코드라고 한다. 예를 들어, 위의 예제에서 애매한 코드는 10101이다. 10101은 ba, acc, d 로 해석할 수 있다.
입력으로 코드가 주어진다. 코드는 0과 1로만 이루어져 있다. 영식이는 어떤 문자열 S를 숌 코드 인코딩 방법을 이용해서 코드로 바꾸려고 한다. 다솜이가 개발한 인코딩방법은 아직 불완전하다. 다솜이가 할 일은 영식이가 코드로 인코딩해서 보낸 문자메시지의 내용을 3개 혹은 그 이상으로 문자열로 바꿀 수 있는지 확인하는 작업이다.
코드가 주어졌을 때, 3개 이상의 문자열로 바꿀 수 있는 숌 코드의 가장 짧은 길이를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 코드의 개수 N이 들어온다. 코드의 개수 N은 2보다 크거나 같고, 26보다 작거나 같은 자연수이다. 둘째 줄부터 한 줄에 하나씩 각각의 알파벳에 해당하는 코드가 입력으로 들어온다. 코드의 길이는 최대 50보다 작거나 같은 자연수 또는 0이다. 만약 코드의 길이가 0이라면 입력으로 -1이 들어온다. 코드는 반드시 0 또는 1만 포함하고 있다. 각각의 코드는 중복될 수 있다.
<출력값>
첫째 줄에 세 개 이상의 문자열로 해석할 수 있는 숌 코드의 최소 길이를 출력한다. 만약 그러한 코드가 없다면 -1을 출력한다.

<문제 1652>
일 년 동안 세계일주를 하던 영식이는 여행을 하다 너무 피곤해서 근처에 있는 코레스코 콘도에서 하룻밤 잠을 자기로 하고 방을 잡았다.
코레스코 콘도에 있는 방은 NxN의 정사각형모양으로 생겼다. 방 안에는 옮길 수 없는 짐들이 이것저것 많이 있어서 영식이의 누울 자리를 차지하고 있었다. 영식이는 이 열악한 환경에서 누울 수 있는 자리를 찾아야 한다. 영식이가 누울 수 있는 자리에는 조건이 있다. 똑바로 연속해서 2칸 이상의 빈 칸이 존재하면 그 곳에 몸을 양 옆으로 쭉 뻗으면서 누울 수 있다. 가로로 누울 수도 있고 세로로 누울 수도 있다. 누울 때는 무조건 몸을 쭉 뻗기 때문에 반드시 벽이나 짐에 닿게 된다. (중간에 어정쩡하게 눕는 경우가 없다.)

만약 방의 구조가 위의 그림처럼 생겼다면, 가로로 누울 수 있는 자리는 5개이고, 세로로 누울 수 있는 자리는 4개 이다. 방의 크기 N과 방의 구조가 주어졌을 때, 가로로 누울 수 있는 자리와 세로로 누울 수 있는 자리의 수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 방의 크기 N이 주어진다. N은 1이상 100이하의 정수이다. 그 다음 N줄에 걸쳐 N개의 문자가 들어오는데 '.'은 아무것도 없는 곳을 의미하고, 'X'는 짐이 있는 곳을 의미한다.
<출력값>
첫째 줄에 가로로 누울 수 있는 자리와 세로로 누울 수 있는 자리의 개수를 출력한다.

<문제 1653>
무게가 서로 다른 추들의 집합이 주어진다. 각 추의 무게는 1g 이상 9g 이하의 정수이다. 이 추들 중에서 몇 개를 선택하여 양팔저울에 올려서 평형을 만들고자 한다. 양팔저울에는 양쪽에 5개씩 등간격의 눈금이 표시되어 있고 추는 눈금 위에만 놓일 수 있다. 한 눈금 위에는 하나의 추만이 놓일 수 있다. 예를 들어, {2, 3, 4, 5, 9}가 추 집합으로 주어졌을 때, 아래 그림과 같이 왼쪽에는 2g짜리 추를 중심에서 3 떨어진 자리에 놓고, 오른쪽에는 3g짜리 추를 중심에서 2 떨어진 자리에 놓으면 저울은 평형을 이루게 된다. (2×3=3×2)

위와 동일한 추 집합에서, 아래 그림과 같이 양쪽에 서로 다른 수의 추를 배치해서 평형을 이룰 수도 있다. (4×4+2×2=5×4)

두 그림과 같이 저울이 평형을 이룬 경우, 추가 놓인 모양에 따라 대응되는 하나의 숫자를 다음과 같이 생성한다. 추가 놓이지 않은 빈 눈금에는 0이 들어가고 추가 놓인 눈금은 그 추의 무게에 해당하는 숫자가 들어간다. 단, 이렇게 만들었을 때 0이 아닌 첫 숫자가 나타나기까지의 왼쪽에 있는 모든 0은 제거한다. 예를 들면, 첫 그림에 대응되는 숫자는 20003000이 되고, 둘째 그림에 해당되는 숫자는 402000050이 된다. 이렇게 하면 양팔저울이 평형을 이루는 추의 배치 방법 각각에 대해 최대 10자리의 정수가 하나씩 대응되는데, 이 수를 "평형정수"라고 하자.
  주어진 추 집합을 입력으로 받아서, 생성할 수 있는 모든 평형정수를 증가하는 순서대로 놓았을 때, k번째(0≤k≤1,000,000,000)에 해당되는 평형정수를 출력하는 프로그램을 작성하시오. 특수한 경우로 k=0에 대응되는 평형정수는 0으로, 저울의 양쪽에 아무 추도 놓이지 않은 상태를 말한다. 만일 k번째에 해당하는 평형정수가 없으면 가능한 가장 큰 평형정수를 출력한다.
<입력값>
첫째 줄에는 추 집합의 크기 n이 주어진다. (1≤n≤9) 둘째 줄에는 서로 다른 n개의 추의 무게가 증가하는 순서로 주어진다. 각 수 사이에는 빈 칸이 하나 있다. 셋째 줄에는 여러분이 계산해야 할 평형정수의 순위 k가 주어진다.
<출력값>
첫째 줄에 입력에서 주어진 추들로 만들 수 있는 모든 평형정수를 증가하는 순서대로 나열했을 때 k번째가 되는 평형정수를 출력하면 된다. 만일 k번째에 해당되는 평형정수가 없을 경우에는 가능한 가장 큰 평형정수를 출력한다.

<문제 1654>
집에서 시간을 보내던 오영식은 박성원의 부름을 받고 급히 달려왔다. 박성원이 캠프 때 쓸 N개의 랜선을 만들어야 하는데 너무 바빠서 영식이에게 도움을 청했다.
이미 오영식은 자체적으로 K개의 랜선을 가지고 있다. 그러나 K개의 랜선은 길이가 제각각이다. 박성원은 랜선을 모두 N개의 같은 길이의 랜선으로 만들고 싶었기 때문에 K개의 랜선을 잘라서 만들어야 한다. 예를 들어 300cm 짜리 랜선에서 140cm 짜리 랜선을 두 개 잘라내면 20cm는 버려야 한다. (이미 자른 랜선은 붙일 수 없다.)
편의를 위해 랜선을 자르거나 만들 때 손실되는 길이는 없다고 가정하며, 기존의 K개의 랜선으로 N개의 랜선을 만들 수 없는 경우는 없다고 가정하자. 그리고 자를 때는 항상 센티미터 단위로 정수길이만큼 자른다고 가정하자. N개보다 많이 만드는 것도 N개를 만드는 것에 포함된다. 이때 만들 수 있는 최대 랜선의 길이를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 오영식이 이미 가지고 있는 랜선의 개수 K, 그리고 필요한 랜선의 개수 N이 입력된다. K는 1이상 10,000이하의 정수이고, N은 1이상 1,000,000이하의 정수이다. 그리고 항상 K ≦ N 이다. 그 후 K줄에 걸쳐 이미 가지고 있는 각 랜선의 길이가 센티미터 단위의 정수로 입력된다. 랜선의 길이는 231-1보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 N개를 만들 수 있는 랜선의 최대 길이를 센티미터 단위의 정수로 출력한다.

<문제 1655>
수빈이는 동생에게 "가운데를 말해요" 게임을 가르쳐주고 있다. 수빈이가 정수를 하나씩 외칠때마다 동생은 지금까지 수빈이가 말한 수 중에서 중간값을 말해야 한다. 만약, 그동안 수빈이가 외친 수의 개수가 짝수개라면 중간에 있는 두 수 중에서 작은 수를 말해야 한다.
예를 들어 수빈이가 동생에게 1, 5, 2, 10, -99, 7, 5를 순서대로 외쳤다고 하면, 동생은 1, 1, 2, 2, 2, 2, 5를 차례대로 말해야 한다. 수빈이가 외치는 수가 주어졌을 때, 동생이 말해야 하는 수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 수빈이가 외치는 정수의 개수 N이 주어진다. N은 1보다 크거나 같고, 100,000보다 작거나 같은 자연수이다. 그 다음 N줄에 걸쳐서 수빈이가 외치는 정수가 차례대로 주어진다. 정수는 -10,000보다 크거나 같고, 10,000보다 작거나 같다.
<출력값>
한 줄에 하나씩 N줄에 걸쳐 수빈이의 동생이 말해야하는 수를 순서대로 출력한다.

<문제 1656>
4개의 다리를 가진 탁자는 다리의 길이가 모두 같지 않으면 덜컹거린다. 덜컹거리는 것이 취향이 아니라면 탁자가 균형을 이루도록 적당한 다리를 골라 적당히 자르면 된다.
이를 일반화시켜 t개의 다리가 균등한 거리만큼 떨어져 있는 원형 탁자를 생각해보자. 이때, 탁자가 덜컹거리지 않게 하기 위해 탁자의 다리를 자를 때, 자르는 양의 최솟값을 계산한다. (무게중심을 생각하면 꼭 모든 다리가 땅에 닿지 않아도 탁자는 덜컹거리지 않을 수 있다.)
<입력값>
입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 케이스마다 첫 번째 줄에 t(3≤t≤50), 그 다음 t개의 줄에 원탁의 다리들의 길이가 원주상의 순서대로 주어진다. 모든 다리는 탁자판에 수직이다.입력의 끝은 0으로 표시한다.
<출력값>
각 테스트 케이스마다 다리를 최소한 얼마나 잘라야 하는지 출력한다. 각 테스트 케이스 사이에는 빈 줄이 하나 끼어있야한다.

<문제 1657>
장홍준은 참 특이한 두부장수이다. 세로크기 N, 가로크기 M인 두부판을 가지고 2x1짜리 두부로 잘라서 판다. 그런데, 두부판의 위치마다 등급이 다르다. 그리고 2x1짜리에 등급이 어떻게 매겨지느냐에 따라 두부의 값도 천차만별이 된다. 다음 등급표를 보자.

위의 표는 2x1짜리 두부의 등급에 따라 매겨지는 두부의 가격표다. 예를 들어 “AC" 두부의 가격은 7이고, ”DB" 두부의 가격은 3이다.
세로크기 M, 가로크기 N의 두부판이 주어진다. 각 칸마다 두부의 등급이 A, B, C, D, F로 매겨져 있다. 홍준이는 전체 두부가격의 합을 최대가 되게 두부를 자르려고 한다. 2x1짜리 두부로 잘라내고 남은 한 칸짜리 두부는 가격이 0이기 때문에 버린다. 홍준이를 도와 가격이 최대가 되게 두부판을 자르는 프로그램을 작성하시오.

위 그림은 N=4, M=4 인 두부판의 한 예이다. 오른쪽 그림이 잘라낸 두부가격의 합을 최대로 한 것이다. 한 칸짜리는 쓸모없으므로 버린다.
<입력값>
첫째 줄에는 두부판의 세로크기 N, 가로크기 M이 주어진다. N, M은 1이상 14이하의 정수이다. 그 다음 N줄에 걸쳐 M개의 문자가 주어진다. 각 문자는 그 칸의 두부의 등급을 나타내며 A, B, C, D, F 중 하나로 주어진다.
<출력값>
첫째 줄에 잘라낸 두부가격 합의 최댓값을 출력한다.

<문제 1658>
종혁이는 자물쇠로 잠긴 M개의 돼지우리가 있는 농장에서 일하고 있다. 종혁이는 열쇠가 없기 때문에 우리들을 열지 못한다.
이 농장에 손님들은 하루에 한 명씩 방문한다. 이들은 몇몇 우리 열쇠를 가지고 있고, 이 우리들을 연 다음 자신이 원하는 만큼의 돼지를 사간다.
농장 운영 방식은 아래와 같다.

손님이 도착해서 가지고 있는 열쇠로 열 수 있는 모든 우리들을 연다.
손님에게 몇몇 돼지들을 판다. (손님이 원하는 만큼을 초과하여 돼지를 팔 순 없지만 그 이하로는 팔 수 있다.)
종혁이는 팔고 남은 돼지들을 현재 열려져 있는 우리들을 상대로 재분배 할 수 있다.

문제는 우리에 들어갈 수 있는 돼지 숫자의 제한이 없다고 할 때 손님들이 방문한 동안 종혁이가 최대로 팔 수 있는 총 돼지의 숫자를 구하는 것이다.
<입력값>
첫째 줄에 돼지 우리 숫자를 나타내는 M(1≤M≤1,000)과 손님들의 숫자를 나타내는 N(1≤N≤100)이 공백으로 구분되어 주어진다. 돼지우리는 1번부터 M번까지의 숫자로 매겨져 있고 손님 역시 1번부터 N번의 숫자로 매겨져 있다.
두 번째 줄에는 각각의 돼지우리에 있는 초기 돼지 숫자를 나타내는 M개의 수가 공백으로 구분되어 주어진다. 이 수는 0 이상 1,000 이하의 수이다.
그 다음 N개의 줄에는 N명의 손님들에 대한 정보가 주어진다. i+2번째 줄에는 i번째 손님에 대한 정보 A, K1, K2, …, KA, B가 주어지는데 이는 i번째 손님이 K1, K2, …, KA번째 우리 열쇠를 가지고 있고 B마리의 돼지를 사길 원한다는 의미이다. A와 B는 0 이상의 정수이다.
<출력값>
첫째 줄에 최대 팔 수 있는 돼지 숫자를 출력한다.

<문제 1659>
음 아닌 정수들로 이루어진 두 개의 집합 S와 T가 있다. S의 원소들과 T의 원소들을 짝지으려고 하는데, 다음과 같은 규칙을 만족하도록 하고 싶다.

S의 임의의 원소 s는 T의 어떤 원소와도 짝지어질 수 있다. 또한 T의 임의의 원소 t도 S의 어떤 원소와도 짝지어질 수 있다.
S의 모든 원소는 적어도 하나의 T의 원소와는 짝지어져야 하고, T의 모든 원소 역시 적어도 하나의 S의 원소와는 짝지어져야 한다.

예를 들어 S={2, 8, 9, 10, 11}, T={0, 3, 4, 6, 7, 11}을 보자. {(2, 0), (2, 3), (2, 4), (8, 6), (9, 7), (10, 11), (11, 11)}은 규칙을 만족하는 경우가 된다. 하지만 {(2, 0), (8, 3), (9, 4), (10, 6), (11, 7)}은 규칙을 만족하는 경우가 아닌데, T의 원소 11이 S의 어떤 원소와도 짝지어지지 않았기 때문이다.
각각의 짝 (a, b)의 비용이란, a와 b의 차이의 절댓값으로 정의된다. 우리는 모든 비용의 합을 최소로 하도록 S의 원소들과 T의 원소들을 짝지으려 한다. 위에서 주어진 S와 T에 대해서는 10이 최소의 비용합이 된다.
S와 T가 주어지면, 모든 비용의 합을 최소로 하도록 S의 원소들과 T의 원소들을 짝지어 주는 프로그램을 작성하시오.
<입력값>
첫째 줄에 S의 원소의 개수와 T의 원소의 개수가 빈 칸을 사이에 두고 주어진다. 둘째 줄에는 S의 원소, 셋째 줄에는 T의 원소가 첫째 줄에 주어진 개수만큼 빈 칸을 사이에 두고 증가하는 순서대로 주어진다. 각 집합의 원소의 크기는 500,000 이하의 자연수이며, 주어지는 수는 0 이상 1,000,000,000 이하의 정수이다.
<출력값>
첫째 줄에 최소의 비용합을 출력한다.

<문제 1660>
캡틴 이다솜은 자신의 해적선에 적을 공격하기 위한 대포알을 많이 보관해 놓는다. 다솜이는 미적감각이 뛰어나기 때문에, 대포알은 반드시 사면체 모양으로 쌓아놓아야 한다고 생각한다. 사면체를 만드는 방법은 길이가 N인 정삼각형 모양을 만든다. 그 위에 길이가 N-1인 정삼각형 모양을 얹고 그위에 계속 해서 얹어서 1크기의 정삼각형 모양을 얹으면 된다.
예를 들어, 사이즈가 3크기의 한 더미 모양은 다음과 같다.

  X

  X
 X X

  X
 X X
X X X

각각의 삼각형은 1, 3, 6, 10 ,..... 와 같이 대포알을 가지고 있다. 따라서 완벽하게 쌓았을 때, 한 사면체에는 1, 4, 10, 20 ,.... 개를 가지고 있을 것이다.
현재 다솜이의 해적선에 대포알이 N개가 있다. 다솜이는 영식이를 시켜서 사면체를 만들게 하고 싶다. 영식이는 물론 하기 싫지만 어쩔수 없이 다솜이가 시키는대로 사면체를 가능한 최소 개수 만큼 만들려고 한다. N개의 대포알로 만들 수 있는 사면체의 최소 개수를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 입력 N이 들어온다. N은 300,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 영식이가 만들 수 있는 사면체 개수의 최솟값을 출력한다.

<문제 1661>
다솜이는 최첨단 유행을 달리는 신발가게를 운영하고 있다. 하지만 다솜이의 가게에는 유행에 덜떨어진 이상한 제품들도 있다. 다솜이는 유행에 덜떨어져서 사람들이 사가지 않는 제품을 더 사기 위해서, 새로운 할인 시스템을 구축했다.
할인 시스템은 다음과 같다.
유행에 덜 떨어진 제품을 C원을 주고 사면, 유행을 달리는 제품을 P% 할인 받아서 살 수 있다. 하지만, 다솜이는 욕심이 많기 때문에, P는 1,2,3 중에 하나이다.
하지만 이러한 할인 시스템이 잘 작동하지 않았다. 다솜이는 유행에 덜 떨어진 물건을 N개 사면, 누적해서 할인을 받을 수 있게 해주었다. 예를 들어, 유행에 떨어진 제품 중에 2%할인 받는 제품과 3%할인 받는 제품을 샀다면, 유행을 달리는 제품 100 짜리를 100*0.98*0.97 = 95.06에 살 수 있다.
입력으로 현재 다솜이의 신발가게에서 할인을 해주는 유행에서 떨어진 제품의 가격과 그 것을 샀을 때 유행을 달리는 제품을 얼마나 할인해주는지 주어졌을 때, 영식이가 사고 싶어 하는 제품 P를 얼마나 작은 가격으로 살 수 있는 지 그 값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 유행에 떨어진 제품의 개수 N과 영식이가 사고 싶어 하는 제품 P의 가격이 들어온다. N은 50보다 작거나 같은 자연수이다. P는 1,000,000,000보다 작거나 같은 자연수이다. 둘째 줄부터 총 N개의 줄에 각각의 유행에 덜떨어지 제품의 가격 C와 그 물건을 샀을 때 할인 받을 수 있는 할인율 P가 주어진다. C는 10,000,000보다 작거나 같은 자연수이고, P는 1, 2, 3 중에 하나다.
<출력값>
첫째 줄에 영식이가 사고싶어하는 신발 P를 얼마나 낮은 가격으로 살 수 잇는지 출력하시오. 절대/상대 오차는 10-6까지 허용한다.

<문제 1662>
압축되지 않은 문자열 S가 주어졌을 때, 이 문자열중 어떤 부분 문자열은 K(Q)와 같이 압축 할 수 있다. K는 한자리 정수이고, Q는 0자리 이상의 문자열이다. 이 Q라는 문자열이 K번 반복된다는 뜻이다. 압축된 문자열이 주어졌을 때, 이 문자열을 다시 압축을 푸는 프로그램을 작성하시오.
<입력값>
첫째 줄에 압축된 문자열 S가 들어온다. S의 길이는 최대 50이다. 문자열은 (, ), 0-9사이의 숫자로만 들어온다.
<출력값>
첫째 줄에 압축되지 않은 문자열의 길이를 출력한다. 이 값은 int범위다.

<문제 1663>
"XYZ 문자열"이란 아래와 같은 문법에 의해 단계별로 만들어지는 일련의 문자열들을 뜻한다.

"XYZ 문자열"은 세 개의 문자 X, Y, Z로만 이루어진다.
1단계 "XYZ 문자열"은 X로 시작한다.
다음 단계의 "XYZ 문자열"은 바로 이전 단계의 "XYZ 문자열"에서 아래와 같은 규칙에 따라 변형되어 만들어진다.


X는 YZ로 변형된다.
Y는 Z로 변형된다.
Z는 X로 변형된다.

위와 같은 문법에 따라 1단계부터 몇 단계의 "XYZ 문자열"을 차례로 적어 보면 아래와 같다.

X
YZ
ZX
XYZ
YZZX
ZXXYZ

N단계의 "XYZ 문자열"과 관련해서, 아래의 문제 중 하나를 푸는 프로그램을 작성하시오.

N단계의 XYZ 문자열의 길이를 구한다.
N단계의 XYZ 문자열에서 k번째 문자가 무엇인지 구한다.
N단계의 XYZ 문자열에서 특정한 문자가 몇 번 나타나는지 구한다.
<입력값>
첫째 줄에 문제 번호가 주어진다. 이는 1, 2, 3 중 하나이다. 이어서 둘째 줄에 자연수 N(1≤N≤100)이 주어진다. 문제 2인 경우는 셋째 줄에 자연수 k가, 문제 3인 경우는 셋째 줄에 X 또는 Y 또는 Z가 주어진다. k는 항상 N번째 문자열의 길이보다 작거나 같다고 가정해도 좋다.
<출력값>
문제 1인 경우는 길이를 나타내는 정수를, 문제 2인 경우는 k번째 문자를, 문제 3인 경우는 특정한 문자가 나타난 횟수를 각각 첫째 줄에 출력하면 된다.

<문제 1664>
내일이면 대한민국에 새로운 대통령이 취임하게 된다. 새로운 정부는, 아래와 같이 19자리로 된 새로운 주민등록번호 체계를 도입한다고 한다.
DDMMYYYYAAAAAAAAAAC
YYYY는 생년, MM은 생월, DD는 생일을 의미한다. 생년은 0001 이상 9999 이하의 수가 되며, MM은 01 이상 12 이하, DD는 01 이상 31 이하이다. 1, 3, 5, 7, 8, 10, 12월은 31일까지, 4, 6, 9, 11월은 30일까지이며, 2월은 평년은 28일까지, 윤년은 29일까지이다. 윤년이란 YYYY가 (1) 100의 배수를 제외한 4의 배수이거나 (2) 400의 배수인 경우가 해당된다.
A로 된 10자리는 어떤 숫자라도 올 수 있다. 마지막 자리인 C는 CONTROL-DIGIT으로, 아래와 같은 알고리즘에 의해 생성된다.

C를 제외한 주민등록번호상의 18자리의 수를 순서대로 Z1, Z2, …, Z18이라고 하자.
S = (10×Z1 + 9×Z2 + 8×Z3 + … + 2×Z9 + 10×Z10 + 9×Z11 + 8×Z12 + … + 2×Z18) % 19
S가 9 이하이면 C=S, 아니면 C = 19 - S

이러한 새로운 주민등록번호 체계상의 한 주민등록번호의 일부 숫자가 지워져 있다. 위의 조건을 만족시키는 가능한 모든 주민등록번호의 경우의 수를 세는 프로그램을 작성하시오.
<입력값>
첫째 줄에 19자리의 주민등록번호가 주어진다. 숫자 또는 X로 주어지게 되는데 X는 숫자가 지워졌음을 의미한다.
<출력값>
첫째 줄에 조건을 만족시키는 가능한 모든 주민등록번호의 경우의 수를 출력한다. 답은 항상 2^63보다 작다.

<문제 1665>
동물원에서 막 탈출한 원숭이 한 마리가 세상구경을 하고 있다. 그 원숭이는 최근 철도청 국장에게 특별 프로젝트 수행을 제의받고 철도청에 근무하고 있다. 그런데 프로젝트를 수행하던 도중, 심각한 문제에 부딪쳤다. 원숭이는 이것을 혼자 해결할 능력이 부족하다. 일단 원숭이가 해결해야하는 문제가 무엇인지 알아보자.
해결해야 하는 문제는 다음과 같다. 화물열차가 두 대가 있을 때, 이웃한 레일 위에 놓인 두 화물 열차 사이에 짐을 옮기려고 한다. 화물 열차의 각 칸에는 컨테이너가 놓여 있기도 하고, 놓여 있지 않기도 한데 컨테이너가 놓인 칸이 가장 많이 겹치도록 두 화물 열차를 겹쳐 놓으면 짐을 옮기는 과정이 수월하다.
처음에 두 화물 열차는 아래 그림과 같이 첫 칸의 앞부분이 서로 마주보며 같은 선에 위치하고 있다. 화물 열차 A는 가만히 있고, 화물 열차 B를 움직여 컨테이너가 놓인 칸이 가능한 많이 겹쳐지게 하려고 한다. 화물 열차 B를 몇 칸 앞으로 움직여야 하는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 화물 열차 A에 연속적으로 컨테이너가 놓여 있는 구간의 개수 N이 주어진다. 이어 N줄에는 Xi와 Yi (Xi ≤ Yi)가 공백을 사이에 두고 주어지는데 이는 화물 열차 A의 Xi칸부터 Yi칸까지 컨테이너가 놓여 있음을 의미한다. 다음 줄에는 화물 열차 B에 연속적으로 컨테이너가 놓여 있는 구간의 개수 M이 주어진다. 이어 M줄에는 Zi와 Wi (Zi ≤ Wi)가 공백을 사이에 두고 주어지는데 이는 화물 열차 B의 Zi칸부터 Wi칸까지 컨테이너가 놓여 있음을 의미한다. N과 M은 1,000이하의 자연수이고, Xi, Yi, Zi, Wi는 109이하의 자연수이다.
<출력값>
첫째 줄에 두 열차의 컨테이너가 놓인 칸이 최대로 겹쳐지게 하기 위하여 화물 열차 B를 몇 칸 앞으로 움직여야 하는지를 출력한다. 최대로 겹쳐지게 하도록 열차 B를 움직이는 칸수가 여러 가지인 경우에는 그 중 최솟값을 출력한다.

<문제 1666>
N개의 직사각형이 좌표 위에 흩어져 있고 이 중 몇 개의 직사각형을 선택하여 집합 L을 구성하려 한다. 집합 L의 조건은 아래와 같다.

왼쪽 아래의 점을 시작점, 오른쪽 위의 점을 끝점이라고 정의 할 때, 집합의 임의의 두 원소 p, q에 대하여 p의 끝점 x좌표가 q의 시작점 x좌표보다 작고 마찬가지로 y좌표도 작거나 또는 q의 끝점 x좌표가 p의 시작점 x좌표보다 작고 y좌표 역시 작아야 한다.
문제는 위의 조건을 만족하는 집합의 최대 원소 개수를 구하는 것이다.
<입력값>
첫째 줄에 직사각형의 개수 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N+1번째 줄까지 i+1번째 줄에 i번째 직사각형의 왼쪽 아래 점의 x좌표, y좌표 오른쪽 위의 점의 x좌표, y좌표를 나타내는 4개의 정수가 공백으로 구분되어 주어진다. 왼쪽 아래 점의 x, y좌표는 오른쪽 위의 x, y좌표보다 항상 작다. (0 ≤ x, y ≤ 100,000)
<출력값>
첫째 줄에 집합의 최대 원소 개수를 출력한다.

<문제 1667>
지민이는 지뢰 사건에 의해 정문이에게 도망 다니고 있다. 그러던 중 N개의 펜스로 설치된 장애물을 만나게 되었다. 이 펜스들은 x축과 평행하고 i번째 펜스의 y좌표는 i이다. 펜스는 너무 높기 때문에 넘을 수 없고 돌아가는 방법만이 가능하다. 또한 현재 위치에서 x축의 양의 방향 또는 음의 방향으로 진행하던 중 펜스의 끝에 도달하면 y축과 평행하게 다음 펜스를 만날 때까지 내려가는 일을 반복한다.

   +-+-S-+             4번째 펜스
 +-+-+-+               3번째 펜스
     +-+-+-+           2번째 펜스
   +-+-+-+             1번째 펜스
 |=|=|=*=|=|=|         
-3-2-1 0 1 2 3 

위의 그림에서 S는 현재 지민이가 있는 위치이다. 그리고 지민이는 펜스를 잘 피하여 *로 표시된 탈출구까지 도달해야한다. 가능한 경로 중 하나는 일단 현재 위치에서 x축과 평행하게 양의 방향으로 1만큼 이동하면 펜스의 끝에 도달한다. 그리고 y축과 평행하게 아래로 내려가면 2번째 펜스에 도달하게 되고 또 다시 1만큼 x좌표가 양인 방향으로 이동하면 펜스의 끝에 도달하게 된다. 그리고 1만큼 내려간 뒤 x좌표가 음인 방향으로 2만큼 이동하면 탈출구에 도달하여 탈출할 수 있다.  y축을 따라 내려가는 길이는 어떤 식으로 내려가든 일정하기 때문에 고려하지 않는다고 하면 위의  경로로 이동한 것은 x축과 평행하게 총 4만큼 이동한 게 된다. 그리고 위의 경로가 이 예에서 최단 경로이다. 문제는 펜스의 위치가 주어졌을 때 최단경로의 길이를 구하는 것이다.
<입력값>
첫째 줄에 펜스의 개수 N(1 ≤ N ≤ 50,000)과 지민이가 있는 x좌표 S(-100,000 ≤ S ≤ 100,000)가 공백으로 구분되어 주어진다.
두 번째 줄부터 N+1번째 줄까지 펜스의 시작 좌표 x와 끝 좌표 x가 공백으로 구분되어 주어진다. 좌표의 범위는 -100,000 이상 100,000 이하이다.
<출력값>
탈출구로 도달하는 최단경로를 출력한다.

<문제 1668>
민식이는 “오민식”이라는 팀이름으로 수없이 많은 로봇대회를 우승했다. 따라서 민식이의 집에는 트로피가 많다. 민식이는 트로피를 어떤 선반 위에 올려놨다. 이 선반은 민식이의 방문을 열고 들어가자마자 선반의 왼쪽이 보인다. 다른말로 하자면, 뒤의 트로피가 앞의 트로피에 가려져 있다는 말이다.
안타깝게도, 높이가 큰 트로피가 높이가 작은 트로피의 왼쪽에 있다면, 높이가 작은 트로피는 큰 트로피에 가려서 보이지 않게 된다. 트로피는 자기의 앞에 (보는 사람의 관점에서) 자기보다 높이가 작은 트로피가 있을 때만 보이게 된다. 민식이는 선반을 180도 회전시켜서 트로피가 보이는 개수를 변하게 할 수도 있다.
선반위에 올려져 있는 트로피의 높이가 주어졌을 때, 왼쪽에서 봤을 때 보이는 개수와, 오른쪽에서 봤을 때 보이는 개수를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 트로피의 개수 N (1 ≤ N ≤ 50)이 주어진다. 둘째 줄부터 N개의 줄에 왼쪽의 트로피부터 차례대로 높이가 주어진다. 트로피의 높이는 100보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 왼쪽에서 봤을 때 보이는 개수, 둘째 줄에 오른쪽에서 봤을 때 보이는 개수를 출력한다.

<문제 1669>
동물원에서 막 탈출한 원숭이 한 마리가 세상구경을 하고 있다. 그러다 오늘도 어김없이 그의 영원한 라이벌 멍멍이를 만나게 되었다. 원숭이는 멍멍이를 쓰다듬고 싶었다. 하지만 원숭이는 멍멍이보다 키가 작기 때문에 멍멍이를 쓰다듬어줄 수 없다. 원숭이가 멍멍이를 쓰다듬으려면 둘의 키가 같아야 하기 때문이다.
그래서 원숭이는 그 날부터 자신의 키를 조절하기로 마음먹었다. 원숭이는 초능력자이기 때문에 마음대로 키를 늘릴 수 있다. 하지만 안타깝게도 사람이 아니라 동물이기 때문에 하루에 늘릴 수 있는 키의 양을 1cm밖에 조절할 수 없다. 예를 들어 오늘 키를 5cm 만큼 늘렸다면, 내일은 키를 4cm, 5cm, 6cm 중 하나만큼 키를 늘릴 수 있다는 뜻이다. 늘릴 수 있는 키의 양은 음수가 될 수 없다. 그리고 첫째 날과 마지막 날에는 무조건 1cm 만큼 늘릴 수 있다.
현재 원숭이와 멍멍이의 키가 주어졌을 때, 원숭이가 매일 키를 늘려서 멍멍이와 키가 같아지는 최소의 일수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 원숭이의 키 X와 멍멍이의 키 Y가 주어진다. X, Y는 0 ≤ X ≤ Y < 231을 만족하는 정수이다.
<출력값>
첫째 줄에 원숭이가 멍멍이의 키와 같아지게 되는 최소의 일수를 출력한다.

<문제 1670>
여러 개의 소국가로 나뉘어져 있었던 A국을 다시 하나의 국가로 합치기 위해 각 소국가의 대표 N명이 원탁에 모였다.
각 대표는 미리 원탁의 자리를 배정받았다. 회의를 시작하기 전에 일단 서로 악수를 하려고 한다. 각 대표는 한 사람과만 악수할수 있고, 모든 악수는 동시에 일어난다. 이때, 어떤 사람의 팔도 교차하지 않았을 때 완벽하게 악수했다고 한다.
N이 주어지면 완벽하게 악수하는 경우의 수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 정상 회담에 참가한 사람의 수 N이 주어진다. 이 값은 10,000보다 작거나 같은 짝수이다.
<출력값>
완벽한 악수의 경우의 수를 987654321로 나눈 나머지를 출력한다.

<문제 1671>
어떤 상어는 저녁식사로 서로를 먹는다. 모든 상어는 자신과 다른 상어의 크기, 속도, 지능을 수치로 나타낸 것을 알고 있다. 만약, 상어 A의 크기, 속도, 지능이 상어 B의 크기, 속도, 지능보다 크거나 같다면 상어 A는 상어 B를 먹을 수 있다. 그러나, 상어들의 왕 김재홍은 상어들이 많이 없어지는 것을 방지하기 위해서 한 상어가 최대 두 개의 상어만 먹을 수 있게 했다. 상어들은 김재홍의 말을 모두 듣는다.
능력치가 모두 같은 상어 A, B가 있다면 A가 B를, B가 A를 잡아먹을 수는 있지만 A, B가 서로 잡아먹을수는 없다.
N마리 상어의 크기, 속도, 지능이 주어졌을 때, 살아남을 수 있는 상어 수의 최솟값을 구하시오.
<입력값>
첫째 줄에 상어의 마리 수 N이 주어진다. 이 값은 50보다 작거나 같은 자연수이다. 둘째 줄부터 각 상어의 크기, 속도, 지능의 정보가 주어진다. 이 값은 2,000,000,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 살아남을 수 있는 상어 수의 최솟값을 출력한다.

<문제 1672>
N개의 A, G, C, T로 구성되어 있는 DNA 염기서열이 있다. 그리고 우리는 이 염기서열을 아래의 표를 이용하여 해독을 해야 한다.

해독 방법은 염기 서열에서 제일 끝에 있는 두 개의 염기를 An-1, An이라 할 때, An-1을 행으로 An을 열로 대응시켜 그에 해당하는 하나의 염기로 바꾸는 방식을 반복하는 것이다.  예를 들어 AAGTCG라는 염기서열이 있다고 하자. 이 서열을 위의 규칙 때로 해독하면 AAGTCG -> AAGTT ->AAGT -> AAA -> AA -> A 가 되어 최종적으로 해독한 염기는 A가 된다.
문제는 어떤 염기서열이 주어졌을 때 위의 표를 참고하여 해독된 최종 염기를 출력하는 것이다.
<입력값>
첫째 줄에 염기 서열의 길이 N(1≤N≤1,000,000)이 주어진다. 둘째 줄에는 염기서열을 나타내는 길이가 N인 문자열이 주어진다.
<출력값>
첫째 줄에 최종 염기를 출력한다.

<문제 1673>
강민이는 치킨 한 마리를 주문할 수 있는 치킨 쿠폰을 n장 가지고 있다. 이 치킨집에서는 치킨을 한 마리 주문할 때마다 도장을 하나씩 찍어 주는데, 도장을 k개 모으면 치킨 쿠폰 한 장으로 교환할 수 있다.
강민이가 지금 갖고 있는 치킨 쿠폰으로 치킨을 최대 몇 마리나 먹을 수 있는지 구하여라. 단, 치킨을 주문하기 위해서는 반드시 치킨 쿠폰을 갖고 있어야 한다.
<입력값>
여러 줄에 걸쳐서 자연수 n과 k가 주어진다.
<출력값>
각 입력마다 한 줄에 정답을 출력한다.

<문제 1674>
성준이는 카페인에 매우 약하다.
아주 조금의 카페인이라도 섭취하면 성준이는 미쳐 날뛰기 시작하여 주변의 모든 것을 때려부순다.
이와 같은 과민반응에 궁금증을 느낀 국과수는 성준이를 데려다 실험을 하기로 했다.
힘든 연구 끝에 얻어낸 결론은 다음과 같다.

성준이는 n의 초콜릿을 섭취한 뒤 t시간이 지나면 8*n - t/12의 반경 내에 있는 사람을 공격한다.
성준이는 n의 커피를 섭취한 뒤 t시간이 지나면 2*n - t*t/79의 반경 내의 모든 물건을 때려부순다.

모든 음식의 작용은 독립적이며, 시간 T일 때까지 성준이가 섭취한 모든 음식에 대한 효과 반경을 모두 더한 만큼을 시간 T에서의 성준이에 대한 안전 거리라 정의한다.
만일 어떤 음식에 대한 효과 반경이 음수가 된다면, 그것은 성준이가 그 음식을 완벽히 소화했다는 것을 의미하며 효과 반경에는 영향을 미치지 않는다.
또한, 성준이에 대한 안전 거리는 비상사태에 대비하여 항상 1 이상을 유지해야 한다.
성준이가 섭취한 음식의 양과 섭취한 시각이 주어지고, 안전 거리를 알아내고 싶은 시간 T가 여러 개 주어진다. 이때, 각각의 시각 T에서의 성준이에 대한 안전 거리를 구하는 프로그램을 작성하라.
<입력값>
입력은 다음의 형태로만 구성되어 있다.

Query T : 안전거리를 알아낼 시각 T (T는 음이 아닌 정수)
Chocolate T N : 성준이가 시각 T에 초콜릿 N만큼을 섭취함 (T는 음이 아닌 정수, N은 음이 아닌 실수)
Coffee T N : 성준이가 시각 T에 커피 N만큼을 섭취함 (T는 음이 아닌 정수, N은 음이 아닌 실수)

입력은 시간 순으로 주어지지 않을 수도 있다.
Query의 수는 1만 개 이하이며, 초콜릿과 커피를 섭취한 횟수는 합해서 100을 넘지 않는다.
<출력값>
입력에 주어진 모든 Query에 대해 시간의 오름차순으로 한 줄에 다음을 출력한다.
T R : T는 시각, R은 안전거리 (소수 둘째 자리에서 반올림)
Query에서 중복되어 입력된 시각이 있다면, 중복된 횟수만큼 여러 번 출력해야 한다.
정답과 10-8 이하의 차이가 날 때는 반올림한 결과에 차이가 없는 데이터만이 입력으로 주어진다.

<문제 1675>
테디라는 팬더는 N개의 대나무 숲을 가진 숲속에 산다. 각각의 대나무 숲은 평면상의 점으로 표현된다. i번째 대나무 숲은 Li개의 대나무와 Wi라는 '맛있는 정도'를 가진다.
테디는 매일 선택된 한 개의 대나무 숲의 모든 대나무들을 먹어치운다. 단 현재 대나무 숲이 그 전날 선택한 대나무 숲보다 '맛있는 정도'가 더 좋아야만 한다.
테디가 걷는 시간이 길면 길수록 그는 더 많은 대나무를 기대하게 되므로, 만약 그가 이전 대나무 숲으로부터 걸어온 거리가 현재 도달한 대나무 숲의 대나무 수보다 적다면 울음을 터뜨린다.
두 점(x0, y0)과 (x1, y1)사이의 거리는 |x0-x1| + |y0-y1|로 표현된다. 따라서 테디는 동서남북 방향으로만 움직인다.
문제는 테디를 하나의 대나무 숲에 데려다 놓으면, 그는 최대 며칠 동안 울음을 터뜨리지 않는지를 구하는 것이다. 테디가 처음 있는 대나무 숲은 당신이 정하는 것이다.
<입력값>
첫째 줄에 대나무 숲의 개수 N이 주어진다. 두 번째 줄부터 N+1번째 줄까지 i+1번째 줄에는 i번째 대나무 숲의 위치를 나타내는 Xi, Yi와 맛있는 정도를 나타내는 Wi, 대나무의 개수 Li가 공백으로 구분되어 주어진다.
<출력값>
첫째 줄에 울음을 터뜨리지 않는 최대 일 수를 출력하시오.

<문제 1676>
N!에서 뒤에서부터 처음 0이 아닌 숫자가 나올 때까지 0의 개수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N이 주어진다. (0 ≤ N ≤ 500)
<출력값>
첫째 줄에 구한 0의 개수를 출력한다.

<문제 1677>
음악에는 C, D, E, F, G, A, B 이렇게 7개의 음정이 있다. 그리고 3개의 음악이 주어질 것이다. 아래의 표를 보면

다음 3개의 음악은 값이 7이 되는 것을 알 수 있다. (음악의 길이가 다른 관계로 3번째 음악은 '&'(공백)이 삽입되었다.)
값을 정하는 방법은 ‘&’를 제외한 7개의 음정 중에 3개의 음악에도 동시에 한 음을 연주하면 3점이고 동시에 2개를 연주하면 1점이고 그렇지 않으면 0점이다. ('&'이 두개라서 1점이 되지는 않는다.)

같은 세 음악임에도 불구하고 중간 중간에 '&'을 삽입함으로써 값이 25로 증가 하였다.
‘&’이 포함되지 않은 세 개의 음악을 입력받아 이것이 값이 최대가 되도록 ‘&’를 삽입하여 그 때의 최대 값을 출력하는 프로그램을 작성하시오.
또 한 가지!!

이와 같이 한 음악에서 연속해서 '&'를 두 번 이상(두 번 포함) 연주하게 해서는 안 된다.
'&'를 연속해서 두 번 이상 쓰지 않고 위와 같은 정렬을 할 수 조차 없을때는 -1을 출력한다.
Music1 : CGCC
Music2 : C
Music3 : CC
다음 3개의 음악은 길이의 차이가 너무 많이 나서 길이를 맞추려면 '&'를 두개 이상 써야 되므로 값이 -1이다.
<입력값>
한 줄에 한 음악씩 3개의 음악이 주어진다. 음악의 최대길이는 100을 넘지 않는다.
<출력값>
첫째 줄에 가장 좋게 배치 했을 때의 값을 출력한다.

<문제 1678>
사무실에서 가까스로 도망친(장애물이 계단을 막고 있는 입력이 주어졌다) 이 사장은 기차를 이용하여 멀리 도망치기로 결심하였다. 도망을 치는 도중에 한 기차를 오래 타고 있는 것은 위험했기 때문에, 이 사장은 같은 기차를 타고 두 역 이상을 이동하지 않기로 하였다. 기차의 종류가 같더라도 출발 시간이 다르면 같은 기차가 아니다.
모든 기차는 0번 역에서 각 기차의 고유 출발시간에 매 시간마다 계속 출발한다. 이 사장은 0번 역에서 한 기차를 타고 1번 역에서 내린다. 그리고 1번 역에서 기차를 기다리다 가장 먼저 오는 기차를 타고 2번 역으로 이동한다. 그리고 2번 역에서 가장 먼저 도착한 기차를 타고 3번 역으로 이동하며, 이를 N번 역에 도착할 때까지 반복한다.
이와 같이 N번 역으로 이동했을 때, 가장 마지막에 탄 기차의 번호를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 기차의 종류 개수 T(<30), 이 사장이 출발하는 시간(분 단위로) M(<60), N(<1,000,000,000)이 주어진다. 다음 줄에는 각 기차 종류별로 기차의 번호(길이 10을 넘지 않는 문자열)과 그 기차가 0번 역에서 출발하는 시간을 분 단위(<60)로 입력한다. 각 줄의 끝에는 -1로 주어진다. 같은 시간에 출발하는 기차는 없다고 가정해도 좋다.
<출력값>
첫째 줄에 기차의 번호를 출력한다

<문제 1679>
홀순이(holsoon)와 짝순이(jjaksoon) 둘이서 숫자 게임을 한다. 정수 1과 3이 주어지고, 이 둘을 통틀어 5번까지 마음대로 사용하여 그 합을 구하여 1,2,3,…을 만드는 놀이다. 먼저, 홀순이가 1 하나만을 사용하여 1을 만든다. 짝순이는 1+1로 1을 두 번 사용하여 2를 만들고, 다시 홀순이는 3을 만들어야하는데 1+1+1로 1을 세 번 사용하거나 3을 한 번 사용하여 3을 만든다. 짝순이는 1+1+1+1, 1+3으로 4를 만든다. 서로 번갈아서 상대방의 수보다 1이 큰 수를 만들어야 한다. 단, 1과 3을 통틀어 최대 5번 사용한다. 이런 식으로 진행하면 13까지는 만들 수 있지만 14를 만들지 못하게 되므로 짝순이가 졌다. 
숫자들과 사용 최대 회수가 주어질 때, 누가 어느 수에서 이기는지를 판별하는 프로그램을 작성하는 것이 문제다. 주어지는 숫자에는 반드시 1이 포함된다. 그렇지 않으면 홀순이가 1을 만들지 못하므로 무조건 지게 된다. 1이 꼭 있으니깐 쉽게 생각하면 상대방이 만든 방법에 1만 한 번 더 쓰면 되지라고 하기 쉽지만 숫자 사용 회수가 정해져 있으므로, 이 방법이 숫자가 커지는 경우에는 잘 되지 않는다. 위에서 13을 홀순이가 만들었지만 짝순이는 숫자 사용 제한 회수 때문에 14를 만들지 못하고 진다.
<입력값>
첫째 줄에 숫자 종류의 개수, 둘째 줄에는 주어지는 숫자들이 작은 것에서 큰 것으로 순서대로 나오며 (1000이하의 수), 세 번째 줄은 숫자 사용 회수(≤50)이 주어진다.
<출력값>
첫째 줄에 누가 몇 번째 숫자에서 이겼는지를 출력한다. (예제에서는 짝순이가 14를 못 만들어서, 홀순이가 14에서 이겼다)

<문제 1680>
쓰레기장에서 출발한 쓰레기차가 여러 지점들을 방문하며 쓰레기를 모으고 있다. 쓰레기차는 쓰레기장에서 가까운 지점부터 방문하며, 쓰레기를 모으다가 다음과 같은 경우에 쓰레기장으로 돌아가 싣고 있는 쓰레기를 비운다.

쓰레기의 양이 용량에 도달했을 때.
그 지점의 쓰레기를 실었을 때 쓰레기차의 용량을 넘게 될 때.
더 이상 쓰레기를 실을 지점이 없을 때.

쓰레기 모으기는 쓰레기차가 모든 지점의 쓰레기를 수거하여 쓰레기장에 도달했을 때 끝난다. 또한, 쓰레기차가 특정 지점에서 쓰레기를 실을 때는 한 번에 모두 실어야 한다.(즉, 쓰레기의 일부를 싣고 쓰레기장에 다녀온 뒤 나머지를 싣는 것은 허용되지 않는다.)
쓰레기차의 용량과 각 지점의 위치와 쓰레기의 양이 주어졌을 때, 위의 방법처럼 쓰레기차가 모든 쓰레기들을 쓰레기장에 수거했을 때 쓰레기차의 총 이동 거리를 구하자.
<입력값>
입력의 첫 번째 줄에는 테스트 케이스의 수 T가 주어진다.
각 테스트 케이스의 첫 번째 줄에는 쓰레기차의 용량 W와 지점의 개수 N이 주어진다. (1 <= W <= 1000, 1 <= N <= 1000)
다음 N개의 줄에는 i번째 지점의 쓰레기장으로부터의 거리 x_i와 쓰레기의 양 w_i가 주어진다. 각 지점의 x_i는 서로 다르며 x_i가 작은 지점부터 순서대로 입력이 주어진다. (0 <= x_i <= 100000, 1 <= w_i <= W) 모든 지점은 일직선 상에 있다.
<출력값>
각 테스트 케이스에 대하여, 쓰레기차가 모든 쓰레기를 수거하여 쓰레기장에 도달할 때까지 움직인 거리를 출력한다.

<문제 1681>
민승이는 N(1≤N≤1,000,000)명의 학생들에게 양의 정수로 된 라벨을 붙이려고 한다. 하지만 모든 학생들은 숫자 L(0≤L≤9)이 자신의 라벨 숫자에 포함되길 원치 않는다. 
문제는 학생들에게 숫자 L을 쓰지 않고 최소한 작은 N개의 양의 수 세트를 라벨링 할 때 학생들이 받는 라벨 중 가장 큰 수가 몇인지를 구하는 것이다.
<입력값>
첫째 줄에 N과 L이 공백으로 구분되어 주어진다.
<출력값>
첫째 줄에 민승이가 학생들에게 붙이는 라벨 중 가장 큰 수를 출력한다.

<문제 1682>
백준씨는 백준 큐브을 만들어 성공하고 난 뒤, 그것을 2차원 형식으로 바꾼 매직 스퀘어를 고안했다.
이것은 아래 그림과 같이 크기가 같은 여덟 개의 정사각형으로 되어 있다

이번 문제에서 우리는 각각의 정사각형 면이 서로 다른 색으로 칠해진 매직 스퀘어를 다룬다. 각 색깔은 1부터 시작하는 8개의 자연수로 표현된다. 한편, 스퀘어의 상태를 나타내는 수열이 있는데, 이는 여덟 개의 숫자로 이루어지며 좌측 상단부터 시작해서 시계 방향으로 수열의 수를 차례대로 채워나간다. 그러므로, 매직 스퀘어의 처음 상태를 이 수열로 나타내면 (1, 2, 3, 4, 5, 6, 7, 8)이 된다. 이를 특별한 경우로, 매직 스퀘어의 처음 상태라고 규정하겠다. 매직 스퀘어에는 네 가지 변환을 가할 수 있다. 이를 차례대로 A, B, C, D로 구분한다. 방법은 다음과 같다.

A: 윗줄과 아랫줄에 있는 수 4개를 모두 바꾼다.
B: 두 줄에 있는 수를 오른쪽으로 한 칸씩 옮기고, 맨 오른쪽에 있던 수를 맨 왼쪽으로 옮긴다.
C: 가운데에 있는 네 정사각형의 수를 반 시계 방향으로 한 번 돌린다.
D: 1번과 5번을 바꾼다. (1번과 5번이라는 것은 위치를 말함. 1,5번 위치는 위의 표의 숫자의 위치와 같음)

매직 스퀘어의 상태가 어떻든 위의 네 가지 변환을 시킬 수 있다.
이번 문제는 초기 상태에 있는 매직 스퀘어에 A, B, C, D 변환을 어느 횟수만큼 하여 지정한 상태의 매직 스퀘어를 만드는 최소의 동작 방법을 계산하는 프로그램을 작성하는 것이다. 참고로 안되는 경우는 없음.
<입력값>
첫째 줄에 매직 스퀘어의 숫자가 입력이 되며 순서는 위에서 말한 수열의 순서이다.
<출력값>
첫 줄에 A, B, C, D의 총 변환 횟수 L이 들어가야 한다.

<문제 1683>
데이브 존슨은 책 수집가이다. 오랜 세월이 지난 후 그는 너무 많은 책들을 모아서 새 책장을 사기로 결심했다. 그는 품질이 모두 다른 여러개의 책장을 샀는데, 문제는 그가 가장 좋아하는 책들을 가장 좋은 책장의 맨 위에 놓고 싶었다는 것이다. 이 책장의 한 칸은 최대 10개의 책을 넣을 수 있다.
그러나 괴짜인 데이브는 가장 좋아하는 책들을 정렬하는 특별한 방법이 있다. 그 책들은 당연히 알파벳 순서로 정렬되어 있어야 하지만, 또한 같은 알파벳이 제목의 같은 위치에 있는 책은 붙어 있으면 안 된다는 것이 문제. 또 중요한 것은 데이브는 오직 알파벳 문자만 문자로 치고, 띄어쓰기나 쉼표, `등은 문자로 치지 않는다는 것이다. 그러므로 "Portnoy's Complaint"라는 제목에서 's'는 8번째 문자이고, 'c'는 9번째 문자이다. 문제에 대한 예를 들자면 "The Grapes Of Wrath" 라는 제목의 책과 "One Flew Over The Cuckoo's Nest" 라는 제목의 책은 서로 붙어 있을 수 없는데, 그것은 두 제목의 세 번째 문자가 공통적으로 'e'이기 때문이다.
이 문제를 해결하려는 우리들을 도와주기 위해서(혹은 문제를 더 어렵게 만들기 위해서), 데이브는 '선호도 지수'라는 것을 모든 책들에 부여했다. 주어지는 책들과 선호도 지수의 목록을 활용해 데이브에게 그가 책장의 가장 윗 칸에 놓게 되는 책들의 목록을 알려 주자. 맨 윗 칸에 놓인 책들의 선호도 지수의 합이 가장 크게 만들어야 한다.
<입력값>
입력 파일마다 한 개의 테스트 케이스가 있다. 입력의 첫줄에는 데이브의 책장 맨 윗칸 후보에 올라있는 책들의 개수 N(10 ≤ N ≤ 2500)이, 그 뒤의 N개의 줄은 각각 책의 선호도 지수 E와 책의 제목 S가 한 칸의 띄어쓰기로 구별되어 입력되고, E는 200 이하의 자연수이며 S는 문자열이며 30문자를 넘지 않는다. S에는 적어도 하나의 알파벳 문자가 포함되어 있다. 입력은 stdin 형식이다.
<출력값>
출력의 첫째 줄은 데이브의 맨 윗칸에 놓을 책의 개수인 정수 M을 출력해야 하며, 두 번째 줄은 맨 윗 칸의 모든 책들의 선호도 지수의 합이어야 하고, 다음 M개의 줄은 맨 윗 칸에 놓을 책들의 제목이 사전식 순서로 정렬되어 출력되어야 한다. 한 개보다 많은 정답이 존재할 경우 아무 것이나 출력해도 상관 없다. 출력은 stdout 형식이어야 한다.

<문제 1684>
정수 N을 정수 D로 나눴을 때의 몫을 Q, 나머지를 R이라고 하면 항등식 R = N - Q*D가 성립한다.
n개의 정수로 된 수열이 있을 때, 모든 정수를 한 정수 D로 나눴을 때 나머지가 같아지는 경우가 있다. 그리고 수열에 따라서는 이러한 정수 D가 여러 개 존재할 수 있다.
n개의 정수로 된 수열이 주어졌을 때, 가장 큰 D를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 n(1≤n≤1,000)이 주어진다. 다음 줄에는 절댓값이 1,000,000을 넘지 않는 n개의 정수들이 주어진다.
<출력값>
첫째 줄에 가장 큰 D를 출력한다. 항상 가장 큰 D가 존재하는 경우만 입력으로 주어진다.

<문제 1685>
홀순이(holsoon)와 짝순이(jjaksoon) 둘이서 숫자 게임을 한다. 정수 1과 3이 주어지고, 이 둘을 통틀어 5번까지 마음대로 사용하여 그 합을 구하여 1,2,3,…을 만드는 놀이다. 먼저, 홀순이가 1 하나만을 사용하여 1을 만든다. 짝순이는 1+1로 1을 두 번 사용하여 2를 만들고, 다시 홀순이는 3을 만들어야하는데 1+1+1로 1을 세 번 사용하거나 3을 한 번 사용하여 3을 만든다. 짝순이는 1+1+1+1, 1+3으로 4를 만든다. 서로 번갈아서 상대방의 수보다 1이 큰 수를 만들어야 한다. 단, 1과 3을 통틀어 최대 5번 사용한다. 이런 식으로 진행하면 13까지는 만들 수 있지만 14를 만들지 못하게 되므로 짝순이가 졌다. 
숫자들과 사용 최대 회수가 주어질 때, 누가 어느 수에서 이기는지를 판별하는 프로그램을 작성하는 것이 문제다. 주어지는 숫자에는 반드시 1이 포함된다. 그렇지 않으면 홀순이가 1을 만들지 못하므로 무조건 지게 된다. 1이 꼭 있으니깐 쉽게 생각하면 상대방이 만든 방법에 1만 한 번 더 쓰면 되지라고 하기 쉽지만 숫자 사용 회수가 정해져 있으므로, 이 방법이 숫자가 커지는 경우에는 잘 되지 않는다. 위에서 13을 홀순이가 만들었지만 짝순이는 숫자 사용 제한 회수 때문에 14를 만들지 못하고 진다.
<입력값>
첫째 줄에 숫자 종류의 개수, 둘째 줄에는 주어지는 숫자들이 작은 것에서 큰 것으로 순서대로 나오며 (1000이하의 수), 세 번째 줄은 숫자 사용 회수(≤50,000)이 주어진다.
<출력값>
첫째 줄에 누가 몇 번째 숫자에서 이겼는지를 출력한다. (예제에서는 짝순이가 14를 못 만들어서, 홀순이가 14에서 이겼다)

<문제 1686>
오늘은 복날이다!
해빈이는 복날을 맞아 순살치킨 파티를 하기 위해 닭을 잡으려고 한다. 하지만 이번에도 쉽게 잡힐까보냐. 용감한 닭 한 마리가 해빈이에게서 도망치려 한다. 닭은 v m/sec의 속도로 이동할 수 있고, (xs, ys)에서 (xt, yt)에 존재하는 벙커까지 이동하면 해빈이에게서 도망칠 수 있다. 하지만 닭이 m분 이상 벙커 밖을 돌아다닌다면 바로 해빈이에게 잡혀 치킨이 되고 말 것이다.
과연 닭은 해빈이에게서 도망칠 수 있을까?
<입력값>
첫 번째 줄에는 닭의 속도 v와 생존 가능 시간 m이 주어진다. 두 번째 줄에는 닭의 시작 위치 xs와 ys가 공백을 사이에 두고 주어지며, 세 번째 줄에는 목적지의 위치 xt, yt가 주어진다.
그 다음부터는 중간 지점에 존재하는 벙커들의 좌표 x y가 주어진다.
모든 단위는 m(미터, meter)이다. 중간 지점에 존재하는 벙커들의 개수는 1,000개 이하이고, 모든 좌표의 범위는 -10,000에서 +10,000이다.
<출력값>
만약 닭이 해빈이에게서 도망치는데 성공한다면, 출력은 "Yes, visiting n other holes."이라고 해야 한다(이때 n은 거쳐야 하는 중간 지점 벙커의 최소 개수이다). 한편 닭의 미래가 처참하다면 "No."를 출력하면 된다.

<문제 1687>
0과 1로 이루어진 행렬이 있다. 이 행렬의 부분행렬은 이 행렬 안에 포함되는 행렬을 의미한다. 이러한 부분행렬들 중에서 0으로만 이루어진 부분행렬을 찾으려 한다. 그 중에서 가장 면적이 넓은 것을 구해내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 행렬의 크기를 나타내는 두 정수 N, M(1≤N, M≤333)이 주어진다. 다음 N개의 줄에는 M개의 정수(0또는 1)가 공백없이 주어진다. 이 숫자는 행렬을 구성하는 원소이다.
<출력값>
첫째 줄에 답을 출력한다.

<문제 1688>
지민이는 유명한 테러리스트이다. 지민이는 대연이, 영훈이, 범진이를 테러하려고 한다. 우석이는 대연이, 영훈이, 범진이를 테러에서 막아주려고 한다. 우석이는 지민이가 통과할 수 없는 방어막을 치려고 한다.
대연이와, 영훈이와, 범진이의 현재 위치가 좌표로 주어질 때, 우석이가 얘네들을 테러에서 막아줄 수 있는지 없는지 구하는 프로그램을 작성하시오. 다각형 경계위에 있는 경우에는 보호되는 것이다.
<입력값>
첫째 줄에 방어막의 꼭짓점의 개수 N(3 ≤ N ≤ 10,000)이 주어진다. 이어서 N개의 줄에는 꼭짓점들의 좌표가 순서대로 주어진다. 시계방향으로 주어질 수도 있고, 반시계방향으로 주어질 수도 있다. 이어서 세 개의 줄에는 대연이, 영훈이, 범진이의 좌표가 주어진다. 모든 좌표를 이루는 수는 0 이상 1,000,000,000 이하의 정수이다.
<출력값>
세 줄에 입력된 순서대로 테러에서 막아줄 수 있으면 1, 없으면 0을 출력한다.

<문제 1689>
1차원 좌표계 위에 선분 N개가 있다. 선분이 최대로 겹쳐있는 부분의 겹친 선분의 개수를 구해보자. 선분의 끝 점에서 겹치는 것은 겹치는 것으로 세지 않는다.
<입력값>
첫째 줄에는 선분의 개수(1 ≤ N ≤ 1,000,000)가 입력으로 들어온다. 그 다음 N개의 줄에 선분의 시작 좌표와 끝나는 좌표가 입력으로 들어온다. 선분의 좌표는 절댓값이 10억보다 작거나 같은 정수이다.
<출력값>
첫째 줄에는 최대로 많이 겹치는 선분들의 개수를 출력한다.

<문제 1690>
N개의 정수로 구성된 배열 A[1..N]가 있다. 이 배열의 원소들은 1부터 N사이의 정수이고 모두 다른 숫자이다. 배열 B[1..N]는 아래의 규칙에 의해 배열 A로부터 만들어진다.
B[A[A[i]]]=i, (1<=i<=n)
문제는 역으로 배열 B를 입력받으면 이에 해당하는 배열 A를 찾는 것이다. (물론 존재하지 않을수도 있다) 만약 가능한 배열 A가 두 개이상 존재한다면 그 중 임의로 하나만 출력하면 된다.
<입력값>
첫 번째 줄에 B배열의 원소 개수 N(1<=N<=20,000)이 입력된다. 두 번째 줄부터 N+1번째 줄까지 한 줄에 하나씩 B[1], …, B[N]이 차례대로 입력된다.
<출력값>
첫 번째 줄에 배열 A의 원소 개수 N을 출력한다. (해가 존재할 경우 배열 B의 원소 개수 N을 출력하고 해가 존재하지 않을 경우 0을 출력한다) 다음 줄부터 한 줄에 하나씩 A[1], …, A[N]을 출력한다.

<문제 1691>
고대에 유명한 조각가인 오세준은 또다른 걸작을 만들기 위한 준비 작업을 하고 있다. 그래서 가로 세로 크기가 W1×H1, W2×H2, ... Wn×Hn인 직사각형 모양의 대리석 석판이 여러 장 필요한 상태이다.
얼마 전, 세준이는 커다란 직사각형 석판을 받았다. 그래서 이것을 원하는 크기에 해당하는 석판들로 쪼개고 싶어한다. 석판은 임의의 정수 위치에서 가로나 세로로 완전히 잘라서 두 개의 직사각형 모양으로 자를 수 있다. 하지만 작은 석판들을 붙여서 큰 판으로 만들 수는 없다. 또한, 석판에는 일정한 방향으로 무늬가 있기 때문에, 회전해서 원하는 크기를 만들 수는 없다. 다시 말해, A×B라는 크기로 잘랐다면 이것을 B×A라는 크기에 맞추어 사용할 수는 없다는 뜻이다. 석판에서 원하는 크기에 해당하는 면을 모두 잘라 낸 뒤, 어느 크기로도 쪼갤 수 없어 남게 된 면들은 버려진다. 세준이는 원판을 어떻게 자르면 이러한 손실을 가능한 한 줄일 수 있을지 알고 싶어한다.

가로 길이가 21이고 세로 길이가 11인 커다란 석판을 예로 들어 보자. 그리고 우리에게 필요한 석판 크기의 종류가 10×4, 6×2, 7×5, 그리고 15×10이라고 가정하자. 이 경우 석판을 아래 그림과 같이 자르면, 각 크기에 해당하는 석판을 각각 두 장, 세 장, 세 장씩 얻으면서 손실되는 영역의 넓이는 10으로 가장 작게 된다.
  15×10의 크기는 한 장이라도 넣을 경우 전체의 손실이 너무 커지기 때문에, 만들기를 포기한 것이다. 한편으로, 가장 넓이가 작은 돌판만으로 여러 장을 잘라 낸다고 해도 손실을 이보다 줄일 수 없다는 것은, 손으로 따져 보면 금방 알 수 있다.
돌판의 원래 크기와 우리가 원하는 돌판 크기들을 입력 받은 뒤, 가장 효율적으로 돌판을 자르는 방법을 계산하여 그때 손실되는 최소한의 돌판 면적의 합을 구하는 프로그램을 작성하시오. 어느 크기의 돌판을 얼마나 얻느냐가 아니라, 어떻게 자르든 손실을 줄이는 것이 목적이다.
<입력값>
첫 줄에는 대리석 원판의 크기를 나타내는 W(가로 길이), H(세로 길이)가 들어있다. 다음 줄에는 우리가 원하는 크기의 개수 N이 있고, 그다음 N줄에는 그 크기들이 역시 가로, 세로 순으로 들어있다. 1≤ W, H ≤600이고 0 < N ≤ 200이다. 잘라야 하는 크기는 가로· 세로 모두 1 이상이고 원판의 크기 이하이다.
<출력값>
정수 하나를 출력한다. 원판을 가장 현명하게 잘랐을 때 손실되는 면적의 최솟값이다.

<문제 1692>
요즘 선풍적으로 팔리는 카드 중 하나는 앞면의 소녀시대가 새겨진 카드이다. 지원이와 항승이는 돈을 모아서 이 카드를 R*16개 사서 R*16 행렬로 나란히 정렬하여 놓았다. 그리고 평소 소녀시대에 환장하는 항승이는 모든 카드를 소녀시대가 그려져있는 앞면으로 놔둔채 흐뭇하게 감상하고 있었다.
하지만 소녀시대 중 한 멤버를 지독히 싫어하던  지원이는 그 멤버가 새겨진 카드들을 뒤집어 안 보이게하길 원하고 있다.
지원이는 카드 뒤집기 능력이 뛰어나 한 번에 가로나 세로로 연속된 카드들을 뒤집을 수 있다. 하지만 항승이가 잠시 홀려있는 상태에 있을 때 순식간에 뒤집어야하기 때문에 뒤집는 횟수를 최소한 줄이려 한다. (뒤집는 카드 수가 아닌 뒤집는 연산의 수인 것에 주의한다) 이런 지원이의 고민을 도와주자.
<입력값>
첫 번째 줄에 카드 행의 수인 R (1 ≤ R ≤ 50)이 주어진다. 다음 R개의 줄에 길이가 16인 '0' 또는 '1'로 구성된 문자열이 주어진다. '0'은 지원이가 싫어하지 않는 멤버가 그려져 있는 카드, '1'은 지원이가 싫어하는 멤버가 그려져 있는 카드이다. 맨 처음 모든 카드는 앞면이다.
<출력값>
지원이가 싫어하지 않는 멤버는 전부 앞면, 싫어하는 멤버는 전부 뒷면인 상태가 되게 하는 뒤집는 연산의 최소 횟수를 출력한다.

<문제 1693>
n개의 정점으로 이루어진 트리가 있다. 이 트리의 각 정점을 색칠하려고 한다. 색칠을 할 때에는 1, 2, 3, …, n번 색깔 중에 하나로 색칠하여야 한다. 각 색깔을 사용하여 한 개의 정점을 색칠할 때마다 1, 2, …, n의 비용이 든다. 즉, i번 색깔로 한 개의 정점을 색칠하면 i만큼의 비용이 든다는 것이다.
또한 정점에 색칠을 할 때에, 주어진 트리 상에서 인접해 있는 서로 다른 두 정점은 서로 다른 색깔로 칠해져야 한다. 이를 만족하면서, 전체 정점들을 색칠하는데 드는 총 비용을 최소화 하려 한다. 최소 비용을 계산하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 정점 및 색깔의 개수 n(1≤n≤100,000)이 주어진다. 다음 n-1개의 줄에는 각 줄에 두 개의 정수로 주어진 트리 상에서 연결되어 있는 두 정점의 번호가 주어진다.
<출력값>
첫째 줄에 최소 비용을 출력한다.

<문제 1694>
Forsyth-Edwards 방식 체스에서는 다음과 같은 표기를 따른다.

게임 내용은 왼쪽 상단부터 시작해서 오른쪽 하단까지 표시한다.
문자 / 는 줄을 구분하기 위해 사용한다.
각 줄은 왼쪽에서 오른쪽으로 표시한다.
흰색 말은 영어 대문자로 다음과 같이 나타낸다 : PNBRQK
검은색 말은 영어 소문자로 다음과 같이 나타낸다 : pnbrqk
빈 칸은 1부터 8까지의 숫자로 나타낸다.
숫자는 연속된 빈칸의 개수를 뜻한다.
각 행에서 숫자와 문자의 합은 반드시 8이다.

예를 들면,

5k1r/2q3p1/p3p2p/1B3p1Q/n4P2/6P1/bbP2N1P/1K1RR3

은 아래의 체스판을 FEN으로 나타낸 것이다.

게임이 시작될 때 체스판은 아래와 같은 상태로 시작한다.

rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR

우리가 해야할 일은, FEN으로 나타낸 체스판이 주어지면 어떤 말도 공격할 수 없는 빈 칸의 개수를 세는 프로그램을 작성하는 것이다.
<입력값>
여러 줄에 걸쳐, FEN로 표기한 체스판이 주어진다. 말의 위치는 임의로 정해진 것이므로 규칙에 어긋날 수 도 있다.
각 줄은 공백없이 주어진다.
<출력값>
각 입력마다 어느곳으로도 공격받지 않는 빈칸의 개수를 출력한다.

<문제 1695>
앞에서 뒤로 보나, 뒤에서 앞으로 보나 같은 수열을 팰린드롬 이라고 한다. 예를 들어 {1}, {1, 2, 1}, {1, 2, 2, 1}과 같은 수열은 팰린드롬 이지만, {1, 2, 3}, {1, 2, 3, 2} 등은 팰린드롬이 아니다.
한 수열이 주어졌을 때, 이 수열에 최소 개수의 수를 끼워 넣어 팰린드롬을 만들려고 한다. 최소 몇 개의 수를 끼워 넣으면 되는지를 알아내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 수열의 길이 N(1≤N≤5,000)이 주어진다. 다음 줄에는 N개의 수열을 이루는 수들이 주어진다. 각 수들은 int 범위이다.
<출력값>
첫째 줄에 끼워 넣을 수들의 최소 개수를 출력한다.

<문제 1696>
상근이는 양 끝 부분이 칠해진 나무 막대 몇 개를 가지고 있다. 상근이는 문득 같은 색깔끼리 닿게 막대를 일직선으로 놓고 싶었다. 그것이 가능한지 불가능한지 알아보는 프로그램을 작성하시오.
<입력값>
입력은 (막대의 개수)줄로 이루어져 있다. 두 단어가 있는데, 각 막대의 양 끝 부분의 색깔을 나타내고, 영어 소문자이며 최대 10자이다. 두 단어 사이에는 공백이 있다. 막대의 개수는 최대 25만 개이다.
<출력값>
일직선으로 막대가 놓여질 수 있으면 Possible, 그렇지 않으면 Impossible을 출력한다.

<문제 1697>
수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동하게 된다.
수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.
<입력값>
첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.
<출력값>
수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.

<문제 1698>
'강화보안기구'라는 회사는 아주 복잡한 전자암호와 보안장치를 만들고 있습니다.
최근 만든 발명품은 R개의 행과 C개의 열로 된 보안 패널입니다. 왼쪽부터 오른쪽으로 숫자가 매겨져 있고, 왼쪽 위가 1, 오른쪽 아래가 R x C로 번호가 매겨져 있습니다. 두 가지 상태로 이루어져 있는데, 켜진 상태와 꺼진 상태입니다. 이 버튼을 누르면 신호가 꺼짐에서 켜짐으로 바뀌거나 켜짐에서 켜짐을 바뀝니다. 한 버튼을 누르면 그 버튼을 중심으로 한 패턴에 따라 신호가 바뀝니다. 이 보안 패널를 해제하려면 모든 버튼이 켜져 있어야 합니다.
예를 들어, 만약 한 버튼을 누르면 누른 버튼과 그 버튼의 위 버튼, 왼쪽 위 버튼, 왼쪽 아래 버튼이 신호가 바뀐다면 가운데 버튼을 눌렀을 때 이렇게 됩니다 :

만약 이 패턴을 2 x 3 보안 패널에 적용시킨다면 2,5,6번 버튼을 누르면 모든 버튼을 킬 수 있습니다. 이것이 과정입니다 :
<입력값>
첫째 줄은 패널의 넓이 R,C(1<=R,C<=5)가 주어지고, 다음 세 줄은 어떤 패턴으로 신호가 바꾸는지를 입력해 줍니다. "*"이 가운데 버튼을 눌렀을 때 신호가 바뀌는 버튼이고, "."은 변하지 않는 버튼입니다.
"0 0" 한 줄로 입력을 받으면 입력이 끝납니다.
<출력값>
각 케이스마다 "Case # Ti"로  출력한 후(지금이 Ti번째 테스트 케이스를 실행하고 있을 때), 만약 가능하다면 누른 버튼을 공백을 하나씩 두고 오름차순으로 출력하고 불가능하다면 "Impossible."이라고 출력합니다. 누른 버튼을 출력할 때에는 최소 횟수를 출력합니다.
가능한 정답이 여러 가지인 경우에는 출력할 수열을 뒤집은 결과가 사전순으로 가장 앞서는 수열을 출력해야 한다.

<문제 1699>
어떤 자연수 N은 그보다 작거나 같은 제곱수들의 합으로 나타낼 수 있다. 예를 들어 11=32+12+12(3개 항)이다. 이런 표현방법은 여러 가지가 될 수 있는데, 11의 경우 11=22+22+12+12+12(5개 항)도 가능하다. 이 경우, 수학자 숌크라테스는 “11은 3개 항의 제곱수 합으로 표현할 수 있다.”라고 말한다. 또한 11은 그보다 적은 항의 제곱수 합으로 표현할 수 없으므로, 11을 그 합으로써 표현할 수 있는 제곱수 항의 최소 개수는 3이다.
주어진 자연수 N을 이렇게 제곱수들의 합으로 표현할 때에 그 항의 최소개수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 자연수 N이 주어진다. (1 ≤ N ≤ 100,000)
<출력값>
주어진 자연수를 제곱수의 합으로 나타낼 때에 그 제곱수 항의 최소 개수를 출력한다.

<문제 1700>
기숙사에서 살고 있는 준규는 한 개의 멀티탭을 이용하고 있다. 준규는 키보드, 헤어드라이기, 핸드폰 충전기, 디지털 카메라 충전기 등 여러 개의 전기용품을 사용하면서 어쩔 수 없이 각종 전기용품의 플러그를 뺐다 꽂았다 하는 불편함을 겪고 있다. 그래서 준규는 자신의 생활 패턴을 분석하여, 자기가 사용하고 있는 전기용품의 사용순서를 알아내었고, 이를 기반으로 플러그를 빼는 횟수를 최소화하는 방법을 고안하여 보다 쾌적한 생활환경을 만들려고 한다.
예를 들어 3 구(구멍이 세 개 달린) 멀티탭을 쓸 때, 전기용품의 사용 순서가 아래와 같이 주어진다면, 

키보드
헤어드라이기
핸드폰 충전기
디지털 카메라 충전기
키보드
헤어드라이기

키보드, 헤어드라이기, 핸드폰 충전기의 플러그를 순서대로 멀티탭에 꽂은 다음 디지털 카메라 충전기 플러그를 꽂기 전에 핸드폰충전기 플러그를 빼는 것이 최적일 것이므로 플러그는 한 번만 빼면 된다.
<입력값>
첫 줄에는 멀티탭 구멍의 개수 N (1 ≤ N ≤ 100)과 전기 용품의 총 사용횟수 K (1 ≤ K ≤ 100)가 정수로 주어진다. 두 번째 줄에는 전기용품의 이름이 K 이하의 자연수로 사용 순서대로 주어진다. 각 줄의 모든 정수 사이는 공백문자로 구분되어 있다.
<출력값>
하나씩 플러그를 빼는 최소의 횟수를 출력하시오.

<문제 1701>
Cubelover는 프로그래밍 언어 Whitespace의 코딩을 도와주는 언어인 Cubelang을 만들었다. Cubelang을 이용해 코딩을 하다보니, 점점 이 언어에 맞는 새로운 에디터가 필요하게 되었다. 오랜 시간 고생한 끝에 새로운 에디터를 만들게 되었고, 그 에디터의 이름은 Cubeditor이다.
텍스트 에디터는 찾기 기능을 지원한다. 대부분의 에디터는 찾으려고 하는 문자열이 단 한 번만 나와도 찾는다. Cubelover는 이 기능은 Cubelang에 부적합하다고 생각했다. Cubelang에서 필요한 기능은 어떤 문자열 내에서 부분 문자열이 두 번 이상 나오는 문자열을 찾는 기능이다. 이때, 두 부분 문자열은 겹쳐도 된다.
예를 들어, abcdabc에서 abc는 두 번 나오기 때문에 검색이 가능하지만, abcd는 한 번 나오기 때문에 검색이 되지를 않는다.
이렇게 어떤 문자열에서 두 번 이상 나오는 부분 문자열은 매우 많을 수도 있다. 이러한 부분 문자열 중에서 가장 길이가 긴 것을 구하는 프로그램을 작성하시오.
예를 들어, abcabcabc에서 abc는 세 번 나오기 때문에 검색할 수 있다. 또, abcabc도 두 번 나오기 때문에 검색할 수 있다. 하지만, abcabca는 한 번 나오기 때문에 검색할 수 없다. 따라서, 두 번 이상 나오는 부분 문자열 중에서 가장 긴 것은 abcabc이기 때문에, 이 문자열이 답이 된다.
<입력값>
첫째 줄에 문자열이 주어진다. 문자열의 길이는 최대 5,000이고, 문자열은 모두 소문자로만 이루어져 있다.
<출력값>
입력에서 주어진 문자열의 두 번이상 나오는 부분문자열 중에서 가장 긴 길이를 출력한다.

<문제 1702>
서울 내의 고속도로 도로망의 이용 요금이 빠르게 증가하고 있다. 때문에 최적의 경로를 찾는 것이 실제 문제로 제기되고 있다. 고속도로 도로망은 두 도시간의 양방향 도로들로 구성되어 있다. 각각의 도로에 대해 도로 이용요금과 도로를 지나가는데 걸리는 시간이 알려져 있다.
경로는 여행하는데 이용하는 도로들을 나열한 것을 의미한다. 경로상의 총 이동시간은 경로상의 도로들을 지나가는데 걸리는 시간의 합을 의미한다. 또한 경로상의 총 요금은 이동하는 도로들의 이용요금의 총합을 말한다. 그리고 경로상의 총 이용시간이 적을수록, 이용요금이 적을수록 더 좋은 경로가 된다. 즉, 어떤 경로가 다른 경로보다 좋다는 말은 이 경로가 다른 경로보다 빠르고 이용요금이 적다는 것을 의미한다. 우리는 어떠한 경로가 다른 어떤 경로보다도 좋은 경로일 때 이를 최적의 경로라 부른다. 하지만 항상 이러한 최적의 경로가 존재하는 것은 아니다.
예를 들어, 아래의 그림과 같은 고속도로 도로망이 있다고 하자. 각각의 도로는 요금과 이동하는데 걸리는 시간을 나타내는 한 쌍의 숫자로 구성되어진다,

그리고 도시 1에서 도시 4로 가는데는 총 4가지 경로가 존재한다. 4가지 경로에 대해 총 이동시간과 요금을 계산하여 보면 1-2-4(요금 4, 시간 5), 1-3-4(요금 4, 시간 5), 1-2-3-4(요금 6, 시간 4), 1-3-2-4(요금 4, 비용 10)이 된다.
그리고 여기서 경로 1-3-4와 1-2-4가 경로 1-3-2-4보다 좋은 것을 알 수 있다. 이 도로망에서는 효율적인 요금-시간 쌍이 두 가지 존재한다. 요금 4, 시간 5(경로 1-2-4, 1-3-4), 요금 6, 시간 4(경로 1-2-3-4). 만약 요금을 많이 내더라도 빠른 길을 원한다면 경로 1-2-3-4를 선택하면 되고 반대로 시간은 조금 더 걸리더라도 요금을 적게 내고 싶으면 경로 1-3-4 또는 1-2-4를 선택하면 된다.
문제는 고속도로 도로망에 대한 정보가 주어지면 시작 도시에서 끝 도시까지 연결하는 효율적인 경로를 계산하는 것이다. 우리는 단지 서로 다른 효율적인 비용-시간 쌍의 개수만 출력하면 된다.
문제는 지역들이 노드로 구성된 그래프가 주어졌을 때 원샘이 원하는 지역 간의 거리를 신속히 알려주는 것이다.
<입력값>
첫째 줄에 도시의 개수 n(1≤n≤100), 도로의 개수 m(1≤m≤300), 시작 도시 s, 도착 도시 e가 주어진다. (1≤s,e≤n, s≠e) 그 다음부터 m개의 줄에 도로에 대한 정보가 주어지는데 한 줄에 한 도로의 양 끝점 p, r(1≤p,r≤n, p≠r)과 요금 c(0≤c≤100), 그리고 시간 t(0≤t≤100)이 주어진다. 두 개 도시 사이에는 한 개 이상의 도로가 존재할 수 있다.
<출력값>
첫 줄에 서로 다른 효율적인 비용-시간 쌍의 개수를 출력한다.

<문제 1703>
branchorama 나무는 특이한 규칙을 가지고 성장합니다. 어린 branchorama 초목은 하나의 잎을 꼭대기에 가진 가는 묘목이며, 그 잎에는 생장점이 있습니다. 성장하는 계절 동안 나무의 생장점들은 여러 개의 가지로 나뉘게 되며, 성장이 끝나면 각 가지는 생장점을 가진 하나의 잎을 꼭대기에 매달게 됩니다. 놀랍게도 같은 나무의 모든 생장점들은 같은 숫자(splitting factor)의 가지로 나뉘며, 그 숫자는 해가 지남에 따라 변합니다.
아래의 예는 Brown 씨의 과수원에서 한 branchorama 나무가 유목에서부터 3년간 자란 결과를 보여줍니다.

예시에서 예측할 수 있듯이, branchorama 나무는 과밀하게 성장하는 경향이 있습니다. 따라서 Brown 씨는 매 겨울마다 과도하게 성장한 나무들의 가지를 쳐냅니다. 아래는 가지를 쳐낸  branchorama 나무의 예입니다

branchorama 나뭇잎은 굉장히 크고 광합성에 유리하지만, 오직 생장점이 온전히 보존된 가지의 끝에만 달립니다. 따라서 나무가 버티지 못할 정도로 가지를 쳐내는 일은 없어야 합니다.
Brown 씨는 각 나무가 몇 개의 잎을 가졌는지 알고 싶어합니다. 나뭇잎을 일일이 세는 것은 지루하기 때문에, 각 해(level) 성장기의 splitting factor와 그 해 겨울에 쳐낸 가지의 수를 이용해 Brown 씨에게 나뭇잎의 수를 알려주세요.
<입력값>
입력의 각 줄은 하나의 branchorama 나무를 의미합니다.
각 줄은 나무의 나이 a(1 ≤ a ≤ 20)로 시작하며, 그 뒤로 2a 개의 정수가 공백을 두고 주어집니다. 2a 개의 정수는 splitting factor와 가지치기 한 가지의 수가 level 별로 나열된 것입니다.
마지막 줄로  '0'이 주어지며 더 이상의 입력은 없습니다. '0'은 처리하지 않습니다.
<출력값>
각 나무에 대하여 나무에 달려있는 잎의 수를 한 줄씩 출력하세요. 나뭇잎의 수가 signed 32-bit integer를 초과하지 않는다고 가정해도 좋습니다.

<문제 1704>
성지는 몰래 열심히 붕어빵타이쿤을 즐기는 중이었다. 하지만 이것은 기존의 붕어빵타이쿤 게임과는 조금 다르다.
M*N 격자에 붕어빵이 들어가 있다. (현재 앞면이 위로 굽히는 것도 있고 뒷면이 위로 굽히는 것도 있다.) 그리고 어떤 한 격자를 누른다면 그 격자를 포함해서 4방에 위치한 붕어빵들도(물론 가장자리에서는 주변에 2개 또는 3개이다) 동시에 뒤집히게 된다.
붕어빵이 노릇하게 익어 모두 꺼낼 때가 되었다. 단 규칙이 있는데 앞면이 위로 보이는 상태에서만 꺼낼 수 있다는 것이다. 느긋하게 뒤집다간 붕어빵이 타고 손님들은 화를 내고 게임은 종료되게 된다. 이에 최소한의 격자만을 눌러 모든 붕어빵이 앞면이 위로 보이게 하려한다. 우리는 이런 성지를 도와주자.
<입력값>
첫째 줄에는 격자의 세로, 가로 크기를 나타내는 두 정수 M과 N이 주어진다. 두 번째부터 M+1번째 줄까지 N개의 0 또는 1의 숫자가 주어지는데 0은 현재 앞면이 위로 보이는 붕어빵이고 1은 현재 앞면이 뒤로 보이는 붕어빵이다. (N ≤ 15, M ≤ 15)
<출력값>
M개의 줄에 N개의 숫자를 출력한다. 이 숫자는 (M, N) 번째 격자를 최종적으로 몇 번 뒤집어야 하는지 나타내는 숫자이다. 단 답이 존재하지 않을 경우 "IMPOSSIBLE"을 출력하고 답이 여러 개 존재할 경우 위에서부터 오른쪽으로 읽을 때 한 줄씩 읽을 때 사전 순으로 가장 빠른 것을 출력한다.

<문제 1705>
민승이는 정문이에게 미션을 주면서 즐기고 있다. 정문이는 눈에 헤드밴드를 썼기 때문에 앞을 볼 수 없다.
미션은 1부터 N까지 번호가 붙어진 N개의 컵으로 진행된다. 처음에 민승이는 이 N개의 컵 중 한 컵에 공을 넣는다. (당연히 정문이는 어디에 넣은지 알 수 없다) 그 다음부터 정문이는 매 단계마다 'A' 또는 'B' 문자를 부르고 이에 따라 민승이는 공을 꺼내서 다른 컵으로 넣는다. (꺼내서 다시 동일한 컵에 넣을 수도 있다.) 단 민승이가 공을 꺼내서 넣는 컵은 현재 컵의 위치와 정문이가 부른 알파벳에 의해서만 결정된다.
만약에 현재 공이 K번째 컵에 있다면 이 컵은 정문이가 부른 알파벳에 의해서 Ak(정문이가 'A'를 불렀을 경우) 또는 Bk(정문이가 'B'를 불렀을 경우)번째 컵으로 이동하게 된다.
정문이의 미션은 처음에 민승이가 공을 어떤 컵에 넣든지간에 최종적으로 이 공이 컵 1로 들어가게 하는 것이다. 우리는 이런 정문이를 도와 공이 컵 1로 들어가기 위해 정문이가 불러야할 알파벳 문자열을 찾는것이다. 단, 이 문자열은 10,000보다 작아야 한다.
<입력값>
첫 번째 줄에 컵의 개수 N (1 ≤ N ≤ 500)이 주어진다. 그 다음 N개의 줄에는 한 컵에 대한 Ak와 Bk가 공백으로 구분되어 주어진다. (두 번째 줄에 A1과 B1, 다음 줄에 A2와 B2 등이 주어진다는 뜻이다)
<출력값>
정문이가 불러야할 A또는 B로 구성된 문자열을 출력한다. (여러 해가 존재할 경우에는 그 중 하나만 출력되면 되고 항상 답이 존재하는 입력만 주어진다고 하자.) 문자열의 길이는 10,000보다 작거나 같아야 한다.

<문제 1706>
동혁이는 크로스워드 퍼즐을 좋아한다. R×C 크기의 크로스워드 퍼즐을 생각해 보자. 이 퍼즐은 R×C 크기의 표로 이루어지는데, 퍼즐을 다 풀면 금지된 칸을 제외하고는 각 칸에 알파벳이 하나씩 적혀 있게 된다. 아래는 R = 5, C = 5 인 경우 다 푼 퍼즐의 한 예이다. 검은 칸은 금지된 칸이다.

세로 또는 가로로 연속되어 있고, 더 이상 확장될 수 없는 낱말이 퍼즐 내에 존재하는 단어가 된다. 위의 퍼즐과 같은 경우, 가로 낱말은 good, an, messy, it, late의 5개가 있고, 세로 낱말은 game, one, sit, byte의 4개가 있다. 이 중 사전식 순으로 가장 앞서 있는 낱말은 an이다.
다 푼 퍼즐이 주어졌을 때, 퍼즐 내에 존재하는 모든 낱말 중 사전식 순으로 가장 앞서 있는 낱말을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 퍼즐의 R과 C가 빈 칸을 사이에 두고 주어진다. (2 ≤ R, C ≤ 20) 이어서 R개의 줄에 걸쳐 다 푼 퍼즐이 주어진다. 각 줄은 C개의 알파벳 소문자 또는 금지된 칸을 나타내는 #로 이루어진다. 낱말이 하나 이상 있는 입력만 주어진다.
<출력값>
첫째 줄에 사전식 순으로 가장 앞서 있는 낱말을 출력한다.

<문제 1707>
그래프의 정점의 집합을 둘로 분할하여, 각 집합에 속한 정점끼리는 서로 인접하지 않도록 분할할 수 있을 때, 그러한 그래프를 특별히 이분 그래프 (Bipartite Graph) 라 부른다.
그래프가 입력으로 주어졌을 때, 이 그래프가 이분 그래프인지 아닌지 판별하는 프로그램을 작성하시오.
<입력값>
입력은 여러 개의 테스트 케이스로 구성되어 있는데, 첫째 줄에 테스트 케이스의 개수 K(2≤K≤5)가 주어진다. 각 테스트 케이스의 첫째 줄에는 그래프의 정점의 개수 V(1≤V≤20,000)와 간선의 개수 E(1≤E≤200,000)가 빈 칸을 사이에 두고 순서대로 주어진다. 각 정점에는 1부터 V까지 차례로 번호가 붙어 있다. 이어서 둘째 줄부터 E개의 줄에 걸쳐 간선에 대한 정보가 주어지는데, 각 줄에 인접한 두 정점의 번호가 빈 칸을 사이에 두고 주어진다.
<출력값>
K개의 줄에 걸쳐 입력으로 주어진 그래프가 이분 그래프이면 YES, 아니면 NO를 순서대로 출력한다.

<문제 1708>
다각형의 임의의 두 꼭짓점을 연결하는 선분이 항상 다각형 내부에 존재하는 다각형을 볼록 다각형이라고 한다. 아래 그림에서 (a)는 볼록 다각형이며, (b)는 볼록 다각형이 아니다.

조금만 생각해 보면 다각형의 모든 내각이 180도 이하일 때 볼록 다각형이 된다는 것을 알 수 있다. 편의상 이 문제에서는 180도 미만인 경우만을 볼록 다각형으로 한정하도록 한다.
2차원 평면에 N개의 점이 주어졌을 때, 이들 중 몇 개의 점을 골라 볼록 다각형을 만드는데, 나머지 모든 점을 내부에 포함하도록 할 수 있다. 이를 볼록 껍질 (CONVEX HULL) 이라 한다. 아래 그림은 N=10인 경우의 한 예이다.

점의 집합이 주어졌을 때, 볼록 껍질을 이루는 점의 개수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 점의 개수 N(3 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N개의 줄에 걸쳐 각 점의 x좌표와 y좌표가 빈 칸을 사이에 두고 주어진다. 주어지는 모든 점의 좌표는 다르다. x좌표와 y좌표의 범위는 절댓값 40,000을 넘지 않는다. 입력으로 주어지는 다각형의 모든 점이 일직선을 이루는 경우는 없다.
<출력값>
첫째 줄에 볼록 껍질을 이루는 점의 개수를 출력한다.
볼록 껍질의 변에 점이 여러 개 있는 경우에는 가장 양 끝 점만 개수에 포함한다.

<문제 1709>
한 변의 길이가 1cm인 정사각형 모양의 타일이 있다. 이 타일들이 큰 정사각형을 빈틈없이 채우고 있는데, 정사각형의 한 변의 길이는 짝수이다. 이 한 변의 길이를 Ncm이라고 하자.
큰 정사각형에 접하는 원을 그린다. 정사각형을 이루고 있는 N×N개의 타일 중에는 원의 둘레가 그려진 타일도 있고, 그렇지 않은 타일도 있게 된다. 원의 둘레가 그려져 있는 타일의 개수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 짝수 N(2 ≤ N ≤ 150,000,000)이 주어진다.
<출력값>
첫째 줄에 원의 둘레가 그려진 타일의 개수를 출력한다.

<문제 1710>
Mensa Web Design Ltd specialises in creating table-based HTML layouts for corporate clients. As a new employee at Mensa, you have been asked to tackle a table simplification problem that has been affecting the company. In short, rather than deal with complicated sets of nested HTML tables, Mensa would prefer that they were flattened into single tables containing equivalently laid-out cells.
For the purposes of this task, you will be working with a subset of HTML even smaller than the subset that Mensa generally uses. Your subset includes only very simple text and well-formed tables, and can be described by the following grammar:

(‘. . . ’ indicates that the preceding grammar element may appear in the expansion zero or more times. Whitespace in the grammar is for clarity only; the only whitespace that actually appears in this HTML subset language is the spaces shown explicitly as ‘’ in the ROWSPAN and COLSPAN elements.)
All ROWs in a TABLE will each contain the same number of CELLs, except for when cells are omitted due to preceding spanned cells above them or to their left. For example, the following snippets of HTML source code specify the tables shown alongside them. Notice how in the second example the first cell in the second row is omitted and ‘<td>C</td>’ actually defines the row’s second cell.

Tables can be nested, which occurs when the CONTENTS for one or more cells is another TABLE rather than simply being TEXT. Mensa’s graphic design department produces layouts which never use row or column spans (so their cell start tags are always simply ‘<td>’) but often use nested tables. They will even nest tables within several cells in different areas of a table, but never more than one on the same row or column of the enclosing table.
For example, this HTML source code produces the nested layout shown on the left:

The layout on the right is a single 4 by 4 table containing cells that are laid-out equivalently to the nested layout on the left. (The cells are not the same size or shape, but that is something that will be taken care of by the graphic designer in the final tidying up.) This layout is produced by the following HTML source code:

Your task is to take nested table layouts as produced by the graphic design department and transform them into equivalent layouts using a single table, introducing row and column spans as necessary.
<입력값>
Input will consist of a line containing '<body>', followed by any number of lines each containing a nested table layout, one per line, followed by a line containing '</body>'.
Each line except the first and last will contain no more than 10,000 characters, and will consist of a sequence of '<table>', '<tr>', '<td>', '</td>', '</tr>', '</table>', and alphanumeric tokens matching a valid TABLE according to the grammar above. This table will contain no cells with row or column spans, but may contain nested tables. Tables may be nested up to 10 deep, and the resulting equivalent flattened table will contain at least one row and one column and no more than 100 rows and 100 columns. Each TEXT sequence will contain no more than 100 alphanumeric characters.
Output must consist of a line containing '<body>', followed by one line for each input table layout line, followed by a line containing '</body>'.
Each output line except the first and last must contain a flattened table layout equivalent to the nested layout on the corresponding input line. These lines must contain a valid TABLE according to the grammar above, but with the only allowable CONTENTS being TEXT (i.e., without any nested sub-tables); in particular, all ‘HTML tags’ must be in lowercase, and row and column spans must have a single space and quotation marks (and must be omitted if their NUMBER would be ‘1’), as shown in the grammar.
<출력값>


<문제 1711>
2차원 평면에 N개의 점이 주어져 있다. 이 중에서 세 점을 골랐을 때, 직각삼각형이 몇 개나 있는지를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 점의 개수 N(3≤N≤1,500)이 주어진다. 둘째 줄부터 N개의 줄에 걸쳐 각 점의 x좌표와 y좌표가 빈 칸을 사이에 두고 주어진다. 좌표값은 절댓값이 1,000,000,000을 넘지 않는 정수이며, 주어지는 모든 점의 좌표는 다르다고 가정해도 좋다.
<출력값>
첫째 줄에 직각삼각형의 개수를 출력한다.

<문제 1712>
월드전자는 노트북을 제조하고 판매하는 회사이다. 노트북 판매 대수에 상관없이 매년 임대료, 재산세, 보험료, 급여 등 A만원의 고정 비용이 들며, 한 대의 노트북을 생산하는 데에는 재료비와 인건비 등 총 B만원의 가변 비용이 든다고 한다.
예를 들어 A=1,000, B=70이라고 하자. 이 경우 노트북을 한 대 생산하는 데는 총 1,070만원이 들며, 열 대 생산하는 데는 총 1,700만원이 든다.
노트북 가격이 C만원으로 책정되었다고 한다. 일반적으로 생산 대수를 늘려 가다 보면 어느 순간 총 수입(판매비용)이 총 비용(=고정비용+가변비용)보다 많아지게 된다. 최초로 총 수입이 총 비용보다 많아져 이익이 발생하는 지점을 손익분기점(BREAK-EVEN POINT)이라고 한다.
A, B, C가 주어졌을 때, 손익분기점을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 A, B, C가 빈 칸을 사이에 두고 순서대로 주어진다. A, B, C는 21억 이하의 자연수이다.
<출력값>
첫 번째 줄에 손익분기점 즉 최초로 이익이 발생하는 판매량을 출력한다. 손익분기점이 존재하지 않으면 -1을 출력한다.

<문제 1713>
월드초등학교 학생회장 후보는 일정 기간 동안 전체 학생의 추천에 의하여 정해진 수만큼 선정된다. 그래서 학교 홈페이지에 추천받은 학생의 사진을 게시할 수 있는 사진틀을 후보의 수만큼 만들었다. 추천받은 학생의 사진을 사진틀에 게시하고 추천받은 횟수를 표시하는 규칙은 다음과 같다.

학생들이 추천을 시작하기 전에 모든 사진틀은 비어있다.
어떤 학생이 특정 학생을 추천하면, 추천받은 학생의 사진이 반드시 사진틀에 게시되어야 한다.
비어있는 사진틀이 없는 경우에는 현재까지 추천 받은 횟수가 가장 적은 학생의 사진을 삭제하고, 그 자리에 새롭게 추천받은 학생의 사진을 게시한다. 이때, 현재까지 추천 받은 횟수가 가장 적은 학생이 두 명 이상일 경우에는 그러한 학생들 중 게시된 지 가장 오래된 사진을 삭제한다.
현재 사진이 게시된 학생이 다른 학생의 추천을 받은 경우에는 추천받은 횟수만 증가시킨다.
사진틀에 게시된 사진이 삭제되는 경우에는 해당 학생이 추천받은 횟수는 0으로 바뀐다.

후보의 수 즉, 사진틀의 개수와 전체 학생의 추천 결과가 추천받은 순서대로 주어졌을 때, 최종 후보가 누구인지 결정하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 사진틀의 개수 N이 주어진다. (1≤N≤20) 둘째 줄에는 전체 학생의 총 추천 횟수가 주어지고, 셋째 줄에는 추천받은 학생을 나타내는 번호가 빈 칸을 사이에 두고 추천받은 순서대로 주어진다. 총 추천 횟수는 1,000번 이하이며 학생을 나타내는 번호는 1부터 100까지의 자연수이다.
<출력값>
사진틀에 사진이 게재된 최종 후보의 학생 번호를 증가하는 순서대로 출력한다.

<문제 1715>
정렬된 두 묶음의 숫자 카드가 있다고 하자. 각 묶음의 카드의 수를 A, B라 하면 보통 두 묶음을 합쳐서 하나로 만드는 데에는 A+B 번의 비교를 해야 한다. 이를테면, 20장의 숫자 카드 묶음과 30장의 숫자 카드 묶음을 합치려면 50번의 비교가 필요하다.
매우 많은 숫자 카드 묶음이 책상 위에 놓여 있다. 이들을 두 묶음씩 골라 서로 합쳐나간다면, 고르는 순서에 따라서 비교 횟수가 매우 달라진다. 예를 들어 10장, 20장, 40장의 묶음이 있다면 10장과 20장을 합친 뒤, 합친 30장 묶음과 40장을 합친다면 (10 + 20) + (30 + 40) = 100번의 비교가 필요하다. 그러나 10장과 40장을 합친 뒤, 합친 50장 묶음과 20장을 합친다면 (10 + 40) + (50 + 20) = 120 번의 비교가 필요하므로 덜 효율적인 방법이다.
N개의 숫자 카드 묶음의 각각의 크기가 주어질 때, 최소한 몇 번의 비교가 필요한지를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N이 주어진다. (1 ≤ N ≤ 100,000) 이어서 N개의 줄에 걸쳐 숫자 카드 묶음의 각각의 크기가 주어진다. 숫자 카드 묶음의 크기는 1,000보다 작거나 같은 양의 정수이다.
<출력값>
첫째 줄에 최소 비교 횟수를 출력한다.

<문제 1716>
Given the polynomial
a(x) = an xn + ... + a1 x + a0,
compute the remainder r(x) when a(x) is divided by xk+1.
<입력값>
The input consists of a number of cases. The first line of each case specifies the two integers n and k (0 ≤ n, k ≤ 10000). The next n+1 integers give the coefficients of a(x), starting from a0 and ending with an. The input is terminated if n = k = -1.
<출력값>
For each case, output the coefficients of the remainder on one line, starting from the constant coefficient r0. If the remainder is 0, print only the constant coefficient. Otherwise, print only the first d+1 coefficients for a remainder of degree d. Separate the coefficients by a single space.
You may assume that the coefficients of the remainder can be represented by 32-bit integers.

<문제 1717>
초기에 {0}, {1}, {2}, ... {n} 이 각각 n+1개의 집합을 이루고 있다. 여기에 합집합 연산과, 두 원소가 같은 집합에 포함되어 있는지를 확인하는 연산을 수행하려고 한다.
집합을 표현하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 n(1 ≤ n ≤ 1,000,000), m(1 ≤ m ≤ 100,000)이 주어진다. m은 입력으로 주어지는 연산의 개수이다. 다음 m개의 줄에는 각각의 연산이 주어진다. 합집합은 0 a b의 형태로 입력이 주어진다. 이는 a가 포함되어 있는 집합과, b가 포함되어 있는 집합을 합친다는 의미이다. 두 원소가 같은 집합에 포함되어 있는지를 확인하는 연산은 1 a b의 형태로 입력이 주어진다. 이는 a와 b가 같은 집합에 포함되어 있는지를 확인하는 연산이다. a와 b는 n 이하의 자연수 또는 0이며 같을 수도 있다.
<출력값>
1로 시작하는 입력에 대해서 한 줄에 하나씩 YES/NO로 결과를 출력한다. (yes/no 를 출력해도 된다)

<문제 1718>
Vigenere cipher이라는 암호화 방법은 암호화하려는 문장 (평문)의 단어와 암호화 키를 숫자로 바꾼 다음, 평문의 단어에 해당하는 숫자에 암호 키에 해당하는 숫자를 더하는 방식이다. 이 방법을 변형하여 평문의 단어에 암호화 키에 해당하는 숫자를 빼서 암호화하는 방식을 생각해 보자.
예를 들어 암호화 키가 love이고, 암호화할 문장이 “nice day” 라면 다음과 같이 암호화가 이루어진다.

제시된 평문의 첫 번째 문자인 ‘n’은 해당 암호화 키 ‘l’의 알파벳 순서가 12 이므로 알파벳상의 순서에서 ‘n’보다 12앞의 문자인 ‘b’로 변형된다.
변형된 문자가 ‘a' 이전의 문자가 되면 알파벳 상에서 맨 뒤로 순서를 돌린다. 예를 들면 평문의 세 번째 문자인‘c’는 알파벳 상에서 3 번째이고 대응하는 암호화키 ‘v'는 알파벳 순서 22로 ‘c'에서 22 앞으로 당기면 ‘a'보다 훨씬 앞의 문자이어야 하는데, ‘a’앞의 문자가 없으므로 ‘z’로 돌아가 반복되어 ‘g’가 된다. 즉 평문의 문자를 암호화키의 문자가 알파벳 상에서 차지하는 순서만큼 앞으로 뺀 것으로 암호화한다.
평문의 문자가 공백 문자인 경우는 그 공백 문자를 그대로 출력한다.
이와 같은 암호화를 행하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 평문이, 둘째 줄에 암호화 키가 주어진다.
평문은 알파벳 소문자와 공백문자(space)로 만  구성되며, 암호화 키는 알파벳 소문자만으로 구성된다. 평문의 길이는 공백까지 포함해서 30000자 이하이다.
<출력값>
첫 번째 줄에 암호문을 출력한다.

<문제 1719>
명우기업은 2008년부터 택배 사업을 새로이 시작하기로 하였다. 우선 택배 화물을 모아서 처리하는 집하장을 몇 개 마련했지만, 택배 화물이 각 집하장들 사이를 오갈 때 어떤 경로를 거쳐야 하는지 결정하지 못했다. 어떤 경로를 거칠지 정해서, 이를 경로표로 정리하는 것이 여러분이 할 일이다.

예시된 그래프에서 굵게 표시된 1, 2, 3, 4, 5, 6은 집하장을 나타낸다. 정점간의 간선은 두 집하장간에 화물 이동이 가능함을 나타내며, 가중치는 이동에 걸리는 시간이다. 이로부터 얻어내야 하는 경로표는 다음과 같다.

경로표는 한 집하장에서 다른 집하장으로 최단경로로 화물을 이동시키기 위해 가장 먼저 거쳐야 하는 집하장을 나타낸 것이다. 예를 들어 4행 5열의 6은 4번 집하장에서 5번 집하장으로 최단 경로를 통해 가기 위해서는 제일 먼저 6번 집하장으로 이동해야 한다는 의미이다.
이와 같은 경로표를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 두 수 n과 m이 빈 칸을 사이에 두고 순서대로 주어진다. n은 집하장의 개수로 200이하의 자연수, m은 집하장간 경로의 개수로 10000이하의 자연수이다. 이어서 한 줄에 하나씩 집하장간 경로가 주어지는데, 두 집하장의 번호와 그 사이를 오가는데 필요한 시간이 순서대로 주어진다. 집하장의 번호들과 경로의 소요시간은 모두 1000이하의 자연수이다.
<출력값>
예시된 것과 같은 형식의 경로표를 출력한다.

<문제 1720>
2×N 크기의 넓은 판을 1×2 (또는 2×1) 크기와 2×2 크기의 타일로 채우려고 한다. 여러 가지 경우가 있을 수 있으므로, 각각을 하나의 코드로 대응시켜서 암호화에 이용하려고 한다.
그런데 문제가 생겼다. 넓은 판을 교환하다 보니 좌우 대칭인 경우가 있어, 뒤집히는 경우 코드가 헷갈리게 되는 경우가 발생한 것이다. 예를 들어 아래의 두 경우는 달라 보이지만 좌우 대칭을 이루고 있다.

N이 주어지면, 전체 타일 코드의 개수를 구하는 프로그램을 작성하시오. (단, 서로 좌우 대칭을 이루는 중복된 표현은 한 가지 경우로만 처리한다.)
<입력값>
첫째 줄에 타일의 크기 N(1≤N≤30)이 주어진다.
<출력값>
첫째 줄에 타일 코드의 개수를 출력한다.

<문제 1722>
1부터 N까지의 수를 임의로 배열한 순열은 총 N! = N×(N-1)×…×2×1 가지가 있다.
임의의 순열은 정렬을 할 수 있다. 예를 들어  N=3인 경우 {1, 2, 3}, {1, 3, 2}, {2, 1, 3}, {2, 3, 1}, {3, 1, 2}, {3, 2, 1}의 순서로 생각할 수 있다. 첫 번째 수가 작은 것이 순서상에서 앞서며, 첫 번째 수가 같으면 두 번째 수가 작은 것이, 두 번째 수도 같으면 세 번째 수가 작은 것이….
N이 주어지면, 아래의 두 소문제 중에 하나를 풀어야 한다. k가 주어지면 k번째 순열을 구하고, 임의의 순열이 주어지면 이 순열이 몇 번째 순열인지를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N(1≤N≤20)이 주어진다. 둘째 줄의 첫 번째 수는 소문제 번호이다. 1인 경우 k(1≤k≤N!)를 입력받고, 2인 경우 임의의 순열을 나타내는 N개의 수를 입력받는다. N개의 수에는 1부터 N까지의 정수가 한 번씩만 나타난다.
<출력값>
k번째 수열을 나타내는 N개의 수를 출력하거나, 몇 번째 수열인지를 출력하면 된다.

<문제 1723>
N개의 점들이 원의 내부에 찍혀 있다. 이 원을 K개의 부채꼴로 등분하려 한다. 즉, 각 부채꼴의 중심각이 360/K도가 되어야 한다. 부채꼴을 어떻게 나누느냐에 따라서 각 부채꼴에 찍혀 있는 점의 개수가 달라질 수 있다.
N개의 점들이 찍혀 있는 각도가 주어졌을 때, 가장 많은 점이 찍혀 있는 부채꼴에 찍혀 있는 점의 개수와, 가장 적은 점이 찍혀 있는 부채꼴에 찍혀 있는 점의 개수의 차이의 최솟값을 구하는 프로그램을 작성하시오.
단, 부채꼴의 테두리에 점이 포함되어서는 안 된다.
<입력값>
첫째 줄에 N(3 ≤ N ≤ 10,000), K(3 ≤ K ≤ 1,000)가 주어진다. 다음 N개의 줄에는 실수로 나타나는 각도가 주어진다. 각도는 0이상 360미만이며, 실수 연산의 오차를 막기 위해 360/K의 정수배에 근접한 각도로 떨어져 있는 점은 없다.
<출력값>
첫째 줄에 부채꼴에 찍혀 있는 점의 최대 개수와 최소 개수의 차이의 최솟값을 출력한다.

<문제 1724>
Microsoft Windows의 그림판에는 색 칠하기 기능이 있다.

이 기능을 사용하면 다른 색으로 둘러싸여진 연속된 공간을 색칠할 수 있다.
직사각형 모양의 그림판에 변에 평행하게 그어진 선분들이 있을 때, 이 선분들로 인해 그림판이 여러 조각으로 쪼개지게 된다. 이들 중 가장 큰 조각의 크기와 가장 작은 조각의 크기를 찾는 프로그램을 작성하시오.
<입력값>
첫 행에는 그림판의 세로 방향 크기 N과 가로 방향 크기 M이 공백으로 구분되어 주어진다. (1 <= N, M <= 500) 다음 행에는 선분의 수 T (1 <= T <= 1000) 가 주어진다. 다음 T 행에 걸쳐 4개의 수 Sx, Sy, Ex, Ey가 주어진다. 이는 점 (Sx, Sy)과 점 (Ex, Ey)를 잇는 선분이 존재한다는 의미이다. 이때 가장 왼쪽 위의 점이 (0, 0)이고 가장 오른쪽 아래의 점이 (N, M)이다.
<출력값>
첫째 줄에는 가장 큰 조각의 크기를, 둘째 줄에는 가장 작은 조각의 크기를 출력한다.

<문제 1725>
히스토그램에 대해서 알고 있는가? 히스토그램은 아래와 같은 막대그래프를 말한다.

각 칸의 간격은 일정하고, 높이는 어떤 정수로 주어진다. 위 그림의 경우 높이가 각각 2 1 4 5 1 3 3이다.
이러한 히스토그램의 내부에 가장 넓이가 큰 직사각형을 그리려고 한다. 아래 그림의 빗금 친 부분이 그 예이다. 이 직사각형의 밑변은 항상 히스토그램의 아랫변에 평행하게 그려져야 한다.

주어진 히스토그램에 대해, 가장 큰 직사각형의 넓이를 구하는 프로그램을 작성하시오.
<입력값>
첫 행에는 N (1 ≤ N ≤ 100,000) 이 주어진다. N은 히스토그램의 가로 칸의 수이다. 다음 N 행에 걸쳐 각 칸의 높이가 왼쪽에서부터 차례대로 주어진다. 각 칸의 높이는 1,000,000,000보다 작거나 같은 자연수 또는 0이다.
<출력값>
첫째 줄에 가장 큰 직사각형의 넓이를 출력한다. 이 값은 20억을 넘지 않는다.

<문제 1726>
많은 공장에서 로봇이 이용되고 있다. 우리 월드 공장의 로봇은 바라보는 방향으로 궤도를 따라 움직이며, 움직이는 방향은 동, 서, 남, 북 가운데 하나이다. 로봇의 이동을 제어하는 명령어는 다음과 같이 두 가지이다.

명령 1. Go k: k는 1, 2 또는 3일 수 있다. 현재 향하고 있는 방향으로 k칸 만큼 움직인다.
명령 2. Turn dir: dir은 left 또는 right 이며, 각각 왼쪽 또는 오른쪽으로 90° 회전한다.

공장 내 궤도가 설치되어 있는 상태가 아래와 같이 0과 1로 이루어진 직사각형 모양으로 로봇에게 입력된다. 0은 궤도가 깔려 있어 로봇이 갈 수 있는 지점이고, 1은 궤도가 없어 로봇이 갈 수 없는 지점이다. 로봇이 (4, 2) 지점에서 남쪽을 향하고 있을 때,  이 로봇을 (2, 4) 지점에서 동쪽으로 향하도록 이동시키는 것은 아래와 같이 9번의 명령으로 가능하다.

로봇의 현재 위치와 바라보는 방향이 주어졌을 때, 로봇을 원하는 위치로 이동시키고, 원하는 방향으로 바라보도록 하는데 최소 몇 번의 명령이 필요한지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 공장 내 궤도 설치 상태를 나타내는 직사각형의 세로 길이 M과 가로 길이 N이 빈칸을 사이에 두고 주어진다. 이때 M과 N은 둘 다 100이하의 자연수이다. 이어 M줄에 걸쳐 한 줄에 N개씩 각 지점의 궤도 설치 상태를 나타내는 숫자 0 또는 1이 빈칸을 사이에 두고 주어진다. 다음 줄에는 로봇의 출발 지점의 위치 (행과 열의 번호)와 바라보는 방향이 빈칸을 사이에 두고 주어진다. 마지막 줄에는 로봇의 도착 지점의 위치 (행과 열의 번호)와 바라보는 방향이 빈칸을 사이에 두고 주어진다. 방향은 동쪽이 1, 서쪽이 2, 남쪽이 3, 북쪽이 4로 주어진다. 출발지점에서 도착지점까지는 항상 이동이 가능하다.
<출력값>
첫째 줄에 로봇을 도착 지점에 원하는 방향으로 이동시키는데 필요한 최소 명령 횟수를 출력한다.

<문제 1727>
여자친구가 없는 남자 n명과 남자친구가 없는 여자 m명을 불러 모아서 이성 친구를 만들어 주기로 하였다. 하지만 아무렇게나 해줄 수는 없고, 최대한 비슷한 성격의 사람들을 짝 지어 주기로 하였다.
당신은 뭔가 알 수 없는 방법으로 각 사람의 성격을 수치화 하는데 성공하였다. 따라서 각 사람의 성격은 어떤 정수로 표현된다. 이와 같은 성격의 수치가 주어졌을 때, 우선 최대한 많은 커플을 만들고, 각 커플을 이루는 두 사람의 성격의 차이의 합이 최소가 되도록 하려 한다. 남자-여자 커플만 허용된다.
<입력값>
첫째 줄에 n, m(1≤n, m≤1,000)이 주어진다. 다음 줄에는 n명의 남자들의 성격이 주어진다. 그 다음 줄에는 m명의 여자들의 성격이 주어진다. 성격은 1,000,000이하의 자연수이다.
<출력값>
첫째 줄에 성격의 차이의 합의 최솟값을 출력한다.

<문제 1728>
탁자 위에 N 개의 구슬이 굴러다닌다. 탁자를 하나의 좌표 평면으로 보았을 때, 구슬은 x축에 나란하게 굴러다니는데, 각각의 y좌표가 달라 굴러다니는 도중에 충돌은 일어나지 않는다. 각각의 구슬은 일정한 속도를 가지고 있으며, 출발 위치가 서로 다르다.
일정한 시간 간격으로 구슬의 사진을 찍어 구슬들의 x좌표들을 모두 나열한다고 생각하자. 이때, 구슬들의 모양이 모두 똑같아서 어느 구슬이 어느 좌표에 있는지는 사진에서 알 수 없다. 그러나 일정한 간격으로 찍은 몇 개의 사진이 주어진다면, 각 구슬의 출발 위치와 속도를 모두 알아낼 수 있게 된다. 이를 알아내는 프로그램을 작성하시오.
<입력값>
첫 행에는 구슬의 개수 N이 주어진다. (1 ≤ N ≤ 500) 사진은 N+1장이 주어지며, 다음 행부터 각각의 사진에 보이는 구슬들의 x좌표가 주어진다.
구슬의 x좌표는 절댓값이 20억을 넘지 않는 정수이다.
<출력값>
N개의 줄에 각 구슬의 처음 위치와 속도를 빈 칸을 사이에 두고 출력한다. 이때, 구슬의 처음 위치를 기준으로, 오름차순 정렬하여 출력하도록 한다.

<문제 1729>
6×6 배열에 0이상 9이하의 수들이 저장되어 있다. 이 배열에 적당한 연산을 하여 배열에 저장되어 있는 수들의 총 합이 최대가 되는 경우를 찾으려 한다.
사용할 수 있는 연산의 목록은 다음과 같다.

i번째 행의 6개의 수들에 1씩을 더한다.
i번째 행의 6개의 수들에서 1씩을 뺀다.
i번째 열의 6개의 수들에 1씩을 더한다.
i번째 열의 6개의 수들에서 1씩을 뺀다.
왼쪽 위에서 오른쪽 아래로의 대각선 위에 있는 6개의 수들에 1씩을 더한다.
오른쪽 위에서 왼쪽 아래로의 대각선 위에 있는 6개의 수들에 1씩을 더한다.
왼쪽 위에서 오른쪽 아래로의 대각선 위에 있는 6개의 수들에서 1씩을 뺀다.
오른쪽 위에서 왼쪽 아래로의 대각선 위에 있는 6개의 수들에서 1씩을 뺀다.

각각의 연산은 횟수의 제한 없이 마음대로 사용할 수 있다. 또, 우리는 한자리의 수들만 고려하므로, 9에 1을 더하면 10이 아닌 0이 되며, 0에서 1을 빼면 -1이 아니라 9가 된다.
예를 들어 다음과 같은 배열을 생각해 보자.
5 9 7 1 5 8
2 5 3 5 2 0
6 8 1 5 0 3
4 8 2 6 9 2
9 1 6 5 3 2
7 0 2 4 3 1

1번째 행에 1을 더하는 연산을 하면 다음처럼 된다.

6 0 8 2 6 9
2 5 3 5 2 0
6 8 1 5 0 3
4 8 2 6 9 2
9 1 6 5 3 2
7 0 2 4 3 1

이번에는 1열에서 1을 빼는 연산을 해 보면, 다음처럼 된다.

5 0 8 2 6 9
1 5 3 5 2 0
5 8 1 5 0 3
3 8 2 6 9 2
8 1 6 5 3 2
6 0 2 4 3 1
<입력값>
배열을 나타내는 정수가 6개의 줄에 6개씩 주어진다. 각각의 수는 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 중 하나이다.
<출력값>
이차원 배열의 합이 최대가 될 때, 그 합을 첫째 줄에 출력한다.

<문제 1730>
W대학교 미술대학 조소과에서는 지루한 목판화 작업을 하는 학생들을 돕기 위해 판화 기계를 제작하였다.
기계는 로봇 팔이 쥔 조각도를 상하좌우 네 방향으로 움직일 수 있는 구조로서, 조각도 아래에 목판을 놓으면 그 위에 선들을 자동으로 그어주는 기능을 가지고 있다.
목판에는 n^2개의 점들이 일정한 간격으로 n행 n열의 격자모양을 이루며 찍혀있다. 처음 로봇의 조각도를 올려놓는 위치는 항상 이 점들 중 맨 왼쪽 맨 위의 꼭짓점이다.
로봇 팔을 움직이는 명령의 순서가 주어졌을 때, 목판 위에 패인 조각도의 혼적을 출력하는 프로그램을 작성하시오.
판화 기계는 작동 도중 로봇 팔이 격자 바깥으로 나가도록 하는 움직임 명령을 만나면, 무시하고 그 다음 명령을 진행한다.
<입력값>
첫째 줄에 목판의 크기 n (2<=n<=100)이 주어진다. 행 열의 점들이 찍혀 있다는 의미이다. 둘째 줄에 로봇팔의 움직임이 한 줄로 공백 없이 입력된다. 위쪽으로 이동은 'U', 아래쪽으로 이동은 'D', 왼쪽으로 이동은 'L', 오른쪽으로 이동은 'R'로 표시된다. 로봇팔의 움직임을 나타내는 이 문자열의 길이는 최대 1000이다.
<출력값>
로봇팔이 지나지 않은 점은 '.'으로, 로봇팔이 수직 방향으로만 지난 점은 '|'으로, 로봇팔이 수평 방향으로만 지난 점은 '-'으로, 수직과 수평 방향 모두로 지난 점은 '+'로 표기하도록 한다. 네 문자의 ASCII 코드는 각각 46, 124, 45, 43이다.

<문제 1731>
등차가 정수인 등차수열 (어떤 수에 차례대로 일정한 수를 더해서 이루어지는 수열) 은 2개의 숫자로 나타낼 수 있다. P는 수열의 첫 번째 수이고, Q는 그 다음수가 되기 위해 바로 전의 수에 더해야 하는 수이다. 예를 들어 P=1, Q=2 이면 그 등차수열은 1, 3, 5, 7, ..... 이 된다.
등비가 정수인 등비수열 (어떤 수에서 시작해 차례로 같은 수를 곱하여 만든 수열) 은 등차수열과 비슷하게 2개의 숫자로 나타낼 수 있다. P는 수열의 첫 번째 수이고, Q는 그 다음수가 되기 위해 바로 전의 수에 곱해야 하는 수이다. 예를 들어 P=3, Q=2이면 그 등비수열은 3, 6, 12, ...이 된다.
테디는 세상에서 수학을 제일 좋아해서 매일같이 이 수열이 등차수열인지 등비수열인지 정한다음에 다음 수를 구한다.
어떤 수열이 주어졌을 때, 그 수열의 규칙이 등차수열인지, 등비수열인지 결정한 후에, 다음에 등장할 수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 수열의 길이 N이 주어진다. 둘째 줄부터 N개의 줄에 수열의 각 원소가 차례대로 주어진다. 주어지는 수열은 등차수열이나 등비수열 중에 하나다. N은 항상 3 이상 50이하이며, 입력되는 수는 10^6 이하의 자연수이다.
<출력값>
첫째 줄에 수열의 다음 원소를 출력한다. 이 수는 20억보다 작거나 같다.

<문제 1732>
2차원 평면상에 N(1≤N≤100,000)개의 기둥이 설치되어 있다. 각각의 기둥의 꼭대기에는 레이저가 설치되어 있는데, 레이저는 (0, 0)의 위치에 있는 조각상을 비추고 있다. 각각의 건물의 높이는 다를 수 있는데, 이때문에 몇몇 레이저들은 다른 건물에 가려질 수도 있다. 두 개의 건물 A, B와 조각상이 일직선상에 순서대로 있을 때, 만약 A의 높이가 B의 높이 이하이면 A의 꼭대기에 설치되어 있는 레이저는 건물 B에 가려지게 된다.
각 건물들의 좌표가 주어졌을 때, 레이저가 가려지게 되는 건물들을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N이 주어진다. 다음 N개의 줄에는 세 정수 x, y, z가 주어진다. 이는 (x, y)의 위치에 높이 z인 건물이 존재한다는 의미이다. 단 -100,000≤x≤100,000, 0≤y≤10,000, 0≤z≤10,000이 만족된다. 같은 위치에는 최대 한 개의 건물만 있을 수 있다.
<출력값>
첫째 줄부터 가려지는 건물들의 좌표를 출력한다. 좌표를 출력할 때에는 x좌표가 증가하는 순서대로, x좌표가 같다면 y좌표가 증가하는 순서대로 출력한다.

<문제 1733>
전국 마라톤 대회가 개최될 예정이다. 몹시 큰 규모의 대회이므로 주최측에서는 등번호가 적힌 티셔츠를 일률적으로 배부하여 참가자들이 이를 입고 뛰게 한다.
이 티셔츠들은 양방향으로 뒤집어서 입을 수 있게 설계 되어 있다. 즉, 안쪽 면과 바깥쪽 면 모두에 등번호가 적혀있기 때문에 참가자들은 한 쪽 면을 선택하여 티셔츠를 입어야 한다.
문제는 티셔츠마다 고유한 등번호를 가지고 있는 것이 아니라는 것이다. 그래서 참가자들이 주의하지 않으면 서로 같은 등번호를 달고 뛰는 경우가 발생하게 된다.
이런 일이 발생하지 않도록, 참가자들에게 어떤 방향으로 옷을 입어야 하는지 알려주기 위한 프로그램을 작성하시오.
<입력값>
첫째 줄에 티셔츠의 개수 N (1 ≤ N ≤ 1,000,000)이 주어진다. 이후 N개의 행에 각 티셔츠의 정보가 두 개의 자연수로 주어진다. 이는 티셔츠의 안쪽과 바깥쪽에 적힌 등번호이다. 각 등번호는 1이상 1,000,000 이하이다.
<출력값>
N개의 행에 각 셔츠별로, 밖으로 내보여야 할 등번호를 출력한다. 불가능한 경우에는 -1을 출력한다.

<문제 1734>
N개의 도시와, 서로 다른 두 도시를 잇는 E개의 도로로 이루어진 나라가 있다. 각 도시는 1번부터 N번까지 번호가 매겨져 있으며, 도로는 양방 통행 도로이다. 즉 i번 도시와 j번 도시 사이에 도로가 존재한다면 i번 도시에서 j번 도시로 이동할 수 있을 뿐더러 j번 도시에서 i번 도시로도 이동할 수 있다.
이 나라의 교통 체계는 매우 복잡해서, 이를 간소화하는 작업을 벌이려고 한다. 간소화를 위한 방법으로는 크게 두 가지가 있다. 두 도시를 연결하는 특정한 도로를 골라서 없애는 단순한 방법이 있고, 특정한 도시를 골라서 이 도시로 들어오거나 나가는 모든 도로를 없애는 방법이 있다.
이러한 교통 체계의 단순화는 면밀한 검토가 필요한 복잡한 작업이 된다. 따라서 몇 개의 질문을 만들어 놓고, 이 질문들에 대한 답을 구해낸 후 이를 토대로 단순화 작업을 벌이기로 하였다. 질문의 유형은 아래의 두 가지 중 하나를 따른다.

두 개의 도시 A, B가 있고, 도시 G1과 도시 G2를 잇는 도로가 있다. 도시 G1과 도시 G2 사이의 도로를 없앤 후에도 도시 A에서 도시 B로 이동할 수 있는가?
세 개의 도시 A, B, C가 있다. 도시 C로 들어오거나 나가는 모든 도로를 없앤 후에도 도시 A에서 도시 B로 이동할 수 있는가?

이 나라의 현재 교통 체계에 대한 정보와 위의 유형에 해당되는 여러 개의 질문들이 주어졌을 때, 교통 체계의 단순화를 위해 주어진 질문들에 대한 답을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 도시의 개수 N과 도로의 개수 E가 주어진다. (2 ≤ N ≤ 100,000, 1 ≤ E ≤ 500,000) 이어서 E개의 줄에 걸쳐 각 줄에 N 이하의 서로 다른 두 자연수가 주어지는데, 이는 두 자연수를 번호로 하는 두 개의 도시 사이에 도로가 존재함을 의미한다. 같은 도로가 여러 번 입력으로 주어지지 않으며, 임의의 두 도시 사이에 항상 이동할 수 있는 경로가 하나 이상 존재하는 교통 체계만이 입력으로 주어진다.
다음 줄에는 질문의 개수 Q가 주어진다. (1 ≤ Q ≤ 300,000) 이어서 Q개의 줄에 걸쳐 질문에 대한 정보가 주어지는데, 각 줄의 첫 번째 자연수는 질문의 유형을 나타내는 1 또는 2이다. 질문이 유형 1에 해당하는 경우는 N 이하의 네 개의 자연수 A, B, G1, G2가 순서대로 주어진다. A와 B는 서로 다르며, G1과 G2 사이에 항상 도로가 존재하는 경우만이 입력으로 주어진다. 질문이 유형 2에 해당하는 경우는 N 이하의 서로 다른 자연수 A, B, C가 순서대로 주어진다.
<출력값>
Q개의 줄에 걸쳐 각 질문에 대한 답을 한 줄에 하나씩 yes나 no로 출력한다. 질문의 답이 "이동할 수 있다"이면 yes를, "이동할 수 없다"이면 no를 출력하면 된다.

<문제 1735>
분수 A/B는 분자가 A, 분모가 B인 분수를 의미한다. A와 B는 모두 자연수라고 하자.
두 분수의 합 또한 분수로 표현할 수 있다. 두 분수가 주어졌을 때, 그 합을 기약분수의 형태로 구하는 프로그램을 작성하시오. 기약분수란 더 이상 약분되지 않는 분수를 의미한다.
<입력값>
첫째 줄과 둘째 줄에, 각 분수의 분자와 분모를 뜻하는 두 개의 자연수가 순서대로 주어진다. 입력되는 네 자연수는 모두 30,000 이하이다.
<출력값>
첫째 줄에 구하고자 하는 기약분수의 분자와 분모를 뜻하는 두 개의 자연수를 빈 칸을 사이에 두고 순서대로 출력한다.

<문제 1736>
방은 세로 N, 가로 M (1 <= N, M <= 100) 크기의 격자 판으로 표현할 수 있다. 왼쪽 위의 위치를 (0, 0)이라 하고, 오른쪽 아래를 (N - 1, M - 1)이라고 하자. 이 판의 몇몇 칸에는 쓰레기가 놓여 있다. 쓰레기를 로봇을 사용해서 수거하려고 하는데, 로봇은 왼쪽 위에서 출발해 오른쪽 아래로 도착한다. 즉, 로봇은 현재 위치에서 오른쪽, 혹은 아래쪽으로밖에 이동할 수 없다.
이때, 모든 쓰레기를 수거하기 위해서 필요한 최소 로봇의 수를 출력하는 프로그램을 작성하시오.
<입력값>
첫 행에는 N, M이 공백으로 구분되어 주어진다.
다음 N 행에 걸쳐 M 개의 수가 주어진다. 이 값이 0이면 해당하는 위치가 비어 있다는 뜻이고, 1이면 해당하는 위치에 쓰레기가 있음을 뜻한다.
<출력값>
필요한 최소 로봇의 수를 출력한다.

<문제 1737>
피보나치(Fibonacci) 수열은 매우 유명한 수열로 그 점화식은 F[i]=F[i-1]+F[i-2]와 같이 표현된다. 우리는 이와 같은 수열을 살짝 변경한 피보나치(Pibonacci) 수열에 대해 살펴보자. 피보나치 수열의 점화식은 아래와 같다.

P[n] = 1 (0 ≤ n ≤ π)
P[n] = P[n-1] + P[n-π] (그 외)

주의할 것은 n이 꼭 정수일 필요는 없다는 것이다. 즉, P[n-π] = P[n-π-1]+P[n-π-π]와 같은 식으로 계산을 해 주어야 한다.
자연수로 n이 주어졌을 때, P[n]을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 자연수 n(1 ≤ n ≤ 1,000)이 주어진다.
<출력값>
첫째 줄에 P[n]을 출력한다. 값이 매우 커질 수 있으므로 1,000,000,000,000,000,000으로 나눈 나머지를 출력한다.

<문제 1738>
민승이는 놀러가기 위해 집을 나섰다. 민승이네 집에서 코레스코 콘도까지 가기 위해서는 복잡하게 얽혀있는 골목길들을 통과해야 한다.
그런데, 어떤 길에는 깡패가 서식하고 있어, 그 길을 지나게 되면 깡패에게 일정한 양의 금품을 갈취당하게 된다. 그런가하면, 어떤 길에는 지나가던 행인들이 흘리고 간 금품들이 떨어져 있어, 그 길을 지나게 되면 일정한 양의 금품을 획득하게 된다. 한 번 지나간 길을 다시 방문하더라도 금품을 갈취당하거나 획득한다.
골목길의 연결 상태와, 각 골목길을 지날 때 갈취당하거나 획득하게 되는 금품의 양이 주어졌을 때, 민승이가 최대한 유리한 경로를 따라 집에서 코레스코 콘도까지 가기 위해서는 어떻게 해야 하는지 출력하는 프로그램을 작성하시오. 
보유 중인 금품의 양이 음수가 될 수 있다. 최대한 유리한 경로 또는 최적의 경로는 민승이네 집에서 출발하여 코레스코 콘도에 도착하는 경로 중 금품의 양이 최대가 되는 경로이다.
<입력값>
첫째 줄에 골목길들이 교차하는 지점의 개수 n (2 ≤ n ≤ 100)과 골목길의 개수 m (1 ≤ m ≤ 20,000) 이 차례로 주어진다. 이어지는 m개의 행에 각각의 골목길을 나타내는 세 정수 u, v, w가 차례로 주어진다. 이는 u번 교차점에서 v번 교차점으로 이동할 수 있는 골목길이 나있다는 의미이다. 즉, 주어지는 골목길들은 기본적으로 모두 일방통행로이다. w (0 ≤ |w| ≤ 1,000)는 이 길을 지날 때 갈취당하거나 획득하게 되는 금품의 양이다. 음수는 갈취, 양수는 획득을 뜻한다.
골목길의 교차점 번호는 1이상 n이하의 정수이다. 민승이네 집은 1번 교차점에 있고, 이곳 코레스코 콘도는 n번 교차점에 있다.
<출력값>
최적의 경로를 구할 수 있다면 민승이네 집부터 코레스코 콘도까지 가는 동안 거치게 되는 교차점들의 번호를 공백 하나를 사이에 두고 차례로 출력하면 된다. 그런데, 경우에 따라서는 최적의 경로라는 것이 존재하지 않는 상황이 발생한다. 어떠한 경우에 그런 상황이 발생하는지 생각해 보자. 그러한 경우에는 -1을 출력하도록 한다.
최적의 경로가 여러 개 존재할 때는 아무거나 출력해도 된다.

<문제 1739>
가로로 N(1≤N≤1,000)개, 세로로 M(1≤M≤1,000)개의 도로가 나 있는 도시가 있다. 또한 이 도로들의 N×M개의 교점들에는 마을이 있다. 이 도로들을 통해서 차들은 자유롭게 마을 사이를 오갈 수 있었는데, 도로들이 좁아서 교통사고가 자주 발생하게 되었다. 이를 막기 위해서, 이 도시의 시장은 각각의 도로들에 방향성을 주어서, 그 도로를 이용할 때는 한 쪽 방향으로만 차가 다닐 수 있도록 하려 한다.
이 도시에는 K(1≤K≤1,000)개의 버스가 있는데, 버스는 한 마을에서 다른 한 마을로 이동하는 직행 버스들이다. 시장은 대중교통을 중요시하는 사람이기 때문에, 버스들을 최우선적으로 고려하여 도로에 방향성을 주려 한다. 즉, 도로를 정비한 후에 각 버스들이 최단거리로 다닐 수 있도록 방향성을 주려 한다. 또한 도로의 혼잡을 줄이기 위해서, 각각의 버스들이 최대 두 개(가로 도로 한 개, 세로 도로 한 개)의 도로만을 이용하는 단순 경로를 지나서 다닐 수 있도록 하려 한다. 이해를 돕기 위해 아래 그림을 보자.
아래 그림에서 왼쪽 위의 점은 시작점을, 오른쪽 아래의 점은 도착점을 나타낸다. a) 의 경우는 방향이 어긋나기 때문에 잘못된 경로이다. b) 의 경우는 방향은 어긋나진 않지만 단순 경로가 아닌 경우이며, c) 가 올바른 경우이다.
이러한 계획을 세우기는 했지만, 시장은 실제로 이러한 조건을 만족하면서 도로들에 방향성을 줄 수 있는지 궁금해졌다. 도로에 대한 정보와 각 버스에 대한 정보가 주어졌을 때, 이러한 조건을 만족하면서 도로들에 방향성을 줄 수 있는지 알아내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 테스트 데이터의 개수 T(1≤T≤10)가 주어진다. 각 테스트 데이터의 첫째 줄에는 세 정수 N, M, K가 주어진다. 다음 K개의 줄에는 각 버스의 운행 정보를 나타내는 네 정수 A, B, C, D가 주어진다. 이는 버스가 A번 가로 도로와 B번 세로 도로가 교차하는 마을에서, C번 가로 도로와 D번 세로 도로가 교차하는 마을로 이동함을 의미한다. 가로 도로의 범위는 1부터 N까지이며, 세로 도로의 범위는 1부터 M까지이다. 버스의 시작점과 도착점은 같을 수도 있다.
<출력값>
T개의 줄에, 각 테스트 데이터에 대한 답을 출력한다. 가능한 경우에는 Yes를, 불가능한 경우에는 No를 출력한다.

<문제 1740>
3의 제곱수를 생각하자. 3의 0제곱, 3의 1제곱, 3의 2제곱, ... 은 순서대로 1, 3, 9, 27, ... 이 된다.
이를 바탕으로, 한 개 이상의 서로 다른 3의 제곱수의 합으로 표현되는 수를 생각할 수 있다. 예를 들어 30은 27과 3의 합이므로, 이러한 수에 포함된다.
한 개 이상의 서로 다른 3의 제곱수의 합으로 표현되는 N번째로 작은 수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N이 주어진다. N은 500,000,000,000 이하의 자연수이다.
<출력값>
첫째 줄에 한 개 이상의 서로 다른 3의 제곱수의 합으로 표현되는 N번째로 작은 수를 출력한다.

<문제 1741>
학생들이 너무 떠드는 것을 보다 못한 나머지, 원장님은 결단을 내리셨다. 반을 나누기로.
학생들은 친한 친구들과 떨어지는 것이 싫어서 몹시 거세게 반발했고, 원장님은 이를 잠재우기 위하여 한 가지 방안을 제시하셨다. 인터넷 메신저로 대화할 수 있게 허락해 주신 것이다.
단, 두 사람이 메신저로 대화를 나누기 위해서는 서로가 서로의 메신저 아이디를 알고 있어야 하는데, 모든 학생이 모든 학생의 아이디를 알고 있는 것은 아니다.
이러한 상황에서, 원장님은 최대한 반을 잘게 나누고자 하신다. 다른 반에 속한 학생들끼리는 메신저로 대화해야 하므로, 반드시 서로의 메신저 아이디를 알고 있어야만 한다.
어떤 학생들끼리 서로의 메신저 아이디를 알고 있는지 주어졌을 때, 가장 많은 반을 편성하려면 어떻게 해야 하는지 알아내는 프로그램을 작성하시오.
<입력값>
첫째 줄 학생들의 수 n과, 서로 메신저 아이디를 알고 있는 학생들 쌍의 수 m이 공백을 사이에 두고 주어진다. (2<=n<=100,000. 1<=m<=2,000,000) 이후 m개의 줄에는 서로 메신저 아이디를 알고 있는 학생들 번호의 쌍이 두 개의 정수로 주어진다. 두 학생의 번호는 1이상 n이하의 정수이다.
<출력값>
첫째 줄에, 최대로 편성할 수 있는 반이 몇 개인지 출력한다. 둘째 줄에는, 최대로 편성했을 때 각 반별 인원수를 오름차순으로 출력한다.

<문제 1742>
상욱이는 레이싱 결과 맞추기를 좋아한다. 상욱이가 레이싱 결과를 맞추는 방법은 이전 경기에서 A란 선수가 B란 선수를 이긴 적이 있으면, A는 B를 무슨일이 있어도 이번 레이스에서 항상 이긴다고 가정하고 경기 결과를 예측 하는 방법이다.
하지만 상욱이는 위와 같은 방법으로는 경기 결과가 하나로 결정되지 않는다는 것을 깨달았다.
예를 들어, 이번 레이스경기에 참가하는 자동차의 수가 4개이고, 상욱이가 알고있는 예전의 경기결과가 1이 2를 이기고, 1이 3을 이긴다면, 상욱이가 예측할 수 있는 레이스의 결과는 4123, 4132, 1423, 1432, 1243, 1342, 1234, 1324로 총 8가지이다.
자동차의 수와, 상욱이가 알고잇는 예전 경기 결과가 주어졌을 때, 현재 가능한 경기결과의 수를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 이번 레이스에 참가하는 자동차의 수 N이 주어진다. N은 30보다 같거나 작은 자연수이다. 둘째 줄에 상욱이가 알고있는 예전 경기 결과의 수 M이 주어진다. M은 15보다 같거나 작은 자연수 또는 0이다. 셋째 줄부터 M개의 줄에는 예전 경기 결과가 주어진다. 예전 경기 결과는 A B 이렇게 주어지는데, A가 B를 항상 이긴다는 뜻이다. 자동차의 번호는 1~N까지이다.
<출력값>
첫째 줄에 상욱이가 예상할 수 있는 경기 결과의 수를 1,000,003으로 나눈 나머지를 출력한다. 만약 예전 경기 결과 모순(1이 2를 이기고, 2가 1을 이기는 상황, 즉 경기결과를 예상할 수 없는 상황)이라면, 0을 출력한다.

<문제 1743>
코레스코 콘도미니엄 8층은 학생들이 3끼의 식사를 해결하는 공간이다. 그러나 몇몇 비양심적인 학생들의 만행으로 음식물이 통로 중간 중간에 떨어져 있다. 이러한 음식물들은 근처에 있는 것끼리 뭉치게 돼서 큰 음식물 쓰레기가 된다. 
이 문제를 출제한 선생님은 개인적으로 이러한 음식물을 실내화에 묻히는 것을 정말 진정으로 싫어한다. 참고로 우리가 구해야 할 답은 이 문제를 낸 조교를 맞추는 것이 아니다. 
통로에 떨어진 음식물을 피해가기란 쉬운 일이 아니다. 따라서 선생님은 떨어진 음식물 중에 제일 큰 음식물만은 피해 가려고 한다. 
선생님을 도와 제일 큰 음식물의 크기를 구해서 “10ra"를 외치지 않게 도와주자.
<입력값>
첫째 줄에 통로의 세로 길이 N(1 ≤ N ≤ 100)과 가로 길이 M(1 ≤ M ≤ 100) 그리고 음식물 쓰레기의 개수 K(1 ≤ K ≤ 10,000)이 주어진다.  그리고 다음 K개의 줄에 음식물이 떨어진 좌표 (r, c)가 주어진다.
좌표 (r, c)의 r은 위에서부터, c는 왼쪽에서부터가 기준이다.
<출력값>
첫째 줄에 음식물 중 가장 큰 음식물의 크기를 출력하라.

<문제 1744>
길이가 N인 수열이 주어졌을 때, 그 수열의 합을 구하려고 한다. 하지만, 그냥 그 수열의 합을 모두 더해서 구하는 것이 아니라, 수열의 두 수를 묶으려고 한다. 어떤 수를 묶으려고 할 때, 위치에 상관없이 묶을 수 있다. 하지만, 같은 위치에 있는 수(자기 자신)를 묶는 것은 불가능하다. 그리고 어떤 수를 묶게 되면, 수열의 합을 구할 때 묶은 수는 서로 곱한 후에 더한다.
예를 들면, 어떤 수열이 {0, 1, 2, 4, 3, 5}일 때, 그냥 이 수열의 합을 구하면 0+1+2+4+3+5 = 15이다. 하지만, 2와 3을 묶고, 4와 5를 묶게 되면, 0+1+(2*3)+(4*5) = 27이 되어 최대가 된다.
수열의 모든 수는 단 한번만 묶거나, 아니면 묶지 않아야한다.
수열이 주어졌을 때, 수열의 각 수를 적절히 묶었을 때, 그 합이 최대가 되게 하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 수열의 크기 N이 주어진다. N은 10,000보다 작은 자연수이다. 둘째 줄부터 N개의 줄에, 수열의 각 수가 주어진다. 수열의 수는 -10,000보다 크거나 같고, 10,000보다 작거나 같은 정수이다.
<출력값>
수를 합이 최대가 나오게 묶었을 때 합을 출력한다. 정답은 항상 231보다 작다.

<문제 1745>
학생들은 선생님들과 조교들이 스타를 하러 간 사이에 여러 방에 들어가 신나게 놀고 있었다. 그리고 시간이 되어 놀던 방에서 자려고 했지만 각 방에서 잘 수 있는 사람의 수가 정해져 있어서 불가피하게 몇몇 학생들은 방을 옮겨 자야한다. 하지만 학생들이 옮기는 시간 중에 스타를 끝내고 오신 원장선생님과 마주치게 되면 안되기 때문에 고민에 빠져있다. 결국 최대한 빠른 시간에  모든 학생들이 방에 잘 수 있는 제한 수를 넘지 않으면서 적당한 방에 숨어 자려고 한다.  
F개의 방에 학생들이 현재 숨어 있고, 이 방들을 연결하는 P개의 통로가 있다. 통로의 폭은 넓기 때문에 동시에 한 통로에 지나가는 학생 수의 제한은 없고 양방으로 통행 가능하다.
모든 방의 제한이 넘지 않도록 학생들이 이동해야 하는 최소 시간을 출력하는 것이 문제이다. 물론 몇몇 학생들은 현재 방에 있을 수 있다. (근데, 아마 이 시간보다 스타가 빨리 끝날듯..)
<입력값>
첫 번째 줄에 F(1≤F≤200), P(1≤P≤1,500)가 주어진다. 2번째 줄부터 F개의 줄까지 i번째 줄에는 i-1번째 방에 현재 있는 학생 수와 그 방에 잘 수 있는 학생 수가 빈칸으로 구분되어 주어진다. 두 수 모두 0 이상 1000 이하의 수이다. 다음 P개의 줄에는 한 통로가 연결되는 두 방과 그 통로를 통과하는데 걸리는 시간(≤1,000,000,000)이 주어진다.
<출력값>
학생들이 이동해야 하는 최소 시간을 출력한다. 불가능할 경우 -1을 출력한다.

<문제 1746>
계속 앉아서 열심히 공부(?)만 하는 학생들은 운동량이 절대적으로 부족하다. 우리의 원장선생님은 이런 학생들을 불쌍히 여기시어 운동을 할 계획을 세우셨다. 그 운동은 바로 단체 릴레이 경주이다. 릴레이 경주란 다들 알다시피 1개의 baton을 가지고 서로 baton을 전달해 주며 달리는 경기이다.
N(N<=1,000,000)명의 학생들은 운동장으로 나와서 T(2<=T<=100)개의 구역에서 바톤을 받을 준비를 하고 있다. 구역과 구역사이는 무조건 1개의 길만 존재한다. 쉽게 말해서 그래프의 구조를 가지고 있다.
릴레이를 하기 위해 각각의 학생들은 구역에 서 있으며 어떤 구역에는 여러명의 사람들이 있을 수 있다. 또한 릴레이의 특성상 baton이 하나기 때문에 각 구역으로 이동하는 데는 1명만 이동할 수 있으며 1명의 학생은 1개의 구간만 달린다. 그래서 학생들은 구역에 적당이 서서 바톤을 받아 끝나는 지점 까지 도달하여야 한다. 그런데 학생들은 운동을 오래 하고 싶지 않아 한다. 그렇기 때문에 시작지점에서 끝나는 지점까지의 최단경로를 알고 싶어 한다. 학생들이 어느 구역에 배치 되어야 되는지 프로그램을 짜서 도와주자. 시작 지점에서 끝지점 까지 정확히 길이(거치는 간선의 수)가 N이 되는 최단경로의 길이를 구하자.

N명의 학생은 모두 달려야 한다.
시작점이나 도착지점에서 학생들이 바톤을 기다릴 수는 있지만 끝날 때에는 마지막 학생이 도착구역으로 가야 한다.
물론 사용한 길을 다시 갈 수도 있다.
<입력값>
첫째 줄에 학생의 수 N(N<=1,000,000)과 구역의 수(T<=100) 시작지점의 번호S(1<=S<=1000) 도착지점의 번호 E(1<=E<=1000)가 주어진다. 그 다음 T개의 줄에 간선의 길이 L (1 ≤ L ≤ 1,000)과 간선을 잇는 두 점이 순서대로 주어진다. 참고로 번호는 1 2 3 4 순서대로 들어오지 않는다.
<출력값>
첫째 줄에 최단경로의 길이를 구하라. 제한시간은 1초이다.

<문제 1747>
어떤 수와 그 수의 숫자 순서를 뒤집은 수가 일치하는 수를 팰린드롬이라 부른다. 예를 들어 79,197과 324,423 등이 팰린드롬 수이다.
어떤 수 N (1 ≤ N ≤ 1,000,000)이 주어졌을 때, N보다 크거나 같고, 소수이면서 팰린드롬인 수 중에서, 가장 작은 수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N이 주어진다.
<출력값>
첫째 줄에 조건을 만족하는 수를 출력한다.

<문제 1748>
1부터 N까지의 수를 이어서 쓰면 다음과 같이 새로운 하나의 수를 얻을 수 있다.

1234567891011121314151617181920212223...

이렇게 만들어진 새로운 수는 몇 자리 수일까? 이 수의 자릿수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N(1 ≤ N ≤ 100,000,000)이 주어진다.
<출력값>
첫째 줄에 새로운 수의 자릿수를 출력한다.

<문제 1749>
동주는 항상 혼자 노느라 심심하다. 하지만 혼자 놀기의 고수가 된 동주는 매일매일 게임을 개발하여 혼자놀기의 진수를 우리에게 보여준다. 어느 날 동주는 새로운 게임을 개발하였다. 바로 점수 따먹기라는 게임인데 그다지 재밌어 보이지는 않는다.
동주가 개발한 게임은 이렇다. 일단 N*M 행렬을 그린 다음, 각 칸에 -10,000 이상 10,000 이하의 정수를 하나씩 쓴다. 그런 다음 그 행렬의 부분행렬을 그려 그 안에 적힌 정수의 합을 구하는 게임이다.
동주가 혼자 재밌게 놀던 중 지나가는 당신을 보고 당신을 붙잡고 게임을 하자고 한다. 귀찮은 당신은 정수의 합이 최대가 되는 부분행렬을 구하여 빨리 동주에게서 벗어나고 싶다.
<입력값>
첫째 줄에 N (1 < N < 200), M (1 < M < 200)이 주어진다. 그 다음 N개의 줄에 M개씩 행렬의 원소가 주어진다.
<출력값>
첫째 줄에 최대의 합을 출력하라.

<문제 1750>
어떤 수열 S가 주어진다. 이때, 한 개 이상을 선택했을 때, 선택한 수의 최대공약수가 1이 되는 것의 개수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 수열의 크기 N이 주어진다. 둘째 줄부터 N개의 줄에 수열의 각 원소 Si가 주어진다. 같은 수가 들어올 수도 있다. (1 ≤ N ≤ 100, 1 ≤ Si ≤ 100,000)
<출력값>
첫째 줄에 정답을 10,000,003으로 나눈 나머지를 출력한다.

<문제 1751>
홍준이는 모의고사 3번에 답이 잘 나오지 않아 디버깅을 하던 중 프로그램 메모리에 상주하는 ‘스퀘어 킬러’라 불리는 버그가 있다는 것을 발견했다. 프로그램 메모리는 0 또는 1로 구성된 R*C 행렬이고, ‘스퀘어 킬러’는 이 메모리 상에 부분정방행렬(정방행렬이란 행과 열의 개수가 같은 행렬을 의미한다. 즉 부분정방행렬이란 정방행렬이면서 그 행렬에 포함되는 어떤 행렬을 의미한다.)로 존재한다. 이 ‘스퀘어 킬러’는 특징이 있는데 이는 이 부분행렬을 180도로 회전시킨 것과 원래 부분행렬이 정확히 일치한다는 것이다.
홍준이는 크기가 가장 큰 ‘스퀘어 킬러’가 궁금해졌다. 크기가 ‘스퀘어 킬러’의 행 또는 열의 개수를 의미한다. 우리는 홍준이를 도와 가장 크기가 큰 ‘스퀘어 킬러’를 찾자.
<입력값>
첫 번째 줄에 300 이하의 R과 C가 주어진다. 그다음 R개의 줄에 각 행의 열을 나타내는 길이가 C인 문자열이 입력된다.
<출력값>
첫 번째 줄에 가장 큰 킬러의 크기를 출력한다.

<문제 1752>
다솜이는 눈이 오늘 날 아침이면 어김없이 테라스에 나가 발자국을 남기는 것이 취미다. 하지만 늦게 일어나는 조교는 단지 발자국만을 보며 추측할 수 밖에 없다. 그러던 어느 날 아침에 조교는 다솜이의 발자취가 궁금해졌다. 하지만 이미 너무 많은 학생들이 왔다 갔다 했기에 발자취를 찾기란 쉬운 일이 아니었다. 
  한 가지 확실한 점은 학생들은 언제나 일직선으로 이동하며 눈을 밟으며 걸음폭도 일정하다는 것이다.


  위의 그림과 같이 다솜이를 포함한 학생들의 발자취는 뛰는 간격이나 방향이 서로 제각각일 수 있다.

위의 그림에서와 같이 학생들은 밖에서부터 일직선으로 들어와 정확한 보폭으로 눈을 밟고 지나간다.

그림 3과 같이 아침에 여러 학생들은 제각기 다른 방향에서 들어와 서로 다른 방향으로 밟고 지나간다. 물론 여러 명이 한 곳을 밟을 수도 있다. 그리고 늦잠을 잔 조교는 그림 4와 같이 밟고 지나간 최종 상태만 볼 수 있다.
  그림 4를 보면, 학생들이 몇 명 들어 와서 어느 방향으로 어느 간격으로 눈 위에 발자국을 내고 갔는지 그 경로를 재현할 수 있다. 단, 세 번 이상 눈 위에 발자국을 낸 학생의 경로만 생각하기로 한다. 그렇다면, 그림 4의 상황이라면 그림 3과 같은 세 개의 학생 경로가 있다고 말할 수 있다. (물론 다른 가짓수도 있을 수 있다.)
한편, 첫째 칸에서 수직으로 내려가는 경로는 보폭이 4인 학생의 경로일 수도 있지만, 이 경로는 총 발자국이 두 개이기 때문에 고려하지 않는다. 그리고 둘째 줄 셋째 칸(2, 3), 셋째 줄 넷째 칸(3, 4), 여섯째 줄 일곱째(6, 7) 칸을 지나는 경로는 일직선이고 세 개의 발자국을 남겼지만, 간격이 일정하지 않기 때문에 한 학생이 밟고 간 경로로 인정하지 않는다.
어떤 학생이 밟고 간 경로에 속하는 선상에 다른 학생이 밟고 간 곳이 있을 수 있다. 예를 들어 위 그림에서 (2, 1), (2, 3), (2, 5), (2, 7)은 한 학생이 밟고 간 경로인데, 이 선 안에는 (2, 6)처럼 다른 학생이 밟고 간 곳이 있을 수 있다. 그리고 사실은, 발자국이 있지만 이번에 학생이 남긴게 아닌 이 전에 눈이 왔을 때 남은 발자국일 수도 있다
세상에서 제일 착한 다솜이는 가장 많은 발자국을 남기고 지나가기에 이를 찾는 것이 문제이다. 그림 4의 경우, 정답은 7이다. 여섯째 줄부터 가로로 일곱 발자국을 모두 밟고 지나간 학생을 다솜이로 추정할 수 있기 때문이다.
<입력값>
첫째 줄에는 테라스의 세로, 가로 크기를 나타내는 정수 R과 C(1≤R, C≤5000)가 있다. 그리고 둘째 줄에는 학생들의 발자국 수 N(3≤N≤5000)이 있다.  그리고 다음 N 줄에는 발자국이 있는 좌표를 나타내는 정수 두 개가 뒤따른다. 처음 것이 줄(세로) 좌표이고 나중 것이 칸(가로) 좌표이다. (1≤줄 좌표≤R, 1≤칸 좌표≤C) 두 정수는 공백 한 칸으로 구분된다. 여러 학생에게 밟혔더라도 좌표는 한 번만 나온다.
<출력값>
다솜이로 추정되는 가장 많은 발자국을 남기고 간 학생의 발자국 수를 출력한다. 만약 학생의 경로를 하나도 발견하지 못했다면 그냥 0을 출력한다.

<문제 1753>
방향그래프가 주어지면 주어진 시작점에서 다른 모든 정점으로의 최단 경로를 구하는 프로그램을 작성하시오. 단, 모든 간선의 가중치는 10 이하의 자연수이다.
<입력값>
첫째 줄에 정점의 개수 V와 간선의 개수 E가 주어진다. (1≤V≤20,000, 1≤E≤300,000) 모든 정점에는 1부터 V까지 번호가 매겨져 있다고 가정한다. 둘째 줄에는 시작 정점의 번호 K(1≤K≤V)가 주어진다. 셋째 줄부터 E개의 줄에 걸쳐 각 간선을 나타내는 세 개의 정수 (u, v, w)가 순서대로 주어진다. 이는 u에서 v로 가는 가중치 w인 간선이 존재한다는 뜻이다. u와 v는 서로 다르며 w는 10 이하의 자연수이다. 서로 다른 두 정점 사이에 여러 개의 간선이 존재할 수도 있음에 유의한다.
<출력값>
첫째 줄부터 V개의 줄에 걸쳐, i번째 줄에 i번 정점으로의 최단 경로의 경로값을 출력한다. 시작점 자신은 0으로 출력하고, 경로가 존재하지 않는 경우에는 INF를 출력하면 된다.

<문제 1754>
어떤 길이 N의 순열이 있다고 한다. 이 순열은 0~N-1 까지의 수로만 이루어져 있다. a = {a[0], a[1], ... , a[n-1])
진영 순열이란 b[a[i]] = i를 만족하는 순열을 말한다.
예를 들어, (2, 0, 3, 1, 4)의 진영 순열은 (1, 3, 0, 2, 4)이다.
진영 순열을 약간 업그레이드한 순열이 존재하는데 그 이름은 K-진영 순열이다.
A가 K-진영 순열이라는 것은 A의 진영 순열인 B가 정확히 b[i] > b[i+1]를 만족하는 i를 정확히 K개 가지는 것을 의미한다.
예를 들어, (2, 0, 3, 1, 4)은 1-진영 순열이다. 그 이유는 (2, 0, 3, 1, 4)의 진영 순열인 (1, 3, 0, 2, 4)에서 b[i] > b[i+1]를 만족하는 i가 단 한 개 존재하기 때문이다.
N과 K와 A[0]이 주어졌을 때, 길이가 N이면서 K-진영 순열인 순열의 개수를 구하는 프로그램을 작성하시오.
예를 들어, N=4, K=1, A[0] = 0일 때, (0, 1, 3, 2), (0, 2, 1, 3), (0, 2, 3, 1), (0, 3, 1, 2)만이 N=4이면서 1-진영 순열이기 때문에 답은 4이다.
<입력값>
첫째 줄에 N, 둘째 줄에 K, 셋째 줄에 A[0],이 주어진다. (1<=N<=20, 0<=K<=N-1, 0<=A[0]<=N-1)
<출력값>
첫째 줄에 길이가 N이고 첫 번째 수가 A[0]인 K-진영 순열인 것의 개수를 출력한다.

<문제 1755>
79를 영어로 읽되 숫자 단위로 하나씩 읽는다면 "seven nine"이 된다. 80은 마찬가지로 "eight zero"라고 읽는다. 79는 80보다 작지만, 영어로 숫자 하나씩 읽는다면 "eight zero"가 "seven nine"보다 사전순으로 먼저 온다.
문제는 정수 M, N(1 ≤ M, N ≤ 99)이 주어지면 M 이상 N 이하의 정수를 숫자 하나씩 읽었을 때를 기준으로 사전순으로 정렬하여 출력하는 것이다.
<입력값>
첫째 줄에 M과 N이 주어진다.
<출력값>
M 이상 N 이하의 정수를 문제 조건에 맞게 정렬하여 한 줄에 10개씩 출력한다.

<문제 1756>
월드피자 원주 지점에서 N개의 피자 반죽을 오븐에 넣고 구우려고 한다. 그런데, 월드피자에서 만드는 피자 반죽은 지름이 제각각이다. 그런가하면, 월드피자에서 사용하는 오븐의 모양도 몹시 오묘하다. 이 오븐은 깊은 관처럼 생겼는데, 관의 지름이 깊이에 따라 들쭉날쭉하게 변한다. 아래는 오븐의 단면 예시이다.

피자 반죽은 완성되는 순서대로 오븐에 들어간다. 이렇게 N개의 피자가 오븐에 모두 들어가고 나면, 맨 위의 피자가 얼마나 깊이 들어가 있는지가 궁금하다. 이를 알아내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 오븐의 깊이 D와 피자 반죽의 개수 N이 공백을 사이에 두고 주어진다. (1<=D, N<=300,000) 둘째 줄에는 오븐의 최상단부터 시작하여 깊이에 따른 오븐의 지름이 차례대로 주어진다. 셋째 줄에는 피자 반죽이 완성되는 순서대로, 그 각각의 지름이 주어진다. 오븐의 지름이나 피자 반죽의 지름은 10억 이하의 자연수이다.
<출력값>
첫째 줄에, 마지막 피자 반죽의 위치를 출력한다. 오븐의 최상단이 1이고, 최하단 가장 깊은 곳이 D이 된다. 만약 피자가 모두 오븐에 들어가지 않는다면, 0을 출력한다.

<문제 1757>
어제, 그리고 어제 어제 단체달리기를 두 번이나 하였다. 원장선생님의 이러한 하드 트레이닝으로 월드 학생들의 체력은 거의 박지성 수준이 되었다. 그래서 월드 학생들은 운동장을 도는데 정확히 N분에 완주할 수 있는 시간 안배능력까지 갖추게 되었다.
그래서 N분동안 학생들은 달릴지 아님 쉴지 결정하여야 한다. 그러나 학생들도 인간이기 때문에 계속 달릴 수는 없다. “지침 지수”라는 것이 있어서 1분을 달린다면 “지침 지수”는 1이 올라간다. 반대로 1분을 쉰다면 “지침 지수”는 1이 내려간다. 또한 이 “지침 지수”가 M보다 커지면 학생들은 더 이상 달릴 수가 없다.
아주 특이하게도 학생들은 시간에 따라 달릴 수 있는 거리가 다르다. 만약 I분에 달렸다면 Di 만큼의 거리를 달릴 수 있다. (i분을 달렸다는 것이 아니라 I분이 되는 때에 달렸다는 뜻임) 또한 학생들이 쉬기 시작하면 지침지수가 0이 되기 전에는 다시 달릴 수가 없다.
물론 이 달리기가 끝나면 학생들은 다시 공부를 해야한다. 그렇기 때문에 달리기가 끝난다음 지침지수가 0이 되지 않는다면 맑은 정신으로 문제를 풀 수가 없기 때문에 달리기가 끝나면 지침지수는 0이 되어야 한다.
월드학생들이 최대한 멀리 갈 수 있는 거리를 구해보자.
<입력값>
첫째 줄에 운동할 시간 N(1 ≤ N ≤ 10000)과 M(1 ≤ M ≤ 500)이 주어진다. 이어서 N개의 줄에 i분에 달릴수 있는 거리 Di(1 ≤ Di ≤ 1,000)가 차례차례 주어진다.
<출력값>
첫째 줄에 최대로 멀리 갈 수 있는 거리를 출력하라.

<문제 1758>
스타박스는 손님을 입장시킬 때 독특한 방법으로 입장시킨다.
스타박스에서는 손님을 8시가 될 때 까지, 문앞에 줄 세워 놓는다. 그리고 8시가 되는 순간 손님들은 모두 입구에서 커피를 하나씩 받고, 자리로 간다. 강호는 입구에서 커피를 하나씩 주는 역할을 한다.
손님들은 입구에 들어갈 때, 강호에게 팁을 준다. 손님들은 자기가 커피를 몇 번째 받는지에 따라 팁을 다른 액수로 강호에게 준다. 각 손님은 강호에게 원래 주려고 생각했던 돈 - (받은 등수 - 1) 만큼의 팁을 강호에게 준다. 만약, 위의 식으로 나온 값이 음수라면, 강호는 팁을 받을 수 없다.
예를 들어, 민호는 팁을 3원 주려고 했고, 재필이는 팁을 2원, 주현이가 팁을 1원 주려고 한 경우를 생각해보자.
민호, 재필, 주현이 순서대로 줄을 서있다면, 민호는 강호에게 3-(1-1) = 3원, 재필이는 2-(2-1) = 1원, 주현이는 1-(3-1) = -1원을 팁으로 주게 된다. 주현이는 음수이기 때문에, 강호에게 팁을 주지 않는다. 따라서, 강호는 팁을 3+1+0=4원을 받게 된다.
스타박스 앞에 있는 사람의 수 N과, 각 사람이 주려고 생각하는 팁이 주어질 때, 손님의 순서를 적절히 바꿨을 때, 강호가 받을 수 잇는 팁의 최댓값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 스타박스 앞에 서 있는 사람의 수 N이 주어진다. N은 100,000보다 작은 자연수이다. 둘째 줄부터 총 N개의 줄에 각 사람이 주려고 하는 팁이 주어진다. 팁은 100,000보다 작거나 같은 자연수이다.
<출력값>
강호가 받을 수 있는 팁의 최댓값을 출력한다.

<문제 1759>
바로 어제 최백준 조교가 방 열쇠를 주머니에 넣은 채 깜빡하고 서울로 가 버리는 황당한 상황에 직면한 조교들은, 702호에 새로운 보안 시스템을 설치하기로 하였다. 이 보안 시스템은 열쇠가 아닌 암호로 동작하게 되어 있는 시스템이다.
암호는 서로 다른 L개의 알파벳 소문자들로 구성되며 최소 한 개의 모음(a, e, i, o, u)과 최소 두 개의 자음으로 구성되어 있다고 알려져 있다. 또한 정렬된 문자열을 선호하는 조교들의 성향으로 미루어 보아 암호를 이루는 알파벳이 암호에서 증가하는 순서로 배열되었을 것이라고 추측된다. 즉, abc는 가능성이 있는 암호이지만 bac는 그렇지 않다.
새 보안 시스템에서 조교들이 암호로 사용했을 법한 문자의 종류는 C가지가 있다고 한다. 이 알파벳을 입수한 민식, 영식 형제는 조교들의 방에 침투하기 위해 암호를 추측해 보려고 한다. C개의 문자들이 모두 주어졌을 때, 가능성 있는 암호들을 모두 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 두 정수 L, C가 주어진다. (3 ≤ L ≤ C ≤ 15) 다음 줄에는 C개의 문자들이 공백으로 구분되어 주어진다. 주어지는 문자들은 알파벳 소문자이며, 중복되는 것은 없다.
<출력값>
각 줄에 하나씩, 사전식으로 가능성 있는 암호를 모두 출력한다.

<문제 1760>
N-Queen 문제를 풀어본 일이 있을 것이다. 격자판에 N개의 Queen을 배치하되, 각 Queen이 서로를 공격할 수 없게 배치하려면 N은 최대 얼마까지 가능한지를 알아내는 문제이다.
이번에는 Rook을 가지고 같은 문제를 풀어 보자. Rook은 격자판의 같은 열, 혹은 같은 행에 다른 말이 있을 경우, 그 말을 공격할 수 있는 말이다.
다만, 이 경우에 문제가 그 가치를 확보하기 위해서는, 격자판을 약간 변형해야 한다. 격자판에 벽과 구덩이를 도입하자.
벽을 사이에 두고 있는 두 Rook은, 서로 볼 수 없으므로, 서로 공격할 수가 없다. 물론 벽이 놓여 있는 격자에는 Rook을 놓을 수 없다.
반면, 구덩이를 사이에 두고 있는 두 Rook은 서로 공격을 시도한다. (아마 공격 도중에 구덩이에 빠지겠지만.) 따라서 두 Rook이 구덩이를 사이에 두고 마주보도록 배치해서는 안 된다. 또, 구덩이를 파 놓은 격자에도 Rook을 놓을 수 없다.
격자판의 모양이 주어졌을 때, Rook을 가장 많이 배치하기 위한 방법을 알아내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 격자의 크기를 나타내는 두 자연수 N, M이 주어진다. 격자가 N행 M열로 이루어져 있다는 의미이다. (1 ≤ N, M ≤ 100) 둘째 줄부터는 격자의 모양을 나타내는 정보가 한 줄에 한 행씩 주어진다. 0은 빈 격자, 1은 구덩이가 파인 격자, 2는 벽이 놓인 격자를 의미한다.
<출력값>
첫째 줄에 배치할 수 있는 Rook의 최대 개수를 출력한다.

<문제 1761>
N(2 ≤ N ≤ 40,000)개의 정점으로 이루어진 트리가 주어지고 M(1 ≤ M ≤ 10,000)개의 두 노드 쌍을 입력받을 때 두 노드 사이의 거리를 출력하라.
<입력값>
첫째 줄에 노드의 개수 N이 입력되고 다음 N-1개의 줄에 트리 상에 연결된 두 점과 거리를 입력받는다. 그 다음 줄에 M이 주어지고, 다음 M개의 줄에 거리를 알고 싶은 노드 쌍이 한 줄에 한 쌍씩 입력된다. 두 점 사이의 거리는 10,000보다 작거나 같은 자연수이다.
정점은 1번부터 N번까지 번호가 매겨져 있다.
<출력값>
M개의 줄에 차례대로 입력받은 두 노드 사이의 거리를 출력한다.

<문제 1762>
N(1 ≤ N ≤ 100,000)개의 정점으로 이루어진 평면그래프가 있다. 이 평면그래프에 삼각형, 즉 길이가 3인 사이클이 몇 개나 존재하는지 알아내는 프로그램을 작성하시오.
평면그래프란, 열심히 노력하면 간선들이 서로 겹치지 않도록 평면상에 그릴 수 있는 그래프를 말한다.
서로 다른 세 정점 x, y, z가 있을 때, x-y, y-z, z-x의 세 간선이 존재하면 세 정점 x, y, z는 삼각형을 이루고 있다고 한다.
정점은 1번부터 N번까지 번호가 매겨져 있다.
<입력값>
첫째 줄에 두 정수 N, M이 주어진다. M은 간선의 개수를 나타내는 0 이상의 정수이다. 다음 M개의 줄에는 각 간선이 연결하는 서로 다른 두 정점의 번호가 주어진다. 같은 간선이 중복되어 입력으로 주어지지 않으며, 간선들에는 방향성이 없다.
<출력값>
첫째 줄에 삼각형의 개수를 출력한다.

<문제 1763>
N개의 노드를 가지고 있으며, 루트가 있는 트리의 각 노드에 가중치가 부여돼 있다. 임의의 노드의 번호를 i라 하고, i번 노드에 부여된 가중치를 C[i]라 한다.
이 트리를 색칠한다고 상상해 보자. 한 노드를 색칠하는 데에는 비용이 드는데, i번 노드가 F[i]번째로 색칠되는 노드라면, i번 노드를 색칠하는 데 드는 비용은 C[i]*F[i]로 계산된다. 전체 트리를 색칠하는 데 드는 비용은 각 노드를 색칠하는 데 드는 비용의 합이다.
단, 어떤 노드를 색칠하기 위해서는 그 노드의 부모 노드가 이미 색칠되어 있어야 한다. 따라서 루트가 가장 먼저 색칠되어야 한다. 이러한 규칙에 따를 때, 최소의 비용으로 트리를 색칠하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 트리 내 노드의 수 N과, 루트의 번호 R이 공백을 사이에 두고 주어진다. (1<=N<=1,000. 1<=R<=N) 둘째 줄에는 C[i]가 차례로 주어진다. 이후 N-1개의 줄에는 트리 내의 간선이 두 개의 자연수로 주어진다. 두 수가 U, V라면 U번 노드와 V번 노드 사이에 간선이 있으며, U가 V의 부모라는 뜻이다.
<출력값>
첫째 줄에, 트리를 색칠하기 위한 최소 비용을 출력한다.

<문제 1764>
김진영이 듣도 못한 사람의 명단과, 보도 못한 사람의 명단이 주어질 때, 듣도 보도 못한 사람의 명단을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 듣도 못한 사람의 수 N, 보도 못한 사람의 수 M이 주어진다. 이어서 둘째 줄부터 N개의 줄에 걸쳐 듣도 못한 사람의 이름과, N+2째 줄부터 보도 못한 사람의 이름이 순서대로 주어진다. 이름은 띄어쓰기 없이 영어 소문자로만 이루어지며, 그 길이는 20 이하이다. N, M은 500,000 이하의 자연수이다.
 
듣도 못한 사람의 명단에는 중복되는 이름이 없으며, 보도 못한 사람의 명단도 마찬가지이다.
<출력값>
듣보잡의 수와 그 명단을 사전순으로 출력한다.

<문제 1765>
닭싸움은 월드의 전통이다. 이번 캠프에서도 어김없이 닭싸움 대회가 열렸다. 그런데, 닭싸움을 하기 위해서는 반드시 누가 우리 편이고, 누가 우리 편이 아닌지를 알아야 할 것이다. 닭싸움의 팀을 정하는 원칙은, 평소 학생들의 인간관계에 따라 다음과 같이 정리할 수 있다.

내 친구의 친구는 내 친구이다.
내 원수의 원수도 내 친구이다.

이 때 두 학생이 친구이면 같은 팀에 속해있어야 하며, 같은 팀에 속해 있는 사람들끼리는 전부 친구여야 한다.
학생들의 인간관계가 주어지면, 닭싸움을 위한 팀 정하기를 할 때, 최대 얼마나 많은 팀이 만들어질 수 있는지 알아내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 학생의 수 n이 주어진다. 각 학생들은 1부터 n까지 번호가 매겨져 있다. (2 ≤ n ≤ 1000) 
둘째 줄에 학생 간의 인간관계 중 알려진 것의 개수 m이 주어진다. (1 ≤ m ≤ 5000)
다음 m개의 줄에는 한 줄에 한 개씩, 학생 간의 인간관계가 F p q 혹은 E p q의 형태로 공백으로 구분되어 주어진다. (1 ≤ p < q ≤ N)
첫 번째 글자가 F인 경우에는 p와 q가 친구인 것이고, E인 경우는 p와 q가 원수인 경우이다. 
입력은 모순이 없음이 보장된다. 즉, 두 학생이 동시에 친구이면서 원수인 경우는 없다.
<출력값>
첫째 줄에, 가능한 최대 팀 개수를 출력한다.

<문제 1766>
민오는 1번부터 N번까지 총 N개의 문제로 되어 있는 문제집을 풀려고 한다. 문제는 난이도 순서로 출제되어 있다. 즉 1번 문제가 가장 쉬운 문제이고 N번 문제가 가장 어려운 문제가 된다.
어떤 문제부터 풀까 고민하면서 문제를 훑어보던 민오는, 몇몇 문제들 사이에는 '먼저 푸는 것이 좋은 문제'가 있다는 것을 알게 되었다. 예를 들어 1번 문제를 풀고 나면 4번 문제가 쉽게 풀린다거나 하는 식이다. 민오는 다음의 세 가지 조건에 따라 문제를 풀 순서를 정하기로 하였다.

N개의 문제는 모두 풀어야 한다.
먼저 푸는 것이 좋은 문제가 있는 문제는, 먼저 푸는 것이 좋은 문제를 반드시 먼저 풀어야 한다.
가능하면 쉬운 문제부터 풀어야 한다.

예를 들어서 네 개의 문제가 있다고 하자. 4번 문제는 2번 문제보다 먼저 푸는 것이 좋고, 3번 문제는 1번 문제보다 먼저 푸는 것이 좋다고 하자. 만일 4-3-2-1의 순서로 문제를 풀게 되면 조건 1과 조건 2를 만족한다. 하지만 조건 3을 만족하지 않는다. 4보다 3을 충분히 먼저 풀 수 있기 때문이다. 따라서 조건 3을 만족하는 문제를 풀 순서는 3-1-4-2가 된다.
문제의 개수와 먼저 푸는 것이 좋은 문제에 대한 정보가 주어졌을 때, 주어진 조건을 만족하면서 민오가 풀 문제의 순서를 결정해 주는 프로그램을 작성하시오.
<입력값>
첫째 줄에 문제의 수 N(1 ≤ N ≤ 32,000)과 먼저 푸는 것이 좋은 문제에 대한 정보의 개수 M(1 ≤ M ≤ 100,000)이 주어진다. 둘째 줄부터 M개의 줄에 걸쳐 두 정수의 순서쌍 A,B가 빈칸을 사이에 두고 주어진다. 이는 A번 문제는 B번 문제보다 먼저 푸는 것이 좋다는 의미이다.
항상 문제를 모두 풀 수 있는 경우만 입력으로 주어진다.
<출력값>
첫째 줄에 문제 번호를 나타내는 1 이상 N 이하의 정수들을 민오가 풀어야 하는 순서대로 빈칸을 사이에 두고 출력한다.

<문제 1767>
체스 세계랭킹 1위의 숌은 더 이상 체스를 대결할 상대가 없자, 새로운 체스방법을 생각했다.
일단 Rook은 체스판의 같은 열, 혹은 같은 행에 다른 말이 있을 경우, 그 말을 공격할 수 있는 말이다.
숌은 N * M 크기의 체스판에 K개의 룩을 놓는데, 서로 공격받지 않는 경우의 수를 구하는 문제를 생각했다. 이 문제는 너무 쉽게 풀려서 숌은 좀 더 어려운 문제를 찾다가 각 룩이 최대 1개의 룩에만 공격받는 경우의 수가 궁금해졌다. 어떤 룩은 공격받지 않을 수도 있다.
N*M크기의 체스판이 주어졌을 때, K개의 룩을 놓을 때, 각 룩이 최대 1개의 룩에만 공격받는 경우의 수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 체스판의 세로 크기 N, 둘째 줄에 가로 크기 M, 셋째 줄에 놓으려고 하는 룩의 수 K가 주어진다. N과 M과 K는 100보다 작거나 같은 자연수이다.
<출력값>
N * M 크기의 체스판에 K개의 룩을 놓을 때, 각 룩이 최대 1개의 룩에만 공격받는 경우의 수를 1,000,001로 나눈 나머지를 출력한다.

<문제 1768>
Given is a set of n points with integer coordinates. Your task is to decide whether the set has a center of symmetry.
A set of points S has the center of symmetry if there exists a point s (not necessarily in S) such that for every point p in S there exists a point q in S such that p-s = s-q.
<입력값>
The first line of input contains a number c giving the number of cases that follow. The first line of data for a single case contains number 1 ≤ n ≤ 10000. The subsequent n lines contain two integer numbers each which are the x and y coordinates of a point. Every point is unique and we have that -10000000 ≤ x, y ≤ 10000000.
<출력값>
For each set of input data print yes if the set of points has a center of symmetry and no otherwise.

<문제 1769>
문제가 잘 풀리지 않을 때, 문제를 바라보는 시각을 조금만 다르게 가지면 문제가 쉽게 풀리는 경험을 종종 해 보았을 것이다. 여러 가지 방법이 있지만 그 중 하나로 우리가 풀고 싶은 문제를 좀 더 쉬운 문제로 바꾸어 풀어 보는 방법이 있다.
소위 "다른 문제로 바꾸어 풀기"라는 이 방법은, 아래와 같은 과정으로 이루어진다.

풀고자 하는 문제를 다른 문제로 변환한다.
변환된 문제의 답을 구한다.
구한 답을 원래 문제의 답으로 삼는다.

이를 보다 쉽게 이해하기 위해서, 다음의 초등학교 수학 수준의 예를 들어 보자.
문제 1. "양의 정수 X는 3의 배수인가?"
이 문제를 아래와 같이 변환하는데, X의 각 자리의 수를 단순히 더한 수 Y를 만든다. 예를 들어 X가 1107이었다면, Y는 1+1+0+7=9가 된다. 그리고 Y에 대해서, 아래와 같은 문제를 생각한다.
문제 2. "Y는 3의 배수인가?"
위의 문제 1의 답은 아래의 문제 2의 대답과 일치한다. 위의 예의 경우, Y=9는 3의 배수이므로 X=1107 역시 3의 배수가 되는 것이다. 214는 각 자리수의 합 2+1+4=7이 3의 배수가 아니므로 3의 배수가 아니다.
문제 1을 풀고 싶으면 문제 2로 변환을 해서 문제 2의 답을 문제 1의 답으로 삼으면 된다. 일반적으로 Y는 X보다 크기가 작으므로, 문제 2가 더 쉬운 문제가 된다.
당신이 알고 있는 3의 배수는 한 자리 수밖에 없다고 가정하자. 즉, 문제 변환의 과정을 여러 번 거치다 보면 Y가 한 자리 수가 되는 순간이 있게 되는데, 그렇게 될 때까지 문제 변환을 반복한다는 뜻이다. 변환 후의 Y가 3, 6, 9 중 하나이면 원래의 수 X는 3의 배수이고, Y가 1, 2, 4, 5, 7, 8 중 하나이면 원래의 수 X는 3의 배수가 아니다.
큰 수 X가 주어졌을 때, 앞에서 설명한 문제 변환의 과정을 몇 번 거쳐야 Y가 한 자리 수가 되어, X가 3의 배수인지 아닌지를 알 수 있게 될지를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 큰 자연수 X가 주어진다. X는 1,000,000자리 이하의 수이다.
<출력값>
첫째 줄에 문제 변환의 과정을 몇 번 거쳤는지를 출력한다. 이 수는 음이 아닌 정수가 되어야 한다. 둘째 줄에는 주어진 수가 3의 배수이면 YES, 아니면 NO를 출력한다.

<문제 1771>
1 이상 N 이하의 자연수가 한 장에 하나씩 순서대로 적혀 있는 N장의 카드가 있다. 이 카드를 임의의 순서로 섞은 뒤 일렬로 배열하였다. 아래는 N = 6인 경우의 한 예이다.

[6] [3] [2] [1] [4] [5]
각각 N장의 카드는 하나의 묶음을 이루고 있다고 생각할 수 있다. 즉 초기에 N개의 카드 묶음이 순서대로 배열되어 있는 것이다.
만일 하나의 카드 묶음 속에 포함되어 있는 카드들이 서로 연속된 수들로만 이루어져 있으면, 그러한 묶음을 유효한 카드 묶음이라고 한다. [2], [4 5], [3 5 6 4] 등은 유효한 카드 묶음의 예이다.
인접한 두 개의 카드 묶음을 하나로 합쳤을 때 새로 생긴 카드 묶음도 유효한 카드 묶음이면, 두 카드 묶음을 하나로 합칠 수 있다. 이러한 과정을 N-1번 반복하면 N개의 카드를 하나의 카드 묶음으로 만들 수 있다. 아래는 이러한 과정의 한 예를 순서대로 보인 것이다.

[6] [3] [2] [1] [4] [5]
[6] [3] [2 1] [4] [5]
[6] [3 2 1] [4] [5]
[6] [3 2 1] [4 5]
[6] [3 2 1 4 5]
[6 3 2 1 4 5]
N장의 카드의 초기 배열이 주어졌을 때, 이러한 과정을 N-1번 반복하여 N개의 카드를 하나의 카드 묶음으로 만드는 과정을 구하는 프로그램을 작성하시오. 항상 가능한 경우만이 입력으로 주어지며, 여러 가지 해 중에서 하나만 출력하면 된다.
<입력값>
첫째 줄에 자연수 N(1 ≤ N ≤ 500,000)이 주어진다. 둘째 줄에는 카드의 초기 배열을 나타내는 N개의 정수가 빈 칸을 사이에 두고 순서대로 주어진다.
<출력값>
첫째 줄부터 N-1개 줄에 걸쳐 합치는 과정을 표현해 줄 한 개의 정수를 출력한다. 합쳐질 두 개의 묶음 중, 앞 묶음의 마지막 카드가 몇 번째 카드인지를 출력하면 된다. 예를 들어, [6] [3 2 1] [4 5]의 경우, 앞 묶음인 [3 2 1]의 마지막 카드인 1은 네 번째이므로, 4를 출력하면 된다.

<문제 1772>
정원을 정리하던 배상욱은 흉측할 정도로 난잡하게 자란 정원수 한 그루를 발견했다. 가지치기를 할 시기가 된 것이다.
정원수는 n개의 정점과 n-1개의 간선으로 구성된, 연결 그래프로 표현된다. 그래프 내의 정점은 정원수의 잎사귀라고 할 수 있으며, 각 간선은 정원수의 가지들이라고 생각하자.
상욱은 가지치기를 통해 정원수 내의 잎사귀 개수가 m이 되도록 만드는 것이다. 즉, 정원수를 나타내는 그래프 내에 m개의 정점만 남겨야 한다. 가지치기란, 정원수 그래프 내의 간선을 끊는 일이다. 특정한 간선을 끊어, 그래프가 두 부분으로 분리되면, 한 부분을 취하고 다른 부분은 버린다.
상욱은 그리 부지런한 사람이 아닌 관계로, 최소한의 가지치기를 이용해서 정원수를 정리하기를 바란다. 정원수의 모양이 주어지면, 어떻게 가지치기를 해야 최소한의 가위질로 작업을 마무리할 수 있을지 알아내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 n과 m이 주어진다. (1<=n<=150, 1<=m<=n) 이후 한 줄에 한 개씩, 정원수의 가지를 나타내는 정보가 주어진다. 이는 정원수 내의 잎사귀 번호 두 개로 이루어져 있으며, 두 잎사귀 사이를 연결하는 가지가 있다는 의미이다. 잎사귀 번호는 1이상 n이하의 정수이다.
<출력값>
첫째 줄에, 최소한의 가지치기 횟수를 출력한다. 불가능한 경우에는 -1을 출력한다.

<문제 1773>
학생들은 3주가 지난 기념으로 매점에서 1월 1일이 지나 싸게 파는 폭죽을 사서 터뜨리고 있다.
폭죽쇼를 하는 동안 N명의 학생들이 폭죽을 터뜨린다. 그리고 이 N명의 학생은 각각 일정한 주기로 폭죽을 터뜨린다. 물론 이 주기는 학생들마다 같을 수도, 다를 수도 있다. 그리고 우리는 초 단위로 관찰을 하고, 폭죽 역시 초 단위로 터진다.
폭죽쇼가 끝날 때까지 얼마나 많은 시간동안 밤하늘에 폭죽이 터지는 것을 볼 수 있는지 궁금해 하는 조교를 도와주자.
<입력값>
첫 줄에 폭죽을 터뜨리는 학생의 수 N(1 ≤ N ≤ 100)과 폭죽쇼가 끝나는 시간 C(1 ≤ C ≤ 2,000,000)가 주어진다. 그 다음 N개의 줄에는 학생들이 폭죽을 터뜨리는 주기가 한 줄에 하나씩 주어진다. 주기는 1보다 크거나 같고, C보다 작거나 같은 자연수이다.
<출력값>
폭죽쇼가 시작되고 끝날 때까지 밤하늘에 폭죽을 볼 수 있는 총 시간을 출력한다.

<문제 1774>
황선자씨는 우주신과 교감을 할수 있는 채널러 이다. 하지만 우주신은 하나만 있는 것이 아니기때문에 황선자 씨는 매번 여럿의 우주신과 교감하느라 힘이 든다. 이러던 와중에 새로운 우주신들이 황선자씨를 이용하게 되었다.
하지만 위대한 우주신들은 바로 황선자씨와 연결될 필요가 없다. 이미 황선자씨와 혹은 이미 우주신끼리 교감할 수 있는 우주신들이 있기 때문에 새로운 우주신들은 그 우주신들을 거쳐서 황선자 씨와 교감을 할 수 있다.
우주신들과의 교감은 우주신들과 황선자씨 혹은 우주신들 끼리 이어진 정신적인 통로를 통해 이루어 진다. 하지만 우주신들과 교감하는 것은 힘든 일이기 때문에 황선자씨는 이런 통로들이 긴 것을  좋아하지 않는다. 왜냐하면 통로들이 길 수록 더 힘이 들기 때문이다.
또한 우리들은 3차원 좌표계로 나타낼 수 있는 세상에 살고 있지만 우주신들과 황선자씨는 2차원 좌표계로 나타낼 수 있는 세상에 살고 있다. 통로들의 길이는 2차원 좌표계상의 거리와 같다.
이미 황선자씨와 연결된, 혹은 우주신들과 연결된 통로들이 존재한다. 우리는 황선자 씨를 도와 아직 연결이 되지 않은 우주신들을 연결해 드려야 한다. 새로 만들어야 할 정신적인 통로의 길이들이 합이 최소가 되게 통로를 만들어 “빵상”을 외칠수 있게 도와주자.
<입력값>
첫째 줄에 우주신들의 개수(N<=1,000) 이미 연결된 신들과의 통로의 개수(M<=1,000)가 주어진다.
두 번째 줄부터 N개의 줄에는 황선자를 포함하여 우주신들의 좌표가 (0<= X<=1,000,000), (0<=Y<=1,000,000)가 주어진다. 그 밑으로 M개의 줄에는 이미 연결된 통로가 주어진다. 번호는 위의 입력받은 좌표들의 순서라고 생각하면 된다. 좌표는 정수이다.
<출력값>
첫째 줄에 만들어야 할 최소의 통로 길이를 출력하라. 출력은 소수점 둘째짜리까지 출력하여라.

<문제 1775>
We are trying to construct a labyrinth on a board of size m × n. Initially, on each square of the board we find a piece of thin plywood of size 1 × 1 with one of the following three patterns painted on it.

While constructing the labyrinth we may turn the pieces arbitrarily but each piece must exactly cover a square of the board. We are not allowed to move a piece to another square of the grid.
Given an initial board covered with the pieces, we would like to turn the pieces in such a way that the patterns on the pieces form at least one polygonal curve connecting the top left corner square of the board with the bottom right square of the board. The picture below presents an initial state of a board of size 4 × 6 and a labyrinth constructed from the board in which the above stated goal has been achieved.

Your task is to read a description of the initial board with the pieces placed on it and to decide whether one can turn the pieces in such a way that the patterns form a line connecting some edge of the top left square and some edge of the bottom right square of the board.
<입력값>
The first line of input contains a number c giving the number of cases that follow. The test data for each case start with two numbers m and n giving the number of rows and columns on the board. The remaining lines form an ASCII rendition of the initial board with the pieces placed on squares. The characters used in the rendition are +, -, |, * and space. See the sample input for the format. The size of the input board will be such that m ×  n ≤ 64.
<출력값>
For each case when a labyrinth with the desired property can be constructed print the labyrinth in the format like the input format which illustrates a path with the smallest number of squares. (If there are many such paths then anyone will do.) The squares not participating in the path should be left blank. If the labyrinth cannot be formed then do not print the board. After printing the board (if any) print how many different paths exist in the solutions to the labyrinth problem in the format shown below.

<문제 1776>
준규는 삐져버린 도현이를 위해 깜짝 선물을 준비하려고 한다. 도현이는 준규의 문자를 계속해서 답장하지 않았고, 준규는 점점 직접 선물을 줄 용기가 없어졌다. 따라서, 도현이가 자주 가는 장소에 선물을 맡겨놓으려고 한다.
도현이가 자주 가는 곳은 모두 일직선 상에 있다. 또, 준규가 선물을 보관해놓은 창고도 일직선상에 있다.
준규는 트럭을 이용해 선물을 배달한다. 준규의 트럭에는 최대 A개의 물건까지 넣을 수 있다. 또, 트럭을 타고 1km를 이동할 때마다, 트럭은 B원을 소비하게 된다. 트럭에 몇 개의 물건이 실려있는지와 상관 없이 항상 1km를 이동할 때마다 B원을 소비한다. 가장 처음에 트럭은 선물을 보관해놓은 창고에 있다.
어떤 곳에 선물을 전달할 때는, 트럭을 주차시켜야 한다. 이때, 주차비는 C원이다. 단, 창고에서 물건을 실을 때는, 주차비를 내지 않아도 된다. 트럭은 어느 곳에서나 주차를 할 수 있다. 준규가 선물을 배달할 때는 반드시 주차를 해야 한다. 즉, 트럭을 운전하면서 선물을 던져서 배달할 수 없다.
선물을 걸어서 배달할 수도 있다. 이때는, 한 개씩만 배달할 수 있다. 선물을 들고 걸어갈 때 드는 비용은 D원이다. 선물을 들지 않고 걸어갈 때는 비용이 들지 않는다.
선물의 개수와 놓여야하는 위치, 트럭이 실을 수 있는 선물의 최대 개수 A, 트럭을 타고 1km를 이동할 때마다 드는 비용 B, 주차비 C, 걸어갈 때 드는 비용 D가 주어졌을 때, 모든 선물을 배달하는데 필요한 비용의 최솟값을 구하는 프로그램을 작성하시오. 선물을 모두 배달하고 난 이후에 트럭은 원래 창고에 돌아가지 않아도 된다.
<입력값>
첫째 줄에 선물을 배달해야 하는 위치의 수 N(1 ≤ N ≤ 100)이 주어진다. 둘째 줄에는 선물을 배달해야 하는 곳과 창고 사이의 거리가 주어진다. 거리는 1,000,000보다 작거나 같은 자연수이고, km 단위이다. 셋째 줄에는 A, B, C, D가 주어진다. (1 ≤ A ≤ 100, 0 ≤ B, C, D ≤ 1,000,000)
<출력값>
배달하는 비용의 최솟값을 출력한다.

<문제 1777>
1부터 N번까지로 수로 이루어진 순열이 있다.
그리고 이 순열과 연관된 "Inversion sequence"라고 부르는 수열이 있다. 이 수열의 i번째 원소에는 순열에서 i보다 뒤에 나오면서 i보다 작은 수의 개수가 들어간다.
2  4  5  1  7  6  3  8
위의 순열이 있다면 이것의 Inversion sequence는
0  1  0  2  2  1  2  0 이 된다.
문제는 역으로 어떤 Inversion sequence가 주어지면 이것에 해당하는 순열을 찾는 프로그램을 작성하는 것이다.
<입력값>
순열의 크기 N(1 ≤ N ≤ 100,000)이 주어진다. 두 번째 줄에는 순열 1, 2, …, N에 해당하는 Inversion sequence가 공백으로 구분되어 들어온다.
<출력값>
입력으로 주어진 Inversion sequence에 대응하는 순열을 공백으로 구분하여 한 줄에 출력한다.

<문제 1778>
There are so many different religions in the world today that it is difficult to keep track of them all. You are interested in finding out how many different religions students in your university believe in.
You know that there are n students in your university (0 < n ≤ 50000). It is infeasible for you to ask every student their religious beliefs. Furthermore, many students are not comfortable expressing their beliefs. One way to avoid these problems is to ask m (0 ≤ m ≤  n(n-1)/2) pairs of students and ask them whether they believe in the same religion (e.g. they may know if they both attend the same church). From this data, you may not know what each person believes in, but you can get an idea of the upper bound of how many different religions can be possibly represented on campus. You may assume that each student subscribes to at most one religion.
<입력값>
The input consists of a number of cases. Each case starts with a line specifying the integers n and m. The next m lines each consists of two integers i and j, specifying that students i and j believe in the same religion. The students are numbered 1 to n. The end of input is specified by a line in which n = m = 0.
<출력값>
For each test case, print on a single line the case number (starting with 1) followed by the maximum number of different religions that the students in the university believe in.

<문제 1779>
One duty Jimmy has at the ACM is to formalize the language and grammar used in texts. Part of this job is expanding contractions and certain acronyms.
A contraction in English is a word or phrase formed by omitting or combining some of the sounds of a longer phrase. For example, "don't" is a contraction for "do not" and "o'clock" comes from "of the clock."
An acronym is a series of letters (or word) formed from the initial letters of a name or from combining parts of a series of words. For example, "ACM" for "Association for Computing Machinery" or "radar" for "radio detecting and ranging."
Your job is to take a list of contractions and acronyms, and expand all contractions and some acronyms in a text.
<입력값>
Input begins with two numbers, C < 50 and A < 50, indicating respectively the number of contractions and acronyms Jimmy must expand. The next C lines list a contraction and its formal expansion. Following will be a list of A acronyms and their expansions, each on individual lines. Both contractions and acronyms will be presented in the following format:

 "contraction or acronym" -> "expansion"

Since contractions, acronyms and expansions may contain spaces, each will be enclosed in quotation marks and be no more than 80 characters in length. Following the lists of contractions and acronyms will be a series of texts to expand. Each text will consist of lines no longer than 80 characters. No contraction or acronym will be split over multiple lines. A text will be terminated with a line consisting only of the character '#'.
<출력값>
Output each text exactly as input, except for necessary expansions.
All contractions must be fully expanded. Each contraction may appear as listed, entirely uppercase, or capitalized (first letter uppercase, remaining letters as listed). The expansion should follow the same rule; if a contraction is uppercased, the expansion should be uppercased as well. If more than one case applies, choose the earliest matching case in the list: "as listed," "uppercased," and "capitalized."
Since acronyms are useful for understanding and identifying names, only modify the first instance of an acronym in each text. An instance of an acronym must match the case exactly ("acm" is not an instance of "ACM"). The modification consists of replacing the acronym with the expansion, followed by a space, followed by the acronym in brackets. This allows the reader to connect the acronym with the fully expanded term.
The terminating line of '#' should be printed after each text. If more than one expansion or acronym match can be valid, use the one which starts earlier in the text. If several begin at the same letter, use the one appearing earliest in the input lists. Use the sample below to illustrate the process.

<문제 1780>
N×N크기의 행렬로 표현되는 종이가 있다. 종이의 각 칸에는 -1, 0, 1의 세 값 중 하나가 저장되어 있다. 우리는 이 행렬을 적절한 크기로 자르려고 하는데, 이때 다음의 규칙에 따라 자르려고 한다.

만약 종이가 모두 같은 수로 되어 있다면 이 종이를 그대로 사용한다.
(1)이 아닌 경우에는 종이를 같은 크기의 9개의 종이로 자르고, 각각의 잘린 종이에 대해서 (1)의 과정을 반복한다.

이와 같이 종이를 잘랐을 때, -1로만 채워진 종이의 개수, 0으로만 채워진 종이의 개수, 1로만 채워진 종이의 개수를 구해내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N(1 ≤ N ≤ 37, N은 3k 꼴)이 주어진다. 다음 N개의 줄에는 N개의 정수로 행렬이 주어진다.
<출력값>
첫째 줄에 -1로만 채워진 종이의 개수를, 둘째 줄에 0으로만 채워진 종이의 개수를, 셋째 줄에 1로만 채워진 종이의 개수를 출력한다.

<문제 1781>
상욱 조교는 동호에게 N개의 문제를 주고서, 각각의 문제를 풀었을 때 컵라면을 몇 개 줄 것인지 제시 하였다. 하지만 동호의 찌를듯한 자신감에 소심한 상욱 조교는 각각의 문제에 대해 데드라인을 정하였다.



문제 번호
1
2
3
4
5
6
7


데드라인
1
1
3
3
2
2
6


컵라면 수
6
7
2
1
4
5
1



위와 같은 상황에서 동호가 2, 6, 3, 1, 7, 5, 4 순으로 숙제를 한다면 2, 6, 3, 7번 문제를 시간 내에 풀어 총 15개의 컵라면을 받을 수 있다.
문제는 동호가 받을 수 있는 최대 컵라면 수를 구하는 것이다. 위의 예에서는 15가 최대이다.
문제를 푸는데는 단위 시간 1이 걸리며, 각 문제의 데드라인은 N이하의 자연수이다. 또, 각 문제를 풀 때 받을 수 있는 컵라면 수와 최대로 받을 수 있는 컵라면 수는 모두 231보다 작거나 같은 자연수이다.
<입력값>
첫 줄에 숙제의 개수 N (1 ≤ N ≤ 200,000)이 들어온다. 다음 줄부터 N+1번째 줄까지 i+1번째 줄에 i번째 문제에 대한 데드라인과 풀면 받을 수 있는 컵라면 수가 공백으로 구분되어 입력된다.
<출력값>
첫 줄에 동호가 받을 수 있는 최대 컵라면 수를 출력한다.

<문제 1782>
디지털 화면에서 숫자(디지털 숫자)는 코레스코 콘도에 돌아다니는 엘리베이터에 나온 숫자처럼 쓴다. (항승이처럼 엘리베이터가 무서워서 못타는 사람은 어쩔수 없다. 항승이가 엘리베이터에 타는 날은 그날 잠자리가 축축할지도 모른다.)
어떤 디지털 숫자를 거울에 비춰봤을 때 그 숫자가 원래 숫자와 같으면 그 숫자를 거울 숫자라고 부른다. 0과 1과 8은 서로 대칭이고, 2와 5는 서로 거울에 비췄을 때 반대 숫자를 보여준다. 다른 숫자는 대칭으로 보여지지 않는다.
예를 들어, 0, 101, 1521은 거울 숫자이다. 하지만, 1221이나 1010은 거울 숫자가 아니다.

두 수 A와 B가 들어오면, A와 B 사이에 있는 거울 숫자의 개수를 출력하는 프로그램을 작성하시오. A와 B도 포함한다.
<입력값>
첫째 줄에 두 수 A와 B가 공백을 사이에 두고 주어진다. 0<=A, B<=10^18
<출력값>
첫째 줄에 거울 숫자의 개수를 출력한다.

<문제 1783>
병든 나이트가 N × M 크기 체스판의 가장 왼쪽아래 칸에 위치해 있다. 병든 나이트는 건강한 보통 체스의 나이트와 다르게 4가지로만 움직일 수 있다.

2칸 위로, 1칸 오른쪽
1칸 위로, 2칸 오른쪽
1칸 아래로, 2칸 오른쪽
2칸 아래로, 1칸 오른쪽

병든 나이트는 여행을 시작하려고 하고, 여행을 하면서 방문한 칸의 수를 최대로 하려고 한다. 병든 나이트의 이동 횟수가 4번보다 적지 않다면, 이동 방법을 모두 한 번씩 사용해야 한다. 이동 횟수가 4번보다 적은 경우(방문한 칸이 5개 미만)에는 이동 방법에 대한 제약이 없다.
체스판의 크기가 주어졌을 때, 병든 나이트가 여행에서 방문할 수 있는 칸의 최대 개수를 구해보자.
<입력값>
첫째 줄에 체스판의 세로 길이 N와 가로 길이 M이 주어진다. N과 M은 2,000,000,000보다 작거나 같은 자연수이다.
<출력값>
병든 나이트가 여행에서 방문할 수 있는 칸의 개수중 최댓값을 출력한다.

<문제 1784>
준규는 심심해서 팰린드롬 인코딩이라는 새로운 인코딩 방법을 만들었다. 
팰린드롬 인코딩은 0과 1로만 이루어진 자료만 인코딩 할 수 있으며, 다음과 같은 과정을 거친다.

문자열 S에서 짝수 길이인 팰린드롬 연속 부분 문자열을 찾는다. 팰린드롬은 앞에서부터 읽을 때와 뒤에서부터 읽을때가 똑같은 문자열을 말한다. 만약, 팰린드롬이 없는 경우에는 3단계로 간다.
찾은 팰린드롬 문자열 중에서 뒤의 절반을 지운다. 예를 들어, 찾은 문자열이 0110이면, 10을 지운다.
만약, 팰린드롬이 더 존재하면 다시 1단계로 돌아가고, 없으면 남은 문자열을 출력한다.

 
문자열 S가 주어졌을 때, 팰린드롬 인코딩을 했을 때, 나올 수 있는 결과 중에서 가장 짧은 길이를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 문자열 S가 주어진다. S의 길이는 1보다 크고, 10,000보다 작다.
<출력값>
첫째 줄에 팰린드롬 인코딩을 했을 때 가능한 최소길이를 출력한다.

<문제 1785>
준규는 심심해서 보드게임을 만들었다. 너무 심심했기 때문에, 보드 게임에 사용되는 돈도 독특하게 만들었다. 
K개의 돈을 만들려고 한다. 첫 번째는 1원이다. 그 다음, 적절히 돈을 만든 다음 돈을 오름차순으로 정렬했을 때, i번째 돈이 i-1번째 돈의 2, 3, 4, 5배 중 하나를 만족하게 만들려고 한다.
이 보드게임을 시작할 때, 각 사람은 N원을 가지게 된다. 준규는 N원을 모든 플레이어에게 줄 때, 주는 지폐의 개수를 최소로 하려고 한다. 준규는 모든 종류의 지폐를 무한개 가지고 있다.
N과 K가 주어졌을 때, N을 만드는 지폐 개수의 최솟값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N과 K(1 ≤ N ≤ 1018, 1 ≤ K ≤ 100)가 주어진다.
<출력값>
첫째 줄에 N원을 만들 수 있는 최소 지폐의 개수를 출력한다.

<문제 1786>
워드프로세서 등을 사용하는 도중에 찾기 기능을 이용해 본 일이 있을 것이다. 이 기능을 여러분이 실제로 구현해 보도록 하자.
두 개의 문자열 P와 T에 대해, 문자열 P가 문자열 T 중간에 몇 번, 어느 위치에서 나타나는지 알아내는 문제를 '문자열 매칭'이라고 한다. 워드프로세서의 찾기 기능은 이 문자열 매칭 문제를 풀어주는 기능이라고 할 수 있다. 이때의 P는 패턴이라고 부르고 T는 텍스트라고 부른다.
편의상 T의 길이를 n, P의 길이를 m이라고 하자. 일반적으로, n ≥ m이라고 가정해도 무리가 없다.  n<m이면 어차피 P는 T중간에 나타날 수 없기 때문이다. 또, T의 i번째 문자를 T[i]라고 표현하도록 하자. 그러면 물론, P의 i번째 문자는 P[i]라고 표현된다.

      1 2 3 4 5 6 7 8 9 …
T : [ A B C D A B C D A B D E ]
      | | | | | | X
P : [ A B C D A B D ]
      1 2 3 4 5 6 7
문자열 P가 문자열 T 중간에 나타난다는 것, 즉 문자열 P가 문자열 T와 매칭을 이룬다는 것이 어떤 것인지 위와 아래의 두 예를 통해 알아보자. 위의 예에서 P는, T의 1번 문자에서 시작하는 매칭에 실패했다. T의 7번 문자 T[7]과, P의 7번 문자 P[7]이 서로 다르기 때문이다.
그러나 아래의 예에서 P는, T의 5번 문자에서 시작하는 매칭에 성공했다. T의 5～11번 문자와 P의 1～7번 문자가 서로 하나씩 대응되기 때문이다.

      1 2 3 4 5 6 7 8 9 …
T : [ A B C D A B C D A B D E ]
              | | | | | | |
P :         [ A B C D A B D ]
              1 2 3 4 5 6 7
가장 단순한 방법으로, 존재하는 모든 매칭을 확인한다면, 시간복잡도가 어떻게 될까? T의 1번 문자에서 시작하는 매칭이 가능한지 알아보기 위해서, T의 1～m번 문자와 P의 1～m번 문자를 비교한다면 최대 m번의 연산이 필요하다. 이 비교들이 끝난 후, T의 2번 문자에서 시작하는 매칭이 가능한지 알아보기 위해서, T의 2～m+1번 문자와 P의 1～m번 문자를 비교한다면 다시 최대 m번의 연산이 수행된다. 매칭은 T의 n-m+1번 문자에서까지 시작할 수 있으므로, 이러한 방식으로 진행한다면 O( (n-m+1) × m ) = O(nm) 의 시간복잡도를 갖는 알고리즘이 된다.
더 좋은 방법은 없을까? 물론 있다. 위에 제시된 예에서, T[7] ≠ P[7] 이므로 T의 1번 문자에서 시작하는 매칭이 실패임을 알게 된 순간으로 돌아가자. 이때 우리는 매칭이 실패라는 사실에서, T[7] ≠ P[7] 라는 정보만을 얻은 것이 아니다. 오히려 i=1…6에 대해 T[i] = P[i] 라고 하는 귀중한 정보를 얻지 않았는가? 이 정보를 십분 활용하면, O(n)의 시간복잡도 내에 문자열 매칭 문제를 풀어내는 알고리즘을 설계할 수 있다.
P 내부에 존재하는 문자열의 반복에 주목하자. P에서 1, 2번 문자 A, B는 5, 6번 문자로 반복되어 나타난다. 또, T의 1번 문자에서 시작하는 매칭이 7번 문자에서야 실패했으므로 T의 5, 6번 문자도 A, B이다.
따라서 T의 1번 문자에서 시작하는 매칭이 실패한 이후, 그 다음으로 가능한 매칭은 T의 5번 문자에서 시작하는 매칭임을 알 수 있다! 더불어, T의 5～6번 문자는 P의 1～2번 문자와 비교하지 않아도, 서로 같다는 것을 이미 알고 있다! 그러므로 이제는 T의 7번 문자와 P의 3번 문자부터 비교해 나가면 된다.
이제 이 방법을 일반화 해 보자. T의 i번 문자에서 시작하는 매칭을 검사하던 중 T[i+j-1] ≠ P[j]임을 발견했다고 하자. 이렇게 P의 j번 문자에서 매칭이 실패한 경우, P[1…k] = P[j-k…j-1]을 만족하는 최대의 k(≠j-1)에 대해 T의 i+j-1번 문자와 P의 k+1번 문자부터 비교를 계속해 나가면 된다.
이 최대의 k를 j에 대한 함수라고 생각하고, 1～m까지의 각 j값에 대해 최대의 k를 미리 계산해 놓으면 편리할 것이다. 이를 전처리 과정이라고 부르며, O(m)에 완료할 수 있다.
이러한 원리를 이용하여, T와 P가 주어졌을 때, 문자열 매칭 문제를 해결하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 문자열 T가, 둘째 줄에 문자열 P가 주어진다. T와 P의 길이 n, m은 1이상 100만 이하이고, 알파벳 대소문자와 공백으로만 이루어져 있다.
<출력값>
첫째 줄에, T 중간에 P가 몇 번 나타나는지를 나타내는 음이 아닌 정수를 출력한다. 둘째 줄에는 P가 나타나는 위치를 차례대로 공백으로 구분해 출력한다. 예컨대, T의 i～i+m-1번 문자와 P의 1～m번 문자가 차례로 일치한다면, i를 출력하는 식이다.

<문제 1787>
알파벳 소문자들로만 이루어진 문자열을 생각하자. 이런 문자열을 읽어 나가다 보면, 문자열의 주기가 예측되는 순간이 있다. 다음과 같은 문자열을 예로 들어 보자.
a b a b a b a
이 문자열을 네 번째 문자까지의 문자열 'a b a b'와, 그 뒤에 남은 'a b a'로 나누어 생각해 볼 수 있다. 이렇게 하면 뒤쪽 문자열은 앞쪽 네 개의 문자 중 세 번째 문자까지가 반복되다가 끝나는 꼴이다.
a b a b a b a
또한, 여섯 번째 문자까지의 문자열 'a b a b a b'와, 그 뒤에 남은 'a'로 나누어서 생각할 수도 있다. 이 경우에도 뒤쪽 문자열은 앞쪽 문자열이 반복되다가 끝나는 꼴이다.
즉, 예시된 문자열은 'a b a b'혹은, 'a b a b a b'가 반복되는 문자열의 일부라고 예상할 수 있는 것이다. 단, 이러한 추정에서 뒤쪽 문자열이 앞쪽 문자열보다 길면 안 된다. 예를 들어 'a b'는 이 문자열의 주기로 예측하기에는 너무 짧다.
이제는 어떤 문자열 S에 대해, 첫 번째 문자부터, i번째 문자까지로 이루어진 부분 문자열 Si를 생각해 보자. 모든  각각에 대해, 위에 예시된 것처럼 문자열의 주기를 추정할 수 있다. 우리가 관심 있는 것은 이렇게  각각에 Si대해 추정할 수 있는 주기 중 가장 긴 것의 길이이다. 이를 Pi라고 하자. 예시된 문자열에서 P7은 4와 6 중 최댓값인 6이 된다.
길이가 n인 문자열 S가 주어졌을 때, P1+P2+...+Pn을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 문자열 S의 길이 n이 주어진다. (1<=n<=1,000,000) 둘째 줄에 문자열 S가 공백 없이 주어진다.
<출력값>
첫째 줄에, P1+P2+...+Pn의 값을 출력한다.

<문제 1788>
수학에서, 피보나치 수는 위의 점화식과 같이 귀납적으로 정의되는 수열이다. 위의 식에서도 알 수 있듯이, 피보나치 수 F(n)은 0 이상의 n에 대해서만 정의된다.
하지만 피보나치 수 F(n)을 n이 음수인 경우로도 확장시킬 수 있다. 위의 식에서 n>1인 경우에만 성립하는 F(n)=F(n-1)+F(n-2)를 n<=1일 때도 성립되도록 정의하는 것이다. 예를 들어 n=1일 때 F(1)=F(0)+F(-1)이 성립되어야 하므로, F(-1)은 1이 되어야 한다.
n이 주어졌을 때, 피보나치 수 F(n)을 구하는 프로그램을 작성하시오. n은 음수로 주어질 수도 있다.
<입력값>
첫째 줄에 n이 주어진다. n은 절댓값이 1,000,000을 넘지 않는 정수이다.
<출력값>
첫째 줄에 F(n)이 양수이면 1, 0이면 0, 음수이면 -1을 출력한다. 둘째 줄에는 F(n)의 절댓값을 출력한다. 이 수가 충분히 커질 수 있으므로, 절댓값을 1,000,000,000으로 나눈 나머지를 출력한다.

<문제 1789>
서로 다른 N개의 자연수의 합이 S라고 한다. S를 알 때, 자연수 N의 최댓값은 얼마일까?
<입력값>
첫째 줄에 자연수 S(1 ≤ S ≤ 4,294,967,295)가 주어진다.
<출력값>
첫째 줄에 자연수 N의 최댓값을 출력한다.

<문제 1790>
1부터 N까지의 수를 이어서 쓰면 다음과 같이 새로운 하나의 수를 얻을 수 있다.

1234567891011121314151617181920212223...

이렇게 만들어진 새로운 수에서, 앞에서 k번째 자리 숫자가 어떤 숫자인지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N(1 ≤ N ≤ 100,000,000)과,  k(1 ≤ k ≤ 1,000,000,000)가 주어진다. N과 k 사이에는 공백이 하나 이상 있다.
<출력값>
첫째 줄에 앞에서 k번째 자리 숫자를 출력한다. 수의 길이가 k보다 작아서 k번째 자리 숫자가 없는 경우는 -1을 출력한다.

<문제 1791>
Due to the increasing number of weird viruses spreading around, all the members of the International Confederation of Revolver Enthusiasts (ICORE) are required by their boss to do quarterly physical checkups at General Hospital. All checkups are arranged by the boss and scheduled on the same day. Each member of ICORE gets instructions where they are given

their number from the set {1 ... n}
the time of the day when they are supposed to show up at General Hospital
a list of doctors' offices that they are to visit in the listed order.

Doctors' offices in General Hospital are numbered with numbers from the set {1 ... m}.
All the members of ICORE have been convinced that the schedule of the checkups has been professionally prepared and that there would be no lining up and waiting at the doctors' doors. However, since their boss was a political appointment their hopes for not wasting time had to be abandoned as soon as they started arriving at the hospital. The queues were forming rapidly despite the fact that the doctors were very efficient due to their usual sloppiness. The members of ICORE are all very disciplined and obey the following rules for visiting the doctors

if an ICORE member was supposed to show up at the hospital at time t, then at time t they show up at the first doctors' office on their list;
if several people show up a doctor's office at time t then they form a queue in increasing order of their numbers and join the end of the queue already formed by people who arrived earlier;
if at time t in front of office x there is a queue of people who arrived earlier or at time t, then the first person from the queue enters office x. This person after a time unit (the doctors do a sloppy job, remember) exits the office and at time t+1 appears at the next office from their list of offices to visit. At that time the first person from the queue enters office x;
if a visit at office x at time t was for the given visitor the last visit on their list, then at time t+1 this visitor leaves the hospital.

Your task is to find the time when the last visitor leaves the hospital.
<입력값>
The first line of input contains a natural number c giving the number of cases to handle. The following lines form the input for the c cases, each in the format described below. The first line of data for a case contains two natural numbers n and m, 1 ≤ n, m ≤ 1000, giving the number of the visitors and the number of doctors' offices for the case. Each of the following n lines contains a sequence of natural numbers. Among these lines, line i (1  ≤ i ≤ n) has the following format
t  k  g1  g2... gk
meaning that the ith visitor arrives at time t and has to visit k offices in the order given by g1 g2 ... gk where each gj is a number of doctor's office, 1 ≤ gj ≤ m. We have that 0 ≤ t ≤ 1000000 and there is no more than 1000000 visits scheduled for a day at the hospital.
<출력값>
For each of the c input cases print one line giving the time when the last visitor leaves the hospital.

<문제 1792>
세 개의 정수 a, b, d가 주어지면, 다음의 세 조건을 만족하는 자연수 순서쌍 (x, y)의 개수를 구하는 프로그램을 작성하시오.

1 ≤ x ≤ a
1 ≤ y ≤ b
x와 y의 최대공약수는 d이다.
<입력값>
여러 개의 문제가 하나의 입력파일 내에 주어진다. 첫째 줄에 문제의 개수 n이 주어진다. 각각의 문제는 세 개의 정수 a, b, d로 이루어져 있다. 둘째 줄부터 한 줄에 한 문제씩, 문제를 나타내는 세 정수 a, b, d가 주어진다. n과 각각의 a, b, d는 모두 50,000 이하의 자연수이며, d는 a, b 이하이다.
<출력값>
각 문제의 답을 한 줄에 하나씩 출력하도록 한다.

<문제 1793>
2×n 직사각형을 2×1과 2×2 타일로 채우는 방법의 수를 구하는 프로그램을 작성하시오.
아래 그림은 2×17 직사각형을 채운 한가지 예이다.
<입력값>
입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스는 한 줄로 이루어져 있으며, 숫자 0 ≤ n ≤ 250이 주어진다.
<출력값>
입력으로 주어지는 각각의 n마다, 2×n 직사각형을 채우는 방법의 수를 출력한다.

<문제 1795>
얼마 전 대통령 선거를 한 월드나라는 선거 조작 의혹으로 12개의 소국가로 나누어졌다.

제1국. Noisulagem, 최백준에 의해 세워진 국가로 월드를 전혀 계승하고 있지 않다.
제2국. WonderGirls, 소희의 남자친구인 신동혁에 의해 세워진 국가다. 5명의 여왕과 1명의 왕이 존재하는 왕족국가이다.
제3국. SoSiNine, 양항승이 소녀시대 9명을 모두 납치해서 만든, 양항승 국왕에 의해 통치되는 국가이다. 효연을 제외한 나머지 멤버는 지하감옥에 갇혀 죽음만 기다리는 삶을 살고 있고, 효연은 양항승의 부인으로 살고 있다.
제4국. ODuck^2, 오직 오타쿠를 위한 국가이다. 이 나라의 비자를 받으려면 미연시 오타쿠 테스트와 일본애니 테스트에서 모두 만점을 받아야 한다. 사용하는 언어는 일본어이다. おたく ふぃえちん。
제5국. SocWorld, 월드에서 위닝을 하던 사람들이 만든 국가로, 해외 축구리그를 좋아한다. 현재 축구리그의 활성화방안이 국가 제1정책이며, 해외 리그의 여러 선수를 막강한 오세준의 자금으로 사들이려고 한다. 위닝 개발자가 이 나라에 납치되어 있다.
제6국. AntiSJ, 오세준을 라이벌로 생각하는 성혁화가 세운 국가이다. 가위바위보를 할 때 이기지도 않았으면서 먼저 좋아하고 보는 사람만이 비자를 받을 수 있다.
제7국. 허경영공화국, 허경영이 암살당한 직후 그 뒤를 이은 오민식이 세운 국가이다. 현재 허경영을 국가 원수로 하는 북한식 국가이고, 새마을 운동을 매일 아침 해야 한다. 결혼을 하면 1억 원을 주고, 아이를 낳으면 5천만 원을 주는 등 돈을 뿌리는 국가로, 현재 인플레이션이 진행중이며, 화장실에서 돈을 휴지 대신 쓰고 있다.
제8국. 김치국, 오직 김치만 먹는 나라. 설명이 필요 없다.
제9국. HHComeOn, 이정문에 의해 세워진 국가로 힙합이 난무한다.
제10국. FTZ, 판타지 소설을 매일 읽어야 한다. 학교에서 판타지 소설을 읽지 않으면 맞는다. 수능시험에서 박종현이 만족할 만한 판타지 소설을 써야 판타지 대학교에 입학할 수 있다.
제11국. EZ2DJ, 오직 건반게임만을 할 수 있다. 스타를 하면 사형. 악덕 국왕 임현수에 의해 많은 사람들이 죽고 있다. 매일 밤 자신과 EZ2DJ를 대결할 사람을 구한 뒤, 자신보다 잘하지 못하면 그 자리에서 처형하는 나라로 유명하다. 매일 1명씩 사라지기 때문에 다른 나라에서 납치를 해 온다.
제12국. 테디, 듣보잡.

서로 독자적으로 잘 살고 있던 월드는 오영식의 침략을 받게 되었다. 오영식은 월드를 점령할 목적으로 레이스, 배틀크루저, 발키리, 사이언스 베슬, 마린, 파이어뱃, 고스트, 메딕, SCV를 포함한 130부대를 데리고 오기 시작했다.
여러 국가의 상위 지도계층들은 서로 긴급 회의를 하려고 한다. 월드는 체스판처럼 이루어져 있다. 지도계층들은 교통수단인 마알을 타고 간다. 마알은 1-마알부터 9-마알 까지 있다. 1-마알은 체스판의 나이트처럼 움직일 수 있으며, K-마알은 한 번에 나이트처럼 K번까지 연속으로 움직일 수 있다.
체스판의 모습과 각각의 K-마알의 위치가 주어졌을 때, 서로 한 곳에 모일 수 있는 최소 이동 횟수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 체스판의 세로 크기 N, 가로 크기 M이 주어진다. N과 M은 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 체스판의 정보가 주어진다. 체스판은 .과 1-9 숫자로만 이루어져있다. "."은 빈 칸이고, 숫자 K는 해당 위치에 K-마알이 놓여 있음을 의미한다.
<출력값>
모든 마알의 이동 횟수의 합의 최솟값을 출력한다. 한 곳에 모일 수 없다면, -1을 출력한다.

<문제 1796>
동혁이의 키보드에는 버튼 세 개와 LCD창 한 개가 달려 있다. LCD창에는 문자열 S가 쓰여 있다. 그리고 커서는 문자열의 가장 왼쪽 글자에 위치해 있다. 버튼 세 개는 왼쪽, 오른쪽, 엔터키이다.
왼쪽 키는 만약 현재 커서에서 왼쪽으로 더 갈 수 있으면, 왼쪽으로 커서를 한 칸 이동시키는 역할을 하고, 오른쪽 키도 현재 커서에서 오른쪽으로 갈 수 있으면 오른쪽으로 커서를 한 칸 이동시키는 역할을 한다. LCD창의 크기는 정확하게 문자열 S의 크기와 같다. 그리고 커서는 절대로 LCD창을 벗어나지 않는다. 엔터키는 문자열을 컴퓨터에 전송해서 컴퓨터 화면에 출력하는 역할을 한다. 문자열이 화면에 출력되면, 그 문자는 빈 칸으로 변한다.
동혁이는 LCD창에 쓰여 있는 문자열을 컴퓨터 화면에 알파벳 순서대로 쓰려고 한다. 동혁이는 완벽주의자이기 때문에, 문자열 S에 있는 모든 문자를 하나도 빠짐없이 출력하려고 한다. 만약 a가 LCD창에 3개가 있으면 컴퓨터 화면에는 a가 3번 나와야 한다. 
LCD창에 쓰여 있는 문자열이 주어질 때, 그 문자열을 알파벳 순서대로 출력할 때, 키의 입력을 최소화하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 LCD창에 쓰여 있는 문자열 S가 주어진다. 문자열 S는 길이가 1,000보다 작다. 문자열 S는 알파벳 소문자로만 이루어져 있다.
<출력값>
동혁이의 신기한 키보드로 문자열 S에 쓰여 있는 문자를 알파벳 순서대로 출력하고자 할 때, 키를 누르는 횟수의 최솟값을 출력하시오.

<문제 1797>
소시갤 회장 항승이는 클럽에 회원들을 모아놓고 함께 소녀시대 춤을 추고 난 뒤 팬들에게 소녀시대 춤에서 마지막 부분에 나오는 멤버들이 한 줄로 모이는 부분을 안무 해주고 있었다.
안무를 하던 중 항승이는 한 줄로 선 상태에서 이들 중 연속된 사람들을 그룹 지었을 때, 이 그룹에 속한 남녀의 수가 같은 그룹이 가장 보기 좋다는 것을 알았다.
그래서 항승이는 팬들이 한 줄로 섰을 때 위의 조건을 만족하는 그룹 중 가장 길이가 긴 그룹을 찾고자 한다. 가장 길이가 길다는 의미는 그룹에서 x좌표가 가장 작은 사람과 큰 사람의 차이가 가장 크다는 것이다. 우리는 이런 항승이를 도와주자.
<입력값>
첫째 줄에는 한 줄로 선 팬들의 수 N(1 ≤ N ≤ 1,000,000)이 주어진다. 그 다음 N개의 줄에는 남녀의 성별을 나타내는 수(남자는 0, 여자는 1)와 이들이 서있는 x좌표가 공백으로 구분되어 주어진다. x좌표는 0 이상 1,000,000,000 이하이다. 각 성별의 팬은 최소 1명 이상 존재하고, 같은 x좌표에 서 있는 팬은 없다.
<출력값>
조건을 만족하는 그룹 중 가장 긴 그룹의 길이를 출력한다.

<문제 1798>
원뿔 하나가 평면 z=0에 반지름 r인 밑면을 두고 놓여 있다. 밑면의 중심은 (0,0,0) 이며, 원뿔의 꼭대기는 (0,0,h)에 위치해 있다. 즉, 원뿔의 높이는 h이다.
원뿔상의 점의 위치는 원뿔좌표계에서 다음과 같이 표현된다.
p = (d,A)
이때 d는 원뿔의 꼭대기(0,0,h)로부터의 거리이고,
A는 평면 y=0과 세 점 p, (0,0,0), (0,0,h)를 지나는 평면, 이렇게 두 평면 사이의 각도를 x축의 방향을 기준으로 시계 반대 방향으로 잰 각도이다. (A<360)
이때, 점은 항상 원뿔 위에 있으므로 d는 3차원 좌표계에서의 (0,0,h)와 p의 최단거리와 같다.
원뿔좌표계로 나타낸 원뿔 위의 두 점 p1 = (d1, A1) , p2 = (d2, A2) 가 주어진다.
이때, 한 점에서 출발하여 원뿔상의 곡면만을 통해 다른 점까지 도달하는 최단거리는 얼마인가?
<입력값>
입력은 여러 테스트 케이스로 이루어져 있다.
각각의 입력 한 줄에 6개의 실수 r, h, d1, A1, d2, A2가 주어진다.
<출력값>
각각의 입력마다 두 점간의 원뿔 상의 최단거리를 소수 둘째 자리까지 반올림하여 한 줄에 출력한다.

<문제 1799>
서양 장기인 체스에는 대각선 방향으로 움직일 수 있는 비숍(bishop)이 있다. <그림 1>과 같은 정사각형 체스판 위에 B라고 표시된 곳에 비숍이 있을 때 비숍은 대각선 방향으로 움직여 O로 표시된 칸에 있는 다른 말을 잡을 수 있다.

그런데 체스판 위에는 비숍이 놓일 수 없는 곳이 있다. <그림 2>에서 체스판에 색칠된 부분은 비숍이 놓일 수 없다고 하자. 이와 같은 체스판에 서로가 서로를 잡을 수 없도록 하면서 비숍을 놓는다면 <그림 3>과 같이 최대 7개의 비숍을 놓을 수 있다.  색칠된 부분에는 비숍이 놓일 수 없지만 지나갈 수는 있다.

정사각형 체스판의 한 변에 놓인 칸의 개수를 체스판의 크기라고 한다. 체스판의 크기와 체스판 각 칸에 비숍을 놓을 수 있는지 없는지에 대한 정보가 주어질 때, 서로가 서로를 잡을 수 없는 위치에 놓을 수 있는 비숍의 최대 개수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 체스판의 크기가 주어진다. 체스판의 크기는 10이하의 자연수이다. 둘째 줄부터 아래의 예와 같이 체스판의 각 칸에 비숍을 놓을 수 있는지 없는지에 대한 정보가 체스판 한 줄 단위로 한 줄씩 주어진다. 비숍을 놓을 수 있는 곳에는 1, 비숍을 놓을 수 없는 곳에는 0이 빈칸을 사이에 두고 주어진다.
<출력값>
첫째 줄에 주어진 체스판 위에 놓을 수 있는 비숍의 최대 개수를 출력한다.

<문제 1800>
오늘 팀전을 다들 열심히 하시는 것을 보고 원장선생님은 세미나 실에 인터넷을 설치해 주기로 마음을 먹으셨다. 하지만 비 협조적인 코레스코 콘도는 원장님께서 학생들에게 인터넷 선을 연결하는 것에 대해서 일부에 대해 돈을 요구하였다.
각각의 학생들의 번호가 1부터 N까지 붙여져 있다고 하면 아무나 서로 인터넷 선이 연결되어 있지 않다. P(P<=10,000)개의 쌍만이 서로 이어 질수 있으며 서로 선을 연결하는데 가격이 다르다.
1번은 다행히 인터넷 서버와 바로 연결되어 있어 인터넷이 가능하다. 우리의 목표는 N번 컴퓨터가 인터넷에 연결하는 것이다. 나머지 컴퓨터는 연결 되어 있거나 연결 안되어 있어도 무방하다.
하지만 코레스코에서는 K개의 인터넷 선에 대해서는 공짜로 연결해주기로 하였다. 그리고 나머지 인터넷 선에 대해서는 남은 것 중 제일 가격이 비싼 것에 대해서만 가격을 받기로 하였다. 이때 원장선생님이 내게 되는 최소의 값을 구하여라.
<입력값>
첫 번째 줄에 N(1 ≤ N ≤ 1,000), 케이블선의 개수 P(1 ≤ P ≤ 10,000), 공짜로 제공하는 케이블선의 개수 K(0 ≤ K < N)이 주어진다. 다음 P개의 줄에는 케이블이 연결하는 두 컴퓨터 번호와 그 가격이 차례로 들어온다. 가격은 1 이상 1,000,000 이하다.
<출력값>
첫째 줄에 원장선생님이 내게 되는 최소의 돈을 출력한다. 만약 1번과 N번 컴퓨터를 잇는 것이 불가능 하다면 -1을 출력한다.

<문제 1801>
막대 N개를 가지고 있다. 이 막대를 이용해 만들 수 있는 가장 큰 직사각형의 넓이를 구하는 프로그램을 작성하시오.
막대는 이어 붙일 수 있고, 조각낼 수는 없다. 예를 들어, 길이가 2인 막대와 3인 막대를 합쳐 5인 막대를 만들 수 있다.
예를 들어, 가지고 있는 막대의 길이가 1, 3, 3, 4, 5, 7라면, 3 두 개와 5, 그리고 1과 4를 붙여 5를 만들면 3*5 크기의 직사각형을 만들 수 있다.
<입력값>
첫째 줄에 막대의 개수 N이 주어진다. N은 4보다 크거나 같고, 16보다 작거나 같은 자연수이다.
둘째 줄에 막대의 길이가 공백을 사이에 두고 주어진다. 막대의 길이는 10보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 만들 수 있는 가장 큰 직사각형의 넓이를 출력한다. 만약 주어진 막대를 이용해서 직사각형을 만들 수 없으면 -1을 출력한다.

<문제 1802>
동호는 종이를 접는데 옆에서 보고 접으려고 한다. 옆에서 본다는 말은 아래 그림과 같이 본다는 뜻이다. 동호는 종이를 반으로 접을 때, 아래와 같이 두가지중 하나로만 접을 수 있다.

오른쪽 반을 반시계 방향으로 접어서 왼쪽 반의 위로 접는다.
오른쪽 반을 시계 방향으로 접어서 왼쪽 반의 아래로 접는다.

아래의 그림은 위의 설명을 그림으로 옮긴 것이다.

한 번의 종이 접기가 끝났을 때, 동호는 종이 접기를 원하는 만큼 더 할 수 있다. 종이 접기를 한번 접을 때 마다 두께는 2배가 되고 길이는 절반이 될 것이다.

종이 접기를 여러 번 했을 때 (안접을 수도 있다), 동호는 종이를 다시 피기로 했다. 그러고 나서 다시 접고 이렇게 놀고 있었다. 옆에서 보고 있던 원룡이는 동호를 위해 종이를 접어서 주기로 했다.(원룡이는 동호의 규칙대로 접지 않는다.) 동호는 그리고 나서 원룡이가 접었다 핀 종이를 다시 동호의 규칙대로 접을 수 있는지 궁금해졌다.
위의 저 종이를 접었다 피면 다음과 같은 그림처럼 펴진다.

종이가 시계방향으로 꺽여있으면 OUT이고, 반시계방향으로 꺾여있으면 IN이다.
종이가 접혀있는 정보가 왼쪽부터 오른쪽까지 차례대로 주어졌을 때, 이 종이를 동호의 규칙대로 접을 수 있는지 없는지를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 테스트 케이스의 개수 T가 주어진다. T는 1000보다 작거나 같은 자연수이다. 둘째 줄부터 T개의 줄에 각각의 종이가 어떻게 접혀있는지가 주어진다. 종이의 정보는 문자열로 주어지며, 1은 위의 그림에서 OUT을 의미하고 0은 위의 그림에서 IN을 의미한다. 예를 들어, 위의 그림과 같은 모양은 100으로 나타낼 수 있다. 문자열의 길이는 3000보다 작으며, 항상 2^N-1꼴이다. (N>=1)
<출력값>
T개의 줄에 차례대로 각각의 종이를 동호의 방법대로 다시 접을 수 있으면 YES를, 접을 수 없으면 NO를 출력한다.

<문제 1803>
학생들은 몸이 약해지지 않도록 무술을 연마한다. 그 중에 대표적인 것으로 활쏘기 연습을 꼽을 수 있다. 한 가지 특이한 점은, 이 활쏘기 연습에 특별한 과녁이 동원되지 않는다는 것이다. 대신, 여러분의 동료가 과녁이 된다!
학생들은 두 줄로 길게 늘어서 있다. 그리고 각 학생들은 반대편 줄 쪽에 서 있는 친구 중 한 명을 바라보고 있다. 다소 충격적일 수는 있지만, 활시위를 당길 준비를 하고 있는 것이다.
그러나 연습은 어디까지나 연습일 뿐이므로, 중간에 다치는 사람이 있어서는 안 된다. 따라서 학생들 중 몇몇은 활 대신 방패를 들어야만 한다. 나머지 학생들을 예정대로 활을 든다. 활쏘기 연습을 위해서.
두 줄로 늘어선 학생들이, 각각 반대편의 어떤 학생을 바라보고 있는지 주어질 때, 각 학생들이 활을 들어야 하는지 혹은 방패를 들어야 하는지를 알아내는 프로그램을 작성하시오.
단, 쓸데없이 방패를 드는 학생이 있어서는 안 된다. 즉 방패를 드는 학생은, 반드시 활을 든 반대편의 학생 중 한 명으로부터 조준당하고 있어야 한다.
<입력값>
첫째 줄에 두 자연수 m, n이 주어진다. (1<=m, n<=50,000) 한쪽 줄에 m명의 학생이, 반대편 줄에 n명의 학생이 서 있다는 의미이다.
학생들이 늘어선 두 개의 줄을 각각 A, B라고 하자. A줄에 늘어선 m 명의 학생은 1∼m까지 차례로 번호가 붙어 있고, B 줄에 늘어선 n 명의 학생은 n명의 학생은 1∼n까지 차례로 번호가 붙어 있다.
두 번째 줄에는 m개의 수가 주어지는데, k번째 수는 A줄의 k번 학생이 바라보고 있는 B줄의 학생 번호이다. 세 번째 줄에는 마찬가지의 방식으로, B줄의 각 학생이 바라보고 있는 A줄의 학생 번호가 주어진다.
<출력값>
첫째 줄에는 A줄의 각 학생들이 활을 들어야 하는지, 방패를 들어야 하는지를 하나의 문자열로 출력한다. k번째 문자가 1이면 k번 학생이 활을 들어야 한다는 의미이고, 0이면 방패를 들어야 한다는 의미이다. 둘째 줄에는 마찬가지의 방식으로, B줄의 각 학생들이 활을 들어야 하는지 방패를 들어야 하는지를 출력한다.

<문제 1804>
조교들은 회식을 끝내고 많은 음식들이 남게 됐다. 그래서 조교는 이 남은 음식물을 랩에 싸서 보관하기로 결정했다.
N개의 음식물들이 2*B 격자에 흩어져서 배치되어 있다. 그리고 랩은 오직 직사각형 모양으로만 쌀 수 있다.
우리에겐 K개의 랩이 있다. 랩은 마음대로 늘릴 수 있기 때문에 한 랩의 가로, 세로 너비 제한은 없다.



 
김치
 
 
 
회
회
족발
족발


 
라면
라면
라면
 
 
 
 
 



위와 같이 음식이 남았을 때는 김치와 라면을 2*3 모양으로 싸고, 회와 족발을 1*4 모양으로 싸면 총 랩을 싸야하는 면적이 10이 된다.
문제는 이렇게 음식들의 위치가 주어졌을 때 모든 음식을 싸기 위해 필요한 랩의 최소 면적을 구하는 것이다.
<입력값>
첫째 줄에 N(1≤N≤1,000), K(1≤K≤N), B(1≤B≤15,000,000)가 공백으로 구분되어 입력된다. 다음 N개의 줄에 음식이 있는 위치가 주어진다.
<출력값>
모든 음식을 싸기 위해 필요한 랩의 최소 면적을 출력한다.

<문제 1805>
양항승 왕국은 거의 모든 지역이 강과 숲으로 이루어져 있다. 상류의 작은 강들은 모여서 큰 강이 되며, 그 강도 다른 강과 만나 더 커져 나중에는 하류로 가면 거대한 강 하나만이 남아 양항승 왕국 근처의 바다로 흘러간다.
양항승 왕국에는 나무꾼들이 사는 n개의 마을이 강변에 있다. 그런데 현재는 목공소가 강의 최하류인 양항승 왕국에 하나만 있기 때문에, 제각기 사는 곳에서 나무를 벤 나무꾼들은 통나무를 강에다 띄워서 그 목공소로 보낸다. 그래서 항승이는  통나무를 하류로 흘려보내는 물류비용을 줄이기 위해, 마을들 중 적당한 곳에 k개의 목공소를 더 짓기로 했다. 목공소가 더 생기면, 상류에서 흘러보낸 통나무들은 왕국까지 갈 필요 없이 처음으로 거치는 목공소에서 바로 처리를 할 수 있으며, 목공소가 있는 마을에서 생산된 통나무는 강을 거칠 필요조차 없어진다.
목공소를 세울 곳을 결정하기 위해, 왕의 신하들은 각 마을별로 연간 생산되는 통나무의 양을 조사해 두었다. 강물은 하류로 갈수록 합쳐지기만 하지 갈라지지는 않기 때문에, 각 마을에서 왕국까지 가는 경로는 오직 하나만 존재한다. 마을별로 강을 이용해 이웃 마을이나 현재의 최종 목적지인 왕국까지 가는 거리에 대한 자료 역시 있다. 이것을 토대로, 전국의 나무의 물류비용을 최소화하려면 어디에 목공소를 건설하면 좋을지 결정하는 프로그램을 작성하시오. 통나무 하나를 강으로 1km 거리만치 운반하는데 드는 비용은 1로 한다. 예를 들어 통나무 2개를 5km 운반하는데 드는 비용을 계산하면 2*5=10 이다.
<입력값>
첫 줄에는 왕국을 제외한 마을의 수 n과 추가로 지으려고 하는 목공소의 수 k가 있다. (2≤n≤100, 1≤k≤50이고 k≤n) 마을들은 1부터 n까지 번호가 부여되어 있으며, 왕국의 번호는 0이다. 그 다음 각 n개의 각 줄마다 다음의 3개의 정수가 주어진다.

wi─마을 i에서 생산하는 나무의 개수
vi─마을 i에서 하류쪽으로 가면 나오는 첫 번째 마을(혹은 왕국 본토)
di─마을 i에서 마을 vi까지의 거리

총 운반비는 2000000000을 넘지 않는다.
<출력값>
목공소를 최적의 위치에다 지었을 때, 마을 전역에서 생산되는 통나무를 "적당한 목공소가 있는 곳"까지 강으로 운반하는데 드는 총 비용의 최솟값을 출력한다.

<문제 1806>
10,000 이하의 자연수로 이루어진 길이 N짜리 수열이 주어진다. 이 수열에서 연속된 수들의 부분합 중에 그 합이 S 이상이 되는 것 중, 가장 짧은 것의 길이를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N (10 ≤ N < 100,000)과 S (0 < S ≤ 100,000,000)가 주어진다. 둘째 줄에는 수열이 주어진다. 수열의 각 원소는 공백으로 구분되어져 있으며, 10,000이하의 자연수이다.
<출력값>
첫째 줄에 구하고자 하는 최소의 길이를 출력한다. 만일 그러한 합을 만드는 것이 불가능하다면 0을 출력하면 된다.

<문제 1807>
길이가 무한대인 수열 A가 있다. A[N](N ≥ 1)은 N으로 시작하는 가장 작은 4의 배수이다. A[N]의 모든 자리수를 이어 붙이면 길이가 무한대인 문자열 S를 만들 수 있다. 척 노리스는 이 수열을 두 번이나 끝까지 써보았다.
S의 K번째 숫자를 구하는 프로그램을 작성하시오.
수열은 12, 20, 32, 4, 52, 60, ... 으로 시작하게 되며, S = "12203245260..."이 된다.
<입력값>
입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스는 한 줄로 이루어져 있으며 양의 정수 K가 주어진다. (K <= 1015) 입력의 마지막 줄에는 0이 하나 주어진다.
<출력값>
각 테스트 케이스에 대해서, S의 K번째 자리수를 출력한다.

<문제 1808>
루트가 있는 트리에서, 어떤 정점 V의 레벨이 L이라는 것은, 루트와 정점 V사이의 거리가 L이라는 것을 의미한다. 정점 U가 정점 V의 부모라는 것은 정점 U와 정점 V가 서로 연결되어 있고, U의 레벨이 L-1, V의 레벨이 L인 것을 의미한다.
다솜이는 루트가 있는 트리를 다음과 같은 작업을 몇 번을 수행하려고 한다.
다솜이는 다음과 같은 작업을 숌작업이라고 이름붙였다.
숌작업은 다음과 같다.

루트가 아닌 정점 V를 선택한다.
V의 조상중 하나인 정점 U를 선택한다.
V와 V의 부모를 이은 간선을 제거한다.
U에서 V로 간선을 이은다. U는 V의 부모가 된다.

숌작업은 독특해서 한번의 작업에 가격이 있다.
가격은 두 정점의 레벨 차이 - 1이다.
예를 들어, V의 레벨이 L1이고, U의 레벨이 L2이면, 숌작업의 가격은 L1-L2-1이다.
어떤 트리의 높이가 K라는 것은, K가 레벨인 정점이 몇 개 있고, K+1인 정점이 없다는 것을 의미한다. 어떤 트리와 숌작업을 이용해서 줄이려고 하는 높이 H가 주어졌을 때, 그 트리를 H보다 작거나 같은 높이로 숌작업을 통해서 줄이는 최소 가격을 출력하는 프로그램을 작성하시오. 숌작업은 여러 번 수행해도 된다.

  예를 들어, 다음과 같은 트리가 주어졌다. 이 트리의 높이를 1보다 작거나 같게 만들려고 한다.

이 트리의 정점 2를 0의 자식으로 연결 하면,
총 비용은 2-0-1 = 1이 되고, 트리의 높이는 1이된다.
<입력값>
첫째 줄에 정점의 수 N (1<=N<=100)이 주어진다. 둘째 줄부터 총 N-1개의 줄에 트리의 간선이 주어진다. 트리의 간선에 대한 정보는 a b 와 같이 주어지며, a는 b의 부모라는 뜻이다. 트리에 주어지는 정점은 0부터 N-1이고, 트리의 루트는 항상 0이다. 그리고, 마지막줄에 줄이려고하는 높이 H가 주어진다. H는 1부터 N-1사이의 수이다.
<출력값>
첫째 줄에 트리의 높이를 H보다 작거나 같은 값으로 숌작업을 통하여 줄일 때 드는 비용의 최솟값을 출력한다.

<문제 1809>
성냥 팔이 소녀 숌은 추위에 덜덜떨며 거리에 많은 성냥을 가지고 앉아있다. 숌은 사람들이 자신의 성냥을 사지 않고 그냥 지나치기만 하자, 성냥을 이용해서 수를 만들기로 결심했다.
원룡이가 운영하는 가게에서는 성냥 몇 개를 숫자 장난감으로 바꿔준다. 모든 숫자가 있는 것은 아니고, 원룡이가 그날 좋아하는 숫자만 무한대로 가지고 있다.
만약 숫자 0으로 바꾸기 위해선 6개의 성냥이 필요하고, 숫자 1로 바꾸고 위해서는 7개의 성냥이, 숫자 2로 바꾸려면 8개의 성냥이 필요하다고 하고, 지금 숌이 성냥이 21개가 있으면, 숌이 만들 수 있는 가장 큰 수는 210(8+7+6) 이다.
숌은 현재 자기가 가지고 있는 성냥중 몇 개를 원룡이의 가게에서 숫자 장난감으로 바꾸려고 한다. 그 다음에 그 장난감을 이용해서 가장 큰 수를 만들려고 한다.
숌이 현재 가지고 있는 성냥의 개수와, 원룡이의 가게에서 숫자 장난감과 성냥의 교환 비율이 주어진다. 교환 비율이란 숫자 장난감 1개 = 성냥 x개 일 때 x를 말한다. 그 때, 숌이 만들 수 있는 가장 큰 수를 출력하는 프로그램을 작성하시오.
숌이 만드는 수는 0을 제외하고는 0으로 시작하지 않으며, 0을 만들고자 할 때는 숫자 0 장난감을 하나만 교환한다.
<입력값>
첫째 줄에 현재 원룡이의 가게에 있는 숫자의 개수 N이 주어진다. 둘째 줄부터 총 N개의 줄에 A B와 같이 두 개의 수가 주어진다. 그 의미는 A라는 숫자 장난감으로 바꾸는데 성냥 B개가 들어간다는 소리다. A는 중복되지 않게 들어오며, 0보다 크거나 같고, 9보다 작거나 같다. B는 1018보다 작거나 같은 자연수이다. 입력으로 주어지지 않는 숫자는 사용할 수 없다. 마지막 줄에는 숌이가 현재 가지고 있는 성냥의 개수가 주어진다. 성냥의 개수는 0보다 크거나 같고, 1018보다 작거나 같은 정수이다.
<출력값>
첫째 줄에 숌이가 만들 수 있는 가장 큰 수의 자리수를 출력한다. 둘째 줄에 숌이가 만들 수 있는 가장 큰 수의 처음 50자리를 출력하고, 셋째 줄에는 숌이가 만들 수 있는 가장 큰 수의 마지막 50자리를 출력한다.
만들 수 없는 경우에는 0을 출력한다.

<문제 1810>
원래 징검다리는 단순히 개울을 건너기 위해 만든 것이다. 그러나 놀이를 좋아하는 사람들은 이 징검다리 위를 달리는 경기를 하기로 하였다.
징검다리가 놓여 있는 위치는 (x, y) 순서쌍으로 표현된다. 시작점은 언제나 (0,0) 원점이다. 경기가 진행되는 동안 여러분들은 현재 위치한 징검다리와 x좌표 차이가 2 이하이고, y좌표 차이도 2 이하인 징검다리로만 점프할 수 있다. 결승선은 x축에 평행한 직선인데, 여러분이 결승선과 y좌표가 동일한 징검다리에 도달하면, 결승선을 통과한 것이므로 경기가 끝난다.
징검다리들의 위치가 주어지면, 경기에서 승리하기 위해, 가장 빠른 경로를 찾아내는 프로그램을 작성하시오. 가장 빠른 경로란, 경로를 구성하고 있는 점프들의 길이 합이 최소인 경로이다. (x1, y1)에 위치한 징검다리에서 (x2, y2)에 위치한 징검다리로의 점프는 루트((x1-x2)^2+(y1-y2)^2)의 길이를 갖는다고 정의한다.
<입력값>
첫째 줄에 징검다리의 개수 N과, 결승선의 y좌표 F가 주어진다. 둘째 줄부터는 N개의 징검다리들의 좌표가 한 줄에 하나씩 주어진다. N은 50,000 이하의 자연수이다. F나 각 좌표들은 0 이상 100만 이하의 정수이다. y좌표가 F를 초과하는 징검다리는 입력되지 않는다. (0,0)은 N개의 징검다리 중 하나로 입력되지 않지만, 여러분의 시작점임을 명심한다.
<출력값>
첫째 줄에, 가장 빠른 경로의 길이를 소수 첫째 자리에서 반올림하여, 정수로 출력하도록 한다. 불가능한 경우에는 -1을 출력한다.

<문제 1811>
Mastermind is a game played with a supply of pegs of various colours, or in the absence of proper equipment, pen and paper (or a computer!) using letters A, B, C, etc, as ‘pegs’ with the different letters representing different colours. One player chooses some particular arrangement of coloured pegs or letters and keeps it hidden. The other players attempts to guess the arrangement, guided by a score that the first player determines for each guess.
In ordinary Mastermind, the score is in two parts: a ‘black score’ counting the number of pegs that match the target peg in the same position, and a ‘white score’ that is the number of pegs that are not themselves ‘black’, but match the colour of an otherwise unmatched target peg in a different position from the guess peg.
Adjacent Mastermind adds a ‘grey score’ that is the number of pegs that do not match their corresponding target pegs but can be matched up with otherwise unmatched target pegs in the positions immediately to their left or right. (The leftmost and rightmost guess pegs of course only have one slot that is adjacent to them and that might make them grey.) The white score then becomes the number of pegs that are not themselves ‘black’ or ‘grey’, but match an otherwise unmatched target peg that is at least two positions away from the guess peg.
As in ordinary Mastermind, each target peg may only be matched by at most one guess peg, and each guess peg may only contribute to one of the scores at most once.
For example:

In guess 1, only the A in slot 1 contributes to the score, since only one peg may match the target A and this one is the best match. Similarly in guess 3 only the B in slot 3 scores, and similarly only one of the Cs in guess 4 scores. Finally in guess 5, only one of the As counts as white, because there is only one target A available.
Adjacent Mastermind is theoretically easier for the guessing player because more information is provided in response to each guess, but more difficult for the first player because the scoring is more complicated. Your task is to help the first player by calculating each guess’s score.
<입력값>
Input consists of lines containing a target arrangement and a guess arrangement, separated by a single space. Each arrangement is a string of between 2 and 50 uppercase letters, ‘A’ to ‘Z’. On each line, the guess arrangement will be of the same length as its target.
A single ‘#’ on a line by itself indicates the end of input. This line should not be processed.
<출력값>
Output will be one line for each target/guess input line, containing the guess and its score in the format ‘guess: b black, g grey, w white’.

<문제 1812>
N(3≤N≤999, N은 홀수)명의 학생들이 원 모양으로 둘러앉아 있다. 각 학생들은 모두 몇 개의 사탕(≤100,000)을 가지고 있는데 그 개수는 사람마다 다를 수 있고, 사탕을 아예 가지고 있지 않을 수도 있다. 물론 사탕의 개수는 음이 아닌 정수이다.편의상 학생들에게 번호를 매기는데, 반시계 방향으로 1번 학생, 2번 학생, …, N번 학생으로 번호를 매겼다. 1번 학생 오른쪽엔 2번 학생, 2번 학생 오른쪽엔 3번 학생이 앉아 있는 것이고, 마지막 N번 학생 오른쪽엔 1번 학생이 앉아 있게 된다.우리는 인접한 두 학생이 가지고 있는 사탕의 수의 합을 안다. 즉 1번 학생과 2번 학생이 가지고 있는 사탕의 수의 합, 2번 학생과 3번 학생이 가지고 있는 사탕의 수의 합, …, N-1번 학생과 N번 학생이 가지고 있는 사탕의 수의 합, 마지막으로 N번 학생과 1번 학생의 가지고 있는 사탕의 수의 합을 안다. 이때, 각 학생이 가지고 있는 사탕의 수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N(3≤N≤999, N은 홀수)이 주어진다. 둘째 줄부터 N개의 줄에 걸쳐 1번 학생과 2번 학생이 가지고 있는 사탕의 수의 합, 2번 학생과 3번 학생이 가지고 있는 사탕의 수의 합, …, N-1번 학생과 N번 학생이 가지고 있는 사탕의 수의 합, 마지막으로 N번 학생과 1번 학생의 가지고 있는 사탕의 수의 합이 순서대로 주어진다.
<출력값>
첫째 줄부터 N개의 줄에 걸쳐 1번 학생이 가지고 있는 사탕의 수, 2번 학생이 가지고 있는 사탕의 수, …, N번 학생이 가지고 있는 사탕의 수를 순서대로 출력한다. 출력하는 수는 음이 아닌 정수들이어야 하며, 항상 답이 존재하는 경우만이 입력으로 주어진다고 가정해도 좋다.

<문제 1813>
논리학 박사 양항승은 죽기 전에 칠판에 다음과 같은 말을 쓰고 죽었다.

(칠판시작)
정확하게 a개의 말은 참이다.
정확하게 b개의 말은 참이다.
정확하게 c개의 말은 참이다.
...
...
...
(칠판끝)

a, b, c는 수이다. 그리고 나서 항승이는 칠판에 쓰여 있는 말 중에 총 몇 개가 참인지 알아내는 사람에게 자신의 재산을 물려주기로 했다.
입력으로 항승이가 쓴 말 중 수만 주어진다. 예를 들면 정확하게 i개의 말은 참이다 일 때, i가 입력으로 들어오는 것이다.
항승이의 마지막 말이 주어졌을 때, 총 몇 개의 말이 참인지 개수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 항승이가 한 말의 개수 N이 주어진다. N은 1보다 크거나 같고, 100,000보다 작거나 같은 자연수이다. 둘째 줄에 항승이가 한 말에 등장하는 정수가 주어진다. 항승이가 말한 수는 100,000보다 작거나 같은 음이 아닌 정수이다.
<출력값>
첫째 줄에 항승이가 한 말 중 몇 개가 참인지 출력한다. 만약 항승이가 한 말이 모순이라면 -1을 출력한다. 만약 가능한 답이 여러개이면 가장 큰 값을 출력한다.

<문제 1814>
N개의 집들로 이루어진 작은 마을이 있다. 이 마을의 몇몇 집들 사이에는 길이 나 있는데, 이 길들을 잘 이용하면 임의의 집에서 출발하여 어느 집으로든 이동할 수 있다. 그러나 출발했던 집으로 되돌아오려 할 때, 이미 방문했던 집들 중 일부를 다시 방문하지 않고서는 방법이 없다.이 마을을 새로 단장하면서 각 집들의 지붕을 색칠하기로 했는데, 서로를 연결하는 길을 사이에 두고 있는 두 개의 집은 다른 색깔의 지붕을 갖도록 하려 한다.집들 사이에 나 있는 길들의 정보와, 색깔별로 페인트들의 가격이 주어졌을 때, 조건을 만족하면서 집들의 지붕을 색칠하기 위한 최소 비용을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에, 마을 내의 집들의 수 N이 주어진다. (1<=N<=10,000) 이후 N-1개의 줄에, 집들을 잇는 길의 정보가 하나씩 주어진다. 각 줄은 1이상 N이하 범위에 있는, 서로 다른 두 자연수 A, B로 구성되는데, A번 집과 B번 집 사이에 길이 나 있다는 의미이다.
  N+1번째 줄에는, 페인트 종류의 수 M이 주어진다. (1<=M<=10,000) N+2번째 줄에 주어지는 M개의 자연수는, 각 페인트별로 한 집의 지붕을 칠하기 위한 비용이다. 이들은 모두 10,000 이하이다.
<출력값>
첫째 줄에, 지붕의 색칠을 위한 최소 비용을 출력한다.

<문제 1815>
월드 방송국에서 유선으로 방송을 하고자 한다. 방송망의 형태는 방송국이 루트인 트리의 형태가 될 것이다. 트리의 터미널 노드들은 사용자를 의미하며 트리에서 터미널을 제외한 노드는 송신기 역할을 하게 된다. (루트는 방송국이면서 송신기이며, 루트와 터미널이 아닌 노드들은 중간 송신기라고 불려진다) 

한 노드에서 다른 노드로 방송 라인을 설치할 때 드는 비용이 주어진다. 총 방송 비용이란 설치한 방송 라인의 비용을 모두 더한 값이다.

같은 방송망에 있지만 각각의 사용자가 내는 돈은 다를 수 있으며 각각 사용자가 방송을 보게 될 때 지불할 돈이 미리 주어진다.

방송국에서는 방송 라인을 하나 설치할 때 지출을 하게 된다. 또한 방송망이 방송국에서 사용자까지 도달되면 방송국은 그 사용자에게서 시청료를 받게 된다.

방송라인을 적절히 설치해서 방송국이 손해를 보지 않으면서 방송을 해줄 수 있는 최대 사용자는 몇 명인가? (손해를 보지 않는다는 말은 총 시청료 - 총 방송 비용 ≥ 0 임을 의미한다)
<입력값>
첫 줄에 N M이 입력된다. (2 ≤ N ≤ 3,000, 1 ≤ M ≤ N-1)
N은 트리의 노드 개수이고 M은 트리의 터미널 노드 개수이다.
노드의 번호는 트리의 루트가 1이며, 루트가 아닌 다른 송신기들은 2부터 N-M까지, 사용자들(터미널노드들)의 번호는 N-M+1부터 N까지 이다.
두 번째 줄부터 N-M개의 줄에 다음과 같은 형식으로 송신기 정보가 주어진다.
K A1 C1 A2 C2 ... Ak Ck
K는 그 송신기가 송신하는 노드의 개수이며 A는 그 노드의 이름 C는 그 비용을 의미한다.
그 이후의 M개의 라인에는 M명의 사용자의 시청료가 각각 입력된다.
<출력값>
최대 사용자 수를 출력한다.

<문제 1816>
현대 사회에서 통용되고 있는 많은 종류의 암호 시스템에서는, 매우 큰 소수의 곱으로 만들어진 수를 암호 키로 이용하는 경우가 많다. 현실적으로 매우 큰 수를 빠른 시간 내에 소인수분해하는 것은 어려운 일이기 때문이다.
물론 실제 생활에서는 수십만 또는 수백만 자리 이상의 매우 큰 소수가 활용되지만 그러한 소수를 구하는 것은 매우 어려운 일이므로, 우리는 좀 더 스케일이 작은 경우에 대해서만 생각해 보기로 하자. 1,000,000=10^6보다 큰 소수이면 매우 큰 소수로 생각하는 것이다.
어떤 수 S ( 10^12 ≤ S ≤ 10^18 ) 가 주어지면, 이 수가 우리가 생각하는 스케일이 작은 경우에서 적절한 암호 키인지 아닌지를 구하는 프로그램을 작성하시오. 만일 S의 모든 소인수가 10^6보다 크다면 그 수는 적절한 암호 키이고, 그렇지 않은 경우는 적절하지 못한 암호 키가 된다.
<입력값>
첫째 줄에는 수의 개수 N (1≤N≤10)이 주어진다. 둘째 줄부터 N개의 줄에 걸쳐 확인하고자 하는 수 S들이 주어진다. ( 10^12 ≤ S ≤ 10^18 )
<출력값>
N개의 줄에 걸쳐, 입력받은 수가 적절한 암호 키이면 YES, 아니면 NO를 순서대로 출력한다.

<문제 1817>
숌은 짐을 챙겨서 겨울캠프에서 집으로 가려고 한다. 근데 숌은 공부를 많이 하러 캠프에 온 것이기 때문에 책을 엄청나게 많이 가지고 왔다. 숌은 이 책을 방에 탑처럼 쌓아 놨다.숌은 책을 박스에 차곡차곡 넣어서 택배로 미리 보내려고 한다. 책은 탑처럼 차곡차곡 쌓여있기 때문에, 차례대로 박스에 넣을 수밖에 없다.각각의 책은 무게가 있다. 그리고 박스는 최대 넣을수 있는 무게가 있다. 숌이 필요한 박스의 개수의 최솟값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 책의 개수 N과 박스에 넣을 수 있는 최대 무게 M이 주어진다. N은 0보다 크거나 같고 100,000보다 작거나 같은 정수 이고, M은 100,000보다 작거나 같은 자연수이다. 둘째 줄에 책의 무게가 공백을 사이에 두고 주어진다. 책의 무게는 M보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 필요한 박스의 개수의 최솟값을 출력한다.

<문제 1818>
동혁이는 캠프가 끝나고 집에 가서 책꽂이 정리를 하고 있었다. 책들은 한 줄로 길게 꽂히 있었다. 동혁이의 책은 1번부터 N번까지 숫자로 표현되고  현재 뒤죽박죽 되어있는 순서를 왼쪽부터 오른쪽으로 순서대로 1∼N번의 책들로 재배열하길 원한다.
동혁이가 책들을 배열하는 방법은 어떠한 책 하나를 꺼내서 다른 위치에 꽂는 방법이다.
1 5 2 3 4
위와 같이 책이 배열되어 있을 때 5번 책을 꺼내 가장 뒤쪽에 꼽으면
1 2 3 4 5
로 배열되고, 1∼5번까지 순서대로 책이 꽂히면서 정리는 끝나게 된다.
문제는 현재 책들의 배열순서가 주어지면 최소 횟수로 책들을 옮겨 책 정리를 끝내는 것이다.
<입력값>
첫째 줄에 책의 개수 N(1 ≤ N ≤ 200,000)이 주어진다. 두 번째 줄에는 현재 책들이 배열된 순서가 공백으로 구분되어 주어진다.
<출력값>
동혁이가 책들을 옮겨야 하는 최소 횟수를 출력한다.

<문제 1819>
상근이의 집에는 전구가 L개 있다. 각 전구를 켜고 끌 수 있는 스위치는 일렬로 늘어서있다. 전구가 켜진 상태에서 스위치를 누르면 꺼지고, 꺼진 상태에서 누르면 켜진다.
매일 밤, 잠을 자기 전에 상근이는 전구를 모두 끈다. 모든 스위치를 한 번씩 눌러 전구를 끄는 일은 시간이 오래걸린다.
불을 켜고 끄는 일을 조금 더 편하게 하기 위해 상근이는 스위치를 편하게 누를 수 있는 장치를 발명했다. 장치는 T개의 슬롯이 일렬로 놓여져있다. 일부 슬롯에는 스위치 버튼을 누를 수 있는 막대가 꽂혀있고, 나머지 슬롯은 비어있다. 예를 들어, 장치에 슬롯이 4개 있고, 1, 2, 4번째 슬롯에 막대가 꽂혀있으면, 이를 '1101'로 표현할 수 있다.
위의 장치로 L개의 스위치 중 가장 왼쪽 스위치를 누르면, 1, 2, 4번 스위치를 누를 수 있고, 그 전구의 상태가 변하게 된다. 3번 슬롯은 비어있기 때문에, 3번 전구는 변하지 않는다. 즉, 가장 왼쪽에 있는 슬롯을 기준으로 i번째 스위치를 누른다면 i, i+1, ..., i+T-1번째 스위치 중 막대가 꽂힌 슬롯에 대응되는 스위치의 전구가 변하게 된다. 단, T개의 모든 슬롯이 스위치와 대응되어야 한다. 즉, 스위치 바깥으로 슬롯이 나가면 안 된다.
현재 스위치의 상태와 상근이가 발명한 슬롯의 상태가 주어졌을 때, 불이 켜진 상태를 최소로 하려면 장치로 슬롯을 몇 번 눌러야 하는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 L (3 ≤ L ≤ 50)과 T (1 ≤ T ≤ 7)가 주어진다. 다음 줄에 길이가 L인 문자열이 주어진다. 1은 i번째 전구가 켜진 상태, 0은 꺼진 상태이다. 세 번째 줄에는 길이가 T인 문자열이 주어진다. 0은 빈 슬롯, 1은 막대가 꽂힌 슬롯이다.
<출력값>
첫째 줄에 최소의 불이 켜진 상태를 만들기 위해 슬롯으로 눌러야할 등불 순서의 개수 K를 출력한다. 그 다음 K줄에는 눌러야 하는 스위치를 순서대로 출력한다. 슬롯으로 누르는 가장 왼쪽 스위치의 번호를 출력한다. (장치를 회전시킬 수는 없다) K는 1000보다 작거나 같아야 한다.

<문제 1820>
A partition of a positive integer number m into n elements (n ≤ m) is a sequence of positive numbers a1,...,an such that a1+...+an = m and a1 ≤ a2 ≤ ... ≤ an. Your task is to find a partition of a number m which occupies the k-th position in the lexicographically ordered sequence of all partitions of m into n elements.
The lexicographic ordering among the partitions of a number is defined as follows. For two partitions a and b of m into n elements such that a = [a1,...,an] and b = [b1,...,bn] we have a  <  b if and only if there exists an 1 ≤ i ≤ n such that for all j < i we have aj = bj and ai < bi. The sequence of all partitions is ordered in increasing lexicographic order and at the first we have the following sequence 1, 1, ... 1, m-n+1.
<입력값>
The first line of input contains a number c giving the number of cases that follow. Each of the subsequent c lines contains three numbers: 1 ≤ m ≤ 220, 1 ≤ n ≤ 10 and 1 ≤ k which is not bigger than the number of partitions of m into n elements.
<출력값>
For each input data set print the k-th partition of m into n elements. Each element of a partition is to be printed in a separate line.

<문제 1821>
가장 윗줄에 1부터 N까지의 숫자가 한 개씩 적혀 있다. 그리고 둘째 줄부터 차례대로 파스칼의 삼각형처럼 위의 두개를 더한 값이 저장되게 된다. 예를 들어 N이 4 이고 가장 윗 줄에 3 1 2 4 가 있다고 했을 때, 다음과 같은 삼각형이 그려진다.
3 1 2 4
 4 3 6
  7 9
   16

	N과 가장 밑에 있는 숫자가 주어져 있을 때 가장 윗줄에 있는 숫자를 구하는 프로그램을 작성하시오. 단, 답이 여러 가지가 나오는 경우에는 사전순으로 가장 앞에 오는 것을 출력하여야 한다.
<입력값>
첫째 줄에 두개의 정수 N(1≤N≤10)과 F가 주어진다. N은 가장 윗줄에 있는 숫자의 개수를 의미하며 F는 가장 밑에 줄에 있는 수로 1,000,000 이하이다.
<출력값>
첫째 줄에 삼각형에서 가장 위에 들어갈 N개의 숫자를 빈 칸을 사이에 두고 출력한다. 답이 존재하지 않는 경우는 입력으로 주어지지 않는다.

<문제 1822>
몇 개의 자연수로 이루어진 두 집합 A와 B가 있다. 집합 A에는 속하면서 집합 B에는 속하지 않는 모든 원소를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 집합 A의 원소의 개수 n(A)와 집합 B의 원소의 개수 n(B)가 빈 칸을 사이에 두고 주어진다. (1 ≤ n(A), n(B) ≤ 500,000)이 주어진다. 둘째 줄에는 집합 A의 원소가, 셋째 줄에는 집합 B의 원소가 빈 칸을 사이에 두고 주어진다. 하나의 집합의 원소는 2,147,483,647 이하의 자연수이며, 하나의 집합에 속하는 모든 원소의 값은 다르다.
<출력값>
첫째 줄에 집합 A에는 속하면서 집합 B에는 속하지 않는 원소의 개수를 출력한다. 다음 줄에는 구체적인 원소를 빈 칸을 사이에 두고 증가하는 순서로 출력한다. 집합 A에는 속하면서 집합 B에는 속하지 않는 원소가 없다면 첫째 줄에 0만을 출력하면 된다.

<문제 1823>
1 × N 크기의 긴 밭에 벼가 심어져 있다. 준희는 이 벼를 수확 하려고 한다. 그런데 가운데 있는 벼를 수확을 하려면 끝에서 가운데까지 헤집고 들어가야 하므로 양 끝에 있는 벼만 수확을 할 수 있다. 처음에는 첫 번째와 N번째 벼를 수확을 할 수 있을 것이며 만약에 첫 번째 벼를 수확을 하였다면 두 번째 벼와 N번째 벼를 수확을 할 수 있다.
수확을 하였을 때 얻을 수 있는 이익은 다음과 같다. 만약에 그 벼의 가치가 v(i)라고 하고 그 벼를 k번째로 수확을 한다고 하면 v(i) × k 만큼의 이익을 얻게 된다.
만약에 벼의 가치가 차례로 1 3 1 5 2 라고 하고 첫 번째, 다섯 번째, 두 번째, 세 번째, 네 번째의 순서대로 수확을 한다고 하면 1×1 + 2×2 + 3×3 + 4×1 + 5×5 = 43 이 되어 43 만큼의 이익을 얻게 된다. 그리고 이 값이 저 벼로 얻을 수 있는 최대 이익이 된다.
우리가 구해야 할 값은 다음과 같다. 벼의 개수 N과 벼의 가치가 주어져 있을 때, 얻을 수 있는 최대 이익을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 벼의 개수 N(1 ≤ N ≤ 2,000)이 주어지고 두 번째 줄부터 N+1번쨰 줄까지 벼의 가치 v(i) (1 ≤ v(i) ≤ 1,000) 가 주어진다.
<출력값>
첫째 줄에 얻을 수 있는 최대 이익을 출력한다.

<문제 1824>
각 칸에 번호가 붙어 있는 N×M 크기의 체스판이 있다. 이 판에는 몇 개의 선이 그러져 있는데, 각각의 선은 두 개의 서로 다른 칸의 경계에 그려진다. 예를 들어 아래의 체스판은 N=4, M=5이고, 9개의 선이 그려져 있는 모습이다.

이 체스판을 1×2 또는 2×1 크기의 도미노로 모두 덮으려고 한다. 단, 선으로 분리되어 있는 두 칸을 하나의 도미노로 덮을 수는 없다. 예를 들어, 위의 그림에서 1번 칸과 2번 칸은 하나의 도미노로 덮을 수 있지만, 6번 칸과 7번 칸은 하나의 도미노로 덮을 수 없다. 아래는 이와 같은 조건을 만족하면서 체스판을 모두 덮은 예이다.
<입력값>
첫째 줄에 N과 M(1≤N, M≤100)이 빈 칸을 사이에 두고 주어진다. N과 M 중 적어도 하나는 짝수이다. 둘째 줄에는 선의 개수 L(0≤L≤5,000)이 주어진다. 이어서 L개의 줄에 걸쳐 선을 나타내는 두 개의 칸 번호가 빈 칸을 사이에 두고 주어진다. 이는 두 칸을 분리시키는 선이라는 의미이다. 번호는 N×M 이하의 자연수로 왼쪽으로부터 i번째, 위로부터 j번째 칸이 (j-1)×M+i 번이 된다.
<출력값>
첫째 줄부터 N×M÷2개 줄에 도미노를 놓을 두 칸의 번호를 빈 칸을 사이에 두고 출력한다. 1×2 또는 2×1 크기의 도미노를 놓을 두 칸은 반드시 인접해 있어야 하며, 선으로 분리되어 있는 두 칸을 덮어서는 안 된다. 하나의 칸에 여러 개의 도미노를 놓아서도 안 되며, 반드시 모든 칸을 겹치지 않게 덮는 해를 출력해야 한다. 출력하는 순서는 상관이 없으며, 도미노를 놓는 방법이 둘 이상인 경우 그 중 한 경우만 출력한다.

<문제 1825>
1부터 N까지의 수들이 중복 없이 임의로 나열된 한 순열을 생각하자. 이러한 순열에서 몇 개의 수들을 제거하면 하나의 수열이 생기는데, 이를 원래 순열의 부분수열이라 한다. 예를 들어 N=4일 때 3 1 2 4 가 순열의 한 예이고, 1 4는 그 순열이 부분수열의 한 예이다. 부분수열은 원래 순열에서의 순서를 유지해야 하므로 4 1은 앞의 순열의 부분수열이 아니다.
부분수열을 이루는 수들이 차례로 증가하는 경우, 이를 부분 증가수열이라 하며, 반대로 차례로 감소하는 경우에는 부분 감소수열이라 한다. 최대 부분 증가수열은 이러한 부분 증가수열들 중 길이가 가장 긴 것을 의미하며, 최대 부분 감소수열은 이러한 부분 감소수열들 중 길이가 가장 긴 것을 의미한다. 앞 예의 3 1 2 4의 최대 부분 증가수열은 1 2 4로 그 길이가 3이며, 최대 부분 감소수열은 3 1 또는 3 2로 그 길이가 2이다.
세 정수 N, M, K가 주어졌을 때, 길이가 N인 순열들 중 최대 부분 증가수열의 길이가 M이고, 최대 부분 감소수열의 길이가 K인 것을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 순열의 길이 N(1 ≤ N ≤ 100,000), 최대 부분 증가수열의 길이 M, 최대 부분 감소수열의 길이 K(1 ≤ M, K ≤ N)가 빈 칸을 사이에 두고 순서대로 주어진다.
<출력값>
첫째 줄에는 문제의 조건을 만족하는 수열 중에서 사전 순으로 가장 앞서는 것을 출력하고, 둘째 줄에는 가장 마지막에 오는 것을 출력한다.
조건을 만족하는 수열이 존재하지 않는 경우 첫째 줄에 -1만을 출력한다.

<문제 1826>
성경이는 트럭을 정글 속에서 운전하다가 트럭의 연료탱크에 갑자기 구멍이 나서 1km를 가는데 1L의 연료가 새 나가게 되었다. 이것을 고치기 위해서는 가장 가까운 마을에 가야 한다. 그런데 그냥 가다가는 중간에 연료가 다 빠질 수가 있다. 다행스럽게도 정글 곳곳에 연료를 채울 수 있는 주유소가 N개 있다. 그런데 정글 속에서 중간에 차를 멈추는 행위는 매우 위험한 행위이므로 주유소에서 멈추는 횟수를 최소화 하려 한다.
그리고 다행이도 성경이의 트럭은 매우 좋아서 연료 탱크에는 연료의 제한이 없이 많이 충분히 많이 넣을 수 있다고 한다. 각각의 주유소의 위치와, 각 주유소에서 얻을 수 있는 연료의 양이 주어져 있을 때, 주유소에서 멈추는 횟수를 구하는 프로그램을 작성하시오.
정글은 일직선이고, 성경이의 트럭과 주유소도 모두 일직선 위에 있다. 주유소는 모두 성경이의 트럭을 기준으로 오른쪽에 있다.
<입력값>
첫째 줄에 주유소의 개수 N(1 ≤ N ≤ 10,000)가 주어지고 두 번째 줄부터 N+1번째 줄 까지 주유소의 정보가 주어진다. 주유소의 정보는 두개의 정수 a,b로 이루어 져 있는데 a(1 ≤ a ≤ 1,000,000)는 성경이의 시작 위치에서 주유소 까지의 거리, 그리고 b(1 ≤ b ≤ 100)는 그 주유소에서 채울 수 있는 연료의 양을 의미한다. 그리고 N+2번째 줄에는 두 정수 L과 P가 주어지는데 L(1 ≤ L ≤ 1,000,000)은 성경이의 위치에서 마을까지의 거리, (1 ≤ P ≤ 1,000,000)는 트럭에 원래 있던 연료의 양을 의미한다.
<출력값>
첫째 줄에 주유소에서 멈추는 횟수를 출력한다. 만약 마을에 도착하지 못할경우 -1을 출력한다.

<문제 1827>
윤화의 직장은 여행을 온 사람들을 버스에서 안내하는 여행 가이드이다. 윤화는 어느 날 다른 날과 다름없이 N명의 사람을 버스 안에서 인솔을 하게 되었다.
그러던 도중 점심시간을 갖게 되었다. 점심시간은 한 시간인데 그 시간동안에는 N명의 사람들은 각자 자기가 가고 싶은 곳으로 갈 수 있다. 한 시간 뒤에 사람들을 버스에서 모이기로 약속을 하고 모두 흩어졌다.
그런데 일이 발생하고 말았다. 한 시간이 흘렀는데 사람들이 아무도 버스에 돌아오지 않은 것이다. 윤화는 흩어진 사람들을 모두 만나서 빨리 버스로 돌아가라고 말을 해 주고 버스로 돌아가야 한다. (단, 그 말을 들은 사람은 그 즉시 자신의 이동 방향을 바꾸어 버스를 향해 이동한다고 가정하여도 좋다.) 그런데 최대한 여행 일정이 늦어지지 않게 하기 위해서 마지막에 버스에 도착하는 사람의 시간을 최소로 하려 한다.
당신이 가지고 있는 정보는 다음과 같다. 점심시간이 끝나는 시각에 N명의 사람들의 위치의 좌표, 그리고 그 사람들의 이동 속도, 그리고 그 사람이 현재 이동하고 있는 방향이 주어진다. (모든 사람은 직선으로만 이동을 한다)
<입력값>
첫째 줄에는 사람의 수 N(1≤N≤8)이 주어진다. 그리고 두 번째 줄에는 당신의 이동 속도가 소수로 주어진다. 그리고 세 번째 줄부터 N+2번째 줄 까지 네 개의 소수 xi,yi,vi,ai가 차례로 주어진다.  (xi, y1) (-10^6 <=xi,yi<= 10^6)는 점심시간이 끝났을 때 i번째 사람의 좌표를 의미하고, vi(1≤vi≤100)는 i번째 사람의 이동 속도를 의미한다. 그리고 ai(1≤ai≤2파이) 는 그 사람의 이동 방향을 의미한다.
<출력값>
마지막 사람이 도착하는 시간을 소수점 첫째 자리에서 반올림하여 정수로 출력하시오. 답은 항상 106 보다 작거나 같다.

<문제 1828>
Long before the days of international trade treaties, a salesman would need to pay taxes at every border crossed. So your task is to ﬁnd the minimum number of borders that need to be crossed when traveling between two countries. We model the surface of Earth as a set of polygons in three dimensions forming a closed convex 3D shape, where each polygon corresponds to one country. You are not allowed to cross at points where more than two countries meet.
<입력값>
The input consists of a line containing c, the number of countries (4 ≤ c ≤ 6000), followed by c lines containing the integers n x1 y1 z1 . . . xn yn zn, describing (in order) the n corners of a closed polygon (3 ≤ n ≤ 20). Then follows a line with one integer m (0 < m ≤ 50), and then m lines with queries ca cb , where ca and cb are country numbers (starting with 1). No point will be on the line between two connected points, and −106 ≤ x, y, z ≤ 106 for all points. No two non-adjacent edges of a country share a common point.
<출력값>
For each query, output the number of borders you must cross to go from ca to cb.

<문제 1829>
N개의 항아리에 사탕이 들어 있다. 첫 번째 항아리에는 K개의 사탕, 두 번째 항아리에는 하나 많은 K+1개의 사탕이 들어 있다. 마찬가지로 항아리의 번호가 1만큼 커질 때마다 항아리에 들어 있는 사탕의 개수도 1개씩 증가하여, 마지막 N번째 항아리에는 K+N-1개의 사탕이 들어 있다. 사탕을 꺼내는 방법은 다음과 같다. 먼저 N개의 항아리 중에서 임의로 몇 개의 항아리를 고른다. 이렇게 고른 항아리에서 같은 개수의 사탕을 각각 꺼낸다. 물론 항아리에 들어 있는 사탕의 개수가 꺼내려는 사탕의 개수보다 작아서는 안 된다.사탕을 좋아하는 순일이는 최대한 빨리 모든 사탕을 꺼내고 싶다. N과 K가 주어지면 주어진 방법을 가능한 적은 횟수로 사용하여 항아리에 들어 있는 모든 사탕을 꺼내는 방법을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N(1≤N≤100,000)과 K(1≤K≤500,000)가 빈 칸을 사이에 두고 주어진다. 모든 항아리에는 순서대로 1번부터 N번까지 번호가 매겨져 있다.
<출력값>
첫째 줄에는 방법을 사용한 최소 횟수 M을 출력한다. 이어서 사용한 방법에 대한 구체적인 정보를 다음과 같이 한 방법에 대해 두 줄씩 총 2×M개의 줄에 걸쳐 순서대로 출력한다. 각 정보는 다음과 같이 출력한다.
첫째 줄에는 선택한 항아리의 개수와 사탕 몇 개를 꺼낼 건지를 출력한다. 둘째 줄에는 선택한 항아리의 번호를 공백으로 구분하여 출력한다. 예를 들어, 1,3,4,5번 항아리에서 사탕 3개를 꺼낸다면
4 3
1 3 4 5
와 같이 출력하면 된다.

<문제 1830>
2차원 평면에서 두 점 사이의 거리를 정의하는 방법은 여러 가지가 있을 수 있다. 가장 일반적으로 사용되는 유클리드 거리(Euclidean distance)는 두 점을 일직선으로 연결했을 때의 길이를 말한다. 이는 한 점에서 다른 점으로 가는 최단 거리라고 볼 수 있다.
이와는 달리 맨해튼 거리(Manhattan distance)는 두 점의 x좌표 차이와 y좌표 차이를 더한 값으로 정의된다. 뉴욕의 자치구 맨해튼의 이름이 붙여진 이 거리는 한 점에서 다른 점으로 x축 또는 y축에 평행하게 이동했을 때의 거리가 된다.
또한 체비셰프 거리(Chebyshev distance)는 두 점의 x좌표 차이와 y좌표 차이 중 큰 값을 갖는 거리이다. 체스 게임에서 왕(King)이 한 점에서 다른 점으로 이동할 때 필요한 최소 이동 횟수와 같다는 점에서 체스판 거리(Chessboard distance)라고도 한다.
이와 같은 세 가지 거리 개념에 대해서, 2차원 평면상에 서로 다른 N개의 점이 주어졌을 때 가장 가까운 두 점 사이의 거리와 가장 먼 두 점 사이의 거리를 각각 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 점의 개수 N(2 ≤ N ≤ 100,000)이 주어진다. 이어서 다음 N개 줄에 걸쳐 각 점의 x좌표와 y좌표가 빈 칸을 사이에 두고 주어진다. 주어지는 좌표는 절댓값이 10,000을 넘지 않는 정수이다.
<출력값>
첫째, 둘째 줄에는 유클리드 거리로 최대 거리와 최소 거리를 각각 제곱해서 출력한다. 셋쩨, 넷째 줄에는 맨해튼 거리로 최대 거리와 최소 거리를 각각 출력한다. 다섯째, 여섯째 줄에는 체비셰프 거리로 최대 거리와 최소 거리를 각각 출력한다.

<문제 1831>
직사각형 모양의 과수원들이 옹기종기 모여 있는 넓은 벌판이 있다. 서로 다른 과수원들은 겹쳐 있지는 않지만, 변을 공유할 있을 수는 있다. 각각의 과수원에는 한 종류의 과일만이 심어져 있다. 물론 서로 다른 과수원에 같은 종류의 과일이 심어져 있을 수도 있다. 아래는 비행기를 타고 상공에서 바라본 두 개의 벌판을 그림으로 도식화한 것이다. 같은 색으로 그려진 직사각형은 같은 종류의 과일이 심어져 있는 과수원이 된다.

같은 색으로 칠해진 직사각형 중에서 가장 큰 것의 넓이를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 과수원의 개수 N(1≤N≤2,500)이 주어진다. 이어서 다음 N개 줄에는 다섯 개의 정수 X1, Y1, X2, Y2, C가 빈 칸을 사이에 두고 주어진다. (X1<X2, Y1<Y2) 이는 과수원이 (X1, Y1), (X2, Y2)를 두 꼭짓점으로 하는 직사각형이라는 뜻이다. 의미한다. 좌표는 0 이상 1,000,000,000 이하의 정수이다. C는 이 과수원에 심어져 있는 과일의 종류를 나타내는 번호이다. (1≤C≤100)
<출력값>
같은 색으로 칠해진 직사각형 중에서 가장 큰 것의 넓이를 출력한다.

<문제 1832>
N명의 카우보이가 있다. 그런데 1번 카우보이부터 N번 카우보이까지 차례로 총을 쏴 다른 사람을 맞추려 한다. (N번 사람이 총을 쏜 후에는 1번 사람이 총을 쏘게 될 것이다.) 총을 맞은 사람은 죽게 되어서 더 이상 총을 쏘지 못하게 된다. 이렇게 계속 반복을 하다가 1명이 남게 되면 그 사람이 승자가 된다고 한다.
그런데 N명의 사람들은 모두 총을 쏠 수 있는 능력이 다르기 때문에 총을 쏴서 다른 사람을 맞힐 수 있는 확률이 다르다. 그렇기 때문에 N명의 카우보이는 모두 이러한 확률을 이용하여서 자기가 이길 수 있는 전략을 짜서 자신이 총을 겨눌 사람을 정하게 된다. 쏘아서 자신의 생존 확률이 가장 커지는 상대가 여러 명일 때,  그 중 무작위로한 명을 쏜다.
N명의 사람들의 총을 쏘는 능력이 주어져 있을 때, 각각의 사람이 최후의 1인이 되는 확률을 구하는 프로그램을 작성하시오.
카우보이들은 투철한 직업관을 가지고 있기 때문에, 허공에 총을 쏠 때 자신의 생존 확률이 가장 높은 경우라도, 항상 다른 사람을 맞추기 위해 최선을 다할 것이다.
<입력값>
첫째 줄에 카우보이의 숫자 N(2 ≤ N ≤ 13)이 주어지고 두 번째 줄에는 N개의 정수 Pi (1 ≤ Pi ≤ 100)가 주어진다. Pi는 i번째 사람이 총을 쏴서 다른 사람을 맞추는 확률을 의미한다.
<출력값>
첫째 줄에 N개의 소수 Qi 를 출력한다 Qi는 i번째 사람이 최후의 1인이 될 확률을 의미한다. 절대/상대 오차는 10-2까지 허용한다.

<문제 1833>
N(1≤N≤200)개의 도시로 이루어진 나라가 있다. 이 도시들 사이를 다니는 고속철도망을 만들어 도시 간의 이동을 편하게 하려고 한다. 단, 고속철도망을 만든 후에 임의의 도시에서 다른 임의의 도시로 고속철도를 이용하여 이동할 수 있게 하려고 한다.시범 사업으로 몇 개의 도시 사이에 고속철도가 설치되었는데 그 결과가 매우 좋아 국가에서는 이 사업을 완성하기로 하였다. 이제 당신은 몇 개의 도시 사이에 고속철도를 추가로 설치하여, 임의의 도시에서 다른 임의의 도시로 고속철도를 이용하여 이동할 수 있게 하려고 한다. 그러나 이 사업은 워낙 돈이 많이 드는 사업이기 때문에, 이 사업에 드는 총 비용을 최소화 하려고 한다. 두 도시 사이에 고속철도를 설치할 때 드는 비용이 주어졌을 때, 총 비용을 최소로 하여 사업을 완성하여 보자. 예를 들어 아래와 같은 경우를 보자. �

현재 1번 도시와 2번 도시, 2번 도시와 4번 도시, 1번 도시와 4번 도시 사이에 고속철도가 설치되어 있다. 각각의 수는 두 도시 사이에 고속철도를 설치하는데 드는 비용을 나타낸다. 예를 들어 2번 도시와 3번 도시 사이에 고속철도를 설치하면 10만큼의 비용이 든다는 것을 의미한다. 위의 그림에 나타나지 않은 비용은 다 1,000이라고 하자. 위와 같은 경우에는 2, 3번 도시 사이에 고속철도를 설치하고, 3, 5번 도시 사이에 고속철도를 설치하면, 임의의 도시에서 다른 임의의 도시로 고속철도를 이용하여 갈 수 있으며, 이 경우는 10+20+30+10+10=80만큼의 총 비용으로 사업을 완성할 수 있다. 10+20+30은 이미 설치된 고속도로에 대한 비용을 의미한다. 2, 4번 도시를 연결하는 고속철도가 없더라도 임의의 도시에서 다른 임의의 도시로 고속철도를 이용하여 이동할 수 있지만, 이미 설치되어 있는 고속철도를 돈을 들여가며 파괴할 필요가 없으므로, 이런 건 생각하지 않기로 한다.
<입력값>
첫째 줄에 자연수 N이 주어진다. 다음 N개의 줄에는 인접행렬 형태로 두 도시 사이에 고속철도를 설치할 때 드는 비용이 주어진다. 이 비용은 각각 10,000을 넘지 않는 자연수이다. 만약 비용이 음수라면, 그 두 도시 사이에 이미 고속철도가 설치되어 있는 경우를 의미한다.
<출력값>
첫째 줄에 두 정수 C, M를 출력한다. C는 고속철도망을 설치하는데 든 총 비용이며, M은 새로이 설치한 고속철도의 개수이다. 다음 M개의 줄에는 새로 고속철도가 설치된 두 도시번호를 출력한다. 우리가 최소화 하려는 것은 C이다.

<문제 1834>
N으로 나누었을 때 나머지와 몫이 같은 모든 자연수의 합을 구하는 프로그램을 작성하시오. 예를 들어 N=3일 때, 나머지와 몫이 모두 같은 자연수는 4와 8 두 개가 있으므로, 그 합은 12이다.
<입력값>
첫째 줄에 2,000,000 이하의 자연수 N이 주어진다.
<출력값>
첫 줄에 구하고자 하는 수를 출력한다.

<문제 1835>
1부터 N까지의 숫자가 적힌 카드가 있다. 찬유는 이 카드를 가지고 마술을 하려 한다. 마술을 하는 순서는 다음과 같다.1) 먼저 1부터 N까지의 숫자가 적힌 카드에서 첫 번째 카드를 가장 뒤로 옮긴다. 그러고 나서 첫 번째 카드를 책상 위에 올려놓는다. 그런데 그 카드는 1이 되어야 한다. 2) 그리고 남은 카드 중에서 첫 번째 카드를 가장 뒤로 옮기고, 또 가장 앞에 있는 카드를 가장 뒤로 옮긴다.(2번 반복) 그리고 가장 앞에 있는 카드를 책상 위에 올려놓는다. 그런데 그 카드는 2가 되어야 한다.3) 또 남은 카드 중에서 첫 번째 카드를 가장 뒤로 옮기고... (3번 반복) 그리고 가장 앞에 있는 카드를 책상위에 올려놓는데 그것은 3이 된다.4) 또 남은 카드 중에서 첫 번째 카드를 가장 뒤로 옮기고.. (4번 반복) 그리고 가장 앞에 있는 카드를 책상 위에 올려놓는데 그것은 4이다.5) 위 과정을 계속 반복하여 N번 카드만 남을 때 까지 반복한다.위와 같은 카드를 하려면 미리 카드의 순서를 알고 있어야 한다. 카드의 개수 N이 주어져 있을 때 위의 마술을 하기 위한 카드의 초기 순서를 구하는 프로그램을 작성하시오.
<입력값>
첫 번째 줄에 카드의 개수 N(1≤N≤1,000)이 주어진다.
<출력값>
첫 번째 줄부터 N번째 줄까지 차례로 카드의 순서를 출력한다.

<문제 1836>
다음과 같은 성질을 만족하는 서로 다른 이진트리의 가짓수를 세는 프로그램을 작성하라.

n개의 노드를 갖는다. (1 ≤ n＜200)
각 노드의 차수는 0 혹은 2이다. 차수란, 각 노드의 자식노드 개수이다.
높이는 k이다. (1＜k＜100) 높이란, 루트에서 단말노드에 이르는 임의의 가장 긴 경로 위에 존재하는 노드의 개수이다. 단말노드란 자식노드가 없는 노드이다.

이때, 구하려는 가짓수가 몹시 큰 수일 수 있으므로 9901로 나눈 나머지만을 출력하도록 한다.
<입력값>
첫째 줄에 n과 k가 주어진다.
<출력값>
조건에 부합하는 서로 다른 이진트리의 가짓수를 9901로 나누어, 그 나머지를 출력한다.

<문제 1837>
원룡이는 한 컴퓨터 보안 회사에서 일을 하고 있다. 그러던 도중, 원룡이는 YESWOA.COM 으로부터 홈페이지 유저들의 비밀키를 만들라는 지시를 받았다. 원룡이는 비밀 키를 다음과 같은 방법으로 만들었다.
개인마다 어떤 특정한 소수 p와 q를 주어 두 소수의 곱 pq를 비밀 키로 두었다. 이렇게 해 주면 두 소수 p,q를 알지 못하는 이상, 비밀 키를 알 수 없다는 장점을 가지고 있다.
하지만 원룡이는 한 가지 사실을 잊고 말았다. 최근 컴퓨터 기술이 발달함에 따라, 소수가 작은 경우에는 컴퓨터로 모든 경우의 수를 돌려보아 비밀 키를 쉽게 알 수 있다는 것이다.
원룡이는 주성조교님께 비밀 키를 제출하려던 바로 직전에 이 사실을 알아냈다. 그래서 두 소수 p, q 중 하나라도 K보다 작은 암호는 좋지 않은 암호로 간주하여 제출하지 않기로 하였다. 이것을 손으로 직접 구해보는 일은 매우 힘들 것이다. 당신은 원룡이를 도와 두 소수의 곱으로 이루어진 암호와 K가 주어져 있을 때, 그 암호가 좋은 암호인지 좋지 않은 암호인지 구하는 프로그램을 작성하여야 한다.
<입력값>
암호 P(4 ≤ P ≤ 10100)와 K (2 ≤ K ≤ 106) 이 주어진다.
<출력값>
만약에 그 암호가 좋은 암호이면 첫째 줄에 GOOD을 출력하고, 만약에 좋지 않은 암호이면 BAD와 소수 r을 공백으로 구분하여 출력하는데 r은 암호를 이루는 두 소수 중 작은 소수를 의미한다.

<문제 1838>
버블 정렬이란 배열에서 서로 인접해 있는 값을 비교해서 작은 값이 더 뒤에 있을 때 두 값을 바꾸어 주는 과정을 계속 반복하는 정렬 방법이다. N개의 서로 다른 정수가 A[0], A[1], ..., A[N-1]의 정수형 배열에 저장되어 있고, 이를 오름차순으로 정렬하기 위해 태국이는 다음과 같은 코드를 작성하였다.

for (i=0; i<N; i++) {
    flag = 0;
    for (j=0; j<N-1; j++) {
        if (A[j] > A[j+1]) {
            flag = 1;
            temp = A[j];
            A[j] = A[j+1];
            A[j+1] = temp;
        }
    }
}
하지만 주어진 배열 A에 따라 변수 i가 모든 loop를 반복하지 않아도 정렬이 완료되기도 한다. 따라서 도현이는 다음과 같이 코드를 개선하였다.

for (i=0; i<N; i++) {
    flag = 0;
    for (j=0; j<N-1; j++) {
        if (A[j] > A[j+1]) {
            flag = 1;
            temp = A[j];
            A[j] = A[j+1];
            A[j+1] = temp;
        }
    }
    if (flag == 0) {
        break;
    }
}
도현이는 자신이 태국이보다 우월하다는 것을 증명하기 위해, 개선된 코드를 이용하여 주어진 배열 A를 정렬해 보려고 한다. 만일 정렬이 완료되었을 때(즉 for문을 빠져나왔을 때)의 i값이 작으면 작을수록 도현이의 코드가 더 빠른 것이 된다. 태국이를 이기고 싶은 도현이를 도와서, 배열 A에 저장된 수가 주어지면 정렬이 완료되었을 때 변수 i에 저장되어 있는 값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 정수 N(1≤N≤500,000)이 주어진다. 다음 줄에 배열 A를 이루는 N개의 정수가 빈 칸을 사이에 두고 순서대로 주어진다. 주어지는 정수는 절댓값이 2,147,483,647을 넘지 않는다.
<출력값>
첫째 줄에 정렬이 완료되었을 때 변수 i에 저장되어 있는 값을 출력한다.

<문제 1839>
월드 장난감 회사는 노끈들을 이용해서 트리의 모형을 만들고자 한다. 이를 돕기 위한 프로그램을 작성하라.트리 (tree)는 그래프 (graph)의 일종으로, 연결되어 있으며, 내부에 싸이클이 존재하지 않는 그래프이다. 그래프에서 버텍스 (vertex), 에지 (edge)라고 부르는 것을, 트리에 한해서는 각각 노드 (node)와 링크 (link)라고 부른다.트리의 노드들은 노끈 위에 매인 매듭으로 표현되고, 각 매듭 사이를 연결하는 노끈이 트리의 링크들을 표현한다. 노드를 표현하는 매듭들은 그냥 한 개의 노끈 중간이나 끝부분을 묶은 것일 수도 있고, 여러 개의 노끈들이 한 점에서 뭉쳐 묶여 있는 부분일 수도 있다.기술적인 문제 때문에, 생산 단가는 모델을 만드는 데 사용되는 노끈의 개수와, 사용된 노끈들 중 가장 긴 노끈의 길이에 의존한다. (각각의 링크들은 길이가 모두 1이다. 매듭을 만드는 데 소요되는 노끈의 길이는 무시한다.)여러분이 할 일은 첫째, 트리의 구조가 주어지면 이를 만들기 위한 최소의 노끈 개수를 구하는 것이다. 둘째로는, 이와 같이 최소 개수의 노끈들을 이용하여 트리를 만들 때 사용되는 가장 긴 노끈 길이의 최솟값을 구하는 것이다.
<입력값>
첫째 줄에 노드의 개수를 나타내는 양의 정수 n이 주어진다. (2≤n≤10,000) 둘째 줄부터는 n-1개의 링크를 나타내는 두 개씩의 양의 정수가 주어진다. 각각은 링크가 연결 짓는 두 노드의 번호를 나타낸다. 노드의 번호는 1번부터 n번까지 빠짐없이 연속하여 붙어 있다.
<출력값>
첫 줄에 필요한 최소한의 노끈 개수와, 가장 긴 노끈 길이의 최솟값을 출력한다.

<문제 1840>
스도쿠는 18세기 스위스 수학자가 만든 ‘라틴 사각형’이란 퍼즐에서 유래한 것으로 현재 많은 인기를 누리고 있다. 이 게임은 아래 그림과 같이 가로, 세로 각각 9개씩 총 81개의 작은 칸으로 이루어진 정사각형 판 위에서 이루어진다. 왼쪽 위 칸은 (1, 1), 오른쪽 아래 칸은 (9, 9)로 생각한다.

이 판에 수를 채우는 규칙은 다음과 같다.

각각의 가로줄과 세로줄에는 1부터 9까지의 숫자가 한 번씩만 나타나야 한다.
굵은 선으로 구분되어 있는 3×3 정사각형 안에도 1부터 9까지의 숫자가 한 번씩만 나타나야 한다.

예를 들어 아래와 같은 경우, 1을 제외한 나머지 2부터 9까지의 숫자들이 이미 나타나 있으므로 빈칸에는 1이 들어가야 한다.

또한 다음과 같은 3×3 정사각형의 경우에는 3을 제외한 나머지 숫자들이 이미 쓰여 있으므로 가운데 빈 칸에는 3이 들어가야 한다.

이와 같이 81개의 칸을 차례로 채워 나가면 조건을 만족시키도록 퍼즐을 풀 수 있다. 하지만 숫자를 채워 나가는 도중에 실수가 있었다면 퍼즐을 완성하지 못하게 될 수도 있다. 예를 들어 29개의 칸을 채운 후 스도쿠 판이 다음과 같았다고 하자.

만일 30번째로 수 5를 (4, 6) 칸에 넣는다면, 현재 단계에서는 규칙에 위배되지 않지만 나머지 51개의 수를 어떻게 채워 넣는다고 해도 이 퍼즐은 풀 수 없는 퍼즐이 된다. 이처럼 가장 먼저 실수한 단계의 번호를 구하는 프로그램을 작성하시오.
<입력값>
81개의 줄에 걸쳐 각 단계에서 숫자를 채울 칸의 좌표를 나타내는 두 정수와 그 칸에 적을 숫자가 빈 칸을 사이에 두고 순서대로 주어진다. 입력되는 모든 숫자는 1 이상 9 이하의 자연수이다.
<출력값>
첫 줄에 가장 먼저 실수한 단계가 몇 번째인지 출력한다. 만일 실수한 곳이 없다면 -1을 출력한다.

<문제 1841>
두 개의 도시와 N(0≤N≤150)개의 마을로 이루어진 나라가 있다. 몇 개의 마을과 도시 사이에는 양방향으로 이동 가능한 길이 있기도 하다. 각각의 길을 이용하여 이동하는데 걸리는 시간은 서로 다를 수 있지만, 하나의 길을 이동할 때에는 어느 방향으로 이동해도 같은 시간이 걸린다.
이 나라에서는 치안에 신경을 쓰기 위해 군대를 배치하기로 하였다. 군대를 마을에 배치할 경우에는 마을 사람들에게 불편을 끼칠 우려가 있기 때문에, 군대를 배치할 때에는 반드시 길 위에 배치해야 한다. 길 위에 배치할 때에는 그 길이 연결하는 두 개의 마을(혹은 도시) 중 어느 한쪽에 원하는 만큼 가까이 배치할 수 있다.
이 나라의 군대는 G(0≤G≤353535)명의 군인으로 구성되어 있는데, 한 곳에 모든 군인을 배치할 수도 있고, 서로 다른 길에 군인들을 배치할 수도 있으며, 한 길 위에도 여러 명의 군인을 (서로 다른 위치에) 배치할 수도 있다. 단, 이와 같이 군대를 배치했을 때, 두 도시 사이를 이동하기 위해서는 적어도 한 명의 군인과 반드시 마주치도록 배치해야 한다.
또한 때로는 각 도시로 군대를 소집해야 할 필요가 있을 수도 있다. 군대를 소집하는 것은 두 도시 중 어느 한 쪽에서도 할 수 있으며, 군대를 소집하는데 걸리는 시간은 제일 마지막 군인이 마을에 도착하는 시간이 된다. 나라에서는 군대를 효율적으로 배치하기 위해서, 두 도시에서 군대를 소집하는데 걸리는 시간 중 더 큰 값이 작아지도록 하려 한다.
도시와 마을에 대한 정보가 주어졌을 때, 군대를 소집하는데 걸리는 시간의 최솟값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 세 정수 N, G, E(0≤E≤5,000)가 주어진다. 다음 E개의 줄에는 각 길에 대한 정보를 나타내는 세 정수 A, B, C가 주어진다. 이는 A번 마을(혹은 도시)와 B번 마을(혹은 도시) 사이에 C만큼 시간이 걸리는 길이 있음을 의미한다. 마을의 번호는 0부터 N-1까지의 정수로 표현되며, 두 도시는 각각 95050과 104729로 표현된다. C는 1,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 답을 출력한다. 답을 출력할 때에는 소수점 아래 첫째 자리까지(둘째 자리에서 반올림) 출력한다. 위의 조건을 만족하도록 군대를 배치하는 것이 불가능한 경우에는 Impossible을 출력한다.

<문제 1842>
1행 m열의 직사각형 체스판 위에서 진행하는 게임을 가정해 보자. 체스판의 각 칸에는 1부터 m까지 번호가 매겨져 있다. n개의 폰 (pawn)이 하나씩의 칸을 차지한 채로 체스판 위에 놓여 있으며, m번 칸은 비어 있다. 두 명의 플레이어가 게임을 한다. 각 플레이어는 자기 차례가 오면 i번 칸에 놓인 폰을 집어서 j번 칸으로 이동시킬 수 있다. 이때, j는 비어있는 칸의 번호 중 최솟값인데, 다만 i보다는 커야 한다. 게임의 승자는 마지막 칸인 m번 칸에 폰을 집어넣는 사람이다.

예를 들어, m=7인 그림의 상황에서 차례가 된 플레이어는 2번 칸의 폰을 4번 칸으로 옮길 수 있고, 3번 칸의 폰을 4번 칸으로 옮길 수도 있으며, 6번 칸의 폰을 7번 칸으로 옮겨 게임을 이길 수도 있다.어떤 플레이어의 수가 ‘필승수'라고 하는 것은, 그 수를 둔 후엔 상대편이 어떤 수를 두더라도 반드시 이길 수 있는 경우를 말한다. 체스판의 현재 상황이 주어졌을 때, 이번에 차례를 맞은 플레이어가 둘 수 있는 필승수의 가짓수를 계산하는 프로그램을 작성하라.
<입력값>
첫째 줄에 두 양의 정수 m과 n이 주어진다. (2≤m≤ 10^9, 1≤n≤10^6, n＜m) 둘째 줄에는 n개의 양의 정수가 오름차순으로 주어지는데, 이는 각각 현재 폰이 놓여 있는 칸의 번호를 나타낸다.
<출력값>
첫째 줄에 이번에 차례를 맞은 플레이어가 둘 수 있는 필승수의 가짓수를 출력한다.

<문제 1843>
X + Y = Z (단, X≤Y)
우리는 세 자연수 X, Y, Z로 이루어진 위와 같은 방정식의 해의 개수를 알고 싶다. 만일 제약 조건이 없다면 방정식의 해는 무수히 많아질 수 있기 때문에, 아래와 같은 제약 조건이 있을 때 해의 개수를 각각 구하려고 한다. 모든 제약 조건이 동시에 적용되는 것은 아니고, 각각의 경우에 해의 개수를 따로 구하면 된다.

제약 조건 A: 세 자연수 X, Y, Z는 모두 N 이하이며, 서로 다르다.
제약 조건 B: 세 자연수 X, Y, Z는 모두 N의 양의 약수이다.
제약 조건 C: 세 자연수 X, Y, Z는 모두 N 이하의 양의 소수이다.

예를 들어 N=6일 때, 각각의 제약 조건이 있을 때의 해를 모두 구하면 다음과 같다.

제약 조건 A: 1+2=3, 1+3=4, 1+4=5,1+5=6, 2+3=5, 2+4=6 (6개)
제약 조건 B: 1+1=2, 1+2=3, 3+3=6 (3개)
제약 조건 C: 2+3=5 (1개)

제약 조건 A, B, C에 대해 주어진 방정식의 해의 개수를 각각 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 자연수 N(1 ≤ N ≤ 500,000)이 주어진다.
<출력값>
첫째 줄에 제약 조건 A가 있을 때 방정식의 해의 개수를 출력한다. 둘째 줄에 제약 조건 B가 있을 때 방정식의 해의 개수를 출력한다. 셋째 줄에 제약 조건 C가 있을 때 방정식의 해의 개수를 출력한다.

<문제 1844>
N미터의 긴 1차원 농지가 있다. 각각의 지역에는 그 지역의 높이가 주어져 있다. 그리고 높이가 같은 한 개 이상의 연속된 구간의 높이가, 양 옆의 높이보다 높을 경우 그 구간을 봉우리라고 부른다.만약에 높이가 1 2 3 3 3 2 1 3 2 2 1 2로 주어진 농지가 있다면 아래 그림과 같이 되어 봉우리의 수는 3개가 된다.    * * *     * 
  * * * * *   * * *   *
* * * * * * * * * * * *
1 2 3 3 3 2 1 3 2 2 1 2그런데 봉우리가 너무 많을 경우에는 농지에서 농작물을 경작하기가 힘들기 때문에 몇 개의 지역을 깎아서 봉우리의 수를 K개 이하로 줄이려 한다. 위의 그림에서 아래와 같이 5 개의 *을 잘라내면 봉우리의 개수는 1개로 줄어들게 된다.    * * *     -
  * * * * *   - - -   -
* * * * * * * * * * * *
1 2 3 3 3 2 1 1 1 1 1 1땅을 깎는 데에는 매우 많은 비용이 드므로 땅을 깎는 비용을 최소화하려고 한다. 즉 위와 같이 *로 그림을 표현하였을 때, 잘라내는 *의 개수를 최소화 한다는 것이다. 농지의 높이 정보와 K가 주어져 있을 때, 최소로 깎아내는 *의 개수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 농지의 길이 N(1≤N≤1,000)과 K(1≤K≤25) 가 주어진다. 그리고 두 번째 줄부터 N+1번째 줄까지 농지의 높이 h(1≤h≤1,000,000)가 주어진다.
<출력값>
첫 줄에 최소로 깎아내는 *의 개수를 출력한다.

<문제 1845>
1부터 N까지의 자연수가 차례로 적혀 있는 배열이 있다. 아래의 배열은 N=6인 경우의 예이다.




1
			
2
3
4
5
6



이러한 배열에서 임의의 구간 (a, b)를 잡아, 그 구간에 포함되는 수들을 회전시킬 수 있다. 회전을 하게 되면 a번째 칸부터 b번째 칸까지 적혀 있는 수의 순서가 뒤집히고, 부호 또한 바뀌게 된다. (1≤a≤b≤N) 예를 들어 위의 배열에서 (1, 4)에서 회전을 수행한 결과는 아래와 같이 된다.




-4
			
-3
-2
-1
5
6



이미 회전을 수행한 배열에 대해서도 물론 계속 회전을 수행할 수 있다. 다시 (3, 5)에서 회전을 수행하면 최종 배열 상태는 아래와 같이 된다.




-4
			
-3
-5
1
2
6



초기 배열에는 1부터 N까지의 자연수가 차례로 적혀 있다. 최종 배열 상태가 주어졌을 때 가급적 적은 횟수의 회전 연산을 수행하여 초기 배열에서 최종 배열을 만드는 프로그램을 작성하시오.
<입력값>
첫째 줄에 배열의 크기 N(1≤N≤250)이 주어진다. 둘째 줄에는 최종 배열 상태가 빈 칸을 사이에 두고 순서대로 주어진다. 주어지는 수열에는 절댓값이 1 이상 N 이하인 수들이 모두 한 번씩 등장한다.
<출력값>
첫 줄에 회전 연산의 사용 횟수 K를 출력한다. 이어서 K줄에 걸쳐 연산을 사용한 순서대로 회전 연산을 사용한 구간 (a, b)를 나타내는 두 정수 a와 b를 빈 칸을 사이에 두고 출력한다. (1≤a≤b≤N)

<문제 1846>
장기의 말 중 차(車)는 상하좌우 네 방향 중 한 방향으로 몇 칸이든 갈 수 있는 말이다. 예를 들어 차가 아래와 같은 위치에 있다고 할 때, 이 차가 이동할 수 있는 칸은 다음과 같다.

우리는 N×N 모양의 게임판에 N개의 차를 배치하려고 하는데, 다음의 두 가지 조건을 만족시키도록 배치하고 싶다.
1) 어떤 차도 다른 차가 이동할 수 있는 칸에 위치해서는 안 된다. 즉 서로 같은 세로줄 또는 가로줄에 두 개의 차가 위치할 수는 없다.
  2) 두 대각선이 지나는 칸 위에는 차가 위치할 수 없다. N=7인 경우, 대각선이 지나는 칸이란 아래와 같은 칸들을 말한다.

주어진 두 조건을 만족하면서 N×N 모양의 게임판에 N개의 차를 배치하는 프로그램을 작성하시오. 아래는 N=4인 경우 조건을 만족하는 배치가 된다. (색칠된 칸은 차를 놓을 수 없는 칸)
<입력값>
첫째 줄에 N(3≤N≤100,000)이 주어진다.
<출력값>
N개의 줄에 걸쳐, 게임판에서 각 줄의 몇 번째 칸에 차를 배치했는지를 나타내는 칸의 번호를 순서대로 출력한다. 조건을 만족시키는 배치가 둘 이상이면 아무 것이나 출력한다. 배치가 불가능한 경우 첫째 줄에 -1만을 출력한다.

<문제 1847>
하나의 큰 원에 1부터 N까지 숫자가 적힌 점이 시계방향으로 차례로 있다. 그리고 각 점은 서로 다른 두 점과 연결이 되어있다. (즉, 모든 점의 차수는 2라는 뜻이다.)그런데 이 점을 연결하는 과정에서 연결하는 선이 서로 엉켜있다면 이것은 볼록다각형이 되지 못할 것이다. 그래서 원 위에 있는 점을 적절한 곳으로 옮겨서 선이 서로 엉키는 것을 푸려고 한다. 다음 그림을 보자.

처음에 왼쪽 그림과 같이 연결이 되어 있다고 하자. 그리고 4번 점을 빨간색 화살표와 같이 이동하면 오른쪽과 같이 될 것이다. 오른쪽 그림은 서로 엉킨 것이 없어 볼록다각형이 될 것이다.

위의 그림도 마찬가지로 가장 왼쪽에 있는 상태에서 위의 빨간색 화살표를 따라 두 번의 이동을 하면 가장 오른쪽과 같이 서로 엉키는 부분이 없어지게 된다.
1부터 N번까지의 점이 연결된 상태들의 정보가 주어져 있을 때, 엉킨 것을 모두 풀어서 볼록 N각형이 되게 하려면 최소한 몇 번의 점의 이동이 있어야 하는지 구하는 프로그램을 작성하여라.
<입력값>
첫째 줄에 점들의 개수 N(1≤N≤500)이 주어진다. 그리고 두 번째 줄부터 N+1번째 줄까지 점들의 연결 상태가 주어진다. 각 정보는 두 개의 정수로 이루어 져 있는데 i번째 줄에 a와 b 두 정수가 주어져 있다면 i번 점과 a, b가 연결이 되어 있다는 것을 의미한다.
<출력값>
첫 줄에 최소 이동 회수를 출력한다. 만약에 볼록 N각형을 만드는 것이 불가능 한 경우에는 -1을 출력한다.

<문제 1848>
월드산의 하부에는 동굴로 들어가는 입구가 있는데, 동굴은 터널을 통해 서로 연결되어 있는 여러 개의 작은 방들로 구성되어 있다. 동굴 입구는 탐험의 시작점이 되는 방 (이하 시작방)으로 곧장 연결되어 있다. 각 방을 연결하는 터널은 서로 교차하지 않으며, 두 개의 방을 연결하는 터널은 많아 봐야 하나이다.
"원쌤배 동굴 탐험 대회"가 개최될 예정이다. 대회의 목표는 시작방에서 출발하여 동굴 내부를 달려, 다시 시작방으로 되돌아 와 빠져 나오는 것인데, 그 경로는 참가자가 마음대로 정할 수 있지만 두 가지 조건을 지켜야 한다. 첫째 조건은, 시작방 이외의 방을 최소한 하나는 거쳐야 한다는 것이며, 둘째 조건은, 어떤 방과 터널도 최대 한 번밖에 방문할 수 없다는 것이다. (시작방은 물론 두 번 방문하게 되므로 예외이다.)
유명한 동굴 탐험가 김진영은 대회에 참가하기 위해 오랜 준비를 했고, 동굴을 여러 번 사전 답사하여 동굴 내부 구조를 알아내는 데 성공했다. 각각의 터널에 대해, 그는 그 터널을 가로지르는 데 필요한 시간을 계산했는데, 터널을 어느 방향으로 가로지르느냐에 따라 걸리는 시간이 서로 다른 경우도 있을 수 있다고 한다. 동굴 입구와 시작방 사이에서 소요되는 시간이나, 방 내부에서 이동하는데 필요한 시간은 무시할 수 있을 만했다. 이제 그는 경기의 규칙을 만족시키면서도, 가장 짧은 시간 내에 완주할 수 있는 경로를 찾아내려고 한다. 그를 돕기 위한 프로그램을 작성하라.
<입력값>
첫째 줄에 n과 m이 주어진다. (3 ≤ n ≤ 5000, 3 ≤ m ≤ 10000) 이는 각각 동굴 내부의 방의 개수와, 터널의 개수를 나타낸다.
이어지는 m개의 줄에는 각각 터널의 정보를 제공하는 네 개의 숫자 a, b, c, d가 포함되어 있다. 이것은 a번 방에서 b번 방으로 갈 때는 c의 시간이 걸리고, 반대로 b번 방에서 a번 방으로 갈 때는 d의 시간이 걸린다는 의미이다. (1 ≤a, b ≤ n. a ≠ b. 1 ≤ c, d ≤ 10000)
방의 번호는 1번부터 n번까지 연속하여 붙어 있으며, 1번 방이 시작방이다. 언제나 조건을 만족하는 경로가 하나는 있다고 가정해도 좋다.
<출력값>
동굴 탐험에 소요되는 최소시간을 출력한다.

<문제 1849>
1부터 N까지의 수들이 한 번씩 쓰인 수열이 있다. 그 수열에서 i 앞에 있는 수 들 중, i보다 큰 수들의 개수를 A[i]라고 정의하자. A[i]가 주어져 있을 때, 원래 수열을 구하는 프로그램을 작성하여라.
<입력값>
첫째 줄에 수열 원소의 개수 (1 ≤ N ≤100,000)이 주어진다. 그리고 두 번째 줄부터 N+1 번째 줄까지 차례로 A[i]가 주어진다.
<출력값>
N개의 줄에 걸쳐서 수열을 출력한다. (i번째 줄에는 i번째 원소를 의미한다)

<문제 1850>
모든 자리가 1로만 이루어져있는 두 자연수 A와 B가 주어진다. 이때, A와 B의 최대 공약수를 구하는 프로그램을 작성하시오.
예를 들어, A가 111이고, B가 1111인 경우에 A와 B의 최대공약수는 1이고, A가 111이고, B가 111111인 경우에는 최대공약수가 111이다.
<입력값>
첫째 줄에 두 자연수 A와 B를 이루는 1의 개수가 주어진다. 입력되는 수는 263보다 작은 자연수이다.
<출력값>
첫째 줄에 A와 B의 최대공약수를 출력한다. 정답은 천만 자리를 넘지 않는다.

<문제 1851>
n개의 추가 여러분 앞에 왼쪽에서 오른쪽까지 일렬로 놓여 있다. 추의 무게는 모두 다르며, 추가 놓여 있는 순서는 무게와 무관한 임의의 순서이다.
이 추를 무게에 따라 왼쪽에서 오른쪽으로 오름차순 정렬하고자 한다. 정렬을 위해서는 두 개의 추를 들어서 서로의 위치를 바꾸는 방법을 쓰는데, 당연히 무거운 추일수록 드는 데 많은 에너지가 필요할 것이다. 무게가 각각 X와 Y인 추의 위치를 서로 바꾼다고 하면, X+Y만큼 에너지가 소모된다고 하자. 여러분이 해야 할 일은 추를 정렬하는 데에 최대한 적은 에너지를 사용하도록, 추의 정렬 계획을 세우는 것이다.
<입력값>
첫째 줄에 추의 개수 n이 주어진다. (1 ≤ n ≤ 100,000) 다음 n개의 줄에는 왼쪽에 놓여 있는 추의 것부터 순서대로 무게가 주어진다. (1 ≤ 추의 무게 ≤ 1,000,000)
<출력값>
첫 줄에 필요한 최소의 에너지를 출력하면 된다.

<문제 1852>
N×3 크기의 2차원 배열에 수들이 적혀 있다. 이 배열에서 상하좌우로 인접한 두 칸을 하나로 묶되, 모든 칸들이 묶이도록 하려고 한다. 다음은 4×3 크기의 2차원 배열을 묶는 두 개의 예이다.

묶인 배열에 대해서 우리는 묶인 수들의 차를 생각할 수 있다. 첫 번째 경우 묶인 수들의 차의 총 합은 5+8+5+3+2+6=29로, 묶인 숫자의 차들의 합을 최대로 할 수 있는 방법이다. 두 번째 경우 묶인 숫들의 차의 총 합은 1+3+2+2+3+4=15이다. 이 방법은 묶인 숫자의 차들의 합을 최소로 할 수 있는 방법이다.
배열이 주어졌을 때, 묶인 수들의 차의 최대 합과 최소 합을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 짝수 N(1≤N≤100,000)이 주어진다. 이어서 다음 N개 줄에는 배열에 적힌 수들이 한 줄에 세 개씩 빈 칸을 사이에 두고 주어진다. 배열에 적힌 수는 절댓값이 10,000을 넘지 않는 정수이다.
<출력값>
첫째 줄에 최대 합, 둘째 줄에 최소 합을 출력한다.

<문제 1853>
3차원 공간에 입체도형이 있다. 이 입체도형은 볼록하며, xz평면과 yz평면에 수직으로 빛을 비췄을 때에 나오는 그림자가 볼록다각형 형태를 띤다. 즉, 입체도형의 두 평면에 대한 정사영이 볼록다각형이다. 예를 들어 밑의 그림과 같이 xz평면과 yz평면 위로의 정사영을 각각 Pxz, Pyz라 했을 때 각각이 볼록다각형임을 확인할 수 있다.

우리가 해야 할 일은 위와 같은 입체도형을 xz평면과 yz평면에 정사영시킨 형태가 주어졌을 때에 원본 입체도형을 복원해 그 부피를 구하는 것이다. 하지만 이 정보만으로 입체도형을 유일하게 복원할 수 없기 때문에 가능한 최대 부피를 구해야 한다.
<입력값>
첫째 줄에 xz평면에 비친 정사영의 꼭짓점의 개수 Nxz (3 ≤ Nxz ≤ 1,000)가 주어진다. 그리고 두 번째 줄부터 Nxz+1번째 줄까지 Pxz의 꼭짓점의 좌표 x,z가 시계방향 순서로 공백을 사이에 두고 주어진다. 그리고 Nxz+2번째 줄에는 yz평면에 비친 정사영의 꼭짓점의 개수 Nyz (3 ≤ Nyz ≤ 1,000)가 주어지고 마찬가지로 Nxz+3번째 줄부터 Nxz+Nyz+2번째 줄까지 Pyz의 꼭짓점 좌표 y, z가 시계방향 순서로 공백을 사이에 두고 주어진다.
주어지는 모든 좌표는 절댓값이 500이하이다. 또한 입력되는 두 다각형은 볼록다각형임이 보장되며, 두 다각형의 최소, 최대 z 좌표는 각각 동일하다. 각 다각형의 입력에서 인접한 두 점은 항상 다르지만, 한 변 위에 있는 세 개 이상의 점이 입력될 수는 있다.
<출력값>
첫째 줄에 원본 입체도형의 부피로 가능한 최댓값을 출력한다. 절대/상대 오차는 10-2까지 허용한다.

<문제 1854>
봄캠프를 마친 김진영 조교는 여러 도시를 돌며 여행을 다닐 계획이다. 그런데 김 조교는, '느림의 미학'을 중요시하는 사람이라 항상 최단경로로만 이동하는 것은 별로 좋아하지 않는다. 하지만 너무 시간이 오래 걸리는 경로도 그리 매력적인 것만은 아니어서, 적당한 타협안인 'k번째 최단경로'를 구하길 원한다. 그를 돕기 위한 프로그램을 작성해 보자.
<입력값>
첫째 줄에 n, m, k가 주어진다. (1 ≤ n ≤ 1000, 0 ≤ m ≤ 2000000, 1 ≤ k ≤ 100) n과 m은 각각 김 조교가 여행을 고려하고 있는 도시들의 개수와, 도시 간에 존재하는 도로의 수이다.
이어지는 m개의 줄에는 각각 도로의 정보를 제공하는 세 개의 정수 a, b, c가 포함되어 있다. 이것은 a번 도시에서 b번 도시로 갈 때는 c의 시간이 걸린다는 의미이다. (1 ≤ a, b ≤ n. 1 ≤ c ≤ 1000)
도시의 번호는 1번부터 n번까지 연속하여 붙어 있으며, 1번 도시는 시작도시이다.
<출력값>
n개의 줄을 출력한다. i번째 줄에 1번 도시에서 i번 도시로 가는 k번째 최단경로의 소요시간을 출력한다.
경로의 소요시간은 경로 위에 있는 도로들을 따라 이동하는데 필요한 시간들의 합이다. i번 도시에서 i번 도시로 가는 최단경로는 0이지만, 일반적인 k번째 최단경로는 0이 아닐 수 있음에 유의한다. 또, k번째 최단경로가 존재하지 않으면 -1을 출력한다. 최단경로에 같은 정점이 여러 번 포함되어도 된다.

<문제 1855>
준표와 세준이는 서로 솔루션을 토론 하면서 다른 사람이 자신들의 솔루션을 듣지 못하게 하도록 서로 메시지를 주고받을 때 메시지를 암호화 하여서 주고받았다. 암호를 만드는 방법은 다음과 같다. 먼저 암호화 할 문자열을 1,1부터 위에서 아래 순서대로 채운다. 그리고 가장 밑의 행을 채운 후에는 오른쪽 열에서 다시 같은 과정을 반복한다. 만약에 "abcdefghijkl" 이라는 문자열을 3개의 열로 암호화 한다고 하자. 그러면 다음과 같이 표를 채울 수 있을 것이다.






a


e


i




b


f


j




c


g


k




d


h


l






그런 후에는 이제 왼쪽-> 오른쪽, 오른쪽-> 왼쪽, 왼쪽->오른쪽 ... 으로 읽으면서 다시 문자열을 만든다. 위의 경우에는 "aeijfbcgklhd" 가 될 것이다.
우리가 할 일은 다음과 같다. 암호화 된 문자열과 몇 개의 열로 암호화를 하였는지 주어져 있을 때 원래의 문자열을 구하는 프로그램을 작성하여라.
<입력값>
열의 개수 K(1≤K≤20)가 주어지고 두 번째 줄에는 암호화 된 문자열(모두 영소문자)이 주어진다. (문자열의 길이는 200 이하이며 K의 배수이다.)
<출력값>
첫 줄에 원래의 문자열을 출력한다..

<문제 1856>
단어가 w개 실린 사전이 하나 주어진다. 사전에 실린 단어들은 모두 a에서 z까지의 알파벳 소문자들로만 이루어져 있고, 길이는 각각 25자 이하이다.길이가 l인 문자열 S도 하나 주어진다. 이 문자열에서 몇 개의 문자를 제거하면, 나머지를 사전에 실린 단어들로 표현해 낼 수 있다. 표현해 낼 수 있다는 것이 무슨 뜻인지는, 입출력 예시를 통해 이해하면 된다.여러분이 할 일은 이렇게 사전에 실린 단어들로 이 문자열을 표현해 내기 위해, 문자열에서 제거해야 하는 문자의 최소 개수가 몇 개인지 계산하는 것이다.
<입력값>
첫째 줄에 w와 l이 주어진다. (1≤w≤600, 2≤l≤300) 두 번째 줄에는 문자열 S가 주어진다. 이어지는 w개의 줄에는 사전 내의 각 단어가 한 줄에 한 개씩 주어진다.
<출력값>
첫 줄에, S에서 제거해야만 하는 최소한의 문자 개수를 출력한다.

<문제 1857>
김주성은 사실 뛰어난 발레 실력을 숨기고 있다. 그는 매일 밤 열심히 발레 연습을 한다.
그는 항상 연습하는 곳의 바닥을 m행 n열의 정사각형 칸들로 나누어 놓고 춤을 춘다. 그가 춤을 추는 방식은 이 직사각형 격자판 위를 점프하여 돌아다니는 것인데, 현재 위치하고 있는 칸에서 점프할 수 있는 위치는 체스판 위의 나이트 (knight)가 이동할 수 있는 곳과 같다. (나이트의 이동 규칙을 모르는 경우 검색해 볼 것. ㅜ.ㅜ) 김주성은 특정한 위치에서 춤을 시작하여, 특정한 위치에서 춤을 마치고 싶다.
밤중에 쿵쿵거리면 실례이므로, 바닥에 방석을 깔아 놓고 춤을 추려고 한다. 방석은 격자칸 한 칸에 꼭 맞는 크기이고, 몇 개의 칸에는 방석이 이미 놓여 있다. 특히, 김 조교가 현재 서 있는 위치와, 최종적으로 도달하려고 하는 위치에는 이미 방석이 놓여 있다.
여러분이 할 일은 최소한의 방석을 더 놓아서 김주성의 춤이 가능하도록 만들고, 그렇게 할 수 있는 방법이 모두 몇 가지인지 계산하는 것이다. 다만, 돌멩이가 놓여 있는 칸도 있는데, 그 부분에는 방석을 놓지 않는다. 부상의 위험이 있기 때문이다.
<입력값>
첫째 줄에 m과 n이 주어진다. (1≤m, n≤30)
이어지는 m개의 줄에는 각 행의 정보를 제공하는 n개의 숫자가 주어진다. 0은 맨땅, 1은 방석이 깔린 곳 중 김주성이 춤을 시작하거나 마치지 않는 위치, 2는 돌멩이가 있는 위치, 3은 김주성이 춤을 시작하는 위치 (방석이 깔려 있음), 4는 김주성이 춤을 마치는 위치 (방석이 깔려 있음)이다.
<출력값>
첫 줄에 필요한 최소의 방석 수를 출력한다. 만약 아무리 방석을 많이 놓아도 김주성의 춤이 불가능할 경우엔, -1을 출력한다. 둘째 줄엔 방석을 놓는 방법의 수를 출력한다. (이 수는 64-bit signed integer 범위 내에 있음을 보장한다.) 만약 첫 줄에 -1을 출력한 경우에는, 둘째 줄은 출력하지 않는다.

<문제 1858>
평면상에 N개의 서로 다른 점들이 주어져 있을 때, 그 중 임의의 두 점을 지나는 직선의 기울기의 절댓값이 가장 큰 두 점을 찾고 싶다. 두 점의 좌표가 (x1, y1), (x2, y2) 라고 할 때, 기울기의 절댓값은 다음과 같은 수식으로 표현된다.
| (y2-y1) / (x2-x1) |
  모든 점의 x좌표는 다르다고 하자. 또한, 모든 점의 y좌표 역시 다르다고 하자.점들의 좌표가 주어지면 임의의 두 점을 지나는 직선의 기울기의 절댓값이 가장 큰 두 점을 찾는 프로그램을 작성하시오.
<입력값>
첫째 줄에 점의 개수 N(1≤N≤50,000)이 주어진다. 이어서 N개의 줄에 걸쳐 각 점의 x좌표와 y좌표가 빈 칸을 사이에 두고 주어진다. 좌표는 절댓값이 30,000을 넘지 않는 정수이다. 모든 점은 입력되는 순서대로 1번부터 N번까지 번호가 매겨진다.
<출력값>
기울기의 절댓값이 가장 큰 두 점의 번호 A와 B를 빈 칸을 사이에 두고 출력한다. (A<B) 그러한 두 점의 쌍이 둘 이상인 경우 A가 가장 작은 것을 출력하고, 만일 A가 가장 작은 답도 여러 가지가 있으면 B가 가장 작은 것을 출력한다.

<문제 1859>
동호는 월드 고등학교의 학생이다. 동호는 학교에서 N개의 시험을 봤다. 시험 점수는 Ti와 Pi로 주어진다. Ti는 i번째 시험에서 동호가 받은 점수를 의미하고, Pi는 i번째 시험의 토탈 점수를 의미한다.
이제 이 N개의 점수를 가지고 성적을 매겨야 하는데 성적은 Ti의 합을 Pi의 합으로 나눈 값을 의미한다. 만약에 동호가 1/2, 5/9, 3/8, 4/10, 1/3 의 점수를 얻었다면 (Ti/Pi의 형식) 동호가 받을 성적은 1+5+3+4+1/2+9+8+10+3 = 14/32 ≒ 0.44가 될 것이다.
그런데 동호의 담임 선생님은 그냥 이렇게 점수를 주면 동호의 성적이 너무 형편없기 때문에 동호가 본 N개의 시험 중, Ti를 Pi로 나눈 값, 즉 백분율이 작은 D개의 시험을 빼서 N-D개의 시험에 대해서만 성적을 합산하려 한다. 예를 들어 위에서 D가 1일 경우에는 1/3이 가장 작기 때문에 동호의 성적은 1/3을 뺀 1/2, 5/9, 3/8, 4/10을 더한 1+5+3+4/ 2+9+8+10 = 13/29 ≒ 0.45가 된다.
그런데 동호는 이러한 선생님의 선택에 반발을 하였다. 어차피 D개의 성적을 뺄 거면 다른 것을 빼지 왜 백분율이 작은 것을 빼냐는 것이다. 만약에 D가 1일 경우 1/3을 빼지 않고 3/8을 빼면 점수가 11/24 ≒ 0.46이 되어 위의 경우보다 점수가 더 높게 된다는 것이다.
동호의 담임선생님은 점수를 올려준다는데도 이에 반발한 동호에게 매우 화가 났다. 그래서 동호의 담임선생님은 즉석에서 다음과 같은 문제를 동호에게 내 주었다. 동호의 시험 점수가 주어져 있을 때, 동호의 이론이 성립하는 D를 모두 구하라는 것이다. 즉, 백분율이 작은 D개를 빼는 것 보다 다른 D개를 빼서 점수를 더 높이는 것이 가능한 D를 모두 구하라는 것이다. 동호는 매우 당황하였다. 점수를 올리려다가 큰 난관에 부딪힌 것이다. 여러분은 동호를 도와서 위의 조건은 만족하는 D를 모두 구하는 프로그램을 작성하여야 한다.
<입력값>
첫째 줄에 동호가 시험을 본 개수 N(1≤N≤5,000, 단 마지막 데이터의 경우에 한해서 N=50,000이다). 그리고 두 번째 줄부터 N+1번째 줄까지 N개의 줄에 걸쳐 Ti와 Pi가 (0 ≤ Ti ≤ Pi ≤ 40,000  0 < Pi) 공백을 사이에 두고 주어진다.
<출력값>
첫 줄에 가능한 D의 개수 K(0≤K≤N) 를 출력한다. 그리고 두 번째 줄부터 K+1번째 줄까지 가능한 D를 오름차순으로 모두 출력한다.

<문제 1860>
동주는 매우 훌륭한 예술가이다. 동주는  크고 훌륭한 예술 작품을 만들기를 매우 좋아한다. 그러던 어는 날 동주는 자신의 논에 큰 거미줄 모양의 예술작품을 만들 계획을 세웠다.동주의 계획은 다음과 같다. 먼저 자신의 논에 N개의 기둥을 세워 커다란 볼록 다각형을 만든 후, 두 기둥에 줄을 연결한다. 그런데 줄을 연결하는데 제약 조건이 있다. 먼저 좀 더 훌륭한 예술 작품이 나오기 위해서 이웃한 두 개의 기둥에는 줄을 연결할 수가 없다. 그리고 줄이 서로 교차하게 되면 나중에 해체할 때 힘들기 때문에 줄이 서로 교차하는 일은 없어야 한다. 그리고 한 가지의 큰 문제점이 있다. 동주의 논은 매우 오랜 시간동안 관리를 하지 않았기 때문에 반지름이 R인 원 모양의 물웅덩이가 G개 있다.  물웅덩이 위로 줄을 연결하는 일은 매우 힘든 일이므로 물웅덩이 위로 줄이 연결되는 일은 없어야 한다. (물웅덩이의 경계를 지나는 경우도 허용되지 않는 것으로 한다.)동주의 목적은 위의 조건을 만족 하면서 줄을 최대한 많이 연결 하는 것이다. 여러분은 동주를 도와 N개의 기둥의 좌표와 물웅덩이의 반지름 R과 G개의 물웅덩이의 중심 좌표가 주어져 있을 때 몇 개의 줄로 연결할 수 있는지 구하는 프로그램을 작성하여야 한다.
<입력값>
첫째 줄에 기둥의 개수 N(1≤N≤150), 웅덩이의 개수   G(1≤G≤100), 웅덩이들의 반지름 R(1≤R≤100,000)이 주어진다. 그리고 두 번째 줄부터 N+1번째 줄까지 기둥의 좌표가 주어진다. 그리고 N+2번째 줄부터 N+G+1번째 줄까지 G개의 줄에 걸쳐 웅덩이의 중심의 좌표가 주어진다. 좌표는 0 이상 1,000,000 이하의 정수이다.
<출력값>
첫 줄에 연결할 수 있는 최대 줄의 개수를 출력한다.

<문제 1861>
N×N의 이차원 배열 A가 있고, A의 각 원소는 -100부터 100 사이의 임의의 정수 값을 갖는다. 이 이차원 배열의 A[1][1]부터 시작하여 A[N][N]에 이르는 경로를 선택하려 하는데, 아래와 같은 제약 조건이 있다.

상하좌우로 인접한 원소들을 방문해 나가야 한다. 즉 왼쪽, 오른쪽, 위쪽, 아래쪽의 네 가지 이동이 가능하다. 대각선으로는 이동이 불가능하다.
한 번 방문한 원소는 다시 방문할 수 없다.

이러한 제약을 만족하면서 임의의 경로를 따라 A[N][N]에 이르면 이 경로 상에 방문되었던 원소들의 값의 총합이 그 경로의 점수가 된다. 임의의 N×N 이차원 배열이 주어질 때, A[1][1]에서 A[N][N]에 이르는 경로의 점수를 최대화하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 이차원 배열의 크기를 나타내는 정수 N(3≤N≤100)이 주어진다. 다음 N개의 줄에는 각각의 N개의 정수(-100이상 100이하)가 빈 칸을 사이에 두고 주어지는데, 둘째 줄에는 A[1][1]～A[1][N], 셋째 줄에는 A[2][1]～A[2][N], … , N+1번째 줄에는 A[N][1]～A[N][N]의 값이 주어진다.
<출력값>
첫째 줄에 프로그램이 구한 경로의 점수를 출력한다. 둘째 줄에는 이동 경로를 나타내는 문자들을 빈 칸을 사이에 두고 출력한다. 왼쪽은 L, 오른쪽은 R, 위쪽은 U, 아래쪽은 D로 나타내며, A[1][1]에서부터의 이동을 순서대로 출력하면 된다.

<문제 1862>
수현이의 차에는 미터계가 있다. 그런데 이 미터계에는 문제가 있다. 숫자 4를 표시할 수가 없어서 3 다음에는 바로 5라는 숫자 체계를 갖고 있다는 것이다.  만약에 15339m에서 수현이의 차가 1m를 더 달린다면 15350m로 표시가 된다. (15340m의 4가 5로 바뀐 것이다.)
우리가 하여야 할 일은 다음과 같다. 수연이의 차에 있는 미터계에 있는 숫자가 주어져 있을 때 원래 수현이의 차가 달린 거리는 얼마인지 구하는 프로그램을 작성하여라.
<입력값>
첫째 줄에 미터계에 표시된 거리가 주어진다. 단, 이 거리는 정수이고, 1 이상 999,999,999 이하이다.
<출력값>
첫째 줄에 원래 달린 거리를 출력한다.

<문제 1863>
도시에서 태양이 질 때에 보이는 건물들의 윤곽을 스카이라인이라고 한다. 스카이라인만을 보고서 도시에 세워진 건물이 몇 채인지 알아 낼 수 있을까? 건물은 모두 직사각형 모양으로 밋밋하게 생겼다고 가정한다.
정확히 건물이 몇 개 있는지 알아내는 것은 대부분의 경우에 불가능하고, 건물이 최소한 몇 채 인지 알아내는 것은 가능해 보인다. 이를 알아내는 프로그램을 작성해 보자.
<입력값>
첫째 줄에 n이 주어진다. (1≤n≤50,000) 다음 n개의 줄에는 왼쪽부터 스카이라인을 보아 갈 때 스카이라인의 고도가 바뀌는 지점의 좌표 x와 y가 주어진다. (1≤x≤1,000,000. 0≤y≤500,000) 첫 번째 지점의 x좌표는 항상 1이다.
<출력값>
첫 줄에 최소 건물 개수를 출력한다.

<문제 1864>
해류가 매우 느리고 바닥을 기어다니는 생물이 적은 바다 밑바닥에서만 발견되는 잔물결 무늬의 정체는 오랫동안 해양학자들에게 수수께끼였다. 하지만 최근의 연구 성과는 동물 언어학 분야에 일대 혁명을 불러왔다. 이 무늬의 정체는 바로 문어가 숫자를 적는 방법이라는 것이 해양 생물학자들에 의해 밝혀진 것이다. 학자들은 문어가 무엇을 세는 것인지는 아직 알 수 없지만, 수 표기법을 해독하는 데에는 성공했다.
뭍 위에 사는 이들에게는 문어가 쓰는 숫자와 그를 표현하는 잔물결 무늬가 매우 낯설 수밖에 없다. 따라서 연구자들은 다음과 같은 기호로 잔물결 무늬를 적기로 합의했다. 각 기호와 대응하는 숫자는 다음과 같다.

-는 0에 대응한다.
\는 1에 대응한다.
(는 2에 대응한다.
@는 3에 대응한다.
?는 4에 대응한다.
>는 5에 대응한다.
&는 6에 대응한다.
%는 7에 대응한다.
/는 -1에 대응한다.

해양 신경학자들은 특히 음수를 나타내는 기호가 있다는 사실에 흥분하면서, 아직 걸음마 단계인 두족류 신경학이 이 발견을 계기로 크게 발전하기를 기대하고 있다.
당연히 문어의 수 체계는 8진법에 기반한다. 예를 들면 다음과 같다.
(@&는 2 × 82 + 3 × 8 + 6 = 158이다.
?/--는 4 × 83 + −1 × 82 + 0 × 8 + 0 = 1984이다.
/(\는 −1 × 82 + 2 × 8 + 1 = −47이다.
당신에게 주어진 문제는 문어 숫자를 입력 받아 십진수로 나타내는 것이다.
<입력값>
한 줄에 하나씩 문어 숫자가 입력으로 주어진다. 각 숫자는 최소 한 개, 최대 여덟 개의 문어 숫자 기호로 이루어져있다. 입력으로 '#'이 들어오면 입력을 종료한다.
<출력값>
입력 받은 문어 숫자에 대응하는 십진수를 한 줄에 하나씩 출력한다.

<문제 1865>
때는 2020년, 백준이는 월드나라의 한 국민이다. 월드나라에는 N개의 지점이 있고 N개의 지점 사이에는 M개의 도로와 W개의 웜홀이 있다. (단 도로는 방향이 없으며 웜홀은 방향이 있다.) 웜홀은 시작 위치에서 도착 위치로 가는 하나의 경로인데, 특이하게도 도착을 하게 되면 시작을 하였을 때보다 시간이 뒤로 가게 된다. 웜홀 내에서는 시계가 거꾸로 간다고 생각하여도 좋다.
시간 여행을 매우 좋아하는 백준이는 한 가지 궁금증에 빠졌다. 한 지점에서 출발을 하여서 시간여행을 하기 시작하여 다시 출발을 하였던 위치로 돌아왔을 때, 출발을 하였을 때보다 시간이 되돌아가 있는 경우가 있는지 없는지 궁금해졌다. 여러분은 백준이를 도와 이런 일이 가능한지 불가능한지 구하는 프로그램을 작성하여라.
<입력값>
첫 번째 줄에는 테스트케이스의 개수 TC(1 ≤ TC ≤ 5)가 주어진다. 그리고 두 번째 줄부터 TC개의 테스트케이스가 차례로 주어지는데 각 테스트케이스의 첫 번째 줄에는 지점의 수 N(1 ≤ N ≤ 500), 도로의 개수 M(1 ≤ M ≤ 2500), 웜홀의 개수 W(1 ≤ W ≤ 200)이 주어진다. 그리고 두 번째 줄부터 M+1번째 줄에 도로의 정보가 주어지는데 각 도로의 정보는 S, E, T 세 정수로 주어진다. S와 E는 연결된 지점의 번호, T는 이 도로를 통해 이동하는데 걸리는 시간을 의미한다. 그리고 M+2번째 줄부터 M+W+1번째 줄까지 웜홀의 정보가 S, E, T 세 정수로 주어지는데 S는 시작 지점, E는 도착 지점, T는 줄어드는 시간을 의미한다. T는 10,000보다 작거나 같은 자연수 또는 0이다.
두 지점을 연결하는 도로가 한 개보다 많을 수도 있다. 지점의 번호는 1부터 N까지 자연수로 중복 없이 매겨져 있다.
<출력값>
TC개의 줄에 걸쳐서 만약에 시간이 줄어들면서 출발 위치로 돌아오는 것이 가능하면 YES, 불가능하면 NO를 출력한다.

<문제 1866>
진영 택배 회사는 물품을 빠르고 정확하게 배송하기로 유명하다. 본점으로 수집된 물품은 각각 지정된 지점으로 배송되는데, 본점은 고속도로가 시작하는 곳에 있고, 지점들은 1번부터 10,000번까지 번호 순서대로 고속도로를 따라 일정한 간격으로 놓여 있다.진영 택배 회사에서 물품을 옮기는 데는 트럭과 헬리콥터를 이용하는 두 가지 방법이 있다. 트럭은 본점에서 지점으로 또는 지점에서 다른 지점으로 물품을 옮기는 데 사용되고, 헬리콥터는 본점에서 지점으로 물품을 옮기는 데 사용된다. 트럭이 한 물품을 운반하는 비용은 그 물품의 운송 거리에 비례하고, 헬리콥터는 물품의 개수와 운송 거리와는 상관없이 비용이 일정하다. 트럭으로는 한 번에 하나의 물품을 운송할 수 있으나, 헬리콥터가 운송할 수 있는 물품의 개수는 제한이 없다. 풍족한 진영 택배 회사에는 항상 충분한 수의 트럭과 헬리콥터가 준비되어 있다고 가정한다. 예를 들어, 본점에 10번, 40번, 30번, 50번, 10번 지점으로 옮겨야 하는 5개의 물품이 접수되었는데, 물품 하나를 트럭으로 한 지점 간격 옮기는 데는 10만큼의 비용이 들고, 헬리콥터를 한 번 이용하는 데는 물품의 개수나 거리에 상관없이 200만큼의 비용이 든다고 하자. 5개의 물품을 모두 트럭을 이용해서 옮기면 1400만큼의 비용이 든다. 하지만 10번 지점으로 가야하는 두 물품은 트럭으로 옮기고, 나머지 세 물품은 한꺼번에 40번 지점으로 헬리콥터를 이용해 옮기면 40번 지점으로 갈 물품은 목적 지점에 도착되었고, 이어 30번 지점과 50번 지점으로 갈 물품을 40번 지점에서 각각 트럭을 이용하여 옮기면, 총 600만큼의 비용이 든다.배송할 물품의 총 개수와, 각 물품의 목적 지점, 트럭과 헬리콥터 사용 비용이 주어졌을 때, 모든 물품을 목적 지점으로 옮기는 데 드는 총 비용의 최솟값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 배송해야 할 물품의 개수 N이 주어진다. (1≤N≤3,000) 둘째 줄에는 각 물품의 목적 지점의 번호가 빈 칸을 사이에 두고 주어진다. 지점의 번호는 10,000 이하의 자연수이다. 셋째 줄에는 물품 하나를 트럭으로 한 지점 간격 옮기는 데 드는 비용과, 헬리콥터를 한 번 이용하는 데 드는 비용이 빈 칸을 사이에 두고 차례로 주어진다. 이들 비용은 각각 1,000이하의 자연수이다.
<출력값>
첫째 줄에 모든 물품을 목적 지점으로 옮기는 데 드는 총 비용의 최솟값을 출력한다. 모든 입력에 대하여 가능한 배송 방법의 총 비용은 10억 이하의 자연수라고 가정해도 좋다.

<문제 1867>
n행 n열의 격자로 나뉜 운동장이 있다. 이 위에 k개의 돌멩이가 있는데, 하나의 돌멩이는 격자 한 칸에 정확히 들어가 있으며, 두 개 이상의 돌멩이가 한 칸에 들어가 있는 경우는 없다.
사고의 위험을 없애기 위해 이 돌멩이를 모두 제거하고 깨끗한 운동장을 만들려고 한다. 돌멩이를 제거할 때에는, 한 행이나 한 열을 따라 직선으로 달려가면서 그 행이나 열에 놓인 돌멩이를 모두 줍는 방식을 쓴다.
여러분이 할 일은 운동장의 상태가 주어졌을 때 최소 몇 번이나 달려가야 돌멩이 줍기를 끝낼 수 있는지 계산하는 것이다.
<입력값>
첫째 줄에 n과 k가 주어진다. (1 ≤ n ≤ 500, 1 ≤ k ≤ 10,000) 이후 k개의 줄에는 돌멩이의 위치가 한 줄에 하나씩 주어진다. 줄마다 첫 번째 숫자는 행 번호, 두 번째 숫자는 열 번호를 나타낸다.
<출력값>
첫 줄에 몇 번의 달리기를 통해 돌멩이를 주울 수 있는지 출력한다.

<문제 1868>
n개의 방으로 이루어진 미로가 있다. 이 미로 내의 임의의 두 방 사이에는 반드시 하나의 경로가 존재하고, 그 경로는 유일하다.
이 방들 중 한 방에는 김주성 조교가 보물을 숨겨 놓았는데, 김진영 조교는 이 보물을 찾길 원한다. 그러기 위해서, 김진영 조교는 김주성 조교에게 특정한 방에 보물이 있는지 물어 본다. 친절한 김주성 조교는 김진영 조교가 옳은 방을 골랐으면 그렇다고 말해 주고, 옳은 방을 고르지 않았다면 그 방에 연결된 복도 중 어느 복도를 따라 가야만 보물을 찾을 수 있는지 말해 준다.
여러분이 할 일은 미로의 구조가 주어졌을 때 김진영 조교가 최악의 경우에 몇 번의 질문을 던져야 하는지 계산해 내는 것이다. 물론, 영리한 김진영 조교는 항상 최선의 질문을 한다.
<입력값>
첫째 줄에 n이 주어진다. (1≤n≤50,000) 이후 n-1개의 줄에는 각각 두 개의 숫자가 주어진다. a와 b가 주어졌다면, a번 방과 b번 방 사이에 복도가 있어 왕래할 수 있다는 의미이다. 방의 번호는 1번부터 n번까지 연속해서 붙어 있다.
<출력값>
첫 줄에 김진영 조교가 최선을 다하더라도, 최악의 경우 몇 번의 질문을 던져야 하는지 출력한다.

<문제 1869>
길이가 정수인 여러 개의 막대기가 있다. 막대기들 중에는 서로 길이가 같은 것도 있고, 다른 것도 있다. 이 중에서 여섯 개의 막대기를 골라 적당한 순서로 이어서 육각형 모양을 만들고 싶다. 여러 개의 막대기를 일직선으로 붙여 더 긴 막대기를 만들거나, 막대기를 더 짧은 길이로 조각낼 수는 없다. 또한, 육각형에 있는 여섯 개의 내각의 크기가 모두 같도록 하고 싶다.

위의 그림은 모든 내각의 크기가 같도록 만든 육각형의 예이다. 왼쪽의 육각형에서 알 수 있듯 막대기의 길이가 모두 같지 않다고 하더라도 주어진 조건을 만족하도록 육각형 모양을 만들 수 있는 경우도 있다.
막대기의 길이에 대한 정보가 주어졌을 때, 조건을 만족하면서 만들 수 있는 서로 다른 육각형의 개수를 구하는 프로그램을 작성하시오. 육각형을 회전하거나 뒤집어서 모양이 같아지는 경우는 하나의 육각형으로 생각한다.
<입력값>
첫째 줄에는 막대기의 개수 N(6≤N≤80)이 주어진다. 다음 줄에는 막대기의 길이를 나타내는 N개의 자연수가 빈 칸을 사이에 두고 주어진다. 막대기의 길이는 1,000,000을 넘지 않는 자연수이다.
<출력값>
첫째 줄에 조건을 만족하면서 만들 수 있는 서로 다른 육각형의 개수를 출력한다.

<문제 1870>
동원이는 지붕을 제작하는 한 건축가이다. 그리고 민균이는 지붕을 디자인하는 디자이너이다. 동원이는 민균이가 제작한 지붕의 디자인을 받아 지붕을 만들려 한다.
그런데 민균이가 제작한 디자인은 미적 효과에만 치중하였기 때문에 볼록다각형의 모양이 아니다. 그렇게 되면 비가 오거나 눈이 오면 밑으로 흘러내리지 않는 문제점이 생기게 된다. 그래서 동원이는 민균이가 준 지붕의 디자인을 조금 개선하여 볼록다각형 모양으로 지붕을 새로 만들려 한다.
민균이는 지붕을 디자인할 때 몇 개의 점을 가지고 디자인 하였다. 동원이는 이 점들을 가지고 다시 디자인을 하는데 제약 조건이 있다. 먼저 민균이가 디자인한 점은 모두 지붕의 아래에 있어야 한다. 그리고 지붕의 변의 개수는 K개 이하가 되어야 한다.
당신이 하여야 할 일은 다음과 같다. 동원이가 새로 디자인 한 지붕이 민균이가 디자인 한 것과 너무 많이 차이가 나면 민균이가 불만이 많기 때문에 차이를 최소로 하려 한다. 단, 디자인의 차이는 아래 그림으로 설명을 할 것이다.

 

  K=2이며 위의 그림이 민균이가 한 디자인이고 밑에 두 그림이 동원이가 새로 디자인한 그림이라고 하자. 여기서 동원이가 만든 지붕과 민균이가 디자인한 지붕의 차이는 그림의 max를 의미한다. 즉 민균이가 만든 점에서 동원이가 디자인한 지붕과의 세로축 차이 중 최댓값을 의미한다는 말이다.
민균이가 디자인한 점들과 K가 주어져 있을 때, 동원이가 디자인한 지붕과 민균이가 디자인한 지붕과의 차이의 최솟값을 구하는 프로그램을 작성하여라.
<입력값>
첫째 줄에 점의 개수 N과 변의 개수 k (1≤N≤100, 1≤k≤N) 가 주어진다. 그리고 두 번째 줄부터 N+1번째 줄까지 N개의 줄에 걸쳐서 점의 좌표 (x,y)가 주어진다. 단, x와 y는 0부터 10000 사이의 소수이다.
<출력값>
첫째 줄에 최소 차이를 출력한다.

<문제 1871>
앨버타의 자동차 번호판은 ABC-0123 (세 글자, 네 숫자)와 같이 두 부분으로 나누어져 있다.
좋은 번호판은 첫 번째 부분의 가치와 두 번째 부분의 가치의 차이가 100을 넘지 않는 번호판이다.
글자로 이루어진 첫 번째 부분의 가치는 글자를 26진법 수처럼 계산한다. (각 자리가 [A..Z]) 예를 들어, "ABC"의 가치는 28 (0*26^2 + 1*26^1 + 2*26^0)이 된다. "ABC-0123"은  |28 - 123| <= 100 이기 때문에, 좋은 번호판이다.
자동차 번호판이 주어졌을 때, 좋은 번호판인지 아닌지를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 번호판의 수 N (1 ≤ N ≤ 100)이 주어진다. 다음 N개 줄에는 자동차 번호판이 LLL-DDDD 형식으로 주어진다.
<출력값>
각각의 자동차 번호판에 대해서, 좋은 번호판이면 "nice"를, 아니면 "not nice"를 출력한다.

<문제 1872>
로마 시대 때는 현재 사용하는 아라비아 숫자가 아닌 다른 방법으로 수를 표현하였다. 로마 숫자는 다음과 같은 7개의 기호로 이루어진다.



기호
I
V
X
L
C
D
M




값
1
5
10
50
100
500
1000



수를 만드는 규칙은 다음과 같다.

규칙 1. 보통 큰 숫자를 왼쪽에, 작은 숫자를 오른쪽에 쓴다. 그리고 그 값은 모든 숫자의 값을 더한 값이 된다. 예를 들어 LX = 50 + 10 = 60이 되고, MLI = 1000 + 50 + 1 = 1051이 된다.
규칙 2. 기호 V, L, D는 한 번만 사용할 수 있고, 기호 I, X, C은 연속해서 세 번까지만 사용할 수 있다. 기호 M은 몇 번이고 사용할 수 있다. 예를 들어 VV나 LXIIII와 같은 수는 없다. 그리고 같은 숫자가 반복되면 그 값도 규칙 1과 마찬가지로 모든 숫자의 값을 더한 값이 된다. 예를 들어 XXX = 10 + 10 + 10 = 30이 되고, CCLIII = 100 + 100 + 50 + 1 + 1 + 1 = 253이 된다.
규칙 3. 작은 숫자가 큰 숫자의 왼쪽에 오는 경우는 다음과 같다. IV = 4, IX = 9, XL = 40, XC = 90, CD = 400, CM = 900을 나타낸다. 이들 각각은 한 번씩만 사용할 수 있다. 이에 따라 LIX = 50 + 9 = 59, CXC = 100 + 90 = 190이 된다. 그런데 IV와 IX는 같이 쓸 수 없으며 XL과 XC, CD와 CM 또한 같이 쓸 수 없다.또한 이들 외에는 작은 숫자가 큰 숫자 왼쪽 어디에도 나올 수 없다. 예를 들어 XCXC나 CMCD, VX나 IIX와 같은 수는 없다.
규칙 4. 모든 수는 가능한 가장 적은 개수의 로마 숫자들로 표현해야 한다. 예를 들어 60은 LX이지 XLXX가 아니고, 5는 V이지 IVI가 아니다.

이러한 네 가지 규칙에 따라, 아래는 몇 개의 수를 로마 숫자로 표현해 본 것이다.

235 = CCXXXV
1940 = MCMXL
5493 = MMMMMCDXCIII

중세 시대의 사람들은 때때로 로마 숫자로 표현된 문자열의 앞이나 뒤, 또는 문자 사이에 다른 문자나 공백을 적절히 삽입하는 운치있는 표현을 즐겼다고 한다. 예를 들어 아래와 같은 문장은 1051 = MLI를 표현한 것이다.

matt is the best school in korea

문자열의 순서를 뒤바꿀 수는 없기 때문에, 문장 안에서도 원래의 로마 숫자에 등장하는 순서대로 문자들이 나타나야 한다. 즉, 아래와 같은 문장은 1051 = MLI를 표현한 것으로 볼 수 없다.

mind control

하지만 이러한 표현은 항상 한 가지로만 해석되는 것이 아니다. 위의 MLI를 표현한 문장은 아래와 같이 1151 = MCLI로 볼 수도 있기 때문이다.

matt is the best school in korea

운치있게 표현된 영어 문장이 주어졌을 때, 이 문장이 어떤 수를 표현한 것인지를 찾아내는 프로그램을 작성하시오. 단, 이 문장이 표현하고 있는 것으로 예상되는 수가 두 가지 이상인 경우는, 그 중 가장 큰 수를 찾아야 한다.
<입력값>
첫째 줄에 문장의 개수 N(1 ≤ N ≤ 10)이 주어진다. 이어서 N개의 줄에 걸쳐 운치있게 표현된 문장이 한 줄에 하나씩 주어진다. 입력되는 문장은 알파벳 소문자와 띄어쓰기만으로 이루어져 있으며, 그 길이는 10,000을 넘지 않는다.
<출력값>
첫째 줄부터 N개의 줄에 걸쳐 각 문장이 표현하고 있는 가장 큰 수를 출력한다. 만일 어떤 숫자도 표현한다고 볼 수 없는 경우는 0을 출력한다.

<문제 1873>
색종이가 한 장 놓여 있고, 이 색종이를 가위로 잘랐을 때 몇 개의 조각으로 나뉘는지 알고 싶다. 이를 계산하는 프로그램을 작성하라.
<입력값>
색종이는 다각형 모양으로, 평면에 놓여 있으며, 이를 가위로 자르는 경로는 x축 또는 y축에 평행한 하나의 직선이다. 첫째 줄에 이 직선이 지나는 두 점의 좌표값 (x1, y1), (x2, y2)가 주어진다. 둘째 줄에는 색종이의 꼭짓점 수가 주어진다. 셋째 줄부터 한 줄에 한 개씩 꼭짓점의 좌표 (x, y)가 주어진다.
각 좌표값은 빈칸으로 분리되어 있고 0이상 1,000,000 이하의 정수이다. 다각형의 꼭짓점은 반시계방향의 순서로 주어지고, 꼭짓점의 개수는 3이상 100,000 이하의 정수이다. 입력에 대해 오류 검사를 할 필요는 없다. 가위질을 한 후 생기는 다각형들은 모두 꼭짓점이 세 개 이상이다.
<출력값>
첫 줄에 가위질로 인해 생기는 색종이의 조각 수를 출력한다.

<문제 1874>
스택 (stack)은 기본적인 자료구조 중 하나로, 컴퓨터 프로그램을 작성할 때 자주 이용되는 개념이다. 스택은 자료를 넣는 (push) 입구와 자료를 뽑는 (pop) 입구가 같아 제일 나중에 들어간 자료가 제일 먼저 나오는 (LIFO, Last in First out) 특성을 가지고 있다.
1부터 n까지의 수를 스택에 넣었다가 뽑아 늘어놓음으로써, 하나의 수열을 만들 수 있다. 이때, 스택에 push하는 순서는 반드시 오름차순을 지키도록 한다고 하자. 임의의 수열이 주어졌을 때 스택을 이용해 그 수열을 만들 수 있는지 없는지, 있다면 어떤 순서로 push와 pop 연산을 수행해야 하는지를 알아낼 수 있다. 이를 계산하는 프로그램을 작성하라.
<입력값>
첫 줄에 n (1 ≤ n ≤ 100,000)이 주어진다. 둘째 줄부터 n개의 줄에는 수열을 이루는 1이상 n이하의 정수가 하나씩 순서대로 주어진다. 물론 같은 정수가 두 번 나오는 일은 없다.
<출력값>
입력된 수열을 만들기 위해 필요한 연산을 한 줄에 한 개씩 출력한다. push연산은 +로, pop 연산은 -로 표현하도록 한다. 불가능한 경우 NO를 출력한다.

<문제 1875>
동혁이는 테트리스와 매우 비슷한 아래와 같은 게임을 즐기는데, 이 게임은 가로 3, 세로 300 길이의 직사각형 모양의 게임 필드에서 이루어진다. 이 게임에는 아래와 같은 일곱 개의 타일이 있다.

동혁이는 각각의 타일을 돌릴 수 있다. 돌린다는 것은 90도, 180도, 270도로 왼쪽 또는 오른쪽으로 타일을 회전시키는 것을 의미하여, 뒤집는 것은 허용되지 않는다. (즉 2번 모양의 타일을 돌려서 3번 모양의 타일로 만들 수는 없다.)
처음에 게임 필드는 비어 있다. 게임이 시작되면 지정된 순서대로 타일들이 게임 필드의 위쪽에서 아래쪽으로 떨어지게 된다. 이를 적절히 좌우로 이동시키거나 회전시켜서 아래부터 순서대로 쌓아 나가야 하는데, 타일끼리 서로 겹쳐서는 안 된다. 또한 타일이 게임 필드 밖으로 나가서도 안 된다.
예를 들어 1번 모양의 타일을 돌리면 가로로 길이가 4가 되기 때문에, 돌릴 수 없다. 또한 2번 모양의 타일은 가로로 길이가 2이므로 첫째, 둘째 가로선에 떨어질 수도 있고, 둘째, 셋째 가로선에 떨어질 수도 있다.
한 번 타일이 필드 아래에 내려와서 쌓인 후 다음 타일이 내려왔으면, 쌓인 타일은 다시 이동하거나 회전할 수 없다. 타일이 내려갈 때도 마찬가지이다, 방향을 정해서 내려가기 시작했으면, 중간에 타일을 이동하거나 회전하는 것은 불가능하다.
타일이 게임 필드에 들어오는 순서가 주어졌을 때, 모든 타일을 게임 필드에 가능한 최소의 높이로 쌓았을 때 그 높이를 출력하는 프로그램을 작성하시오. 높이란 아래로부터 타일이 쌓여져 있는 최소의 칸이다. 즉 다시 이야기하면, 첫째, 둘째, 셋째 가로칸 모두 아래로부터 K번째 세로칸까지만 타일이 놓여 있도록 하는 최소의 K를 찾으면 된다.
<입력값>
첫째 줄에 타일의 개수 N이 주어진다. (1≤N≤100) 이어 N개의 줄에 걸쳐 순서대로 떨어지는 타일이 몇 번 모양인지를 나타내는 자연수가 각 줄에 하나씩 주어진다. 주어지는 자연수는 7 이하이다.
<출력값>
첫째 줄에 최소의 높이 K를 출력한다.

<문제 1876>
상근이는 지름이 20cm인 볼링공을 폭이 105cm인 볼링 레인에 각도 X도로 레인의 중심에서 던졌다. (아래 그림을 참고)

레인은 범퍼가 장착되어 있어, 공이 범퍼에 닿으면, 입사각과 같은 각도로 튕기게 된다. 지름이 12cm 핀이 T 미터 떨어진 곳에 놓여져 있다. 상근이가 던진 볼링공이 이 핀을 맞출 수 있는지 없는지를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 테스트 케이스의 개수 N이 주어진다. 다음 N개 줄에는 볼링공과 핀 사이의 거리 T (16.0 ≤ T ≤ 18.0)와 공을 던진 각도 X (중심을 기준으로 계산, 10 ≤ X ≤ 80)가 주어진다.
<출력값>
각 테스트 케이스마다, 볼링공이 핀을 맞추면 "yes"를, 아니면 "no"를 출력한다.

<문제 1877>
우리는 양의 정수들이 나열된 다음과 같은 끔찍한 수열 <a1, a2, ..., an>을 구하는 두 개의 문제를 풀려고 한다. 수열<a1, a2, ..., an>의 길이는 수열에 포함된 정수들의 개수 이라고 정의한다.
문제 A: 양의 정수 M이 주어질 때,  정수들의 합 a1+a2+...+an=M을 만족시키면서, 정수들의 곱 a1*a2*...*an의 값이 가장 크게 되는 끔찍한 수열 <a1, a2, ..., an>을 구하시오. 단, 곱 a1*a2*...*an의 값이 가장 크게 되는 서로 다른 길이의 수열이 두 개 이상 존재할 경우, 수열의 길이 n이 최대인 것과 최소인 것을 모두 구한다.
문제 B: 양의 정수 M이 주어질 때, 정수들의 곱 a1*a2*...*am=M을 만족시키면서, 정수들의 합 a1+a2+...+am의 값이 가장 작게 되는 끔찍한 수열  <a1, a2, ..., am>을 구하시오. 단, 합 a1+a2+...+am의 값이 가장 작게 되는 서로 다른 길이의 수열이 두 개 이상 존재할 경우, 수열의 길이 m이 최대인 것과 최소인 것을 모두 구한다.
문제 A에서 구한 수열의 최대/최소 길이 n과 문제 B에서 구한 수열의 최대/최소 길이 m을 출력하는 프로그램을 작성하시오.
예를 들어 M=6이면, 문제 A에서 구한 수열은  뿐이므로 이 수열의 최대/최소 길이는 2이고, 문제 B에서 구한 수열은  뿐이므로 이 수열의 최대/최소 길이는 2이다.
<입력값>
첫째 줄에 정수 이 주어진다. (1<=M<=1,000,000)
<출력값>
첫째 줄에 문제 A에서 구한 수열의 최대/최소 길이 n과 문제 B에서 구한 수열의 최대/최소 길이 m을 나타내는 네 개의 정수를 빈칸을 사이에 두고 차례대로 출력한다.

<문제 1879>
2차원 평면에 두 개의 다각형이 있다. 우리는 이 두 개의 다각형 중 하나를 x축 방향으로 이동시킬 수 있다. x축 외의 방향으로는 이동시킬 수 없으며, 이동하는 중에는 서로 두 다각형이 겹칠 수도 있다.
우리는 두 개의 다각형을 가능하면 빡빡하게 배치해야 한다. 즉 두 개의 다각형 위에 있는 모든 점들 중 x좌표의 최댓값과 최솟값의 차이를 최소로 해야 하는 것이다.
하지만 하나의 조건이 있다 : 두 개의 다각형이 지나치게 가까워지면, 서로 굉장히 부끄러워하는 성질이 있다. 따라서, 이들이 서로 부끄러워하지 않을 정도의 거리인 L만큼은 떨어져 있어야 한다. 즉, 두 다각형에서 임의의 점을 각각 하나씩 잡았을 때, 어떤 경우에도 두 점 사이의 거리가 L보다 작아서는 안 된다는 것이다.

예를 들어 두 개의 다각형이 위와 같이 위치하고 있다고 하자. 만일 L=10.0이라면, 두 다각형을 옆의 그림과 같이 배치하여 두 개의 다각형 위에 있는 모든 점들 중 x좌표의 최댓값과 최솟값의 차이를 최소인 100으로 만들어 줄 수 있다. 이 값이 100보다 클 수는 없다. - 이미 하나의 다각형에서만 구해도 100을 이루기 때문이다.

L값과 두 개의 부끄러운 다각형이 주어지면, 거리가 L만큼은 떨어져 있으면서도 가능하면 빽빽하게 배치했을 때, 두 개의 다각형 위에 있는 모든 점들 중 x좌표의 최댓값과 최솟값의 차이를 최소로 하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 실수 L(0.1≤N≤50.0)이 주어진다. 둘째 줄에는 첫 번째 다각형의 꼭짓점의 개수 N1이 주어진다. 이어서 N1개의 줄에 걸쳐 다각형을 이루는 꼭짓점의 x좌표와 y좌표가 빈 칸을 사이에 두고 반시계 방향으로 주어진다. 이어서 두 번째 다각형의 꼭짓점의 개수 N2가 주어지고 이어서 N2개의 줄에 걸쳐 다각형을 이루는 꼭짓점의 좌표가 마찬가지 형태로 주어진다.
  다각형의 꼭짓점의 개수는 2 이상 15 이하이다. (2인 경우 선분을 이루게 된다) 입력되는 모든 좌표는 음 아닌 정수로 500을 넘지 않는다. 다각형은 단순 다각형으로 서로 교차하거나 닿아 있지 않다.
<출력값>
첫째 줄에 두 다각형의 거리가 L만큼은 떨어져 있으면서도 가능하면 빽빽하게 배치했을 때, 두 개의 다각형 위에 있는 모든 점들 중 x좌표의 최댓값과 최솟값의 차이의 최솟값을 출력한다. 소수점 셋째 자리에서 반올림하여 출력하며, 소수점 이하 자리가 0이여도 반드시 출력해야 한다.

<문제 1880>
A spy agency wants to monitor all communications in a computer network. They have a budget for at most 10 installations of spying software on 10 of the host computers on the network. For the software to work properly each communication line A–B must have at least one host A or B being monitored.
<입력값>
Input will consist of a number of network scenarios. Each scenario will contain:

An integer n (10 ≤ n ≤ 2500) on a line on its own, giving the number of hosts in the network.
A line of data for each host (thus n lines in total) giving the list of other hosts to which the host has a direct communication line. The hosts are named 0, 1, . . . , n−1; the first line of data gives the neighbours of host 0, the second those of host 1, and so on up to host n − 1.
	Each of these lines consists of an integer d (1 ≤ d < n) which is the number of neighbours host k has, followed by d integers which are the neighbouring hosts’ names, separated by spaces. The neighbours will be given in numerical order, and will each be valid host names in 0, 1, . . . n − 1 other than k.
	(Note that each of these input lines may thus be up to 2500×5 characters in length.)

The last line of input will be a ‘0’ on a line by itself. This line should not be processed.
<출력값>
Output will consist of one line for each input network, indicating whether the network can be successfully spied upon by infecting 10 nodes. Each line of the output will consist of ‘Network n: ’, where n is the scenario number, starting at 1, followed by ‘yes’ or ‘no’.

<문제 1881>
0부터 9까지의 숫자가 각각 적힌 열 개의 공과, 0부터 9까지의 숫자 중 하나가 적힌 여러 장의 카드들이 있다. 그리고 각각 공 하나씩을 담을 수 있는 상자 네 개가 있다. 같은 숫자의 카드는 여러 장 있을 수 있지만, 공은 하나씩이다.
카드를 한 장씩 뽑아서 그에 해당하는 공을 상자 중 하나에 넣어야 하며, 다음과 같은 규칙을 따른다.
(규칙 1) 해당하는 공이 이미 상자 중 하나에 들어가 있을 경우엔 아무 일도 하지 않는다.
  (규칙 2) 빈 상자가 있으면 해당하는 공을 거기에 그냥 넣으면 된다. (삽입 연산)
  (규칙 3) 빈 상자가 없을 경우엔 이미 상자에 들어가 있는 공 중 하나을 빼내고, 새 공으로 교환해 넣어야 한다. (교환 연산)
임의 개수의 카드를 뽑았을 때, 삽입․교환 연산을 최소한으로 하여 순서대로 작업을 처리하는 프로그램을 작성하여 보자.
<입력값>
첫 줄에 뽑은 카드의 장수 n이 주어진다. (0≤n≤100) 둘째 줄에 n개의 숫자가 주어지는데, 뽑힌 카드에 적힌 숫자를 순서대로 나타낸다.
<출력값>
첫 줄에 필요한 최소한의 연산 수를 출력한다.

<문제 1882>
분모가 N 이하인 모든 기약분수 p / q 를 증가하는 순서대로 나열하려고 한다. (1≤p<q≤N) 예를 들어 N=5인 경우, 아래와 같이 나열할 수 있다.
1/5 , 1/4 , 1/3 , 2/5 , 1/2 , 3/5 , 2/3 , 3/4 , 4/5
N이 주어졌을 때, 위와 같이 분수를 나열했을 때 K번째 분수를 구하는 프로그램을 작성하시오. 예를 들어 N=5이고 K=6인 경우 구하고자 하는 분수는 3/5가 된다.
<입력값>
첫째 줄에 자연수 N과 K가 빈 칸을 사이에 두고 주어진다. (1≤N≤40,000) 분모가 N 이하인 모든 기약분수의 개수보다 K가 큰 경우는 없다.
<출력값>
첫째 줄에 K번째 분수가 p / q인 경우 p와 q를 빈 칸을 사이에 두고 출력한다. p와 q는 반드시 서로 소여야 한다.

<문제 1884>
봄캠프 기간 동안 고속도로의 통행료가 급격하게 올라, 참가자들이 자칫 집으로 돌아가지 못할 수도 있는 위기에 봉착했다! 통행료가 인하되기 전까지는 여기 속초에서 원쌤과 함께 계속 프로그래밍 공부를 해야 할 수도 있는 상황인 것이다! 이 모든 것은 귀가시에 사용할 교통비를, 고속도로 통행료가 오르기 전에 계산해서 들고 왔기 때문이다.
다급해진 여러분은 정해진 예산을 가지고 집으로 돌아갈 수 있을지 알아보고, 갈 수 있다면 그에 필요한 최단 이동거리를 계산하려고 한다. 이를 해결하기 위한 프로그램을 작성하라.
<입력값>
첫 줄에 여러분이 준비해 둔 교통비 K가 주어진다. (0≤K≤10,000) 둘째 줄과 셋째 줄에는 각각 도시의 숫자 N과 도로의 숫자 R이 주어진다. (2≤N≤100, 1≤R≤10,000) 이후 R개의 줄에 각 도로의 정보가 주어지는데, 각 줄은 네 개의 숫자 s, d, l, t로 이루어져 있다. s는 도로의 출발 도시 번호이고, d는 도로의 도착 도시 번호이다. l은 도로의 길이이고, t는 도로의 통행료이다. (1≤s≤N, 1≤d≤N, 1≤l≤100, 0≤t≤100)
도시의 번호는 1번부터 N번까지 빠짐없이 붙어 있다. 이곳 속초는 1번 도시이고, 여러분의 집은 N번 도시에 있다. 각 도로는 일방통행로이다. 서로 다른 두 도로가 서로 같은 시작 도시와 서로 같은 도착 도시를 가질 수 있음에 유의하라.
<출력값>
첫 줄에 정해진 예산 내에서 이용할 수 있는 경로 중 제일 짧은 것의 길이를 출력한다. 만약 가능한 경로가 없을 때에는 -1을 출력한다.

<문제 1885>
수열에서 몇 개의 수를 순서대로 골라 만들 수 있는 수열을 부분수열이라고 한다. 예를 들어 수열 S=[1, 5, 3, 2, 5, 1, 3, 4, 4, 2, 5, 1, 2, 3]에서 첫 번째, 다섯 번째, 일곱 번째, 열 번째 수를 고르면 부분수열 p=[1, 5, 3, 2]을 만들 수 있다.
수열 S와 임의의 부분수열 p가 주어졌을 때, 모두 몇 가지 방법으로 S에서 고른 수로 p를 구성할 수 있는지에 관한 문제는 많이 다루어진 문제이므로, 이번에는 반대의 경우를 생각해 보자. 수열 S가 주어지고, 이 수열에서 만들 수 없는 부분수열에 관해 생각해 보는 것이다.
부분수열이 충분히 길면 물론 만들어 낼 수 없을 것이다. 그럼 만들어 낼 수 없는 부분수열 중 가장 짧은 것의 길이는 얼마일까? 이를 알아내는 프로그램을 작성하라.
<입력값>
첫 줄에 두 정수 n과 k가 주어진다. (1≤n≤100,000. 1≤k≤10,000) n은 수열 S의 길이이고, k는 수열 내에 존재하는 수들의 범위이다. 다시 말해, S가 1이상 k이하의 정수들로만 이루어져 있음을 나타낸다. 둘째 줄부터는 S를 이루는 수들이 한 줄에 한 개씩 차례로 주어진다.
<출력값>
첫 줄에 S에 존재하지 않는 부분수열 중 가장 짧은 것의 길이를 출력한다.

<문제 1886>
N*M 크기의 감옥이 있다. 감옥은 스코필드가 미리 뚫어 놓은 탈출구, 벽, 그리고 빈 칸으로 이루어져 있는데 각각의 모든 빈 칸에는 사람이 한 명씩 있다. 감옥 안에 있는 모든 사람들은 탈출구를 통해 탈옥을 해 내야 한다. 물론, 최대한 빨리 모든 사람이 탈출하도록 하고 싶다.
각 사람이 한 칸을 이동하는 데에는 1초가 걸리며, 하나의 탈출구를 통해서는 1초에 한 사람만 탈출을 할 수 있다. 그리고 사람들이 탈출하는 동안에는 하나의 빈 칸에 여러 명의 사람들이 있어도 된다. 감옥의 정보가 주어져 있을 때, 사람들이 모두 탈출하려면 모두 몇 초의 시간이 걸리는지 구하는 프로그램을 작성하시오.
감옥의 가장자리는 반드시 벽 또는 탈출구이며, 안쪽에는 탈출구가 없다. 또, 감옥 내부에는 빈 칸이 적어도 하나 있다.
<입력값>
첫째 줄에 감옥의 행의 수와 열의 수, N, M이 공백을 사이에 두고 주어진다( 3 ≤ N,M ≤ 12 ). 그리고 N개의 줄에 걸쳐서 감옥의 정보가 주어진다. ‘X'는 벽을 의미하고 '.'은 빈 칸, 'D'는 스코필드가 미리 뚫어 놓은 탈출구 위치를 의미한다.
<출력값>
첫째 줄에 모든 사람이 탈출을 하는 최소시간을 출력한다. 만약에 모두 탈출하는 것이 불가능하다면 “impossible"을 출력한다.

<문제 1887>
Oh how the cows love their pizza! Even though they are picky, they do love variety, too. They order from the local pizza parlor that features T (1 <= T <= 20) different toppings in addition to a complete set of soft drinks and healthy salads.
The toppings are conveniently numbered 1..T so the cows can order by number. Your job is to calculate how many possible pizzas can be created given that some cows will not tolerate various combinations of toppings (e.g., some cows simply will not eat Anchovies or the combination of Mushrooms and Asparagus).
Given a set of N (1 <= N <= 52) constraints, figure out how many pizzas can be made using all possible combinations of the ingredients (which, of course, includes no ingredients at all). Each constraint is a set of numbers of size 1..T that lists the ingredients that disqualify a pizza from being considered.
A constraint like "5 3" means that no pizza can contain ingredient #5 and also ingredient #3. This means a pizza with ingredients 3, 5, and 6 will not be counted as acceptable.
<입력값>
Line 1: Two space-separated integers: T and N
Lines 2..N+1: Each line describes a constraint using space-separated integers. The first integer is the number of ingredients in the constraint, Z (1 <= Z <= T). The subsequent Z integers (which are unique) list the ingredient(s) whose combination disqualifies a pizza from consideration for the cows.
<출력값>
Line 1: A single integer that is the total number of pizzas that can be created using the number of ingredients and constraints.

<문제 1888>
벽에 곰팡이가 자라고 있다. 곰팡이들은 현재 여러 개의 덩어리를 이루고 있는 상태인데, 이들이 점점 자라나서 한 덩어리로 될 때까지 얼마의 시간이 걸릴지 알고 싶다. 이를 계산하는 프로그램을 작성해 보자.
곰팡이가 피어 있는 벽은 m행 n열의 격자로 나뉘어 있고, 한 칸 당 한 개의 곰팡이가 있다. 곰팡이의 덩어리라는 것은, 격자 상에 가로세로로 인접한 곰팡이들의 집합을 말한다.
맨 처음 상태에서는 한 덩어리 안의 곰팡이들이 모두 같은 종으로, 자라는 속도도 같다. 그러나 서로 다른 덩어리에 속한 곰팡이는 종이 달라 자라는 속도도 다를 수 있다. 또, 시간이 지남에 따라 서로 다른 종의 곰팡이 덩어리가 한 덩어리로 합쳐지는 경우도 있을 수 있다. 만약 어느 곰팡이의 자라는 속도가 k라면, 하루가 지났을 때 그 곰팡이가 피어있던 자리를 중심으로 2k+1행 2k+1열의 격자에 같은 종의 곰팡이가 번진다는 의미이다. 만약 서로 다른 종의 곰팡이가 같은 칸에 번져 오면, 자라는 속도가 빠른 곰팡이가 그 칸을 차지한다.
<입력값>
첫 줄에 곰팡이가 피어 있는 벽의 크기를 나타내는 두 정수 m과 n이 주어진다. (1≤m, n≤100) 둘째 줄부터는 벽의 상황이 한 줄에 한 행씩 주어진다. 곰팡이가 피어있는 곳은 그 곰팡이의 자라는 속도로, 그렇지 않은 곳은 0으로 표시되어 있다. 자라는 속도는 1이상 5이하의 정수이다. 각 숫자 사이에는 빈 칸이 없다.
<출력값>
첫 줄에 곰팡이가 한 덩어리가 되기까지 걸리는 시간을 하루 단위로 출력한다.

<문제 1889>
캠프의 마지막 날에 선물 교환 이벤트를 하려고 한다. 모든 학생들이 각자 두 개씩 선물을 준비해 와서 두 명의 친구에게 주는 것이다. 이벤트를 준비하던 중, 조교들은 이러한 이벤트가 불화를 일으킬 수 있음을 알게 되었다. 참석한 학생들 중 일부 학생들은 선물을 못 받거나 하나만 받게 되는 데 비해, 인기가 많은 학생들은 선물을 세 개 또는 그 이상 받게 되는 것이다.
그래서 조교들은 모든 학생들이 두 개의 선물을 주고, 또한 모든 학생들이 정확히 두 개의 선물만을 받도록 이벤트를 준비하고자 한다. 이를 위해 각각의 학생이 선물을 주고자 하는 두 명의 학생이 누구인지를 미리 알아내었다. 리스트를 살펴보던 조교들은, 몇 명의 학생을 추려 내면 모든 학생이 정확히 두 개의 선물을 받을 수 있다는 것을 알게 되었다.
참여한 모든 학생이 정확히 선물을 두 개씩 받도록 이벤트에 참여할 학생들을 결정하는 프로그램을 작성하시오. 단, 이벤트에 참여하는 학생의 수가 최대가 되도록 해야 한다.
<입력값>
첫째 줄에 학생의 수 N(3≤N≤200,000)이 주어진다. 학생은 1부터 N까지 번호가 매겨진다. 이어서 다음 N개 줄에는 각 학생이 선물을 주고자 하는 두 학생의 번호가 빈 칸을 사이에 두고 주어진다. 자기 자신에게 선물을 주는 경우는 없으며, 두 사람의 번호는 항상 다르다.
<출력값>
첫째 줄에 최대로 참여시킬 수 있는 학생의 수를 출력한다. 둘째 줄에는 참여할 학생들의 번호를 증가하는 순서대로 빈 칸을 사이에 두고 출력한다. 가능한 방법이 둘 이상인 경우 그 중 한 가지만 출력한다. 만일 한 명의 학생도 참여시킬 수 없는 경우 첫째 줄에 0만을 출력한다.

<문제 1890>
N×N 게임판에 수가 적혀져 있다. 이 게임의 목표는 가장 왼쪽 위 칸에서 가장 오른쪽 아래 칸으로 규칙에 맞게 점프를 해서 가는 것이다.
각 칸에 적혀있는 수는 현재 칸에서 갈 수 있는 거리를 의미한다. 반드시 오른쪽이나 아래쪽으로만 이동해야 한다. 0은 더 이상 진행을 막는 종착점이며, 항상 현재 칸에 적혀있는 수만큼 오른쪽이나 아래로 가야 한다. 한 번 점프를 할 때, 방향을 바꾸면 안 된다. 즉, 한 칸에서 오른쪽으로 점프를 하거나, 아래로 점프를 하는 두 경우만 존재한다.
가장 왼쪽 위 칸에서 가장 오른쪽 아래 칸으로 규칙에 맞게 이동할 수 있는 경로의 개수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 게임 판의 크기 N (4 ≤ N ≤ 100)이 주어진다. 그 다음 N개 줄에는 각 칸에 적혀져 있는 수가 N개씩 주어진다. 칸에 적혀있는 수는 0보다 크거나 같고, 9보다 작거나 같은 정수이며, 가장 오른쪽 아래 칸에는 항상 0이 주어진다.
<출력값>
가장 왼쪽 위 칸에서 가장 오른쪽 아래 칸으로 문제의 규칙에 맞게 갈 수 있는 경로의 개수를 출력한다. 경로의 개수는 263-1보다 작거나 같다.

<문제 1891>
하나의 좌표평면은 다음과 같이 네 개의 사분면으로 나뉜다.

그러면, 각각의 사분면을 다시 사분면으로 나누어 번호를 붙여 보면 어떨까? 예를 들어 1번 사분면의 1번 사분면은 11번 사분면, 3번 사분면의 2번 사분면은 32번 사분면이라고 하면 좋지 않을까? 물론 한 번 더 나눠 볼 수도 있겠다. 3번 사분면의 4번 사분면의 1번 사분면은 341번 사분면이다.

사분면의 번호 길이가 길어짐에 따라 각각의 사분면의 크기는 급격히 작아지며, 그 개수는 기하급수적으로 증가한다.
사분면에 번호를 붙이는 이러한 규칙을 상정하고서, 어떤 사분면 조각을 이동시켰을 때, 그 조각이 위치하게 되는 사분면의 번호가 궁금하다. 예를 들어, 341번 사분면을 오른쪽으로 두 번, 위쪽으로 한 번 이동시키면 424번 사분면에 온다.

하나의 사분면 조각을 이동시켰을 때, 그 조각이 도착한 사분면의 번호를 알아내는 프로그램을 작성하라.
<입력값>
첫 줄에 이동시키려는 사분면 조각 번호의 자릿수를 나타내는 정수 d와, 그 사분면 조각의 번호가 주어진다. (1≤d≤50) 둘째 줄에는 이동의 내용을 나타내는 두 정수가 x, y가 주어진다. (|x|, |y|≤2^50) 오른쪽으로 이동한 경우 x가 양수, 왼쪽으로 이동한 경우 음수이며, 그 절댓값은 오른쪽 왼쪽 방향 이동 횟수를 나타낸다. 위쪽으로 이동한 경우 y가 양수, 아래쪽으로 이동한 경우 음수이며, 역시 그 절댓값은 아래위 방향 이동 횟수를 나타낸다.
<출력값>
첫 줄에 도착한 사분면의 번호를 출력한다. 만약, 존재하지 않는 사분면인 경우에는 -1을 출력한다.

<문제 1892>
동주와 항승이가 가위바위보 게임을 하고 있다. N번의 가위바위보를 하는데, K번 먼저 이기는 사람이 게임에서 승리하게 된다. 동주를 꼭 이기고 싶어하는 항승이는 자신이 승리할 확률이 얼마나 되는지 궁금해졌다.
항승이가 가위바위보로 동주를 이길 확률을 구하는 프로그램을 작성하시오. 단, 두 사람 모두 가위, 바위, 보를 같은 확률로 낸다고 가정한다.
<입력값>
첫째 줄에 두 정수 N과 K가 빈 칸을 사이에 두고 주어진다. (1≤K≤N≤40)
<출력값>
항승이가 이길 확률을 A/B로 나타낸다고 할 때, A와 B를 빈 칸을 사이에 두고 출력한다. A와 B는 서로 소인 자연수여야 한다.

<문제 1893>
암호학에서, 시저 암호(또는 시프트 암호, 시저 코드, 시저 시프트)는 가장 간단하면서 많이 알려진 암호화 기술 중 하나이다. "시저 암호"라는 이름은 비밀 통신을 위해 이 방법을 개발한 율리우스 시저의 이름을 딴 것이다. 시저 암호는 대치 암호의 한 종류로써, 원문의 각 글자가 어떤 일정한 수만큼의 뒷 순서의 알파벳으로 대체되는 방식이다. (단, Z의 다음 알파벳은 A로 한다) 예를 들어, 대문자 알파벳의 일반적인 순서를 따르면서 3만큼 시프트(이동) 시키면, A는 D로 대체되고, B는 E로, C는 F로... 그런 식으로 변환되어서 마지막 X, Y, Z는 다시 A, B, C로 대체된다. 이런 식으로 알파벳 순서에서 X만큼 뒤로 옮기는 암호화 방법의 "시프트 값"을 X라고 하겠다.
당신에게 어떤 알파벳 순서 A, 원문 W, 시저 암호화된 문자열 S가 주어진다.
암호문을 해독했을 때 그 해독한 문자열에서 원문이 단 한 번만 나타난다고 할 때, 암호화 할 때 쓰였다고 추측 가능한 시프트 값을 ([0,|A|-1] 범위에서) 모두 찾아라.
<입력값>
입력의 첫 줄에는 테스트 케이스의 수를 의미하는 정수 N이 있다. 각 테스트 케이스는 알파벳의 순서 A, 원문 W, 암호문 S가 3줄에 걸쳐 순서대로 쓰여 있다. 알파벳 순서 A는 알파벳 소문자, 대문자, 그리고 숫자만을 포함하며, 이 순서는 사전순이 아닐 수도 있다 (예제 입력의 3번째 테스트 케이스를 참고하라). A의 모든 문자는 다르다.
입력 범위 : 3 <= |A| <= 62, 1 <= |W| <= 50,000, 3 <= |S| <= 500,000.
<출력값>
각 테스트 케이스에 대해 1줄씩 출력한다. 만약 해독된 암호문에서 원문이 단 한번만 등장하게 하는 암호화 방법이 존재하지 않는다면, 즉 조건을 만족하는 암호문의 시프트 값이 존재하지 않는다면 "no solution"을 출력한다 (따옴표 제외). 만약 오직 하나의 시프트 값만이 조건을 만족한다면, "unique: #" (단, #는 조건을 만족하는 시프트 값) 을 출력한다 (따옴표 제외). 만약 조건을 만족하는 시프트 값이 여러 개 존재한다면, "ambiguous: " 를 출력하고 그 뒤에 오름차순으로 정렬된 조건을 만족하는 시프트 값의 목록을 출력한다.
자세한 사항은 예제 출력을 참고하라.

<문제 1894>
꿍은 지금 학생들에게 평행사변형에 대해 가르쳐주고 있는데 다음과 같은 문제를 내주고 있다. 여러분들도 함께 풀어 보아라.
문제 : 평행사변형의 인접한 두 변의 꼭짓점의 좌표들이 주어졌을 때, 나머지 하나의 점, 즉 4번째 점의 좌표를 구하여라.
<입력값>
각 줄은 8개의 실수로 이루어져 있는데 각각 첫 번째 변의 양 끝점의 (x,y) 좌표와 두 번째 변의 양 끝점의 (x,y) 좌표로 구성되어 있다. 모든 좌표는 미터 단위이며 mm까지 나타내야 한다. 또한 모든 좌표값은 -10000~10000의 범위를 갖는다.
<출력값>
각각의 입력에 대해 각 줄에 네 번째 점의 좌표를 미터 단위로 mm까지 나타내어라.

<문제 1895>
숫자 9개가 오름차순이나 내림차순으로 정렬되어 있을 때, 중앙값은 다섯 번째 숫자이다. 예를 들어, 1, 3, 4, 1, 2, 6, 8, 4, 10의 중앙값은 4이다. (1 ≤ 1 ≤ 2 ≤ 3 ≤ 4 ≤ 4 ≤ 6 ≤ 8 ≤ 10)
이미지 I는 크기가 R × C인 2차원 픽셀이다. (3 ≤ R ≤ 40, 3 ≤ C ≤ 40) 각 픽셀은 어두운 정도 V를 나타낸다. (0 ≤ V ≤ 255)
중앙 필터는 이미지에 있는 노이즈를 제거하는 필터이다. 필터의 크기는 3 × 3이고, 이미지의 중앙값을 찾으면서 잡음을 제거한다.
예를 들어, 아래와 같은 6 × 5 이미지가 있다.

필터링된 이미지의 크기는 4 × 3이고, 아래와 같다.

가장 왼쪽 윗 행에 필터를 두고, 오른쪽으로 움직이면서 중앙값을 찾는다. 한 행을 모두 이동했으면, 다음 행으로 이동해 다시 중앙값을 찾는다. 아래와 같은 순서를 가진다.

위의 그림에서 각각의 중앙값은 36, 36, 21이 된다. 이 값은 필터링된 이미지 J의 첫 행과 같다. 
이미지 I가 주어졌을 때, 필터링 된 이미지 J를 구하고, 값이 T보다 크거나 같은 픽셀의 수를 구하는 프로그램을 작성하시오.
예를 들어, T = 40일 때, 위의 예에서 정답은 7이다.
<입력값>
첫째 줄에 이미지의 크기 R과 C가 주어진다. 그 다음 R개의 각 줄에는 C개의 픽셀 값이 주어진다. 마지막 줄에는 T값이 주어진다.
<출력값>
첫째 줄에 필터링 된 이미지 J의 각 픽셀 값 중에서 T보다 크거나 같은 것의 개수를 출력한다.

<문제 1896>
파급효과가 가능한 퍼즐인지 판별하여라.
파급효과는 여러개의 폴리오미노로 구성된 직사각형의 그리드에서 발생한다. 폴리오미노는 하나 이상의 같은 크기의 정사각형을 이어붙여 만든 도형이다.
우리는 그리드 안의 모든 칸에 자연수를 배치해야한다. 이때 다음과 같은 규칙을 따르며, 일부 자연수는 미리 주어질 수 있다.

1 ~ (폴리노미오 안의 칸 수) 의 자연수들은 해당 폴리노미오 안에 반드시 한번씩만 배치되어야 한다.
하나의 줄이나 행에 동일한 숫자가 배치되기 위해선 두 숫자 사이에 해당 숫자만큼의 다른 칸이 존재해야 한다.
	예를 들어, '1'이 배치된 칸은 서로 인접할 수 없으며, 다른 숫자가 쓰여진 칸이 두 '1' 사이에 하나 이상 존재해야 한다.
	같은 줄이나 행에 '3'이 배치되기 위해선 다른 숫자가 쓰여진 칸이 사이에 세개 이상 존재해야 한다.

이 문제에서 폴리노미오의 크기는 최대 8이다.
<입력값>
입력의 첫째 줄에는 테스트 케이스 T가 주어진다. (T<=100)
각각의 테스트 케이스의 첫째 줄에는 두 정수 R, C 가 주어진다. (4<=R, C<=15)
이후 R개 줄에는 그리드에 쓰여진 숫자들을 나태는 C개의 숫자 d_i로 구성된 문자열이 입력된다. (1<=d_i<=8)
이후 R개 줄에는 퍼즐의 각 칸이 폴리노미오로 연결된 방향을 나타내는 C개의 숫자가 입력된다. (이는 RxC 의 테이블이며, 이를 "descr" 라고 하자. 0<=descr(r,c)<=15)
descr(r,c)의 값은 이웃된 칸과의 연결 여부에 따라 다음과 같이 결정된다.

descr(r,c)=0
if(connected((r,c),(r-1,c)) descr(r,c)+=1; (UP)
if(connected((r,c),(r,c+1)) descr(r,c)+=2; (RIGHT)
if(connected((r,c),(r+1,c)) descr(r,c)+=4; (DOWN)
if(connected((r,c),(r,c-1)) descr(r,c)+=8; (LEFT)
예를 들어, 크기가 1인 폴리노미오의 칸은 주변의 어떠한 칸과도 이어져있지 않으므로 0의 값을 가지며, 위쪽의 칸과 아래의 칸에 이어져있는 칸들은 5의 값을 가지게 된다.
<출력값>
각각의 테스트 케이스에 대해 한 "valid" 또는 "invalid" 를 출력하여라.

<문제 1898>
길이 n의 수열 S가 주어진다. S는 1부터 n까지의 n개 정수를 임의 순서로 늘어놓은 것이다. 다음 조건을 만족하는 수열들 중 오름차순으로 가장 앞에 오는 수열이 무엇인지 궁금하다. 이를 알아내는 프로그램을 작성하라.

1부터 n까지의 정수를 임의 순서로 늘어놓은 수열이다.
이 수열의 i번째 수 와 원래 수열 S의 i번째 수 의 차는 1을 넘을 수 없다.
<입력값>
첫 줄에 수열의 길이 n이 주어진다. (3≤n≤50,000) 이후 n개의 줄에 수열을 이루는 수가 한 개씩 차례대로 주어진다.
<출력값>
n개의 줄에 걸쳐, 조건을 만족하는 수열 중 오름차순으로 가장 앞에 오는 수열을 출력한다.

<문제 1899>
봄캠프에 와서 공부하고 있는 월드인들의 공부 스타일은 도대체 어떤 스타일일까?
월드인들은 봄캠프 일과에 따라 낮에는 문제를 풀고, 밤에는 토론을 한다고 한다. 학생들을 너무나 사랑하는 김진영 조교는 오랜 분석을 거친 후에 월드인의 공부 스타일은 20X호의 네 명의 학생들의 유형으로 구분된다는 것을 알았다.

‘권○○’형 (kwon) : 낮에 문제를 풀 때도 열심히 하고, 밤에 토론을 할 때도 열심히 하는 모범적인 스타일. 매사에 열심이라서, 원장님께 항상 거짓말을 하지 않는 착하고 성실한 유형.
‘김○○’형 (kim) : 낮에 문제를 풀 때는 열심히 하지만, 밤에 토론을 할 때는 열심히 하지 않는다. 혼자 묵묵히 문제만 푸는 스타일이 되겠다. 따라서 낮에는 원장님께 거짓말을 하지 않지만, 밤에는 토론에 참여하지 않다 보니 찔려서, 자신도 모르게 거짓말을 하게 되는 유형.
‘이○○’형 (lee) : 낮에 문제를 풀 때는 별로 열심히 하지 않지만, 밤에 토론을 할 때는 열심히 참여한다. 코딩을 하는 것보다 말로 토론하는 것을 좋아하는 스타일. 따라서 낮에는 원장님께 거짓말을 하며 놀다가, 밤에는 잘못을 뉘우치고 거짓말을 하지 않는 유형.
‘한○○’형 (han) : 낮에 문제를 풀 때든, 밤에 토론을 할 때든 상관없이 열심히 하지 않는 스타일이 되겠다. 따라서 본의 아니게 낮과 밤을 가리지 않고 원장님께 족족 거짓말을 하게 되는 유형.

학생들의 스타일을 전혀 모르고, 지금이 낮인지 밤인지도 모르는 원장님께서 몇몇 아이들과 대화를 나누어 보고 있다. 원장님께서는 알려진 대로 “각 학생들의 공부 스타일은 도대체 어떤 스타일일까?”를 굉장히 궁금해 하신다고 한다. 학생들과의 대화 내용만을 가지고 지금이 낮인지, 밤인지, 문제를 푸는지, 토론을 하는지를 최대한 추론해야 한다. 물론, 모든 학생들은 다른 학생들의 스타일을 정확히 파악하고 있다고 하자.
대화 내용이 주어지면, 원장님을 도와 이 대화만으로 유추할 수 있는 정보를 모두 알아내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 테스트 케이스의 개수 T(1≤T≤10)가 주어진다. 각 테스트 케이스는 아래와 같은 형식을 따른다.
첫째 줄에 문장의 개수 N(1≤N≤100)이 주어진다. 이어서 N개 줄에 대화 내용이 입력되는데, 모든 대화는 화자의 이름과 그 뒤를 따르는 ‘:’으로 시작된다. 학생들의 이름은 A∼H 중 하나이다. 모든 대화는 아래와 같은 형식을 따른다.

I am [not] ( kwon | kim | lee | han | lying ).
‘X’ is [not] ( kwon | kim | lee | han | lying ).
We are ( problem solving | discussing ).
It is ( day | night ).

여기서 [not]의 의미는 not이 나타날 수도 있고 나타나지 않을 수도 있다는 것이다. ()의 의미는 |으로 구분된 단어 중 하나는 반드시 나타나야 한다는 것이다. X는 A∼H 중 하나를 말한다.
<출력값>
각 케이스마다 첫째 줄에 번호를 "#1"∼"#10"과 같이 출력한다.
만약 입력된 대화가 절대 일어날 수 없는 것이라면 "Impossible."을 출력한다. 가능한 대화이기는 하지만 입력으로부터 추론할 수 있는 사실이 아무 것도 없다면 "No idea."를 출력한다. 그렇지 않다면 추론 가능한 모든 사실을 출력해야 한다. 사실들은 다음과 같은 형식으로 출력한다.

‘X’ is ( kwon | kim | lee | han)
They are ( problem solving | discussing )
It is ( day | night )

학생들의 정보는 A부터 H의 순서로 출력하고, 그 외의 사실들은 위의 형식에 나타난 순서대로 출력한다.

<문제 1900>
옛날에 레슬링을 무척 좋아하는 동호라는 국왕이 살았다. 그 당시 레슬링 선수들은 초자연적인 힘을 가졌다. 경기에 이기기 위해서 레슬링 선수는 자신의 힘뿐만 아니라 경기할 때 착용하는 마술 링에도 의존한다. 마술 링은 레슬링 선수로 하여금 상대 선수의 힘에 비례하는 힘을 추가로 얻을 수 있게 해준다.
레슬링 선수의 힘과 마술 링의 힘은 모두 양의 정수이다. 선수 A가 선수 B와 경기할 때, A의 ‘경기력’은 ‘A의 힘’ + ‘B의 힘’ * ‘A가 착용하고 있는 마술 링의 힘’이다. 경기에서는 경기력이 높은 선수가 이긴다.
예를 들어, 선수 A의 힘이 10이고 착용하고 있는 마술 링의 힘은 3이라고 하고, 선수 B의 힘은 18이고 착용하고 있는 마술 링의 힘은 4라고 하자. 이 두 선수가 경기를 가지면, A가 이긴다. 왜냐하면, A의 경기력은 10+3*18=64이지만 B의 경기력은 18+4*10=58이기 때문이다. 만약 A가 힘이 15이고 마술의 힘이 5인 링을 착용한 선수 C를 만났다면, C가 이긴다. 이 경기에서 A의 경기력은 10+3*15=55이고 C의 경기력은 15+5*10=65이다. 마찬가지로 B와 C의 경기에서는 C가 이긴다.
동호는 매년 레슬링 축제를 연다. 축제 기간에 각 레슬링 선수는 다른 모든 선수들과 한번씩 경기를 가진다. 이 축제의 마지막에 동호는 레슬링 선수를 보두 초대하여 축하하고 금화를 수여한다.
레슬링 선수들이 동호를 만나는 줄(순서)를 정하는 것은 희현이 할 일이다. 이 일은 매우 중요하다. 왜냐하면, 동호가 수여하는 금화의 수는 그가 이긴 경기수와 그가 선수들의 줄 어느 위치에 서 있느냐로 결정한다고 선언하였기 때문이다. 한 선수가 받는 금화의 수는 그가 이긴 경기 수 + 선수들의 줄에서 자기보다 앞에 있는데 자기가 이긴 선수의 수이다.
예를 들어 위의 세 선수 A, B, C에게 A, B, C의 순서로 동호를 만나면, A는 금화 1개, B는 0개, C는 4개를 받게 된다. C는 2 경기를 이겨서 2개에 자기가 이긴 A, B가 자기보다 줄에서 앞에 있으므로 각각 하나씩 2개를 합하여 4개를 받는다. 만약 C, A, B 순서라면 C는 2개, A는 1개, B는 0개를 받게 된다.
희현이는 나라의 재정을 고려하여 수여하는 금화의 수를 최소화하고자 한다. 당신이 할 일은 재무장관을 도와 수여하는 금화의 수를 최소화하도록 동호를 만나는 순서를 결정하는 것이다. 모든 선수들의 힘과 가진 마술 링의 힘이 주어진다. 경기에서 비기는 경우를 발생시키지 않는다고 가정한다.
<입력값>
첫째 줄에 선수들의 수 N이 주어진다. 선수들은 1부터 N까지 번호가 붙어 있다. 다음 N개의 줄에는 한 줄에 한 선수의 힘과 그가 가진 마술 링의 힘이 주어진다. 선수 k의 정보는 k+1번째 줄에 주어진다. N은 10000 이하이고, 선수의 힘과 마술 링의 힘은 모두 1 이상 1000 이하라고 가정하여도 좋다.
<출력값>
동호를 만나는 순서대로 한 줄에 하나씩 선수의 번호를 출력한다.

<문제 1901>
논리식은 컴퓨터 프로그램에 자주 사용된다. 논리식은 다음으로 구성된다.

true 또는 false의 값을 가지는 변수
단항 및 이항 논리 연산자
연산의 순서에 영향을 줄 수 있는 괄호

단항 연산자는 하나의 변수에 대해 동작하고, 이항 연산자는 두 개의 변수에 대해 동작한다. 자주 쓰이는 단항 연산자로 NOT이 있고, 자주 쓰이는 이항 연산자로 AND, OR, XOR, NAND, NOR 등이 있다.
논리 연산자는 '진리표'로써 정의할 수 있다. 이 진리표는 단항 연산자의 경우 1차원, 이항 연산자의 경우 2차원이다. 예를 들어, 다음 그림을 보자.

위쪽 여백과 왼쪽 여백 모두 첫 번째 피연산자가 false이고, 두 번째 피연산자가 true임에 주목하자.
논리식의 예시는 다음과 같다.

(x AND (NOT(y NAND z)))
(x OR ((NOT y) XOR z))

이 문제에서 논리식의 정확한 구조는 다음 문법으로 정의된다.

<expression> = <variable> | ( <expression> <operator> <expression> ) | ( <operator> <expression>)
<variable> = <lowercase_letter>
<operator> = <uppercase_letter> | <operator> <uppercase_letter>
(여기서 수직 막대 '|'는 'or'라고 발음하며, 문법을 정의할 때 사용하는 글자이다. 실제 식에서는 나타나지 않는다.) <lowercase_letter>와 <uppercase_letter>는 알파벳 대소문자이다.
어떤 경우에서는 모든 변수의 값이 정해지지 않아도 논리식을 계산할 수 있다. 위의 첫 번째 예시에서, y는 false이고, x와 z의 값은 모른다고 해 보자. 그러면 나머지 변수의 값이 무엇이든 해당 논리식은 항상 false로 계산됨을 알 수 있다. 반면, 같은 예시에서, x = true, y = true이고, z의 값은 모른다고 해보자. 그러면 z의 값을 알지 않고서는 논리식의 값을 결정할 수 없다.
<입력값>
입력은 하나 이상의 테스트 케이스로 이루어져 있다. 각 테스트 케이스마다 첫 줄에 100 이하의 음이 아닌 정수가 2개 주어지며, 각각 그 케이스에서 사용할 단항 연산자와 이항 연산자의 종류이다.
그 다음에는 아래 두 문단에서 설명하는 형식으로 각 연산자의 이름과 진리표 형태의 연산자 정의가 여러 줄에 걸쳐 주어진다. 모든 연산자의 이름은 20글자를 넘지 않으며, 서로 다르다.
우선 단항 연산자를 각각 2줄씩에 걸쳐 정의한다. 첫째 줄에는 연산자의 이름이 주어지고, 둘째 줄에는 두 개의 참/거짓 값이 주어지며, 이것이 그 연산자의 진리표가 된다. 피연산자의 순서는 위 그림에 주어진 것과 같이 false, true이다.
단항 연산자 다음에는 이항 연산자를 각각 3줄씩에 걸쳐 정의한다. 첫째 줄에는 연산자의 이름이 주어지고, 다음 두 줄에는 두 개씩의 참/거짓 값이 주어지며, 이것이 그 연산자의 진리표가 된다. 왼쪽 피연산자는 위 그림의 왼쪽 여백에, 오른쪽 피연산자는 위쪽 여백에 해당한다.
연산자를 모두 정의한 다음에는 위의 문법을 만족하는 유효한 논리식을 한 줄에 입력받는다. 변수와 연산자는 하나 이상의 띄어쓰기로 구분되어 있으며, 괄호로 묶인 식과 연산자 사이에는 띄어쓰기가 있을 수도 없을 수도 있다. 논리식에는 같은 변수가 두 번 이상 등장하지 않음이 보장된다. 논리식의 길이는 1 이상 500 이하이다.
논리식 다음에는 0개 이상의 변수의 값이 각각 한 줄로 주어진다. 각 줄은 아래 둘 중 하나의 형태이다.

<variable> true
<variable> false

같은 변수는 두 번 이상 주어지지 않는다.
각 테스트 케이스의 끝에는 별표(*) 하나가 주어지며, 입력의 끝에는 음의 정수 두 개가 한 줄로 주어진다.
<출력값>
각 테스트 케이스마다 한 줄씩 케이스 번호를 표시하고, 그 뒤에 true, false, unknown 중 주어진 논리식에 알맞은 것을 문제에서 설명한 대로 출력한다.
출력 포맷은 예제 출력을 통해 확인할 수 있다.

<문제 1902>
In a cave near Mirko's village lived his ancestors thousands of years ago. 
Mirko came to a conclusion that he is the only one who can find the remains of this ancient civilization so he started with preparations to explore. Therefore, he bought new pants, boots, a shovel and a hammer. Just before research he realized that there was no power supply in the cave and that he has to buy some lamps. But as he spent all the money for buying an up-to-date hammer, he realized that he had money only for one lamp. 
As Mirko wants to choose a spot from where he can see the entire floor, help him to determine a minimum height to which he must raise a lamp in order to illuminate the entire floor of the cave. 
We will imagine the cave's floor as a broken line in a coordinate system consisting of N peaks t1, t2 tN and lengths which connect consecutive peaks. 
The floor always goes from left to right, i.e. for every i=1, ..., N-1 x-coordinate of ti is smaller than xcoordinate of ti+1. 
Example (possible solution for third test example)

The lamp should be placed somewhere in a spot "above" cave's floor so that it illuminates the entire floor. To put it more precisely, x coordinate of the lamp must be placed between x coordinate of the first and last point of the floor (inclusive), and y coordinate of the lamp must be bigger than or equal to y coordinate of the floor point with the same x coordinate. 
We can say that the lamp illuminates the entire floor, if for every point on the floor we can say that the length which connects this point with a lamp does not perforate the broken line which represents the floor. However, it is allowed for the length and the broken line to connect at some points or along certain segments. 
Write a program that will determine the smallest possible height on which we can place a lamp sothat it illuminates the entire floor. 
You can presume that the result will always be less than or equal to 1,000,000 (one million).
<입력값>
In the first line,there is an integer N, 2 ≤ N ≤ 5000, number of peaks of the floor. 
In each of the next N lines, there are integers Xi i Yi, 0 ≤ Xi, Yi ≤ 100,000, in ith line numbers Xi i Yi i.e. coordinates of ith peak. Numbers Xi will be in ascending order.
<출력값>
In first and only line you should write y coordinate where you will put a lamp, real decimal number rounded to 2 decimal places. 
Your output value must be within 0.01 absolute or relative error of the correct value.

<문제 1904>
지원이에게 2진 수열을 가르쳐 주기 위해, 지원이 아버지는 그에게 타일들을 선물해주셨다. 그리고 이 각각의 타일들은 0 또는 1이 쓰여 있는 낱장의 타일들이다.
어느 날 짓궂은 동주가 지원이의 공부를 방해하기 위해 0이 쓰여진 낱장의 타일들을 붙여서 한 쌍으로 이루어진 00 타일들을 만들었다. 결국 현재 1 하나만으로 이루어진 타일 또는 0타일을 두 개 붙인 한 쌍의 00타일들만이 남게 되었다.
그러므로 지원이는 타일로 더 이상 크기가 N인 모든 2진 수열을 만들 수 없게 되었다. 예를 들어, N=1일 때 1만 만들 수 있고, N=2일 때는 00, 11을 만들 수 있다. (01, 10은 만들 수 없게 되었다.) 또한 N=4일 때는 0011, 0000, 1001, 1100, 1111 등 총 5개의 2진 수열을 만들 수 있다.
우리의 목표는 N이 주어졌을 때 지원이가 만들 수 있는 모든 가짓수를 세는 것이다. 단 타일들은 무한히 많은 것으로 가정하자.
<입력값>
첫 번째 줄에 자연수 N이 주어진다. (1 ≤ N ≤ 1,000,000)
<출력값>
첫 번째 줄에 지원이가 만들 수 있는 길이가 N인 모든 2진 수열의 개수를 15746으로 나눈 나머지를 출력한다.

<문제 1905>
넓은 창고에 상자들을 쌓으려고 한다. 상자는 하나씩 창고에 입고되며, 입고되는 순서대로 쌓아 나가야 한다. 또, 각 상자마다 그 상자를 쌓아야 하는 위치가 정확히 지정되어 있으며, 쌓을 때 회전시킬 수도 없다. 상자들은 직육면체 모양으로, 가로, 세로, 높이의 길이가 다양하다. 상자를 쌓아 둘 창고 역시 직육면체 모양이지만, 그 높이는 충분히 높다고 가정하자.
편의상 창고 바닥의 남서쪽 코너를 원점으로 하여 좌표계를 구성하도록 한다. 창고의 각 모서리는 x, y, z 각 좌표축에 평행하거나 수직하다. x축은 동쪽 방향, y축은 북쪽 방향, z축은 하늘 방향으로 잡는다. 물론 상자들도 각 모서리가 x, y, z축에 평행하거나 수직하게 되도록 쌓을 것이다.
여러분이 할 일은, 주어진 순서대로 각 상자들을 쌓았을 때, 가장 높은 위치의 고도를 알아내는 것이다. 이를 위한 프로그램을 작성하라.
<입력값>
첫 줄에 세 정수 Lx, Ly, N이 주어진다. (1 ≤ Lx, Ly ≤ 1,000, 1 ≤ N ≤ 20,000) Lx와 Ly는 창고의 가로, 세로 길이이며, N은 입고되는 상자의 개수이다. 이후 N개의 줄에 각 상자의 정보가 입고되는 순서로 주어진다. 이는 다섯 개의 정수 lx, ly, lz, px, py 로 이루어진다. (1 ≤ lx, 0 ≤ px, px+lx ≤ Lx, 1 ≤ ly, 0 ≤ py, py+ly ≤ Ly, 1 ≤ lz ≤ 100,000) lx, ly, lz는 각각 상자의 가로, 세로, 높이 길이를 나타낸다. px, py는 상자를 쌓아야 하는 위치를 나타낸다. 상자 바닥의 네 꼭짓점 중 가장 남서쪽에 있는 것의 x, y좌표를 px, py에 맞추어 쌓으면 된다.
<출력값>
첫 줄에 상자를 모두 쌓았을 때, 가장 높은 곳의 고도를 출력한다.

<문제 1906>
내일은 월드생이 팀전을 펼치는 날이다. 팀은 총 K팀으로 나뉘어져 있고, N명의 월드생들은 모두 1팀부터 K팀 중 단 하나의 팀에만 소속되어 있다.
월드생들은 현재 팀에 상관없이 한 줄로 뒤죽박죽으로 앉아서 공부를 하고 있기 때문에 팀끼리 함께 공부하기 위해 자리 교체의 필요성을 느끼고 있다.
하지만 귀찮은 것을 싫어하는 월드생들이기에, 게다가 오늘은 모의고사까지 봤기 때문에 자리를 바꾸는 것을 원치 않는다.
결국 이에 자칭 월드 Ace 성원이가 나서서 학생들이 자리를 최소로 바꿔 모든 팀들이 연속적으로 앉는 프로그램을 짜겠다고 나섰다.
<입력값>
첫 번째 줄에 N(1≤N≤300,000)과 K(1≤K≤8)가 입력된다. 이어서 한 줄에 하나씩 N개의 수가 주어지는데 이는 각 학생이 속해 있는 팀의 번호이다.
<출력값>
첫째 줄에 모든 팀이 연속적으로 앉기 위해 필요한 최소의 자리 교체 횟수를 출력한다.

<문제 1907>
세 가지 종류의 원자 - C, H, O로만 이루어진 화합물을 탄소 화합물이라고 한다. 우리는 아래와 같은 단순한 화학식의 계수를 맞추어 균형을 주려고 한다.
<분자> + <분자> = <분자>
여기서 <분자>란 아래와 같은 형식으로 되어 있는 문자열을 말한다.
<원자>[숫자]<원자>[숫자] … <원자>[숫자]
각각의 분자는 적어도 하나 이상의 원자로 구성되어 있고, 각각의 원자 뒤에 따라붙게 되는 숫자는 그 원자가 몇 번 나타나는가 하는 것이다. 숫자는 2 이상 9 이하이며, 숫자가 표시되지 않은 경우는 그 원자가 한 번만 나타났다는 뜻이다.
예를 들어 HC3OH2와 같은 문자열은 분자이고, 이는 H 3개, C 3개, O 1개로 되어 있는 분자가 된다. C2HOH + CH = C5O2H4와 같은 식이 우리가 관심이 있는 화학식이 된다.
어떤 화학식이 균형이 있다는 것은, 등호(=)를 기준으로 왼쪽에 있는 각각의 원자의 개수와 오른쪽에 있는 각각의 원자의 개수가 같을 때를 말한다. 예를 들어 C+CH=C2H와 같은 식이 균형 있는 화학식이 된다.
만일 어떤 화학식이 균형이 있지 않다면, 적절한 계수를 주어 화학식의 균형을 맞출 수 있다. 즉 각 <분자>가 여러 개 있는 것으로 생각한다는 것이다. 예를 들어 C+CC=CCCCC와 같은 화학식은 C + 2 ( CC ) = CCCCC 와 같이 1, 2, 1의 계수를 주어 균형을 맞출 수 있다는 것이다.
탄소 화합물 분자로만 이루어진 <분자> + <분자> = <분자> 형태의 화학식이 주어지면, 적절히 계수를 맞추어서 균형 있는 화학식으로 만드는 프로그램을 작성하시오. 단, 계수는 1 이상 10 이하로만 한정하도록 하자.
<입력값>
첫째 줄에 M1+M2=M3 형태의 화학식이 입력으로 주어진다. 주어지는 화학식의 길이는 50을 넘지 않으며, 'C', 'H', 'O', '+', '='와 '2'∼'9'만으로 이루어져 있다.
<출력값>
첫째 줄에 세 정수 X1, X2, X3 (1 이상 10 이하)를 빈 칸을 사이에 두고 순서대로 출력한다. 이는 각각 M1, M2, M3의 계수가 된다. 만일 해가 둘 이상이라면 답을 세 자연수로 이루어진 수열으로 생각해서, 사전순으로 가장 앞선 것을 출력한다. (즉 X1이 가장 작은 것을 먼저 출력하고, 그것도 둘 이상이면 X2가 가장 작은 것, ... 이런 순서로 출력한다.)

<문제 1908>
대수학에서 전개식을 구하는 것은 꽤나 지루한 작업 중의 하나이다. 자연수 n이 주어지면, 아래와 같은 곱셈식을 생각해 볼 수 있다.
(x+a1)(x+a2)...(x+an-1)(x+an)
예를 들어 n=2와 n=3인 경우, 위 식을 전개해 보면 아래와 같은 결과가 된다.

n=2: x2+x(a1+a2)+a1a2
n=3: x3+x2(a1+a2+a3)+x(a1a2+a1a3+a2a3)+a1a2a3

매번 곱셈 전개식을 구하는 번거로움을 덜기 위해, 당신은 n이 주어지면 이를 계산해 주는 프로그램을 작성하려고 한다. 하지만 텍스트로 수식을 출력하려면 위 첨자와 아래 첨자 때문에 아래와 같이 세 줄에 걸쳐서 출력해야 한다. (맨 위의 숫자가 적힌 줄은 길이를 나타내 주기 위함이다.)

1234567890123456789012345678901234567890
 3  2        
x +x (a +a +a )+x(a a +a a +a a )+a a a
       1  2  3     1 2  1 3  2 3   1 2 3

따라서 우리는 n=3일 때 곱셈 전개식의 길이가 40이 됨을 알 수 있다. 만일 n이 점점 커진다면, 곱셈 전개식의 길이는 어떻게 될까? 이를 구하는 프로그램을 작성하시오.
주의할 점은 출력할 때 불필요한 괄호가 포함되어서는 안 되고, x를 x1과 같이 표현해서는 안 된다는 것이다.
예를 들어 n=10일 때, 곱셈 전개식의 앞 부분은 아래와 같이 된다.

123456789012345678901234567890123456789012345678
 10  9                                  8
x  +x (a +a +a +a +a +a +a +a +a +a  )+x (a a +
        1  2  3  4  5  6  7  8  9  10      1 2
<입력값>
첫째 줄에 자연수 n이 주어진다. (1 ≤ n ≤ 1,000,000,000)
<출력값>
첫째 줄에 식을 전개하였을 때의 길이를 출력한다. 단, 길이가 매우 길어질 수 있으므로 이를 10,000으로 나눈 나머지만을 출력한다.

<문제 1909>
월드 캠프가 계속될수록, 씻지 않아 냄새를 풍기는 사람들이 늘어 가고 있다. 이에 따라 당신은 교실에서 한 지점에서 다른 지점으로 이동할 일이 생겼을 때, 냄새나는 사람들이 앉아 있는 자리로부터 최대한 멀리 떨어진 경로를 따라 걸어가고 싶어졌다. 이를 해결하는 프로그램을 작성하라.
교실은 좌표 평면으로 표현된다. 친구들이 앉아 있는 좌표 (x,y), 시작지점과 목적지점의 좌표 (sx,sy), (tx,ty)는 교실의 가로 세로 크기 Wx, Wy에 대해 1≤x, sx, tx≤Wx, 1≤y, sy, ty≤Wy를 만족한다. Wx, Wy는 2≤Wx, Wy≤1,000를 만족한다. 냄새나는 사람들의 수 n은 1≤n≤Wx*Wy- 2 를 만족한다.
좌표 평면에서 x축 혹은 y축에 평행하게 (가로 혹은 세로 방향으로) 1만큼씩 움직여, 시작지점에서 목적지점까지 이동하며 거친 점들의 자취를 하나의 경로라고 한다. 단, 점들의 좌표는 항상 양의 정수를 유지해야 한다. 냄새나는 사람들과 어떤 경로와의 거리는, 경로 위의 임의의 점과, 임의의 냄새나는 사람들이 앉아 있는 점들 사이의 거리 중 가장 짧은 것으로 정의된다. 가능한 경로 중, 냄새나는 사람들과의 거리가 가장 먼 경로를 최적의 경로라고 할 수 있다.
여러분이 할 일은, 시작지점과 목적지점, 냄새나는 사람들이 앉아 있는 위치가 주어졌을 때, 최적의 경로를 따라 이동할 경우, 냄새나는 사람들과 경로와의 거리가 얼마인지 구하는 것이다.
<입력값>
첫 줄에 교실의 크기를 나타내는 두 정수 Wx, Wy가 주어진다. 둘째 줄에는 시작지점과 목적지점의 좌표를 나타내는 네 정수 sx, sy, tx, ty가 주어진다. 셋째 줄에는 냄새나는 사람들의 수 n이 주어진다. 넷째 줄부터는 한 줄에 하나씩 냄새나는 사람들이 앉아있는 곳의 좌표 xi, yi가 주어진다. 시작지점과 도착지점에는 냄새나는 사람들이 앉아있지 않다.
<출력값>
최적의 경로로 이동할 때, 냄새나는 사람들과 경로와의 거리가 얼마인지를 구해서, 첫 줄에 그 제곱값을 출력한다. 무슨 수를 쓰더라도 냄새나는 사람들이 있는 위치를 피해갈 수 없을 경우, 출력값은 0이 된다.

<문제 1910>
어제 자유시간에 혼자 위닝을 하면서 자신의 실력을 자랑하던 주호는 강조교한테 편안하게 버스를 타고 말았다.
이에 화가 난 주호는 공부에 대한 생각도 잊은채 위닝을 연습하기로 결심하였다. 하지만 수업시간에 컴퓨터로 직접 하는것이 힘들었기 때문에 바깥에서 N개의 돌멩이로 전략을 세우기로 결심하였다.
주호는 연구한 끝에 자신의 가장 큰 약점은 패스라는 것을 깨달았다. 결국 적절하게 돌멩이를 배치한 다음 효율적으로 패스하는 법을 연구하기로 했는데….
N개의 돌멩이들이 있고  상호간에 패스가 가능한 쌍들이 있다. 즉 모든 쌍들 사이에 패스가 가능한 것이 아니다.
주호는 이 돌멩이들을 적절하게 공격 그룹과 수비 그룹의 두 그룹으로 나누고자 한다. 하지만 패스가 효율적으로 이루어지기 위해서는 각각의 돌멩이들에 대해, 자신과 같은 그룹에 속해 있으면서 패스가 가능한 돌멩이들의 수가 짝수가 되어야 한다. 결국 주호의 목적은 이 조건을 만족하는 총 돌멩이의 숫자가 최대 몇 개인지 알아내는 것이다.
<입력값>
첫 번째 줄에 돌멩이의 개수 N(1 ≤ N ≤ 200)이 주어진다. 그 다음 i+1번째 줄에 i번째 돌멩이가 패스할 수 있는 돌멩이의 개수 Li가 들어온다. 그리고 그 다음 각각의 줄에 Li개의 패스 가능한 돌멩이에 해당하는 숫자가 들어온다. 단 각각의 돌멩이들이 자신에게 패스하는 경우는 없고, A 돌멩이가 B 돌멩이의 패스가 가능하다면 B도 A에게 패스가 가능하다고 하자.
<출력값>
첫 번째 줄에 공격이나 수비 중 한쪽 그룹에 속한 돌멩이의 개수 M이 출력된다. 그리고 그 다음 줄에 그 그룹에 속한 돌멩이에 해당하는 숫자를 출력한다. 출력되지 않은 숫자는 반대편 그룹에 속하는 것으로 한다. 여러 가지 해가 존재하는 경우 그 중 하나만 출력하면 된다.

<문제 1911>
어젯밤 겨울 캠프 장소에서 월드 본원까지 이어지는, 흙으로 된 비밀길 위에 폭우가 내려서 N (1 <= N <= 10,000) 개의 물웅덩이가 생겼다. 월드학원은 물웅덩이를 덮을 수 있는 길이 L (L은 양의 정수) 짜리 널빤지들을 충분히 가지고 있어서, 이들로 다리를 만들어 물웅덩이들을 모두 덮으려고 한다. 물웅덩이들의 위치와 크기에 대한 정보가 주어질 때, 모든 물웅덩이들을 덮기 위해 필요한 널빤지들의 최소 개수를 구하여라.
<입력값>
첫째 줄에 N과 L이 들어온다.
둘째 줄부터 N+1번째 줄까지 총 N개의 줄에 각각의 웅덩이들의 정보가 주어진다. 웅덩이의 정보는 웅덩이의 시작 위치와 끝 위치로 이루어진다. 각 위치는 0이상 1,000,000,000이하의 정수이다.
<출력값>
첫째 줄에 모든 물웅덩이들을 덮기 위해 필요한 널빤지들의 최소 개수를 출력한다.

<문제 1912>
n개의 정수로 이루어진 임의의 수열이 주어진다. 우리는 이 중 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하려고 한다. 단, 수는 한 개 이상 선택해야 한다.
예를 들어서 10, -4, 3, 1, 5, 6, -35, 12, 21, -1 이라는 수열이 주어졌다고 하자. 여기서 정답은 12+21인 33이 정답이 된다.
<입력값>
첫째 줄에 정수 n(1 ≤ n ≤ 100,000)이 주어지고 둘째 줄에는 n개의 정수로 이루어진 수열이 주어진다. 수는 -1,000보다 크거나 같고, 1,000보다 작거나 같은 정수이다.
<출력값>
첫째 줄에 답을 출력한다.

<문제 1913>
홀수인 자연수 N(3≤N≤999)이 주어지면, 다음과 같이 1부터 N2까지의 자연수를 달팽이 모양으로 N*N의 표에 늘어놓을 수 있다.



9
2
3


8
1
4


7
6
5






25
10
11
12
13


24
9
2
3
14


23
8
1
4
15


22
7
6
5
16


21
20
19
18
17



N이 주어졌을 때, 이러한 표를 출력하는 프로그램을 작성하시오. 또한 N2 이하의 자연수가 하나 주어졌을 때, 그 좌표도 함께 출력하시오. 예를 들어 N=5인 경우 6의 좌표는 (4,3)이다.
<입력값>
첫째 줄에 홀수인 자연수 N이 주어진다. 둘째 줄에는 위치를 찾고자 하는 N2 이하의 자연수가 하나 주어진다.
<출력값>
N개의 줄에 걸쳐 표를 출력한다. 각 줄에 N개의 자연수를 한 칸씩 띄어서 출력하면 되며, 자릿수를 맞출 필요가 없다. N+1번째 줄에는 입력받은 자연수의 좌표를 나타내는 두 정수를 한 칸 띄어서 출력한다.

<문제 1914>
세 개의 장대가 있고 첫 번째 장대에는 반경이 서로 다른 n개의 원판이 쌓여 있다. 각 원판은 반경이 큰 순서대로 쌓여있다. 이제 수도승들이 다음 규칙에 따라 첫 번째 장대에서 세 번째 장대로 옮기려 한다.

한 번에 한 개의 원판만을 다른 탑으로 옮길 수 있다.
쌓아 놓은 원판은 항상 위의 것이 아래의 것보다 작아야 한다.

이 작업을 수행하는데 필요한 이동 순서를 출력하는 프로그램을 작성하라. 단, 이동 횟수는 최소가 되어야 한다.
아래 그림은 원판이 5개인 경우의 예시이다.
<입력값>
첫째 줄에 첫 번째 장대에 쌓인 원판의 개수 N (1 ≤ N ≤ 100)이 주어진다.
<출력값>
첫째 줄에 옮긴 횟수 K를 출력한다.
N이 20 이하인 입력에 대해서는 두 번째 줄부터 수행 과정을 출력한다. 두 번째 줄부터 K개의 줄에 걸쳐 두 정수 A B를 빈칸을 사이에 두고 출력하는데, 이는 A번째 탑의 가장 위에 있는 원판을 B번째 탑의 가장 위로 옮긴다는 뜻이다. N이 20보다 큰 경우에는 과정은 출력할 필요가 없다.

<문제 1915>
n×m의 0, 1로 된 배열이 있다. 이 배열에서 1로 된 가장 큰 정사각형의 크기를 구하는 프로그램을 작성하시오.



0
1
0
0


0
1
1
1


1
1
1
0


0
0
1
0



위와 같은 예제에서는 가운데의 2×2 배열이 가장 큰 정사각형이다.
<입력값>
첫째 줄에 n, m(1 ≤ n, m ≤ 1,000)이 주어진다. 다음 n개의 줄에는 m개의 숫자로 배열이 주어진다.
<출력값>
첫째 줄에 가장 큰 정사각형의 넓이를 출력한다.

<문제 1916>
N개의 도시가 있다. 그리고 한 도시에서 출발하여 다른 도시에 도착하는 M개의 버스가 있다. 우리는 A번째 도시에서 B번째 도시까지 가는데 드는 버스 비용을 최소화 시키려고 한다. A번째 도시에서 B번째 도시까지 가는데 드는 최소비용을 출력하여라. 도시의 번호는 1부터 N까지이다.
<입력값>
첫째 줄에 도시의 개수 N(1 ≤ N ≤ 1,000)이 주어지고 둘째 줄에는 버스의 개수 M(1 ≤ M ≤ 100,000)이 주어진다. 그리고 셋째 줄부터 M+2줄까지 다음과 같은 버스의 정보가 주어진다. 먼저 처음에는 그 버스의 출발 도시의 번호가 주어진다. 그리고 그 다음에는 도착지의 도시 번호가 주어지고 또 그 버스 비용이 주어진다. 버스 비용은 0보다 크거나 같고, 100,000보다 작은 정수이다.
그리고 M+3째 줄에는 우리가 구하고자 하는 구간 출발점의 도시번호와 도착점의 도시번호가 주어진다. 출발점에서 도착점을 갈 수 있는 경우만 입력으로 주어진다.
<출력값>
첫째 줄에 출발 도시에서 도착 도시까지 가는데 드는 최소 비용을 출력한다.

<문제 1917>
여섯 개의 정사각형 모양의 종이가 있으면, 이를 적절히 이어 붙여서 정육면체의 전개도를 만들 수 있다. 정육면체의 전개도라는 것은, 선을 따라 종이를 적절히 접었을 때 정육면체를 완성할 수 있는 경우를 말한다.
예를 들면 아래의 모양은 정육면체의 전개도가 될 수 있다.

하지만 모든 경우에 정육면체를 만들 수 있는 것은 아니다. 예를 들어 다음과 같은 모양의 전개도는 여섯 개의 정사각형으로 이루어 있기는 하나 정육면체를 만들 수는 없다.

여섯 개의 정사각형으로 이루어진 전개도가 주어졌을 때, 이것이 정육면체의 전개도가 될 수 있는지 없는지를 가려내는 프로그램을 작성하시오.
<입력값>
세 개의 입력 데이터가 주어지며, 각각의 입력 데이터는 여섯 개의 줄로 이루어져 있다. 각 데이터는 여섯 개의 줄에 걸쳐 여섯 개의 숫자가 빈 칸을 사이에 두고 주어진다. 숫자는 0 또는 1로 이루어지며, 36개의 숫자 중 1은 정확히 6개가 있다. 0은 공백을 나타내며 1은 정사각형을 나타낸다. (즉 전체의 그림이 전개도를 나타낸다고 보면 된다.) 정사각형들이 서로 떨어져 있는 경우는 없다.
<출력값>
세 개의 줄에 걸쳐, 입력된 순서대로 전개도가 정육면체의 전개도이면 yes를, 아니면 no를 출력한다.

<문제 1918>
수식은 일반적으로 3가지 표기법으로 표현할 수 있다. 연산자가 피연산자 가운데 위치하는 중위 표기법(일반적으로 우리가 쓰는 방법이다), 연산자가 피연산자 앞에 위치하는 전위 표기법(prefix notation), 연산자가 피연산자 뒤에 위치하는 후위 표기법(postfix notation)이 그것이다. 예를 들어 중위 표기법으로 표현된 a+b는 전위 표기법으로는 +ab이고, 후위 표기법으로는 ab+가 된다.
이 문제에서 우리가 다룰 표기법은 후위 표기법이다. 후위 표기법은 위에서 말한 법과 같이 연산자가 피연산자 뒤에 위치하는 방법이다. 이 방법의 장점은 다음과 같다. 우리가 흔히 쓰는 중위 표기식 같은 경우에는 덧셈과 곱셈의 우선순위에 차이가 있어 왼쪽부터 차례로 계산할 수 없지만 후위 표기식을 사용하면 순서를 적절히 조절하여 순서를 정해줄 수 있다. 또한 같은 방법으로 괄호 등도 필요 없게 된다. 예를 들어 a+b*c를 후위 표기식으로 바꾸면 abc*+가 된다.
중위 표기식을 후위 표기식으로 바꾸는 방법을 간단히 설명하면 이렇다. 우선 주어진 중위 표기식을 연산자의 우선순위에 따라 괄호로 묶어준다. 그런 다음에 괄호 안의 연산자를 괄호의 오른쪽으로 옮겨주면 된다.
예를 들어 a+b*c는 (a+(b*c))의 식과 같게 된다. 그 다음에 안에 있는 괄호의 연산자 *를 괄호 밖으로 꺼내게 되면 (a+bc*)가 된다. 마지막으로 또 +를 괄호의 오른쪽으로 고치면 abc*+가 되게 된다.
다른 예를 들어 그림으로 표현하면 A+B*C-D/E를 완전하게 괄호로 묶고 연산자를 이동시킬 장소를 표시하면 다음과 같이 된다.

이러한 사실을 알고 중위 표기식이 주어졌을 때 후위 표기식으로 고치는 프로그램을 작성하시오
<입력값>
첫째 줄에 중위 표기식이 주어진다. 단 이 수식의 피연산자는 A~Z의 문자로 이루어지며 수식에서 한 번씩만 등장한다. 그리고 -A+B와 같이 -가 가장 앞에 오거나 AB와 같이 *가 생략되는 등의 수식은 주어지지 않는다. 표기식은 알파벳 대문자와 +, -, *, /, (, )로만 이루어져 있으며, 길이는 100을 넘지 않는다.
<출력값>
첫째 줄에 후위 표기식으로 바뀐 식을 출력하시오

<문제 1919>
두 영어 단어가 철자의 순서를 뒤바꾸어 같아질 수 있을 때, 그러한 두 단어를 서로 애너그램 관계에 있다고 한다. 예를 들면 occurs 라는 영어 단어와 succor 는 서로 애너그램 관계에 있는데, occurs의 각 문자들의 순서를 잘 바꾸면 succor이 되기 때문이다.
한 편, dared와 bread는 서로 애너그램 관계에 있지 않다. 하지만 dared에서 맨 앞의 d를 제거하고, bread에서 제일 앞의 b를 제거하면, ared와 read라는 서로 애너그램 관계에 있는 단어가 남게 된다.
두 개의 영어 단어가 주어졌을 때, 두 단어가 서로 애너그램 관계에 있도록 만들기 위해서 제거해야 하는 최소 개수의 문자 수를 구하는 프로그램을 작성하시오. 문자를 제거할 때에는 아무 위치에 있는 문자든지 제거할 수 있다.
<입력값>
첫째 줄과 둘째 줄에 영어 단어가 소문자로 주어진다. 각각의 길이는 1,000자를 넘지 않으며, 적어도 한 글자로 이루어진 단어가 주어진다.
<출력값>
첫째 줄에 답을 출력한다.

<문제 1920>
N개의 정수 A[1], A[2], …, A[N]이 주어져 있을 때, 이 안에 X라는 정수가 존재하는지 알아내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 자연수 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 줄에는 N개의 정수 A[1], A[2], …, A[N]이 주어진다. 다음 줄에는 M(1 ≤ M ≤ 100,000)이 주어진다. 다음 줄에는 M개의 수들이 주어지는데, 이 수들이 A안에 존재하는지 알아내면 된다. 모든 정수의 범위는 -231 보다 크거나 같고 231보다 작다.
<출력값>
M개의 줄에 답을 출력한다. 존재하면 1을, 존재하지 않으면 0을 출력한다.

<문제 1922>
도현이는 컴퓨터와 컴퓨터를 모두 연결하는 네트워크를 구축하려 한다. 하지만 아쉽게도 허브가 있지 않아 컴퓨터와 컴퓨터를 직접 연결하여야 한다. 그런데 모두가 자료를 공유하기 위해서는 모든 컴퓨터가 연결이 되어 있어야 한다. (a와 b가 연결이 되어 있다는 말은 a에서 b로의 경로가 존재한다는 것을 의미한다. a에서 b를 연결하는 선이 있고, b와 c를 연결하는 선이 있으면 a와 c는 연결이 되어 있다.)
그런데 이왕이면 컴퓨터를 연결하는 비용을 최소로 하여야 컴퓨터를 연결하는 비용 외에 다른 곳에 돈을 더 쓸 수 있을 것이다. 이제 각 컴퓨터를 연결하는데 필요한 비용이 주어졌을 때 모든 컴퓨터를 연결하는데 필요한 최소비용을 출력하라. 모든 컴퓨터를 연결할 수 없는 경우는 없다.
<입력값>
첫째 줄에 컴퓨터의 수 N (1 ≤ N ≤ 1000)가 주어진다.
둘째 줄에는 연결할 수 있는 선의 수 M (1 ≤ M ≤ 100,000)가 주어진다.
셋째 줄부터 M+2번째 줄까지 총 M개의 줄에 각 컴퓨터를 연결하는데 드는 비용이 주어진다. 이 비용의 정보는 세 개의 정수로 주어지는데, 만약에 a b c 가 주어져 있다고 하면 a컴퓨터와 b컴퓨터를 연결하는데 비용이 c (1 ≤ c ≤ 10,000) 만큼 든다는 것을 의미한다. a와 b는 같을 수도 있다.
<출력값>
모든 컴퓨터를 연결하는데 필요한 최소비용을 첫째 줄에 출력한다.

<문제 1924>
오늘은 2007년 1월 1일 월요일이다. 그렇다면 2007년 x월 y일은 무슨 요일일까? 이를 알아내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 빈 칸을 사이에 두고 x(1 ≤ x ≤ 12)와 y(1 ≤ y ≤ 31)이 주어진다. 참고로 2007년에는 1, 3, 5, 7, 8, 10, 12월은 31일까지, 4, 6, 9, 11월은 30일까지, 2월은 28일까지 있다.
<출력값>
첫째 줄에 x월 y일이 무슨 요일인지에 따라 SUN, MON, TUE, WED, THU, FRI, SAT중 하나를 출력한다.

<문제 1925>
평면상에 세 개의 점이 주어지면, 그 세 점으로 이루어지는 삼각형은 유일하게 결정된다.  (또는, 삼각형이 이루어지지 않기도 한다.) 세 점의 좌표가 주어졌을 때 다음에 따라 이 삼각형의 종류를 판단하는 프로그램을 작성하시오.

세 점이 일직선 위에 있으면 - ‘삼각형이 아님’  출력할 때는 X
세 변의 길이가 같으면 - ‘정삼각형’ 출력할 때는 JungTriangle
두 변의 길이가 같으면
	
가장 큰 각이 90°보다 크면 - ‘둔각이등변삼각형’ 출력할 때는 Dunkak2Triangle
가장 큰 각이 90°이면 - ‘직각이등변삼각형’ 출력할 때는 Jikkak2Triangle
가장 큰 각이 90°보다 작으면 - ‘예각이등변삼각형’ 출력할 때는 Yeahkak2Triangle


세 변의 길이가 모두 다르면
	
가장 큰 각이 90°보다 크면 - ‘둔각삼각형’ 출혁할 때는 DunkakTriangle
가장 큰 각이 90°이면 - ‘직각삼각형’ 출력할 때는 JikkakTriangle
가장 큰 각이 90°보다 작으면 - ‘예각삼각형’ 출력할 때는 YeahkakTriangle
<입력값>
첫째 줄부터 셋째 줄까지 삼각형을 이루는 점의 x좌표와 y좌표가 빈칸을 사이에 두고 주어진다. 입력되는 수는 절댓값이 10,000을 넘지 않는 정수이다.
<출력값>
위의 경우에 따라 삼각형의 종류가 무엇인지 출력한다.

<문제 1926>
어떤 큰 도화지에 그림이 그려져 있을 때, 그 그림의 개수와, 그 그림 중 넓이가 가장 넓은 것의 넓이를 출력하여라. 단, 그림이라는 것은 1로 연결된 것을 한 그림이라고 정의하자. 가로나 세로로 연결된 것은 연결이 된 것이고 대각선으로 연결이 된 것은 떨어진 그림이다. 그림의 넓이란 그림에 포함된 1의 개수이다.
<입력값>
첫째 줄에 도화지의 세로 크기 n(1 ≤ n ≤ 500)과 가로 크기 m(1 ≤ m ≤ 500)이 차례로 주어진다. 두 번째 줄부터 n+1 줄 까지 그림의 정보가 주어진다. (단 그림의 정보는 0과 1이 공백을 두고 주어지며, 0은 색칠이 안된 부분, 1은 색칠이 된 부분을 의미한다)
<출력값>
첫째 줄에는 그림의 개수, 둘째 줄에는 그 중 가장 넓은 그림의 넓이를 출력하여라. 단, 그림이 하나도 없는 경우에는 가장 넓은 그림의 넓이는 0이다.

<문제 1927>
널리 잘 알려진 자료구조 중 최소 힙이 있다. 최소 힙을 이용하여 다음과 같은 연산을 지원하는 프로그램을 작성하시오.

배열에 자연수 x를 넣는다.
배열에서 가장 작은 값을 출력하고, 그 값을 배열에서 제거한다.

프로그램은 처음에 비어있는 배열에서 시작하게 된다.
<입력값>
첫째 줄에 연산의 개수 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 N개의 줄에는 연산에 대한 정보를 나타내는 정수 x가 주어진다. 만약 x가 자연수라면 배열에 x라는 값을 넣는(추가하는) 연산이고, x가 0이라면 배열에서 가장 작은 값을 출력하고 그 값을 배열에서 제거하는 경우이다. 입력되는 자연수는 231보다 작다.
<출력값>
입력에서 0이 주어진 회수만큼 답을 출력한다. 만약 배열이 비어 있는 경우인데 가장 작은 값을 출력하라고 한 경우에는 0을 출력하면 된다.

<문제 1928>
원장선생님께서 캠프 시간 내내 공부만 하면 지루하니까 조금이나마 분위기를 살리기 위해서 재미난(?) 게임을 한 개 고안하셨다. 이 게임은 우선 두 개의 팀으로 나누어서 게임을 하는 팀플레이 이다. 한 팀은 공격을 하는 팀이고 한 팀은 수비를 하는 팀이다. 두 팀은 각자 진영(조교 이름 아님-_-)을 가지고 있다. 이 상태에서 공격 팀이 수비 팀에게 몇 명을 보내 공격을 하고 수비 팀도 몇 명의 인원을 출전시켜 수비를 한다. 그런데 두 팀이 출전시키는데 는 다음과 같은 제약조건이 있다.

공격 팀은 자기 진영에 최소한 한 명 이상 남기고 수비 진영에게 쳐들어가게 된다. 만약에 공격 진영에 3명밖에 없다면 이 팀은 2명밖에 공격을 갈 수 없다. 하지만 수비 팀은 자신의 진영을 지켜야 하므로 상대팀이 쳐들어 올 경우 자기 진영에 한 명도 남기지 않고 출정할 수 있다.
공격 팀, 수비 팀 모두 최대 3명밖에 출전시킬 수 없다. 만약에 공격 팀이 5명이 있다고해도 3명밖에 쳐들어가지 못하고, 수비 팀도 마찬가지라는 소리이다.
두 팀 모두 보낼 수 있는 데로 최대한 많이 출전시켜야 한다. 예를 들어 공격 팀에 100명이 있다고 하면 3명을 꼭 출전시켜야 한다는 것이다. 또 공격 팀에 만약 2명이있다고 하면 1명을 꼭 출전시켜야 하는 것이다.

이러한 조건으로 두 팀에서 각각 출전시킨 사람들이 게임을 하게 된다. 게임의 규칙은 다음과 같다. 각 팀에서 출전한 사람들은 모두 주사위를 던진다. 그렇게 해서 서로 나온 눈의 수를 비교하는데, 이때 공격 팀에서 가장 높은 눈이 나온 사람과, 수비 팀에서 가장 높은 눈이 나온 사람이 비교하고, 또 공격 팀에서 두 번째로 높은 눈이 나온 사람과, 수비 팀에서 두 번째로 높은 눈이 나온 사람이 비교를 한다. 이렇게 해서 만약에 비교를 한 낮은 쪽의 사람은 죽게 된다. 만약에 두 사람의 눈의 숫자가 같다면 수비 팀에서 나온 사람이 이기고 공격 쪽에서 나온 사람이 죽게 된다.
만약에 공격 팀에서(3명 출전) 나온 눈이 3, 6, 5이고 수비 팀에서(2명 출전) 나온 눈이 4,6 이라면 공격 팀에서 6이 나온 사람과(수비 팀에서 가장 높은 6과 같으므로) 수비 팀에서 4가 나온 사람은 죽게 된다(공격 팀에서 두 번째로 높은 5가 4보다 높으므로). 이렇게 해서 싸움이 끝나게 되면 공격 팀과 수비 팀에 남은 사람은 각자 자기 진영으로 돌아간다. 그리고 다시 출전을 하여서 싸우게 되는 것이다.
이런 식으로 하다가 더 이상 공격을 할 수 없으면(공격 팀이 1명밖에 남지 않는 등) 수비 팀이 이기고, 수비 팀이 다 죽게 되면 공격 팀이 이기게 된다. 원장 선생님은 이러한 게임을 만들고 고민에 빠졌다. 수비 팀이 너무 유리하다는 것이다. 그래서 인원 배치를 적절히 하여서 공격 팀에 더 많은 숫자를 두려 한다.
하지만 이를 손으로 계산하는 것은 매우 어리석은 짓일 것이다. 그래서 원장 선생님은 선수반 학생들에게 도움을 요청하셨다. 우리가 해야 할 일은 이렇다. 수비 팀의 숫자가 주어졌을 때, 공격 팀의 인원이 몇 명 이상이 되어야 공격 팀이 이길 확률이 50% 이상이 되는지 구해야 하는 것이다.
<입력값>
첫째 줄에 수비 진영에 있는 사람의 숫자 N(1<=N<=1000) 이 주어진다.
<출력값>
최소 공격 진영에 필요한 인원을 출력한다.

<문제 1929>
M이상 N이하의 소수를 모두 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 자연수 M과 N이 빈 칸을 사이에 두고 주어진다. (1 ≤ M ≤ N ≤ 1,000,000) M이상 N이하의 소수가 하나 이상 있는 입력만 주어진다.
<출력값>
한 줄에 하나씩, 증가하는 순서대로 소수를 출력한다.

<문제 1930>
두 정사면체가 있다. 각 면에는 어떤 색깔이 칠해져 있다. 색깔은 정수로 표시한다. 두 정사면체의 면에 어떤 색이 칠해져 있는지가 주어졌을 때, 두 정사면체가 같은 정사면체인지 판별하시오. 정사면체를 회전하였을 때 같아지는 경우도 같은 경우로 본다.
<입력값>
첫째 줄에 데이터의 개수 K(1≤K≤1,000)가 주어진다. 다음 K개의 줄에는 8개의 정수로 정사면체의 각 면의 색깔이 주어진다. 첫 수는 밑면의 색깔이고, 다음 수들은 옆면의 색깔이 시계방향으로 순서대로 주어진다. 한 정사면체에 대한 네 정수가 먼저 주어지고, 다른 정사면체에 대한 네 정수가 뒤따른다. 색깔은 6만 칼라로 한다(1~60,000).
<출력값>
K개의 줄에 결과를 출력한다. 같으면 1, 다르면 0을 출력한다.

<문제 1931>
한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다. 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자. 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다.
<입력값>
첫째 줄에 회의의 수 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N+1 줄까지 각 회의의 정보가 주어지는데 이것은 공백을 사이에 두고 회의의 시작시간과 끝나는 시간이 주어진다. 시작 시간과 끝나는 시간은 231-1보다 작거나 같은 자연수 또는 0이다.
<출력값>
첫째 줄에 최대 사용할 수 있는 회의의 최대 개수를 출력한다.

<문제 1932>
7
      3   8
    8   1   0
  2   7   4   4
4   5   2   6   5
위 그림은 크기가 5인 정수 삼각형의 한 모습이다.
맨 위층 7부터 시작해서 아래에 있는 수 중 하나를 선택하여 아래층으로 내려올 때, 이제까지 선택된 수의 합이 최대가 되는 경로를 구하는 프로그램을 작성하라. 아래층에 있는 수는 현재 층에서 선택된 수의 대각선 왼쪽 또는 대각선 오른쪽에 있는 것 중에서만 선택할 수 있다.
삼각형의 크기는 1 이상 500 이하이다. 삼각형을 이루고 있는 각 수는 모두 정수이며, 범위는 0 이상 9999 이하이다.
<입력값>
첫째 줄에 삼각형의 크기 n(1 ≤ n ≤ 500)이 주어지고, 둘째 줄부터 n+1번째 줄까지 정수 삼각형이 주어진다.
<출력값>
첫째 줄에 합이 최대가 되는 경로에 있는 수의 합을 출력한다.

<문제 1933>
N개의 직사각형 모양의 건물들이 주어졌을 때, 스카이라인을 구해내는 프로그램을 작성하시오. 스카이라인은 건물 전체의 윤곽을 의미한다. 즉, 각각의 건물을 직사각형으로 표현했을 때, 그러한 직사각형들의 합집합을 구하는 문제이다.

예를 들어 직사각형 모양의 건물들이 위와 같이 주어졌다고 하자. 각각의 건물은 왼쪽 x좌표와 오른쪽 x좌표, 그리고 높이로 나타난다. 모든 건물들은 편의상 같은 높이의 지면(땅) 위에 있다고 가정하자. 위의 예에서 스카이라인을 구하면 아래와 같다.
<입력값>
첫째 줄에 건물의 개수 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 N개의 줄에는 N개의 건물에 대한 정보가 주어진다. 건물에 대한 정보는 세 정수 L, H, R로 나타나는데, 각각 건물의 왼쪽 x좌표, 높이, 오른쪽 x좌표를 의미한다. (1 ≤ L < R ≤ 1,000,000,000, 1 ≤ H ≤ 1,000,000,000)
<출력값>
첫째 줄에 스카이라인을 출력한다. 출력을 할 때에는 높이가 변하는 지점에 대해서, 그 지점의 x좌표와 그 지점에서의 높이를 출력한다.

<문제 1934>
두 자연수 A와 B에 대해서, A의 배수이면서 B의 배수인 자연수를 A와 B의 공배수라고 한다. 이런 공배수 중에서 가장 작은 수를 최소공배수라고 한다. 예를 들어, 6과 15의 공배수는 30, 60, 90등이 있으며, 최소 공배수는 30이다.
두 자연수 A와 B가 주어졌을 때, A와 B의 최소공배수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 테스트 케이스의 개수 T(1 ≤ T ≤ 1,000)가 주어진다. 둘째 줄부터 T개의 줄에 걸쳐서 A와 B가 주어진다. (1 ≤ A, B ≤ 45,000)
<출력값>
첫째 줄부터 T개의 줄에 A와 B의 최소공배수를 입력받은 순서대로 한 줄에 하나씩 출력한다.

<문제 1935>
후위 표기식과 각 피연산자에 대응하는 값들이 주어져 있을 때, 그 식을 계산하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 피연산자의 개수(1 ≤ N ≤ 26) 가 주어진다. 그리고 둘째 줄에는 후위 표기식이 주어진다. (여기서 피연산자는 A~Z의 영대문자이며, A부터 순서대로 N개의 영대문자만이 사용되며, 길이는 100을 넘지 않는다) 그리고 셋째 줄부터 N+2번째 줄까지는 각 피연산자에 대응하는 값이 주어진다. (3번째 줄에는 A에 해당하는 값, 4번째 줄에는 B에 해당하는값 , 5번째 줄에는 C ...이 주어진다, 그리고 피연산자에 대응 하는 값은 정수이다)
<출력값>
계산 결과를 소숫점 둘째 자리까지 출력한다.

<문제 1937>
n*n의 크기의 대나무 숲이 있다. 욕심쟁이 판다는 어떤 지역에서 대나무를 먹기 시작한다. 그리고 그 곳의 대나무를 다 먹어 치우면 상, 하, 좌, 우 중 한 곳으로 이동을 한다. 그리고 또 그곳에서 대나무를 먹는다. 그런데 단 조건이 있다. 이 판다는 매우 욕심이 많아서 대나무를 먹고 자리를 옮기면 그 옮긴 지역에 그 전 지역보다 대나무가 많이 있어야 한다. 만약에 그런 지점이 없으면 이 판다는 불만을 가지고 단식 투쟁을 하다가 죽게 된다(-_-)
이 판다의 사육사는 이런 판다를 대나무 숲에 풀어 놓아야 하는데, 어떤 지점에 처음에 풀어 놓아야 하고, 어떤 곳으로 이동을 시켜야 둘 다 소중한 생명이지만 판다가 최대한 오래 살 수 있는지 고민에 빠져 있다. 우리의 임무는 이 사육사를 도와주는 것이다. n*n 크기의 대나무 숲이 주어져 있을 때, 이 판다가 최대한 오래 살려면 어떤 경로를 통하여 움직여야 하는지 구하여라.
<입력값>
첫째 줄에 대나무 숲의 크기 n(1 ≤ n ≤ 500)이 주어진다. 그리고 둘째 줄부터 n+1번째 줄까지 대나무 숲의 정보가 주어진다. 대나무 숲의 정보는 공백을 사이로 두고 각 지역의 대나무의 양이 정수 값으로 주어진다. 대나무의 양은 1,000,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에는 판다가 최대한 살 수 있는 일수(K)를 출력한다.

<문제 1938>
가로와 세로의 길이가 같은 평지에서 벌목을 한다. 그 지형은 0과 1로 나타나 있다. 1은 아직 잘려지지 않은 나무를 나타내고 0은 아무 것도 없음을 나타낸다. 다음 지형을 보자.

B 0 0 1 1
B 0 0 0 0
B 0 0 0 0
1 1 0 0 0
E E E 0 0
위의 지형에서 길이 3인 통나무 BBB를 밀거나 회전시켜 EEE의 위치로 옮기는 작업을 하는 문제를 생각해 보자. BBB와 EEE의 위치는 임의로 주어진다. 단 문제에서 통나무의 길이는 항상 3이며 B의 개수와 E의 개수는 같다. 통나무를 움직이는 방법은 아래와 같이 상하좌우(Up, Down, Left, Right)와 회전(Turn)이 있다.



코드
의미




U
통나무를 위로 한 칸 옮긴다.


D
통나무를 아래로 한 칸 옮긴다.


L
통나무를 왼쪽으로 한 칸 옮긴다.


R
통나무를 오른쪽으로 한 칸 옮긴다.


T
중심점을 중심으로 90도 회전시킨다.



예를 들면, 다음과 같다. (초기상태로부터의 이동)



초기상태
상(U)
하(D)
좌(L)
우(R)
회전(T)






0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 B B B 0 0
0 0 0 0 0 0
0 0 0 1 0 0



0 0 0 0 0 0
0 0 0 0 0 0
0 B B B 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 1 0 0



0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 B B B 0 0
0 0 0 1 0 0



0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
B B B 0 0 0
0 0 0 0 0 0
0 0 0 1 0 0



0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0 B B B 0
0 0 0 0 0 0
0 0 0 1 0 0



0 0 0 0 0 0
0 0 0 0 0 0
0 0 B 0 0 0
0 0 B 0 0 0
0 0 B 0 0 0
0 0 0 1 0 0




이와 같은 방식으로 이동시킬 때에 그 움직일 위치에 다른 나무, 즉 1이 없어야만 움직일 수 있다. 그리고 움직임은 위의 그림과 같이 한 번에 한 칸씩만 움직인다. 단 움직이는 통나무는 어떤 경우이든지 중간단계에서 한 행이나 한 열에만 놓일 수 있다. 예를 들면 아래 그림에서 a와 같은 단계는 불가능하다. 그리고 회전의 경우에서는 반드시 중심점을 중심으로 90도 회전을 해야 한다. (항상 통나무의 길이가 3이므로 중심점이 있음)
그리고 이런 회전(Turn)이 가능하기 위해서는 그 통나무를 둘러싸고 있는 3*3 정사각형의 구역에 단 한 그루의 나무도 없어야만 한다. 즉, 아래그림 b, d와 같이 ?로 표시된 지역에 다른 나무, 즉 1이 없어야만 회전시킬 수 있다. 따라서 c와 같은 경우에, 통나무는 왼쪽 아직 벌채되지 않은 나무 때문에 회전시킬 수 없다.



a
b
c
d






0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 B 0 0
0 0 B 0 0 0
0 B 0 0 0 0
0 0 0 1 0 0



0 0 0 0 0 0
0 0 0 0 0 0
0 0 ? ? ? 0
0 0 B B B 0
0 0 ? ? ? 0
0 0 0 0 0 0



0 0 0 0 0 0
0 0 0 0 0 0
0 0 1 B 0 0
0 0 0 B 0 0
0 0 0 B 0 0
0 0 0 0 0 0



0 0 0 0 0 0
0 0 0 0 0 0
0 0 ? B ? 0
0 0 ? B ? 0
0 0 ? B ? 0
0 0 0 0 0 0




문제는 통나무를 5개의 기본동작(U, D, L, R, T)만을 사용하여 처음위치(BBB)에서 최종위치(EEE)로 옮기는 프로그램을 작성하는 것이다. 단, 최소 횟수의 단위 동작을 사용해야 한다.
<입력값>
첫째 줄에 주어진 평지의 한 변의 길이 N이 주어진다. (4<=N<=50) 주어진다. 이어서 그 지형의 정보가 0, 1, B, E로 이루어진 문자열로 주어진다. 한 줄에 입력되는 문자열의 길이는 N이며 입력 문자 사이에는 빈칸이 없다. 통나무와 최종 위치의 개수는 1개이다.
<출력값>
첫째 줄에 최소 동작 횟수를 출력한다. 이동이 불가능하면 0만을 출력한다.

<문제 1939>
N(2≤N≤10,000)개의 섬으로 이루어진 나라가 있다. 이들 중 몇 개의 섬 사이에는 다리가 설치되어 있어서 차들이 다닐 수 있다.
영식 중공업에서는 두 개의 섬에 공장을 세워 두고 물품을 생산하는 일을 하고 있다. 물품을 생산하다 보면 공장에서 다른 공장으로 생산 중이던 물품을 수송해야 할 일이 생기곤 한다. 그런데 각각의 다리마다 중량제한이 있기 때문에 무턱대고 물품을 옮길 순 없다. 만약 중량제한을 초과하는 양의 물품이 다리를 지나게 되면 다리가 무너지게 된다.
한 번의 이동에서 옮길 수 있는 물품들의 중량의 최댓값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N, M(1≤M≤100,000)이 주어진다. 다음 M개의 줄에는 다리에 대한 정보를 나타내는 세 정수 A, B(1≤A, B≤N), C(1≤C≤1,000,000,000)가 주어진다. 이는 A번 섬과 B번 섬 사이에 중량제한이 C인 다리가 존재한다는 의미이다. 서로 같은 두 도시 사이에 여러 개의 다리가 있을 수도 있으며, 모든 다리는 양방향이다. 마지막 줄에는 공장이 위치해 있는 섬의 번호를 나타내는 서로 다른 두 정수가 주어진다. 공장이 있는 두 섬을 연결하는 경로는 항상 존재하는 데이터만 입력으로 주어진다.
<출력값>
첫째 줄에 답을 출력한다.

<문제 1940>
주몽은 철기군을 양성하기 위한 프로젝트에 나섰다. 그래서 야철대장을 통해 철기군이 입을 갑옷을 만들게 하였다. 야철대장은 주몽의 명에 따르기 위하여 연구에 착수하던 중 아래와 같은 사실을 발견하게 되었다.
갑옷을 만드는 재료들은 각각 고유한 번호를 가지고 있다. 갑옷은 두 개의 재료로 만드는데 두 재료의 고유한 번호를 합쳐서 M(1 ≤ M ≤ 10,000,000)이 되면 갑옷이 만들어 지게 된다. 야철대장은 자신이 만들고 있는 재료를 가지고 갑옷을 몇 개나 만들 수 있는지 궁금해졌다. 이러한 궁금증을 풀어 주기 위하여 N(1 ≤ N ≤ 15,000) 개의 재료와 M이 주어졌을 때 몇 개의 갑옷을 만들 수 있는지를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 재료의 개수 N(1 ≤ N ≤ 15,000)이 주어진다. 그리고 두 번째 줄에는 갑옷을 만드는데 필요한 수 M(1 ≤ M ≤ 10,000,000) 주어진다. 그리고 마지막으로 셋째 줄에는 N개의 재료들이 가진 고유한 번호들이 공백을 사이에 두고 주어진다. 고유한 번호는 100,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 갑옷을 만들 수 있는 개수를 출력한다.

<문제 1941>
총 25명의 여학생들로 이루어진 여학생반은 5*5의 정사각형 격자 형태로 자리가 배치되었고, 얼마 지나지 않아 이다솜과 임도연이라는 두 학생이 두각을 나타내며 다른 학생들을 휘어잡기 시작했다. 곧 모든 여학생이 ‘이다솜파’와 ‘임도연파’의 두 파로 갈라지게 되었으며, 얼마 지나지 않아 ‘임도연파’가 세력을 확장시키며 ‘이다솜파’를 위협하기 시작했다.
위기의식을 느낀 ‘이다솜파’의 학생들은 과감히 현재의 체제를 포기하고, ‘소문난 칠공주’를 결성하는 것이 유일한 생존 수단임을 깨달았다. ‘소문난 칠공주’는 다음과 같은 규칙을 만족해야 한다.

이름이 이름인 만큼, 7명의 여학생들로 구성되어야 한다.
강한 결속력을 위해, 7명의 자리는 서로 가로나 세로로 반드시 인접해 있어야 한다.
화합과 번영을 위해, 반드시 ‘이다솜파’의 학생들로만 구성될 필요는 없다.
그러나 생존을 위해, ‘이다솜파’가 반드시 우위를 점해야 한다. 따라서 7명의 학생 중 ‘이다솜파’의 학생이 적어도 4명 이상은 반드시 포함되어 있어야 한다.

여학생반의 자리 배치도가 주어졌을 때, ‘소문난 칠공주’를 결성할 수 있는 모든 경우의 수를 구하는 프로그램을 작성하시오.
<입력값>
'S'(이다‘솜’파의 학생을 나타냄) 또는 'Y'(임도‘연’파의 학생을 나타냄)을 값으로 갖는 5*5 행렬이 공백 없이 첫째 줄부터 다섯 줄에 걸쳐 주어진다.
<출력값>
첫째 줄에 ‘소문난 칠공주’를 결성할 수 있는 모든 경우의 수를 출력한다.

<문제 1942>
디지털시계는 일반적으로 시각을 “hh:mm:ss”의 형태로 표현한다. hh는 00 이상 23 이하의 값을, mm과 ss는 00 이상 59 이하의 값을 가질 수 있다. 이러한 형태의 시각에서 콜론(“:”)을 제거하면 “hhmmss”라는 정수를 얻을 수 있는데, 이러한 정수를 시계 정수라고 한다. 예를 들어, 오후 5시 5분 13초, 즉 17:05:13의 시계 정수는 170513이고, 오전 0시 7분 37초, 즉 00:07:37의 시계 정수는 737이다.
이 문제에서 시간이란 시각의 구간을 나타낸다. 예를 들어 [00:59:58, 01:01:24]와 같이 시작하는 시각과 끝나는 시각으로 이루어진 구간을 우리는 시간이라고 부른다. (이러한 구간에는 시작하는 시간과 끝나는 시간도 포함된다)
이렇게 시간이 구간으로 주어지면, 그 구간에 포함되는 시계 정수들을 나열할 수 있다. 예를 들어 [00:59:58, 01:01:24]에 포함되는 시계 정수는 5958, 5959, 다음으로 10000 이상 10059 이하, 마지막으로 10100 이상 10124 이하로 총 87개가 된다. 우리는 이처럼 특정한 시간에 포함되는 시계 정수들 중, 3의 배수인 것이 몇 개나 있는지를 알고 싶다.
시간은 자정을 포함할 수도 있다. 즉 [23:59:03, 00:01:24]처럼 시작하는 시각의 시계 정수(235903)가 끝나는 시각의 시계 정수(124)보다 클 수도 있다. 물론 이 경우 이 구간에 포함되는 시계 정수는 235903 이상 235959 이하, 0 이상 59 이하, 100 이상 124 이하가 된다. 모든 구간이 포함하는 시간은 만 하루, 즉 24시간보다는 항상 작다고 가정해도 좋다.
시간이 시작하는 시각과 끝나는 시각으로 주어졌을 때, 이 구간에 포함되는 시계 정수들 중, 3의 배수인 것의 개수를 구하는 프로그램을 작성하시오.
<입력값>
세 개의 입력이 주어진다. 첫째 줄부터 세 줄에 걸쳐 시작하는 시각과 끝나는 시각이 “hh:mm:ss”의 형태로 주어진다. 시작하는 시각과 끝나는 시각 사이에는 빈 칸이 하나 있어서, 한 줄마다 (빈 칸을 포함하여) 총 17글자가 입력으로 주어진다. 시작하는 시각과 끝나는 시각은 항상 다르다.
<출력값>
첫째 줄부터 세 개의 줄에 걸쳐 입력된 구간에 포함되는 시계 정수들 중, 3의 배수인 것의 개수를 출력한다. 입력된 순서대로 각 줄에 한 개씩 차례로 출력하면 된다.

<문제 1943>
윤화와 준희는 솔선수범하여 쓰레기를 줍는 착한 일을 하였다. 원장선생님께서는 윤화와 준희를 칭찬하시고 과자나 사 먹으라고 하시며 동전 몇 개를 윤화와 준희에게 건네 주었다.
그런데 돈을 받은 윤화와 준희는 좋아하기보다 고민에 빠지고 말았다. 원장선생님께 받은 이 돈을 어떻게 나누어 할지 고민에 빠진 것이다. 두 사람 모두 상대방이 자기보다 1원이라도 더 받는 것은 도저히 인정할 수 없어 한다. 따라서 돈을 똑같이 둘로 나누어 가져야 두 사람이 모두 만족할 수 있게 된다.
하지만 두 사람에게 돈을 똑같이 나누는 것이 불가능한 경우도 있다. 예를 들어 500원짜리 1개와 50원짜리 1개를 받았다면, 이 돈을 두 사람이 똑같이 나누어 가질 수는 없다. 물론 동전을 반으로 잘라서 나누어 가질 수도 있겠지만 그러면 돈으로서의 가치를 잃기 때문에 그렇게 할 수는 없다.
이제 우리가 할 일은 다음과 같다. 원장 선생님께서 N가지 종류의 동전을 각각 몇 개씩 주셨을 때, 그 돈을 반으로 나눌 수 있는지 없는지 판단하는 것이다.
<입력값>
세 개의 입력이 주어진다. 각 입력의 첫째 줄에 동전의 종류 N(1≤N≤100)이 주어진다. 각 입력의 둘째 줄부터 N+1째 줄까지 각각의 동전의 금액과 개수가 빈 칸을 사이에 두고 주어진다. 단, 원장선생님께서 주신 금액의 총 합은 100,000원을 넘지 않는다.
<출력값>
첫째 줄부터 세 줄에 걸쳐, 각 입력에 대하여 반으로 나누는 것이 가능하면 1, 불가능하면 0을 출력한다.

<문제 1944>
세준이는 어느 날 획기적인 로봇을 한 개 개발하였다. 그 로봇은 복제 장치를 이용하면 자기 자신을 똑같은 로봇으로 원하는 개수만큼 복제시킬 수 있다. 세준이는 어느 날 이 로봇을 테스트하기 위하여 어떤 미로에 이 로봇을 풀어 놓았다. 이 로봇의 임무는 미로에 흩어진 열쇠들을 모두 찾는 것이다. 그리고 열쇠가 있는 곳들과 로봇이 출발하는 위치에 로봇이 복제할 수 있는 장치를 장착해 두었다.
N*N의 정사각형 미로와 M개의 흩어진 열쇠의 위치, 그리고 이 로봇의 시작 위치가 주어져 있을 때, 모든 열쇠를 찾으면서 로봇이 움직이는 횟수의 합을 최소로 하는 프로그램을 작성하여라. 로봇은 상하좌우 네 방향으로 움직이며, 로봇이 열쇠가 있는 위치에 도달했을 때 열쇠를 찾은 것으로 한다. (복제된 로봇이어도 상관없다) 하나의 칸에 동시에 여러 개의 로봇이 위치할 수 있으며, 로봇이 한 번 지나간 자리라도 다른 로봇 또는 자기 자신이 다시 지나갈 수 있다. 복제에는 시간이 들지 않으며, 로봇이 움직이는 횟수의 합은 분열된 로봇 각각이 움직인 횟수의 총 합을 말한다. 복제된 로봇이 열쇠를 모두 찾은 후 같은 위치로 모일 필요는 없다.
<입력값>
첫째 줄에 미로의 크기 N(4 ≤ N ≤ 50)과 열쇠의 개수 M(1 ≤ M ≤ 250) 이 공백을 사이에 두고 주어진다. 그리고 둘째 줄부터 N+1째 줄까지 미로의 정보가 주어진다. 미로는 1과 0, 그리고 S와 K로 주어진다. 1은 미로의 벽을 의미하고, 0은 지나다닐 수 있는 길, S는 로봇이 출발하는 위치, K는 열쇠의 위치가 주어진다. S는 1개, K는 M개가 주어진다. S와 K에서만 복제를 할 수 있음에 유의한다. 미로는 벽으로 둘러쌓여 있는 형태이다. 즉, 모든 테두리는 벽이다.
<출력값>
첫째 줄에 모든 로봇이 움직인 횟수의 총 합을 출력한다. 모든 열쇠를 찾는 것이 불가능한 경우 횟수 대신 첫째 줄에 -1을 출력하면 된다.

<문제 1945>
2차원 평면상에 N개의 직사각형이 있다. 직사각형의 각 변은 각 좌표축과 평행하다. 이들 직사각형은 다른 직사각형와 겹쳐지거나 일치할 수 있으며, 다른 것의 내부에 그려질 수도 있다. 직사각형의 각 꼭짓점은 자연수 좌표를 가진다.

위의 그림의 경우는 8개의 직사각형이 그려진 경우이다. 이제 이 2차원 평면에 원점 (0,0)을 지나는 직선을 하나 그릴 수 있다. 이 직선은 직사각형들과 교차할 수 있는데, 위의 그림의 경우 2, 5, 6, 7, 8번 직사각형들과 교차하게 된다. (단지 직사각형의 꼭짓점만을 스쳐 지나가더라도 교차하는 것으로 간주한다.)
가장 많은 직사각형과 교차하도록 원점을 지나는 직선을 그린다고 할 때, 최대 몇 개의 직사각형과 교차할 수 있는지를 구하는 프로그램을 작성하시오. 위의 그림의 경우 직선을 어떻게 그린다고 해도 6개 이상의 직사각형과는 교차하지 않으므로, 5개가 최대가 된다.
<입력값>
첫째 줄에 직사각형의 개수 N(1≤N≤10,000)이 주어진다. 둘째 줄부터 N개의 줄에는 직사각형의 왼쪽 아래 꼭짓점의 좌표 xbl, ybl과 오른쪽 위 꼭짓점의 좌표 xtr, ytr이 순서대로 빈칸 하나를 사이에 두고 주어진다. 입력되는 좌표는 1,000,000,000 이하의 자연수이다.
<출력값>
첫째 줄에 최대로 교차할 수 있는 직사각형의 개수를 출력한다.

<문제 1946>
언제나 최고만을 지향하는 굴지의 대기업 진영 주식회사가 신규 사원 채용을 실시한다. 인재 선발 시험은 1차 서류심사와 2차 면접시험으로 이루어진다. 최고만을 지향한다는 기업의 이념에 따라 그들은 최고의 인재들만을 사원으로 선발하고 싶어 한다.
그래서 진영 주식회사는, 다른 모든 지원자와 비교했을 때 서류심사 성적과 면접시험 성적 중 적어도 하나가 다른 지원자보다 떨어지지 않는 자만 선발한다는 원칙을 세웠다. 즉, 어떤 지원자 A의 성적이 다른 어떤 지원자 B의 성적에 비해 서류 심사 결과와 면접 성적이 모두 떨어진다면 A는 결코 선발되지 않는다.
이러한 조건을 만족시키면서, 진영 주식회사가 이번 신규 사원 채용에서 선발할 수 있는 신입사원의 최대 인원수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 테스트 케이스의 개수 T(1 ≤ T ≤ 20)가 주어진다. 각 테스트 케이스의 첫째 줄에 지원자의 숫자 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N개 줄에는 각각의 지원자의 서류심사 성적, 면접 성적의 순위가 공백을 사이에 두고 한 줄에 주어진다. 두 성적 순위는 모두 1위부터 N위까지 동석차 없이 결정된다고 가정한다.
<출력값>
각 테스트 케이스에 대해서 진영 주식회사가 선발할 수 있는 신입사원의 최대 인원수를 한 줄에 하나씩 출력한다.

<문제 1947>
이번 ACM-ICPC 대회에 참가한 모든 사람들은 선물을 하나씩 준비했다.
대회가 끝나고 난 후에 각자 선물을 전달하려고 할 때, 선물을 나누는 경우의 수를 구하는 프로그램을 작성하시오.
모든 사람은 선물은 하나씩 받으며, 자기의 선물을 자기가 받는 경우는 없다.
<입력값>
첫째 줄에 ACM-ICPC 대회에 참가한 학생의 수 N(1≤N≤1,000,000)이 주어진다.
<출력값>
경우의 수를 1,000,000,000으로 나눈 나머지를 첫째 줄에 출력한다.

<문제 1948>
월드 나라는 모든 도로가 일방통행인 도로이고, 싸이클이 없다. 그런데 어떤 무수히 많은 사람들이 월드 나라의 지도를 그리기 위해서, 어떤 시작 도시로부터 도착 도시까지 출발을 하여 가능한 모든 경로를 탐색한다고 한다.
이 지도를 그리는 사람들은 사이가 너무 좋아서 지도를 그리는 일을 다 마치고 도착 도시에서 모두 다 만나기로 하였다. 그렇다고 하였을 때 이들이 만나는 시간은 출발 도시로부터 출발한 후 최소 몇 시간 후에 만날 수 있는가? 즉, 마지막에 도착하는 사람까지 도착을 하는 시간을 의미한다.
어떤 사람은 이 시간에 만나기 위하여 1분도 쉬지 않고 달려야 한다. 이런 사람들이 지나는 도로의 수를 카운트 하여라.
출발 도시는 들어오는 도로가 0개이고, 도착 도시는 나가는 도로가 0개이다.
<입력값>
첫째 줄에 도시의 개수 n(1 ≤ n ≤ 10,000)이 주어지고 둘째 줄에는 도로의 개수 m(1 ≤ m ≤ 100,000)이 주어진다. 그리고 셋째 줄부터 m+2줄까지 다음과 같은 도로의 정보가 주어진다. 처음에는 도로의 출발 도시의 번호가 주어지고 그 다음에는 도착 도시의 번호, 그리고 마지막에는 이 도로를 지나는데 걸리는 시간이 주어진다. 도로를 지나가는 시간은 10,000보다 작거나 같은 자연수이다.
그리고 m+3째 줄에는 지도를 그리는 사람들이 출발하는 출발 도시와 도착 도시가 주어진다.
모든 도시는 출발 도시로부터 도달이 가능하고, 모든 도시로부터 도착 도시에 도달이 가능하다.
<출력값>
첫째 줄에는 이들이 만나는 시간을, 둘째 줄에는 1분도 쉬지 않고 달려야 하는 도로의 수가 몇 개인지 출력하여라.

<문제 1949>
N개의 마을로 이루어진 나라가 있다. 편의상 마을에는 1부터 N까지 번호가 붙어 있다고 하자. 이 나라는 트리(Tree) 구조로 이루어져 있다. 즉 마을과 마을 사이를 직접 잇는 N-1개의 길이 있으며, 각 길은 방향성이 없어서 A번 마을에서 B번 마을로 갈 수 있다면 B번 마을에서 A번 마을로 갈 수 있다. 또, 모든 마을은 연결되어 있다. 두 마을 사이에 직접 잇는 길이 있을 때, 두 마을이 인접해 있다고 한다.
이 나라의 주민들에게 성취감을 높여 주기 위해, 다음 세 가지 조건을 만족하면서 N개의 마을 중 몇 개의 마을을 '우수 마을'로 선정하려고 한다.

'우수 마을'로 선정된 마을 주민 수의 총 합을 최대로 해야 한다.
마을 사이의 충돌을 방지하기 위해서, 만일 두 마을이 인접해 있으면 두 마을을 모두 '우수 마을'로 선정할 수는 없다. 즉 '우수 마을'끼리는 서로 인접해 있을 수 없다.
선정되지 못한 마을에 경각심을 불러일으키기 위해서, '우수 마을'로 선정되지 못한 마을은 적어도 하나의 '우수 마을'과는 인접해 있어야 한다.

각 마을 주민 수와 마을 사이의 길에 대한 정보가 주어졌을 때, 주어진 조건을 만족하도록 '우수 마을'을 선정하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 정수 N이 주어진다. (1≤N≤10,000) 둘째 줄에는 마을 주민 수를 나타내는 N개의 자연수가 빈칸을 사이에 두고 주어진다. 1번 마을부터 N번 마을까지 순서대로 주어지며, 주민 수는 10,000 이하이다. 셋째 줄부터 N-1개 줄에 걸쳐서 인접한 두 마을의 번호가 빈칸을 사이에 두고 주어진다.
<출력값>
첫째 줄에 '우수 마을'의 주민 수의 총 합을 출력한다.

<문제 1950>
지도에 지명을 적절히 배열하는 것은 중요한 문제이다. 만일 지명들이 서로 겹치거나, 지명이 다른 도시를 가리게 된다면 지도를 읽는 것이 매우 어려워지기 때문이다.
지도에 지명을 써 넣어야 할 도시의 위치가 (x, y) 좌표로 주어져 있다. 지명은 직사각형 영역에 써 넣어야 하는데, 지명을 써 넣을 직사각형은 x축과 y축에 평행하며, 가로 길이가 세로 길이의 3배이다. 각 도시의 지명은 도시 좌표의 우측 하단에 표시가 된다. 즉 도시의 위치가 (5, 3)이고 직사각형의 가로 길이가 3, 세로 길이가 1이라면, 지명을 써 넣을 직사각형은 (5, 3)-(8, 2)에 위치하게 된다. 직사각형의 크기는 모든 도시에 대해 동일해야 한다.
모든 도시에 지명을 작성할 수 있는 가장 큰 직사각형의 크기를 구할 수 있는 프로그램을 작성하시오. 지명을 표시하는 직사각형끼리 서로 점과 선을 공유할 수는 있지만, 서로 겹치는 면적이 있어서는 안 된다.
<입력값>
첫째 줄에 도시의 개수 n(2≤n≤100,000)이 주어진다. 다음 n개의 줄에는 각 줄에 도시의 좌표를 나타내는 두 개의 음이 아닌 정수 x와 y(0≤x, y≤1,000,000)가 주어진다. 서로 다른 두 도시가 동일한 좌표로 주어지지 않는다.
<출력값>
첫줄에 가장 큰 직사각형의 가로 길이를 출력한다. 소수점 셋째자리에서 반올림하여 소수점 둘째자리까지 출력하도록 한다. (반드시 두 자리 모두 출력해야 한다.)

<문제 1951>
옛날에는 책을 만들 때, 한글자 한글자를 나눠서 활자를 만들어서 그걸 합쳐서 책을 만들었다고 한다. 예를 들면 가나다라는 글씨를 쓰기 위해서는 3개의 활자가 필요할 것이다. 그렇다고 할 때, 1~N까지의 숫자를 활자로 표현하기 위해서는 몇 개의 활자가 필요한지 구하여라.  예를 들어 1~10까지의 숫자를 활자로 표현하려면 1,2,3,4,5,6,7,8,9,1,0 이렇게 11개의 활자가 필요할 것이다.
<입력값>
첫째 줄에 N(1<=N<=2000000000)이 주어진다.
<출력값>
첫째 줄에 필요한 활자의 수를 1234567로 나눈 나머지를 출력한다.

<문제 1952>
M줄 N칸으로 되어 있는 표 위에, 달팽이 모양으로 선을 그리려고 한다.



ㅇ
 
 


 
 
 


 
 
 


 
 
 


 
 
 



위의 그림은 M=5, N=3의 예이다. 이제 표의 왼쪽 위 칸(ㅇ)에서 시작하여, 오른쪽으로 선을 그려 나간다. 표의 바깥 또는 이미 그려진 칸에 닿아서 더 이상 이동할 수 없게 되면, 시계방향으로 선을 꺾어서 그려나간다.



ㅇ
→
↘


↗
↘
↓


↑
↓
↓


↑
끝
↓


↖
←
↙



위의 표는 선을 그려 나간 모양을 나타낸 것이다. (선이 꺾어진 부분은 대각선으로 나타내었다. 표의 모든 칸이 채워질 때까지, 선을 몇 번 꺾게 될까?
<입력값>
첫째 줄에 M과 N이 빈 칸을 사이에 두고 주어진다. (2≤M, N≤100)
<출력값>
첫째 줄에 표의 모든 칸이 채워질 때까지 선이 꺾어지는 횟수를 출력한다.

<문제 1953>
2007년 1월 9일(화)는 원장선생님의 말씀대로 어제와 같이 하루 일과를 팀플레이를 통해 하려고 한다. 이 날은 특별히 청팀과 백팀으로 두 팀을 나누어 팀전을 하려 한다. 하지만 어제 하루 팀플레이를 하면서, 서로 같은 팀을 하기 싫어하는 사람들이 생겼다.
이제 우리가 할 일은 다음과 같다. 사람들이 각각 싫어하는 사람들의 정보가 주어져 있을 때, 그 사람들의 요구를 수용하여 서로 싫어하는 사람은 같은 팀에 넣지 않으려 한다. 이 조건을 만족하여 n명의 사람들 두 팀으로 나누는 프로그램을 작성하여라.
<입력값>
첫 줄에는 학생들의 수 n (1 ≤ n ≤ 100)이 주어진다. 그리고 둘째 줄부터 n+1번째 줄까지 서로가 싫어하는 사람들의 정보가 주어진다. i+1번째 줄에는 i번째 사람이 싫어하는 사람의 수와 싫어하는 사람들이 나온다.
모든 사람이 싫어하는 사람이 단 한 명도 없는 경우는 없다.
<출력값>
첫줄에는 청팀의 사람의 수를 출력하고, 그리고 둘째 줄에는 청팀에 속한 사람들을 오름차순으로 나열한다. 그리고 셋째 줄과 넷째 줄은 위와 같은 방법으로 백팀에 속한 인원의 수, 백팀에 속한 사람들을 출력한다. 단 답이 여러 가지 일 경우에는 한 가지만 출력하여도 좋다.

<문제 1954>
우리에게는 n가지 종류의 화학 시약이 있다.(이 시약을  t1,t2,...,tn이라고 하자.) 그리고 M mg의 용액이 있다. 이 용액 중 x mg을 시약 ti에 넣으면  aix+bi만큼의 어떤 가스가 발생한다고 한다.
우리가 할 일은 이렇다. M mg의 용액을 적절히 n가지 종류의 시약에 넣어서 각각의 시약에서 같은 양의 가스를 발생시키려 한다. 예를 들어  a1=3, b1=5, a2=4, b2=3, a3=1, b3=7 이라고 하자. 그리고 용액이 M = 27mg이라고 하자. 그러면 첫 번째 시약에 6mg, 두 번째 시약에 5mg, 세 번째 시약에 16mg을 넣으면 세 개의 시약 모두 23mg이 발생하게 된다. 하지만 M=26일 경우에는 이렇게 세 개의 시약 모두 같은 양의 가스를 발생시키는 것이 불가능 하다.
시약의 개수 n과 용액의 양 M, 그리고 a1,a2,...,an과 b1,b2,...,bn이 주어져 있을 때, 만약에 n개의 시약 모두 같은 양의 가스를 발생 시킬 수 있으면 그 가스의 양을 출력하고, 그럴 수 없으면 0을 출력하는 프로그램을 작성하시오.
<입력값>
첫 번째 줄에 시약의 종류 n(1<=n<=100)이 주어진다. 그리고 두 번째 줄부터 n+1번째 줄까지 공백을 사이에 두고 ai와bi가(1<=ai<=10, 1<=bi<=1000) 주어진다. (i+1번째 줄에 ai,bi 가 주어진다는 말이다.) 그리고 n+2번째 줄에는 용액의 양 M(1<=M<=10000) 이 주어진다.
<출력값>
만약에 n개의 시약 모두 같은 양의 가스를 발생시키는 것이 가능하면 첫 번째 줄에 그 가스의 양을 출력하고, 그것이 불가능하면 첫째 줄에 대신 0을 출력하여라.

<문제 1955>
수식 표현이란 1, +, *, !, (, )로만 이루어진 수식을 말한다. 간명하게 정의하기 위해, 다음과 같이 귀납적으로 정의할 수 있다.

1은 수식표현이다.
e가 수식표현이면 (e)와 e!도 수식표현이다.
e1과 e2가 수식표현이면 e1+e2와 e1*e2도 수식표현이다.

예를 들어 18의 수식표현은 (1+1+1)*(1+1+1)!, (1+1+1+1)*(1+1+1) +(1+1+1)! 등이 있다. 우리는 n이 주어졌을 때, n의 값을 갖는 수식표현을 구하고 싶다. 단, 1의 개수를 최소로 사용하는 것이어야 한다.
<입력값>
첫째 줄에 n이 주어진다. (1<=n<=10,000)
<출력값>
첫째 줄에 n의 수식표현에 필요한 최소 1의 개수를 출력한다.

<문제 1956>
V개의 마을와 E개의 도로로 구성되어 있는 도시가 있다. 도로는 마을과 마을 사이에 놓여 있으며, 일방 통행 도로이다. 마을에는 편의상 1번부터 V번까지 번호가 매겨져 있다고 하자.
당신은 도로를 따라 운동을 하기 위한 경로를 찾으려고 한다. 운동을 한 후에는 다시 시작점으로 돌아오는 것이 좋기 때문에, 우리는 사이클을 찾기를 원한다. 단, 당신은 운동을 매우 귀찮아하므로, 사이클을 이루는 도로의 길이의 합이 최소가 되도록 찾으려고 한다.
도로의 정보가 주어졌을 때, 도로의 길이의 합이 가장 작은 사이클을 찾는 프로그램을 작성하시오. 두 마을을 왕복하는 경우도 사이클에 포함됨에 주의한다.
<입력값>
첫째 줄에 V와 E가 빈칸을 사이에 두고 주어진다. (2 ≤ V ≤ 400, 0 ≤ E ≤ V(V-1)) 다음 E개의 줄에는 각각 세 개의 정수 a, b, c가 주어진다. a번 마을에서 b번 마을로 가는 거리가 c인 도로가 있다는 의미이다. (a → b임에 주의) 거리는 10,000 이하의 자연수이다. (a, b) 쌍이 같은 도로가 여러 번 주어지지 않는다.
<출력값>
첫째 줄에 최소 사이클의 도로 길이의 합을 출력한다. 운동 경로를 찾는 것이 불가능한 경우에는 -1을 출력한다.

<문제 1957>
이번 겨울 캠프에서 N(1≤N≤1,000,000)명의 학생들이 무더기로 인터넷을 하다 걸렸다. 이에 격분한 김조교는 학생들을 일렬로 세우고, 다음과 같은 벌칙을 실시하도록 하였다.

먼저 처음의 상태는 학생들이 임의로 정할 수 있다. 학생들은 앉아 있을 수도 있으며, 일어나 있을 수도 있다. 이때의 상태를 임의로 0번째 단계라고 하자.
이 벌칙에는 단계가 있는데, 다음 단계로 넘어갈 때에는 자신의 오른쪽 학생의 상태에 따라 자신의 상태를 결정해야 한다. 만일 이번 단계에 오른쪽 학생이 일어서 있으면 자신은 다음 턴에 상태를 바꾸어야 한다. 즉 일어나 있었으면 앉아야 하고, 앉아 있었으면 일어나야 한다. 만일 이번 턴에 오른쪽 학생이 앉아 있으면 자신은 다음 턴에 상태를 바꿀 필요 없이 그대로 있어도 된다. (바꾸면 안 된다)
학생의 번호는 편의상 왼쪽부터 오른쪽으로 1부터 N까지 매겨진다. T LOGIN을 제공하여 학생들이 인터넷을 할 수 있도록 해 준 N번 학생은 특별히 가장 어려운데, 자신의 오른쪽 학생이 없지만 1번 학생을 자신의 오른쪽 학생으로 생각하고 벌칙을 받아야 한다.

예를 들어 N=4이고, 처음에 4번 학생만 일어나 있다고 하자. 이 벌칙이 몇 번 진행된 상태는 다음과 같다. 약삭빠른 학생들은 어이없게도 순식간에 머리를 굴려서, 4단계 이후 모두가 쉴 수 있는 다음과 같은 초기 상태를 정하고야 말았다.




 


학생 1


학생 2


학생 3


학생 4




0단계


앉음


앉음


앉음


일어남




1단계


앉음


앉음


일어남


일어남




2단계


앉음


일어남


앉음


일어남




3단계


일어남


일어남


일어남


일어남




4단계


앉음


앉음


앉음


앉음




허걱...




학생들이 뉘우치지는 않고 어떡하면 벌칙을 덜 받을 수 있을까만을 궁리하는 모습에 격분한 김조교는 학생들에게 이 벌칙을 무려 M(1≤M≤1,000,000,000)단계까지 반복하도록 하고, 휭 나가버렸다. 김 조교는 곧 돌아올텐데, M번째 단계에 학생들은 어떤 모습을 하고 있어야 할까?
<입력값>
첫째 줄에 N과 M이 빈칸을 사이에 두고 주어진다. 둘째 줄에는 학생들의 0단계 상태가 빈 칸 없이 N개의 문자열로 주어진다. 1번 학생부터 N번 학생까지의 상태를 순서대로 나타낸 것으로, u는 일어난 상태, d는 앉은 상태를 나타낸다.
<출력값>
첫째 줄에 M번째 단계에 학생들의 상태를 입력과 마찬가지 형식으로 출력한다.

<문제 1958>
문자열과 놀기를 세상에서 제일 좋아하는 영식이는 오늘도 문자열 2개의 LCS(Longest Common Subsequence)를 구하고 있었다. 어느 날 영식이는 조교들이 문자열 3개의 LCS를 구하는 것을 보았다. 영식이도 도전해 보았지만 실패하고 말았다.
이제 우리가 할 일은 다음과 같다. 영식이를 도와서 문자열 3개의 LCS를 구하는 프로그램을 작성하라.
<입력값>
첫 줄에는 첫 번째 문자열이, 둘째 줄에는 두 번째 문자열이, 셋째 줄에는 세 번째 문자열이 주어진다. 각 문자열은 알파벳 소문자로 이루어져 있고, 길이는 100보다 작거나 같다.
<출력값>
첫 줄에 첫 번째 문자열과 두 번째 문자열과 세 번째 문자열의 LCS의 길이를 출력한다.

<문제 1959>
M줄 N칸으로 되어 있는 표 위에, 달팽이 모양으로 선을 그리려고 한다.



ㅇ
 
 


 
 
 


 
 
 


 
 
 


 
 
 



위의 그림은 M=5, N=3의 예이다. 이제 표의 왼쪽 위 칸(○)에서 시작하여, 오른쪽으로 선을 그려 나간다. 표의 바깥 또는 이미 그려진 칸에 닿아서 더 이상 이동할 수 없게 되면, 시계방향으로 선을 꺾어서 그려나간다.



ㅇ
→
↘


↗
↘
↓


↑
↓
↓


↑
끝
↓


↖
←
↙



위의 표는 선을 그려 나간 모양을 나타낸 것이다. (선이 꺾어진 부분은 대각선으로 나타내었다.)  표의 모든 칸이 채워질 때까지 선을 몇 번 꺾게 될까? 또, 어디에서 끝나게 될까?
<입력값>
첫째 줄에 M과 N이 빈 칸을 사이에 두고 주어진다. (2≤M, N≤2,100,000,000)
<출력값>
첫째 줄에 표의 모든 칸이 채워질 때까지 선이 꺾어지는 횟수를 출력한다. 둘째 줄에 끝나는 점의 좌표를 출력한다. 왼쪽 위 칸의 좌표를 (1, 1), 오른쪽 아래 칸의 좌표를 (M, N)이라고 하자.

<문제 1960>
n*n 크기의 행렬이 있다. 이 행렬은 0과 1로 이루어 져 있다. 예를 들어 다음과 같은 행렬이 있다고 하자.




1
			

1
			

0
			

0
			



			1
			

			0
			

			1
			

			1
			



			0
			

			1
			

			0
			

			0
			



			0
			

			0
			

			1
			

			0
			



그런데 행렬이 그려진 종이를 잃어버리고 말았다. 그래서 행렬에 대한 자세한 정보는 잃어버렸고 각 행과 열에 있는 1의 개수만을 알고 있다. 위 예에는 1행에는 1이 두 개, 2행에는 3개, 3행에 1개, 4행에 1개, 그리고 1열에 2개, 2열에 2개, 3열에 2개, 4열에 1개가 있는 것이다. 이와 같은 데이터가 주어져 있을 때, 원래의 행렬을 만드는 프로그램을 작성하시오.
<입력값>
첫째 줄에 n(1≤n≤500)이 주어진다. 다음 줄에는 각 행에 있는 1의 개수가 1행부터 n행까지 차례로 주어진다. 그 다음 줄에는 각 열에 있는 1의 개수가 1열부터 n열까지 차례로 주어진다.
<출력값>
만약 행렬을 구할 수 있으면 첫째 줄에 1을 출력한다. 그리고 n개의 줄에 행렬의 수들을 붙여서 출력한다. 만약 구할 수 없다면 첫째 줄에 -1을 출력한다. 가능한 행렬이 여러 개 존재할 경우에는 그 중 임의의 한 개를 출력하면 된다.

<문제 1963>
소수를 유난히도 좋아하는 창영이는 게임 아이디 비밀번호를 4자리 ‘소수’로 정해놓았다. 어느 날 창영이는 친한 친구와 대화를 나누었는데:

“이제 슬슬 비번 바꿀 때도 됐잖아”
“응 지금은 1033으로 해놨는데... 다음 소수를 무엇으로 할지 고민중이야"
“그럼 8179로 해”
“흠... 생각 좀 해볼게. 이 게임은 좀 이상해서 비밀번호를 한 번에 한 자리 밖에 못 바꾼단 말이야. 예를 들어 내가 첫 자리만 바꾸면 8033이 되니까 소수가 아니잖아. 여러 단계를 거쳐야 만들 수 있을 것 같은데... 예를 들면... 1033 1733 3733 3739 3779 8779 8179처럼 말이야.”
“흠...역시 소수에 미쳤군. 그럼 아예 프로그램을 짜지 그래. 네 자리 소수 두 개를 입력받아서 바꾸는데 몇 단계나 필요한지 계산하게 말야.”
“귀찮아”

그렇다. 그래서 여러분이 이 문제를 풀게 되었다. 입력은 항상 네 자리 소수만(1000 이상) 주어진다고 가정하자. 주어진 두 소수 A에서 B로 바꾸는 과정에서도 항상 네 자리 소수임을 유지해야 하고, ‘네 자리 수’라 하였기 때문에 0039 와 같은 1000 미만의 비밀번호는 허용되지 않는다.
<입력값>
첫 줄에 test case의 수 T가 주어진다. 다음 T줄에 걸쳐 각 줄에 1쌍씩 네 자리 소수가 주어진다.
<출력값>
각 test case에 대해 두 소수 사이의 변환에 필요한 최소 회수를 출력한다. 불가능한 경우 Impossible을 출력한다.

<문제 1964>
오각형의 각 변에 아래 그림과 같이 점을 찍어 나간다. N단계에서 점의 개수는 모두 몇 개일까?
<입력값>
첫째 줄에 N(1≤N≤10,000,000)이 주어진다.
<출력값>
첫째 줄에 N단계에서 점의 개수를 45678로 나눈 나머지를 출력한다.

<문제 1965>
정육면체 모양의 상자가 일렬로 늘어서 있다. 상자마다 크기가 주어져 있는데, 앞에 있는 상자의 크기가 뒤에 있는 상자의 크기보다 작으면, 앞에 있는 상자를 뒤에 있는 상자 안에 넣을 수가 있다. 예를 들어 앞에서부터 순서대로 크기가 (1, 5, 2, 3, 7)인 5개의 상자가 있다면, 크기 1인 상자를 크기 5인 상자에 넣고, 다시 이 상자를 크기 7인 상자 안에 넣을 수 있다. 하지만 이렇게 상자를 넣을 수 있는 방법은 여러 가지가 있을 수 있다. 앞의 예에서 차례대로 크기가 1, 2, 3, 7인 상자를 선택하면 총 4개의 상자가 한 개의 상자에 들어가게 된다.
상자의 크기가 주어질 때, 한 번에 넣을 수 있는 최대의 상자 개수를 출력하는 프로그램을 작성하시오.
<입력값>
파일의 첫 번째 줄은 상자의 개수 n (1 ≤ n ≤ 1000)을 나타낸다. 두 번째 줄에는 각 상자의 크기가 순서대로 주어진다. 상자의 크기는 1,000을 넘지 않는 자연수이다.
<출력값>
첫째 줄에 한 줄에 넣을 수 있는 최대의 상자 개수를 출력한다.

<문제 1966>
여러분도 알다시피 여러분의 프린터 기기는 여러분이 인쇄하고자 하는 문서를 인쇄 명령을 받은 ‘순서대로’, 즉 먼저 요청된 것을 먼저 인쇄한다. 여러 개의 문서가 쌓인다면 Queue 자료구조에 쌓여서 FIFO - First In First Out - 에 따라 인쇄가 되게 된다. 하지만 상근이는 새로운 프린터기 내부 소프트웨어를 개발하였는데, 이 프린터기는 다음과 같은 조건에 따라 인쇄를 하게 된다.

현재 Queue의 가장 앞에 있는 문서의 ‘중요도’를 확인한다.
나머지 문서들 중 현재 문서보다 중요도가 높은 문서가 하나라도 있다면, 이 문서를 인쇄하지 않고 Queue의 가장 뒤에 재배치 한다. 그렇지 않다면 바로 인쇄를 한다.

예를 들어 Queue에 4개의 문서(A B C D)가 있고, 중요도가 2 1 4 3 라면 C를 인쇄하고, 다음으로 D를 인쇄하고 A, B를 인쇄하게 된다.
여러분이 할 일은, 현재 Queue에 있는 문서의 수와 중요도가 주어졌을 때, 어떤 한 문서가 몇 번째로 인쇄되는지 알아내는 것이다. 예를 들어 위의 예에서 C문서는 1번째로, A문서는 3번째로 인쇄되게 된다.
<입력값>
첫 줄에 테스트케이스의 수가 주어진다. 각 테스트케이스는 두 줄로 이루어져 있다.
테스트케이스의 첫 번째 줄에는 문서의 개수 N(1 ≤ N ≤ 100)과, 몇 번째로 인쇄되었는지 궁금한 문서가 현재 Queue에서 몇 번째에 놓여 있는지를 나타내는 정수 M(0 ≤ M < N)이 주어진다. 이때 맨 왼쪽은 0번째라고 하자. 두 번째 줄에는 N개 문서의 중요도가 차례대로 주어진다. 중요도는 1 이상 9 이하의 정수이고, 중요도가 같은 문서가 여러 개 있을 수도 있다.
<출력값>
각 테스트 케이스에 대해 문서가 몇 번째로 인쇄되는지 출력한다.

<문제 1967>
트리(tree)는 사이클이 없는 무방향 그래프이다. 트리에서는 어떤 두 노드를 선택해도 둘 사이에 경로가 항상 하나만 존재하게 된다. 트리에서 어떤 두 노드를 선택해서 양쪽으로 쫙 당길 때, 가장 길게 늘어나는 경우가 있을 것이다. 이럴 때 트리의 모든 노드들은 이 두 노드를 지름의 끝 점으로 하는 원 안에 들어가게 된다.

이런 두 노드 사이의 경로의 길이를 트리의 지름이라고 한다. 정확히 정의하자면 트리에 존재하는 모든 경로들 중에서 가장 긴 것의 길이를 말한다.
입력으로 루트가 있는 트리를 가중치가 있는 간선들로 줄 때, 트리의 지름을 구해서 출력하는 프로그램을 작성하시오. 아래와 같은 트리가 주어진다면 트리의 지름은 45가 된다.

트리의 노드는 1부터 n까지 번호가 매겨져 있다.
<입력값>
파일의 첫 번째 줄은 노드의 개수 n(1 ≤ n ≤ 10,000)이다. 둘째 줄부터 n-1개의 줄에 각 간선에 대한 정보가 들어온다. 간선에 대한 정보는 세 개의 정수로 이루어져 있다. 첫 번째 정수는 간선이 연결하는 두 노드 중 부모 노드의 번호를 나타내고, 두 번째 정수는 자식 노드를, 세 번째 정수는 간선의 가중치를 나타낸다. 간선에 대한 정보는 부모 노드의 번호가 작은 것이 먼저 입력되고, 부모 노드의 번호가 같으면 자식 노드의 번호가 작은 것이 먼저 입력된다. 루트 노드의 번호는 항상 1이라고 가정하며, 간선의 가중치는 100보다 크지 않은 양의 정수이다.
<출력값>
첫째 줄에 트리의 지름을 출력한다.

<문제 1968>
N개의 집들로 이루어진 작은 마을이 있다. 집들 중, 몇 개는 길로 연결되어 있다. 각각의 길의 가운데에 우체통이 하나씩 있어서 마을 사람들은 이 우체통을 이용한다.
이 마을에는 우체부가 한 명 있는데, 이 우체부가 길들을 돌아다니며 우체통 안의 우편물을 수거한다. 이 우체부는 한 번 갔던 길을 다시 방문하는 비효율적인 일을 하려 하지 않는다. 다행히도, 이 마을의 구조상 한 번 갔던 길을 다시 지나지 않으면서 모든 길을 지나는 방법이 항상 존재한다.
우체부는 이러한 방법을 찾아낸 뒤, 매번 같은 경로를 이용하여 우편물을 모으고 있었다. 그러다보니 매번 우편물들이 똑같은 순서로 모이게 되었는데, 우편물들의 우선순위가 다를 때도 우편물들이 같은 순서로 모이는 비효율적인 현상이 발생하게 되었다.
이에 마을 사람들은 다음과 같은 방법을 동원하기로 하였다. 각각의 우체통에는 w[i]라는 가중치가 있는데, 이 우체통이 우체부가 k번째로 지나는 우체통이라 하자. 만약 w[i]보다 k가 작다면 우체부는 w[i]-k의 수익을 얻는다. 반면에 w[i]가 k보다 크다면 우체부는 k-w[i]의 손실을 얻는다.
이와 같은 조건이 주어졌을 때, 우체부의 총 이익을 최대로 하는 경로를 찾으시오. 총 이익은 우체부의 수익에서 손실을 뺀 값이다.
<입력값>
첫째 줄에 N(1≤N≤1,000), M(1≤M≤100,000)이 주어진다. 다음 M개의 줄에는 i번째 길에 대한 정보 a[i], b[i], w[i]가 주어진다. 이는 i번째 길이 a[i]번 마을과 b[i]번 마을을 연결함을 의미한다. a[i]는 항상 b[i]와 다르다고 가정하자. w[i]는 8자리 이하의 자연수이다.
<출력값>
첫째 줄부터 방문한 순서대로 마을의 번호를 출력한다. 파일의 마지막 줄에는 -1을 출력한다.

<문제 1969>
DNA란 어떤 유전물질을 구성하는 분자이다. 이 DNA는 서로 다른 4가지의 뉴클레오티드로 이루어져 있다(Adenine, Thymine, Guanine, Cytosine). 우리는 어떤 DNA의 물질을 표현할 때, 이 DNA를 이루는 뉴클레오티드의 첫글자를 따서 표현한다. 만약에 Thymine-Adenine-Adenine-Cytosine-Thymine-Guanine-Cytosine-Cytosine-Guanine-Adenine-Thymine로 이루어진 DNA가 있다고 하면, “TAACTGCCGAT”로 표현할 수 있다. 그리고 Hamming Distance란 길이가 같은 두 DNA가 있을 때, 각 위치의 뉴클오티드 문자가 다른 것의 개수이다. 만약에 “AGCAT"와 ”GGAAT"는 첫 번째 글자와 세 번째 글자가 다르므로 Hamming Distance는 2이다.
우리가 할 일은 다음과 같다. N개의 길이 M인 DNA s1, s2, ..., sn가 주어져 있을 때 Hamming Distance의 합이 가장 작은 DNA s를 구하는 것이다. 즉, s와 s1의 Hamming Distance + s와 s2의 Hamming Distance + s와 s3의 Hamming Distance ... 의 합이 최소가 된다는 의미이다.
<입력값>
첫 줄에 DNA의 수 N과 문자열의 길이 M이 주어진다. 그리고 둘째 줄부터 N+1번째 줄까지 N개의 DNA가 주어진다. N은 1,000보다 작거나 같은 자연수이고, M은 50보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 Hamming Distance의 합이 가장 작은 DNA 를 출력하고, 둘째 줄에는 그 Hamming Distance의 합을 출력하시오. 그러한 DNA가 여러 개 있을 때에는 사전순으로 가장 앞서는 것을 출력한다.

<문제 1970>
N명의 사람이 원판 테이블에 앉아서 콜라를 마시고 있다. 그 상황에서 두 사람이 짝을 지어서 건배를 하려 한다. 그런데 이들은 건배를 할 때, 보기 좋게 하기 위하여 마시고 있는 콜라의 브랜드가 같은 경우에만 건배를 할 수 있다고 한다. 그리고 사람들이 동시에 건배를 할 때, 사람들의 팔이 서로 엇갈리는 경우에는 건배를 할 수 없다고 한다.

예를 들어 왼쪽 그림과 같은 경우는 겹치는 경우가 없어 건배를 할 수 있으나 오른쪽과 같은 경우에는 건배를 할 수 없다. 사람의 수 N과 각각의 사람이 마시는 콜라의 브랜드가 주어져 있을 때, 동시에 건배를 할 수 있는 가장 많은 쌍의 개수를 출력하시오.
<입력값>
첫 줄에 사람의 수 (1 ≤ N ≤ 1000) 이 주어진다. 그리고 둘째 줄에 N개의 정수(1 이상 100 이하)가 공백을 사이에 두고 주어지는데 이는 각각의 사람이 마시는 콜라의 브랜드이다. (시계방향순서대로 주어진다)
<출력값>
동시에 건배를 할 수 있는 가장 많은 쌍의 개수를 출력한다.

<문제 1971>
You have been approached by a spy agency to determine the amount of contraband goods that are being traded among several nefarious countries. After being shipped from its country of origin, each container of goods is routed through at least one neutral port. At the port, the container are stored in a warehouse before being sent on their way, so you cannot trace individual containers from their country of origin to their final destination. Satellite cameras can tell you the number of containers travelling in each direction on each leg of the journey. They cannot distinguish individual containers, nor do you have information on the times individual containers have been observed. You know, however, that every container takes the shortest possible route to its destination. 
The task is to determine both the maximum and minimum number of containers that could have been travelling from one country to another. The transport network that is observed is an unrooted tree, with countries as leaves and ports as internal nodes. For each edge the number of containers is given in two directions. You know from the description above that no container leaves a port in the direction it came from. 

In the figure above we see six countries 1,2,4,5,7,9 and three ports 3,6,8. Although all edges on the route from country 1 to country 4 have a capacity of at least 4, it is not possible to send four container along this route. In that case, in port 6 one of the containers arriving from country 2 would be forced to return, which is forbidden. 
This problem was taken from Dennis E. Shasha's monthly column Puzzling Adventures, published in Scientific American, July 2003.
<입력값>
The first line of the input contains a single number: the number of test cases to follow. Each test case describes a single unrooted tree, in the following format:

One line with one integer n (3 ≤ n ≤ 10000): the number of nodes (countries and ports).
n - 1 lines with four integers a, b, c1, c2 each(1 ≤ a, b ≤ n and 0 ≤ c1, c2 ≤ 1000), describing an edge from node a to (another) node b with c1 containers counted in the direction from a to b and c2 in the other direction.
One line with two integers fr and to (1 ≤ fr, to ≤ n, fr ≠ to): the begin and end nodes (countries, i.e., leaves in the tree).

Integers on the same line are separated by single spaces. The input satisfies Kirchhoff's law: in each port the number of incoming containers equals the number of outgoing containers. This in itself is not sufficient to guarantee the existence of a transport of containers that matches the description (as containers never move back from where they came). In each test case given a matching transport exists.
<출력값>
For every test case in the input, the output should contain a single line with two integers, separated by a single space, the minimum and maximum number of containers transported from fr to to fitting the data given.

<문제 1972>
대문자 알파벳으로만 이루어져 있는 문자열이 있다. 이 문자열에 대해서 ‘D-쌍’이라는 것을 정의할 수 있는데, 이 문자열에 포함되어 있는, 거리가 D인 두 문자를 순서대로 나열한 것을 이 문자열의 D-쌍이라고 한다. 예를 들어 문자열이 ZGBG라고 하자. 이 문자열의 0-쌍은 ZG, GB, BG가 되고, 이 문자열의 1-쌍은 ZB, GG가 되며, 이 문자열의 2-쌍은 ZG가 된다. 문자열의 길이가 N이라고 할 때, 0-쌍부터 (N-2)-쌍까지가 정의됨을 알 수 있다.
만일 정의되는 D에 대해, 어떤 문자열의 모든 D-쌍들이 서로 다를 때, 이 문자열을 D-유일하다고 한다. 위의 예를 보면, 0-쌍들은 ZG, GB, BG로 모두 다르다. 따라서 이 문자열은 0-유일하며, 마찬가지로 1-유일하고, 2-유일하다. 하지만 만일 문자열이 AAA라고 하자. 이 문자열은 0-유일하지 않으며, 다만 1-유일하다.
만일 어떤 문자열이 정의되는 모든 D에 대해 D-유일하면, 이 문자열을 정말이지 ‘놀라운 문자열’이라고 한다. 문자열이 주어질 때, 이 문자열이 놀라운 문자열인지 아닌지를 구하는 프로그램을 작성하시오.
<입력값>
입력의 각 줄에는 알파벳 대문자로만 구성된 문자열이 주어진다. 모든 문자열의 길이는 80을 넘지 않으며, 입력의 마지막 줄에는 마지막을 나타내는 *가 주어진다. 입력은 마지막 줄을 포함해서 101줄을 넘지 않는다.
<출력값>
각 줄에 이 문자열이 놀라운(surprising) 문자열인지 아닌지를 아래의 예제와 같이 출력한다.

<문제 1973>
당신이 한 버스 정거장에 아침 9시에 도착했다. 그리고 9시부터 9시 59분까지 그 곳에 있었다. 그 동안 노선이 다른 여러 버스들이 이 정거장에 섰는데, 당신은 그 버스들이 도착하는 시각을 주의 깊게 관찰하였다.
노선이 같은 버스는 9시 정각부터 9분까지 같은 시간 간격으로 규칙성 있게 도착한다. 버스를 관찰한 시간은 0부터 59분까지이다. 각 노선을 달리는 버스는 그 동안 적어도 두 번은 정거장에 서며, 시간은 정수 시간만을 계산한다. (최소 단위는 1분)
노선이 다르더라도 어떤 버스 노선의 시간 스케줄은 최초 도착 시간이나 시간 간격 중 하나 이상이 다른 노선의 스케줄과 일치할 수 있다. 그런 이유로, 같은 시각에 노선이 다른 버스가 두 대 이상 도착하면 그 시각은 온 버스 수만큼 중복 기록한다. 즉, 만약 최초 도착 시간과 오는 간격이 완전히 같은 두 노선이 있더라도 그 노선을 다니는 버스들이 온 시각은 구분되어 따로 입력 파일에 기록된다는 뜻이다.
버스가 도착한 시간 기록을 입력 받아서 이 간격대로 있을 수 있는 서로 다른 버스 노선들을 구해 이들의 시간 스케줄을 출력하는 프로그램을 작성하라. 그리고 찾아낸 버스 노선마다 그 노선의 첫 도착 시간과 다음 간격을 출력하라. 그러한 경우가 많다면, 버스 노선의 수가 가장 적은 경우를 찾아야 한다. (버스의 수는 25를 넘지 않는다)
<입력값>
첫째 줄에 버스가 선 횟수 n(2≤n≤300)이 주어진다. 다음 줄에는 버스가 온 시각 n개가 주어진다. 각각의 시각은 정수라 가정하자. 시각은 분 단위만 기록하며, 0이상 59이하의 값을 갖는다. 입력의 중간에는 공백 대신 엔터가 주어질 수도 있다.
<출력값>
첫째 줄에 버스 노선의 최소 개수 X를 출력한다. 다음 X개의 줄에는 각 노선의 첫 도착 시각과 간격을 출력한다. 최적해가 여러 개인 경우에는 임의의 하나만 출력하면 되며, 출력 순서는 상관이 없다.

<문제 1975>
창영이는 심심해서 혼자 재미 없는 게임을 하나 생각해냈다. 숫자 N을 먼저 정하고, 이 숫자를 2진법, 3진법, 4진법, ..., 100만진법, 100만 1진법 등등으로 바꾸어 보면서, 마지막자리에 연속된 0의 개수를 모두 더하는 것이다.
예를 들어 N=5라면, 2진법 101, 3진법 12, 4진법 11, 5진법 10, 6진법 5, 7진법 5, ... 등과 같으므로 답은 1이 된다. 여러분이 할 일은 주어진 N에 대해서 창영이가 구한 답을 찾는 것이다. 정확히 설명하기 위해 수학식으로 쓰자면, f(N, b)를 N을 b진법으로 나타냈을 때 마지막에 따르는 연속된 0의 개수로 정의 할 때
\[\sum_{b=2}^{\infty}{f(N, b)}\]
를 구하는 것이다.
<입력값>
첫 줄에 테스트 케이스의 수 T가 주어진다. 다음 T줄에 걸쳐서 N이 주어진다.
<출력값>
각 줄에 위 수식에 대한 답을 출력한다.

<문제 1976>
동혁이는 친구들과 함께 여행을 가려고 한다. 한국에는 도시가 N개 있고 임의의 두 도시 사이에 길이 있을 수도, 없을 수도 있다. 동혁이의 여행 일정이 주어졌을 때, 이 여행 경로가 가능한 것인지 알아보자. 물론 중간에 다른 도시를 경유해서 여행을 할 수도 있다. 예를 들어 도시가 5개 있고, A-B, B-C, A-D, B-D, E-A의 길이 있고, 동혁이의 여행 계획이 E C B C D 라면 E-A-B-C-B-C-B-D라는 여행경로를 통해 목적을 달성할 수 있다.
도시들의 개수와 도시들 간의 연결 여부가 주어져 있고, 동혁이의 여행 계획에 속한 도시들이 순서대로 주어졌을 때 가능한지 여부를 판별하는 프로그램을 작성하시오. 같은 도시를 여러 번 방문하는 것도 가능하다.
<입력값>
첫 줄에 도시의 수 N이 주어진다. N은 200이하이다. 둘째 줄에 여행 계획에 속한 도시들의 수 M이 주어진다. M은 1000이하이다. 다음 N개의 줄에는 N개의 정수가 주어진다. i번째 줄의 j번째 수는 i번 도시와 j번 도시의 연결 정보를 의미한다. 1이면 연결된 것이고 0이면 연결이 되지 않은 것이다. A와 B가 연결되었으면 B와 A도 연결되어 있다. 마지막 줄에는 여행 계획이 주어진다. 도시의 번호는 1부터 N까지 차례대로 매겨져 있다.
<출력값>
첫 줄에 가능하면 YES 불가능하면 NO를 출력한다.

<문제 1977>
M과 N이 주어질 때 M이상 N이하의 자연수 중 완전제곱수인 것을 모두 골라 그 합을 구하고 그 중 최솟값을 찾는 프로그램을 작성하시오. 예를 들어 M=60, N=100인 경우 60이상 100이하의 자연수 중 완전제곱수는 64, 81, 100 이렇게 총 3개가 있으므로 그 합은 245가 되고 이 중 최솟값은 64가 된다.
<입력값>
첫째 줄에 M이, 둘째 줄에 N이 주어진다. M과 N은 10000이하의 자연수이며 M은 N보다 같거나 작다.
<출력값>
M이상 N이하의 자연수 중 완전제곱수인 것을 모두 찾아 첫째 줄에 그 합을, 둘째 줄에 그 중 최솟값을 출력한다. 단, M이상 N이하의 자연수 중 완전제곱수가 없을 경우는 첫째 줄에 -1을 출력한다.

<문제 1978>
주어진 수 N개 중에서 소수가 몇 개인지 찾아서 출력하는 프로그램을 작성하시오.
<입력값>
첫 줄에 수의 개수 N이 주어진다. N은 100이하이다. 다음으로 N개의 수가 주어지는데 수는 1,000 이하의 자연수이다.
<출력값>
주어진 수들 중 소수의 개수를 출력한다.

<문제 1979>
혁화는 초등학생 동생의 곱셈 숙제를 도와주다가 새롭게 알아낸 사실이 있다.
102564에 4를 곱하면 410256이 되고, 이 수는 102564가 오른쪽으로 한 칸씩 옮겨진 숫자이다.
이렇게 어떤 숫자에 n을 곱했는데 오른쪽으로 한 칸씩 옮겨지는 숫자를 n-극적인 숫자라고 한다. 예를 들어, 102564와 128205는 4-극적인 숫자이다.
두 숫자 n과 k가 주어졌을 때, n-극적인 숫자중 마지막 숫자가 k인 수를 구하는 프로그램을 작성하시오. (정답이 여러 가지인 경우 가장 작은 것을 출력한다)
<입력값>
첫째 줄에 n(1 ≤ n ≤ 9)과 k(1 ≤ k ≤ 9)가 공백을 사이에 두고 주어진다.
<출력값>
첫째 줄에 구한 n-극적인 숫자 중 마지막 숫자가 k인 수를 출력한다. 그런 숫자가 존재하지 않는 경우에는 0을 출력한다.

<문제 1980>
민혁이는 타워버거와 불고기버거를 매우 좋아한다. 민혁이는 타워버거를 먹는데 n분이 걸리고, 불고기버거를 먹는데 m분이 걸린다. 그는 t분 동안 햄버거를 최대한 많이 먹으려고 한다. 햄버거를 먹는 도중에 t분이 끝나면 안 되고, 아무것도 안 먹고 있을 때는 콜라를 마신다. 문제의 목적은 다음과 같다.

우선 콜라를 마시는 시간을 최소로 한다.
콜라를 마시는 시간이 같은 여러 가지 경우에는 햄버거를 가장 많이 먹을 수 있는 경우를 알아본다.
<입력값>
첫 줄에 n, m, 주어진 시간 t가 주어진다. 세 수는 모두 1만 이하의 자연수이다.
<출력값>
한 줄에 두 개의 수를 출력하는데, 첫 수는 먹은 햄버거의 개수이고, 두 번째 수는 콜라를 마신 시간이다.

<문제 1981>
n×n짜리의 배열이 하나 있다. 이 배열의 (1, 1)에서 (n, n)까지 이동하려고 한다. 이동할 때는 상, 하, 좌, 우의 네 인접한 칸으로만 이동할 수 있다.
이와 같이 이동하다 보면, 배열에서 몇 개의 수를 거쳐서 이동하게 된다. 이동하기 위해 거쳐 간 수들 중 최댓값과 최솟값의 차이가 가장 작아지는 경우를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 n(2≤n≤100)이 주어진다. 다음 n개의 줄에는 배열이 주어진다. 배열의 각 수는 0보다 크거나 같고, 200보다 작거나 같은 정수이다.
<출력값>
첫째 줄에 (최대 - 최소)가 가장 작아질 때의 그 값을 출력한다.

<문제 1982>
홍준이는 월드여행사에서 일을 하고 있다. 그런데 여행사에서 다음과 같은 일을 홍준이에게 시켰다. M명의 남자와 F명의 여자가 있다. 그리고 C쌍의 결혼을 한 커플이 있다. 이러한 사람들을 호텔에 적절히 분배를 시키려 하는데 다음과 같은 조건을 만족시키며 방을 나누어 줘야 한다.

서로 결혼을 하지 않은 남자와 여자는 같은 방에 들어갈 수 없다.
결혼을 한 남자와 여자가 방에 들어가 있으면 그 두 사람 이외에 다른 사람은 그 방에 같이 들어가 있을 수 없다.
그렇다고 결혼을 한 사람들이 반드시 같은 방에 들어가야 한다는 것이 아니다.

이러한 조건이 있을 때, 홍준이가 해야 할 일은 호텔을 예약하는데 필요한 비용을 최소로 하려는 것이다. 홍준이를 도와 남자의 수 m, 여자의 수 f, 그리고 방의 수 r, 결혼을 한 쌍의 수 c가 주어지고 방에 들어갈 수 있는 최대 인원과 비용이 주어져 있을 때 최소비용을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 남자의 수 m(1<=m<=100), 여자의 수 f(1<=f<=100), 방의 수 (1<=r<=100), 그리고 결혼을 한 쌍의 수 c(1<=c<=min(m,f))가 공백을 사이에 두고 주어진다. 그리고 두 번째 줄부터 r+1번째 줄까지 방의 정보가 주어지는데 각 줄에는 두 개의 정수 1<=a<=5, 1<=b<=1000이 공백을 사이에 두고 주어진다. a는 번째 방에 들어갈 수 있는 최대인원, b는 번째 방을 얻는데 필요한 비용을 의미한다.
<출력값>
첫째 줄에 방을 빌리는데 필요한 최소비용을 출력한다. 만약에 모든 사람이 방을 빌리는 것이 불가능 할 경우에는 Impossible을 첫째 줄에 대신 출력한다.

<문제 1983>
그림과 같이 숫자 박스는 위와 아래의 두 행과 N개의 열로 나누어져 있다. 따라서 숫자 박스는 전체 2N개의 칸으로 이루어져 있고, 각 칸에는 0이 아닌 -10 이상 10 이하의 정수가 적힌 숫자판이 들어갈 수 있다. 아래 그림은 N=7 인 경우 어떤 숫자 박스의 상태를 보여주고 있다. 빈칸은 숫자판이 들어있지 않은 칸을 나타내며, 위와 아래의 행에 들어있는 숫자판의 개수는 같지 않을 수도 있다.

숫자 박스의 "값"은 각 열의 위와 아래에 있는 두 숫자들의 곱을 모두 더한 값으로 정의된다. 빈칸은 0으로 계산한다. 예를 들면, 위 그림의 숫자 박스의 값은 (-3)×0 + (-1)×(-3) + (-2)×2 + 0×4 + 5×0 + (-1)×5 + 0×(-2) = -6 이다. 각 행에 주어진 숫자판들에 대해 그 순서를 유지하면서 좌우로 움직이면 다른 숫자 박스의 “값”을 얻을 수 있다. 위의 예에서 윗 행에 있는 5와 -1을 오른쪽으로 각각 한 칸씩 옮기고, 아래 행의 -3을 왼쪽으로 한 칸, 2와 4를 오른쪽으로 각각 한 칸씩 옮기면 그 결과 숫자 박스는 다음과 같다.

 이 숫자 박스의 “값”은 9 + 25 + 2 = 36이 된다. 주어진 숫자 박스의 위와 아래의 행에 놓인 숫자판들을 그 순서는 유지하면서 위의 조건을 만족하도록 움직여서 얻을 수 있는 숫자 박스의 최댓값을 구하는 프로그램을 작성하시오. 숫자판들은 좌우 빈칸으로만 움직일 수 있으며, 건너뛰는 형태로 다른 숫자판과 그 위치가 교환될 수는 없다. 다시 말하면, 빈칸을 제외하면 각 행의 숫자판들의 순서는 항상 그대로 유지되어야 한다.
<입력값>
첫 줄에는 숫자 박스의 열의 수를 나타내는 정수 N(1<=N<=400)이 주어진다. 그 다음 두 줄에는 각각 숫자 박스의 위와 아래의 행에 놓인 초기 숫자판들의 숫자가 하나 이상의 공백을 두고 나타나는데, 숫자판이 없는 빈칸은 0으로 표시된다. 단, 숫자판의 숫자는 모두 -10 이상 10 이하의 0이 아닌 정수이다.
<출력값>
입력으로 주어진 숫자 박스의 각 행의 숫자판들을 가로로 이동시켜 얻을 수 있는 숫자 박스의 최댓값을 첫 번째 줄에 출력한다.

<문제 1985>
두 정수가 만약에 완전히 같은 숫자들로만 이루어져 있으면 두 숫자를 friends(친구)라고 부른다. 예를 들어 123과 32331313323213은 friends 이지만 123과 22121221은 아니다.
그러나 friends가 아닌 두 개의 정수가 만약에 이웃한 두 숫자를 규칙에 따라 고쳤을 때 friends가 되면 almost friends(거의 친구)라고 부른다. 그 규칙은 만약에 a와 b가 붙어 있으면 a에 1을 빼고 b에 1을 더하거나 a에 1을 더하고 b에 1을 뺄 수 있다는 것이다. 하지만 그 결과에서 맨 앞자리 숫자가 0이라면 이것은 허용이 되지 않는다. 예를 들어 123과 2223042는 almost friends이다. (2223042 -> 2223132) 하지만 137과 470은 friends도 almost friends도 아니다. (137 -> 047)은 허용이 되지 않는다. 연산은 두 수 중 하나에게만, 최대 한 번 사용할 수 있다.
만약에 두 정수가 주어져 있을 때, 두 정수가 friends인지, almost friends인지, 아니면 아무것도 아닌지 구하는 프로그램을 작성하시오.
<입력값>
세 개의 입력 데이터가 주어지며, 각각의 입력 데이터는 한 개의 줄로 이루어져 있다. 각 데이터의 첫째 줄에 두 정수 x,y가 공백을 사이에 두고 주어진다.(0<x,y<10^100)
<출력값>
세 개의 줄에 걸쳐 입력된 순서대로 x,y가 friends면 “friends", almost friends이면 ”almost friends", 둘 다 아니면 “nothing" 이라고 출력한다.

<문제 1986>
n*m 크기의 체스 판과, 상대팀의 Queen, Knight, Pawn의 위치가 주어져 있을 때, 안전한 칸이 몇 칸인지 세는 프로그램을 작성하시오. (안전한 칸이란 말은 그 곳에 자신의 말이 있어도 잡힐 가능성이 없다는 것이다.)
참고로 Queen은 가로, 세로, 대각선으로 갈 수 있는 만큼 최대한 많이 이동을 할 수 있는데 만약 그 중간에 장애물이 있다면 이동을 할 수 없다. 그리고 Knight는 2*3 직사각형을 그렸을 때, 반대쪽 꼭짓점으로 이동을 할 수 있다. 아래 그림과 같은 8칸이 이에 해당한다.

이때 Knight는 중간에 장애물이 있더라도 이동을 할 수 있다. 그리고 Pawn은 상대팀의 말은 잡을 수 없다고 하자(즉, 장애물의 역할만 한다는 것이다).
예를 들어 다음과 같이 말이 배치가 되어 있다면 진하게 표시된 부분이 안전한 칸이 될 것이다. (K : Knight, Q : Queen, P : Pawn)
<입력값>
첫째 줄에는 체스 판의 크기 n과 m이 주어진다. (1<=n, m<=1000) 그리고 둘째 줄에는 Queen의 개수와 그 개수만큼의 Queen의 위치가 입력된다. 그리고 마찬가지로 셋째 줄에는
Knight의 개수와 위치, 넷째 줄에는 Pawn의 개수와 위치가 입력된다. (즉 둘째 줄~ 넷째 줄은  k,r1,c1,r2,c2,...,rk,ck 이 빈칸을 사이에 두고 주어진다는 것이다. 여기서 ri는 i번째 말의 행 위치, ci는 i번째 말의 열 위치를 의미한다.) 한 칸에는 하나의 말만 놓인다고 가정한다. Knight, Queen, Pawn의 개수는 각각 100을 넘지 않는다.
<출력값>
첫째 줄에 n*m 체스판에 안전한 칸이 몇 칸인지 출력하시오.

<문제 1987>
세로 R칸, 가로 C칸으로 된 표 모양의 보드가 있다. 보드의 각 칸에는 대문자 알파벳이 하나씩 적혀 있고, 좌측 상단 칸 (1행 1열) 에는 말이 놓여 있다.
말은 상하좌우로 인접한 네 칸 중의 한 칸으로 이동할 수 있는데, 새로 이동한 칸에 적혀 있는 알파벳은 지금까지 지나온 모든 칸에 적혀 있는 알파벳과는 달라야 한다. 즉, 같은 알파벳이 적힌 칸을 두 번 지날 수 없다.
좌측 상단에서 시작해서, 말이 최대한 몇 칸을 지날 수 있는지를 구하는 프로그램을 작성하시오. 말이 지나는 칸은 좌측 상단의 칸도 포함된다.
<입력값>
첫째 줄에 R과 C가 빈칸을 사이에 두고 주어진다. (1 ≤ R,C ≤ 20) 둘째 줄부터 R개의 줄에 걸쳐서 보드에 적혀 있는 C개의 대문자 알파벳들이 빈칸 없이 주어진다.
<출력값>
첫째 줄에 말이 지날 수 있는 최대의 칸 수를 출력한다.

<문제 1988>
동혁이는 낮잠 시간을 N개의 구간으로 나누어서 그 중 B개의 구간동안만 잠을 자려고 한다. B개의 구간이 연속일 필요는 없다. 각 구간동안에 동혁이가 얻을 수 있는 피로 회복량이 정해져 있는데, 동혁이는 이 양을 최대화 하려고 한다. 잠을 설치는 경우가 한 예이다.

	예를 들어 구간을 5개로 나누었을 경우, B=3이고 [2 3 4]구간에 잠을 자기로 했다고 치자. 잠을 들기 위해서는 준비 시간이 필요하기 때문에 이 준비 시간 동안에는 피로 회복이 되지 않는다. 각 분할의 첫 구간에서는 피로가 회복되지 않는 것이다. 따라서 [2 3 4] 구간에 잠을 자면 [2]구간에서는 회복을 못하고 [3 4]구간에서만 회복할 수 있다. 이 구간은 N번째 구간과 1번째 구간이 이어져있지 않다고 생각하자.

	동혁이가 어떻게 하면 피로회복을 최대로 할 수 있는지 구해보자.
<입력값>
첫 줄에 N과 B가 주어진다. N은 3이상 3,000이하이고 B는 2이상 N미만이다. 다음으로 N줄에 걸쳐 피로회복량이 주어지는 0이상 200,000 이하의 자연수이다.
<출력값>
첫 줄에 가능한 최대 피로회복량을 출력한다.

<문제 1989>
크기가 N(1≤N≤100,000)인 1차원 배열 A[1], …, A[N]이 있다. 어떤 i, j(1≤i≤j≤N)에 대한 점수는, (A[i]+…+A[j])×Min{A[i], …, A[j]}가 된다. 즉, i부터 j까지의 합에다가 i부터 j까지의 최솟값을 곱한 것이 점수가 된다.
배열이 주어졌을 때, 최대의 점수를 갖는 부분배열을 골라내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 정수 N이 주어진다. 다음 줄에는 A[1], …, A[N]을 나타내는 정수들이 주어진다. 각각의 정수들은 음이 아닌 값을 가지며, 1,000,000을 넘지 않는다.
<출력값>
첫째 줄에 최대 점수를 출력한고, 둘째 줄에 그 구간의 시작 위치(i)와 끝 위치(j)를 출력한다.

<문제 1990>
151은 소수이면서 동시에 팰린드롬이기 때문에 소수인 팰린드롬이다. 팰린드롬이란 앞으로 읽어나 뒤로 읽으나 같은 수를 말한다. 예를 들어 1234는 앞으로 읽으면 1234지만, 뒤로 읽으면 4321이 되고 이 두 수가 다르기 때문에 팰린드롬이 아니다. 두 정수 a, b가 주어졌을 때, a이상 b이하인 소수인 팰린드롬을 모두 구하는 프로그램을 작성하시오.
<입력값>
입력은 첫째 줄에 공백으로 구분된 두 자연수 a, b가 주어진다. 단 5 ≤ a < b ≤ 100,000,000 이다.
<출력값>
첫째 줄부터 차례로 증가하는 순서대로 한 줄에 한개씩 소수인 팰린드롬을 출력한다. 마지막 줄에는 -1을 출력한다.

<문제 1991>
이진 트리를 입력받아 전위 순회(preorder traversal), 중위 순회(inorder traversal), 후위 순회(postorder traversal)한 결과를 출력하는 프로그램을 작성하시오.

예를 들어 위와 같은 이진 트리가 입력되면,

전위 순회한 결과 : ABDCEFG // (루트) (왼쪽 자식) (오른쪽 자식)
중위 순회한 결과 : DBAECFG // (왼쪽 자식) (루트) (오른쪽 자식)
후위 순회한 결과 : DBEGFCA // (왼쪽 자식) (오른쪽 자식) (루트)

가 된다.
<입력값>
첫째 줄에는 이진 트리의 노드의 개수 N(1≤N≤26)이 주어진다. 둘째 줄부터 N개의 줄에 걸쳐 각 노드와 그의 왼쪽 자식 노드, 오른쪽 자식 노드가 주어진다. 노드의 이름은 A부터 차례대로 영문자 대문자로 매겨지며, 항상 A가 루트 노드가 된다. 자식 노드가 없는 경우에는 .으로 표현된다.
<출력값>
첫째 줄에 전위 순회, 둘째 줄에 중위 순회, 셋째 줄에 후위 순회한 결과를 출력한다. 각 줄에 N개의 알파벳을 공백 없이 출력하면 된다.

<문제 1992>
흑백 영상을 압축하여 표현하는 데이터 구조로 쿼드 트리(Quad Tree)라는 방법이 있다. 흰 점을 나타내는 0과 검은 점을 나타내는 1로만 이루어진 영상(2차원 배열)에서 같은 숫자의 점들이 한 곳에 많이 몰려있으면, 쿼드 트리에서는 이를 압축하여 간단히 표현할 수 있다.
주어진 영상이 모두 0으로만 되어 있으면 압축 결과는 "0"이 되고, 모두 1로만 되어 있으면 압축 결과는 "1"이 된다. 만약 0과 1이 섞여 있으면 전체를 한 번에 나타내지를 못하고, 왼쪽 위, 오른쪽 위, 왼쪽 아래, 오른쪽 아래, 이렇게 4개의 영상으로 나누어 압축하게 되며, 이 4개의 영역을 압축한 결과를 차례대로 괄호 안에 묶어서 표현한다

위 그림에서 왼쪽의 영상은 오른쪽의 배열과 같이 숫자로 주어지며, 이 영상을 쿼드 트리 구조를 이용하여 압축하면 "(0(0011)(0(0111)01)1)"로 표현된다.  N ×N 크기의 영상이 주어질 때, 이 영상을 압축한 결과를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 영상의 크기를 나타내는 숫자 N 이 주어진다. N 은 언제나 2의 제곱수로 주어지며, 1 ≤ N ≤ 64의 범위를 가진다. 두 번째 줄부터는 길이 N의 문자열이 N개 들어온다. 각 문자열은 0 또는 1의 숫자로 이루어져 있으며, 영상의 각 점들을 나타낸다.
<출력값>
영상을 압축한 결과를 출력한다.

<문제 1993>
n개의 체크포인트가 있고, 원점에서 출발하여 체크포인트들을 순서대로 방문하고 원점으로 돌아오는 경주가 진행된다. 이때 모든 체크포인트를 방문할 필요는 없지만 반드시 주어진 순서를 지키면서 방문해야 한다. 체크포인트 번호가 순서대로 1~n이라 할 때, 1, 2, 5번 순서대로 방문할 수는 있지만 4, 2번 순서대로는 방문할 수 없다.
원점이나 체크포인트 사이를 이동할 때는 반드시 직선 경로로 이동하는데, 이때 경로 위에 다른 체크포인트가 존재할 수도 있다. 이때는 방문해도 되고 방문하지 않아도 된다. 그리고 각각의 체크포인트에는 방문할 시 얻는 점수가 있는데, 우승자는 방문한 체크포인트의 점수 합이 가장 높은 사람이 된다. 물론 하나의 체크포인트에서는 점수를 한 번만 획득할 수 있다.
그러나 경주에 참여한 사람들이 모두 남규와 그 친구들이라 하나같이 약골이다. 그들은 각각 달릴 수 있는 거리 한계가 명확해서 그 안에 돌아오지 못하면 대회를 완주할 수 없다. 그들은 약골인데다 근성도 없어서 절대 그 거리보다 많이 뛸 수 없다. 다행히 각자는 자신이 얼마나 달릴 수 있는지 알고 있기 때문에, 한도 안에서 완주하면서 얻을 수 있는 점수가 최대 몇 점인지를 미리 계산해보려고 한다. 남규와 친구들을 위해 이를 구해 주는 프로그램을 작성해보자!
<입력값>
입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스는 다음과 같이 이루어져 있으며, 전체 입력의 끝에는 0 하나가 주어진다.

첫째 줄에 체크포인트의 개수 n이 주어진다(1 ≤ n ≤ 30).
이어서 n개의 줄에 각 체크포인트의 좌표 x, y, 점수 s를 의미하는 정수 3개가 순서대로 주어진다(−5000 ≤ x, y ≤ 5000, 10 ≤ s ≤ 200).
이어서 여러 줄에 각 선수의 이름과 최대한 달릴 수 있는 거리의 한계를 의미하는 정수 d가 공백으로 구분되어 줄마다 주어진다(0 ≤ d ≤ 10000). 선수의 이름은 60글자를 넘지 않으며 공백을 포함하지 않는다. 마지막 줄에는 선수 이름 대신 '# 0'이 주어지며, 이 줄은 각 테스트 케이스의 끝을 의미한다.

각 선수들은 원점(0, 0)에서 출발하여 몇몇 체크포인트를 방문했다가 다시 원점으로 돌아와야 한다. 아무것도 방문하지 않을 수도 있다. 경주가 이루어지는 공간은 완전히 평평한 2차원 공간이라고 가정한다.
<출력값>
각 테스트 케이스마다 첫째 줄에 ‘Race r’을 출력한다. r에는 테스트 케이스의 번호가 들어간다. 이어서 각 줄마다 선수 정보를 입력받은 순서대로 선수의 이름과 얻을 수 있는 최대 점수를 출력 양식 ‘이름: 점수’에 맞게 출력한다.

<문제 1994>
N(1≤N≤2,000)개의 음 아닌 정수들이 있다. 이들 중 몇 개의 정수를 선택하여 나열하면 등차수열을 만들 수 있다. 예를 들어 4, 3, 1, 5, 7이 있을 때 1, 3, 5, 7을 선택하여 나열하면 등차수열이 된다. 이와 같이 했을 때, 등차수열의 길이가 최대 얼마까지 가능한지 알아내시오.
등차수열은 일정한 값만큼 증가하는 수열을 말한다. 이 일정한 값은 음수나 0도 될 수 있다.
<입력값>
첫째 줄에는 숫자의 개수 N(1≤N≤2,000)이 주어지고, 다음 N개의 줄에는 정수들이 주어진다. 정수들은 1,000,000,000보다 작다.
<출력값>
첫째 줄에 가장 긴 등차수열의 길이를 출력한다.

<문제 1995>
볼록 n각형 모양의 건물이 있고, 건물 밖에 CCTV 몇 개를 설치해 건물 주위를 감시하려고 한다. 이때, 건물 밖에 m개의 장소가 주어져 있어 그 곳에만 CCTV를 설치할 수 있다.

위 그림 1과 같이 CCTV를 설치할 수 있는 장소가 주어져 있을 때, 1번 위치에 CCTV를 설치하면(그림 2) 빨간색으로 표시한 2개의 외벽을 감시할 수 있다. 단, 외벽과 CCTV의 위치가 일직선상에 위치한 경우에는 그 외벽을 감시하지 못한다고 가정한다. 예를 들어 6번 위치에 CCTV를 설치하면(그림 3) 파란색으로 표시한 벽면은 감시하지 못한다.
이때, CCTV를 몇 군데에 설치하여 건물 외벽을 모두 감시하도록 만들 수 있다. 위 그림 1과 같은 경우에는 1, 2, 4, 6 위치에 CCTV를 설치하거나(그림 4), 혹은 1, 3, 5, 7번 위치에 CCTV를 설치하면(그림 5) 건물 외벽을 모두 감시할 수 있다.

그런데 각각의 위치마다 CCTV를 설치하는 데 드는 비용이 다르다. 우리가 할 일은 건물 외벽을 모두 감시하도록 CCTV를 설치할 때 드는 최소 비용을 구하는 것이다.
<입력값>
첫 번째 줄에 자연수 n(1≤n≤1,000)과 m(1≤m≤1,000)의 값이 주어진다. 두 번째 줄부터 차례로 n개의 줄에 걸쳐 다각형을 이루는 꼭짓점들의 x, y 좌표가 반시계 방향으로 하나씩 주어진다. 그 다음 m개 줄에는 CCTV를 설치할 수 있는 곳의 x, y좌표, 그리고 그 위치에 설치할 때 드는 비용이 차례로 주어진다. 두 좌표 사이에는 빈 칸이 하나 있다. 모든 좌표값은 절댓값이 100,000을 넘지 않는 정수이며 CCTV를 설치할 때 드는 비용은 100,000 이하의 자연수이다. 다각형의 인접한 두 변이 일직선상에 위치하는 경우는 없다고 가정해도 좋다.
<출력값>
첫 번째 줄에 최소 비용을 출력한다. 건물 외벽을 모두 감시하도록 CCTV를 설치하는 것이 불가능하다면 -1을 출력한하면 된다.

<문제 1996>
다들 windows에서 지원하는 지뢰 찾기 게임을 한번쯤은 해 보았을 것이다. 특히 동호는 지뢰찾기의 매니아로 알려져 있다. 지뢰 찾기 map은 N*N의 정사각형 모양으로 각 칸에는 숫자가 들어가 있거나 지뢰가 들어가 있다. 빈 칸에는 숫자 0이 들어있다고 생각하자.
map의 어떤 칸에 적혀 있는 숫자는, 그 칸과 인접해 있는 여덟 개의 칸 중에서 지뢰가 들어 있는 칸이 몇 개인지를 나타내 준다. 물론 인접한 칸이 map 내부에 있는 경우에 대해서만 생각하면 된다. 예제를 보면 더 잘 이해할 수 있을 것이다.
이번 문제는 조금 업그레이드 된 지뢰 찾기로, 한 칸에 한 개의 지뢰가 있는 것이 아니고, 한 칸에 여러 개(1 이상 9 이하)의 지뢰가 묻혀 있는 게임이다. 따라서 map의 어떤 칸에 적혀 있는 숫자는, 그 칸과 인접해 있는 여덟 개의 칸들에 들어 있는 지뢰의 총 개수가 된다.
이미 windows 지뢰찾기 같은 것을 마스터한 영식이는, map에서 지뢰에 대한 정보만이 주어졌을 때, 영식이는 map을 완성하고 싶다고 한다. N과 지뢰의 위치가 주어졌을 때, 영식이를 도와서 지뢰 찾기 map을 완성하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N(1≤N≤1,000)이 주어진다. 다음 N개의 줄에는 지뢰 찾기 map에 대한 정보가 주어지는데 '.' 또는 숫자로 이루어진 문자열이 들어온다. '.'는 지뢰가 없는 것이고 숫자는 지뢰가 있는 경우로 그 칸의 지뢰의 개수이다. 한 줄은 N개의 문자로 이루어져 있다.
<출력값>
N개의 줄에 걸쳐서 완성된 지뢰 찾기 map을 출력한다. 지뢰는 '*'로 출력하며. 10 이상인 경우는 'M'(Many)으로 출력하면 된다. map은 숫자 또는 'M' 또는 '*'로만 이루어져 있어야 한다.

<문제 1997>
동호는 어떤 도자기 장식 판을 포장하는 회사에서 일을 하고 있다. 모든 장식 판은 두께가 1이고 너비가 모두 같으며 각자 자신의 고유한 모양을 가지고 있다.

박스의 너비는 장식 판의 너비와 같아 장식 판을 포장할 때, 차례로 쌓을 수밖에 없다. 예를 들어 위의 장식 판을 차례로 쌓으면 아래의 왼쪽 그림과 같은 모양이 나오게 되고 세 번째 -> 두 번째 -> 첫 번째 순서로 쌓으면 오른쪽 그림과 같이 나오게 된다.

그런데 박스의 높이에는 한계가 있어서 왼쪽과 같은 경우에는 박스를 포장할 수 없게 된다. 그렇기 때문에 왼쪽과 같이 포장을 하려면 박스를 두개로 나누어서 첫 번째 박스는 두 번째 장식 판까지 쌓고, 두 번째 박스에 세 번째 장식 판을 넣어 포장을 해야 할 것이다.
우리가 해야 할 일은 다음과 같다. 어떤 장식 판의 개수, 너비, 박스의 높이, 그리고 장식 판들의 모양이 주어져 있다고 가정하자. 이러한 상황에서 주어진 장식 판을 순서대로 쌓을 때, 사용한 각 박스 안에 쌓은 높이를 출력하는 프로그램을 작성하시오. (ex, 위의 예 같은 경우에는 첫 번째 박스에 2번째 장식 판 까지 쌓아 높이가 9가 되고 두 번째 박스에 세 번째 장식 판을 넣어 높이가 6이 된다. 그래서 답은 9 6이 되는 것이다.)
<입력값>
입력은 첫째 줄에 공백으로 구분된 100을 넘지 않는 세 자연수 n, w, b가 주어진다. n은 장식 판의 종류이고, w는 장식판과 박스의 너비, 그리고 b는 박스의 높이이다. 그리고 다음으로 n개의 장식 판의 정보가 주어지는데, 각 정보의 첫줄에는 장식 판의 높이 h(1<=h<=10, h<=b) 가 주어지고 두 번째 줄부터 h+1번째 줄까지 장식 판의 정보가 .과 X로 주어진다. .은 빈 공간을 의미하고 X는 장식 판의 한 부분을 의미한다.
<출력값>
필요한 박스의 개수만큼의 정수를 출력하는데 각 박스에 쌓인 장식 판의 높이를 공백을 사이에 두고 출력한다.

<문제 1998>
흰색과 검은색으로 이루어진 이미지는 쿼드트리를 이용하여 표현할 수 있다. 쿼드트리의 루트는 이미지의 전체를 나타낸다. 만약 전체 이미지가 한 색깔로 이루어져 있으면, 그 색깔에 해당하는 정점을 루트로 한다. 그 외의 경우에는 그림을 넷으로 나누고, 각각의 나눠진 그림을 루트의 네 자식 정점으로 표현하면 된다. 이때 첫 번째 자식이 왼쪽 위의 그림을, 두 번째 자식이 오른쪽 위의 그림을, 세 번째 자식이 왼쪽 아래의 그림을, 네 번째 자식이 오른쪽 아래의 그림을 표현하게 된다. 각각의 작은 이미지를 표현할 때도 같은 방법을 재귀적으로 적용한다.

위의 예는 4×4 크기의 이미지와 그에 해당하는 쿼드트리이다. 위의 예에서는 이미지의 크기(사각형의 변의 길이)가 2의 k승이라서 상관이 없었지만, 그 외의 경우에는 문제가 된다. 만약에 이미지의 크기가 2의 k승이 아닐 경우에는, 이미지의 크기를 오른쪽과 아래쪽으로 가장 가까운 2의 k승으로 늘린 뒤, 흰색으로 나머지 공간을 채우면 된다. 이때 이미지가 정사각형 모양이 되도록 한다. 예를 들어 5×13의 이미지는 16×16 크기의 이미지가 되고, 원래의 이미지가 왼쪽 위에 들어가고 나머지 공간은 흰색으로 채우면 된다.
쿼드트리 자체가 이미지를 압축적으로 표현하는 방법이지만, 우리는 압축된 쿼드트리를 이용하여 좀 더 효율적으로 표현하려 한다. 만약 쿼드트리에서 같은 모양의 부분 트리가 여러 개 나올 경우, 이를 한 번만 저장한 뒤 나머지는 포인터로 연결할 수 있다. 위의 예는 다음과 같은 압축된 쿼드트리로 표현할 수 있다.

원래의 쿼드트리는 17개의 정점을 갖지만, 압축된 쿼드트리는 12개의 정점을 갖는다. 12개의 정점을 갖는 압축된 쿼드트리가 몇 개 더 있기는 하지만, 11개 이하의 정점을 갖는 압축된 쿼드트리는 존재하지 않는다. 따라서 위의 경우가 가장 효율적(정점 개수가 최소)이다.
주의할 것은, B나 W로 표현되는 정점은 포인터가 아니가 값 자체이므로 이를 연결할 경우는 압축하는 것이 아니다. 즉, 정점이 하나인 경우(높이가 1인 경우)에는 포인터를 이용하여 연결할 필요가 없다. 또, 실제 이미지의 크기가 다르더라도 트리의 모양이 같다면, 같은 쿼드트리로 표현될 수 있는데, 이런 경우에도 포인터로 연결할 수 있다.
이미지가 주어졌을 때, 쿼드트리의 정점의 개수와 가장 효율적인 압축된 쿼드트리의 정점의 개수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 이미지의 크기를 나타내는 두 정수 n(1≤n≤128), m(1≤m≤128)이 주어진다. 이는 이미지의 크기가 n×m이라는 의미이다. 다음 n개의 줄에는 m개의 숫자로 이미지가 주어진다. 흰색은 0으로, 검은색은 1로 표현된다.
<출력값>
첫째 줄에 쿼드트리의 정점의 개수와 가장 효율적인 압축된 쿼드트리의 정점의 개수를 출력한다.

<문제 1999>
N×N의 행렬이 있다(1≤N≤250). 행렬의 각 성분은 정수이다(0≤성분≤250). 당신에게는 K(1≤K≤100,000)개의 질문이 주어진다. 각 질문은, 주어진 행렬의 B×B 크기의 부분행렬의  최댓값과 최솟값의 차이를 묻는 질문들이다(1≤B≤N). 각 질문에 대해서, 부분행렬의 가장 왼쪽 위의 위치가 주어지며, 모든 질문들은 같은 B값을 갖는다. 질문에 답하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 세 정수 N, B, K가 주어진다. 다음 N개의 줄에는 행렬이 주어진다. 차례로 1행, 2행, …, N행이 된다. 각 줄에는 N개의 정수가 주어지며, 이는 차례로 1열의 성분, 2열의 성분, …, N열의 성분이 된다. 다음 K개의 줄에는 질문들이 주어진다. 각 질문들은 두 정수 i, j로 주어진다. i는 부분행렬의 가장 윗쪽의 행 번호이며, j는 부분행렬의 가장 왼쪽의 열 번호이다(1≤i, j≤N-B+1)
<출력값>
K개의 줄에, 차례로 각 질문의 답변(부분행렬의 최댓값과 최솟값의 차이값)을 출력한다.

<문제 2000>
상진이는 n개의 책을 담기 위한 책장을 만들려 한다. 그런데 상진이는 외관적인 문제 때문에 반드시 책장을 세개의 칸으로 구분하려 한다. 그런데 책장을 제작하는데는 많은 돈이 들기 때문에 책장의 크기를 최소화 하려 한다.
그런데 책장은 반드시 직사각형의 모양으로 이루어 져야 한다. 그렇다고 하였을 때, 책장의 크기는 다음과 같이 구할 수 있을 것이다. i번째 책의 높이와 두께를 각각 hi와 ti라고 하고, 첫 번째 책장에 들어가는 책의 집합을 S1, 두 번째 책장을 S2, 세 번째 책장을 S3 라고 하였을 때, 책장의 크기는 다음과 같은 식으로 구할 수 있다.
\[(\sum _{ j=1 }^{ 3 }{ max_{i\in S_{j} } h_{i} } )\times( max_{ j=1 }^{ 3 }{ \sum_{i\in S_{j} } t_{i} } )\]
이 식은 직관적으로 쉽게 알 수 있다. 각 칸의 높이는 그 칸에 들어있는 책들의 높이 중 가장 큰 높이가 될 것이고, 책장의 전체 넓이는 각 칸의 너비들 중 가장 큰 너비가 될 것이다. 그런데 각 칸의 너비는 최소한 그 칸에 들어있는 책들의 너비의 합이 되어야 하므로 위와 같은 식이 나오게 된다.
<입력값>
첫째 줄에 책들의 개수 n이 주어진다. 그리고 두 번째 줄부터 n+1번째 줄까지 책들의 높이와 두께 hi, ti가 공백을 사이에 두고 주어진다.
<출력값>
첫째 줄에 책장의 최소 너비를 출력한다.

<문제 2001>
n(1 ≤ n ≤ 100)개의 섬이 m(1 ≤ m ≤ 1,000)개의 다리로 연결되어 있다. 각각의 다리는 서로 다른 두 섬을 연결하고 있으며, 서로 다른 두 섬은 최대 한 개의 다리로만 직접 연결되어 있다. 각각의 다리들의 튼튼한 정도는 서로 달라서, 각각의 다리마다 견딜 수 있는 무게의 제한이 다를 수 있다.
섬들 중, K(1 ≤ K ≤ 14)개의 서로 다른 섬에 각각 한 개씩 보석이 있다. 당신은 1번 섬에서 빈손으로 출발하여 최대한 많은 보석을 줍고 1번 섬으로 돌아오려 한다. 주의할 것은, 보석을 너무 많이 줍다 보면 다리를 건널 때 다리가 무게를 견디지 못하고 무너질 수 있다는 점이다. 따라서 당신은 다리가 무너지지 않는 한도 내에서 보석을 주워야 한다.
한 번 지난 적이 있는 다리와 섬을 여러 번 지날 수 있으며, 보석이 있는 섬을 지날 때에 그 보석을 줍지 않을 수도 있다고 하자.
<입력값>
첫째 줄에 n, m, K가 주어진다. 다음 K개의 줄에는 보석이 있는 섬의 번호가 주어진다. 다음 m개의 줄에는 각 다리에 대한 정보를 나타내는 세 자연수 a, b, c(1 ≤ c ≤ 100)가 주어진다. 이는 a번 섬과 b번 섬이 다리로 연결되어 있는데, 그 다리가 최대 c개의 보석만을 견딜 수 있다는 의미이다. 예를 들어 c가 2라면, 그 다리를 지날 때 보석을 0, 1, 2개 가지고 있어야 한다는 의미이다. 3개 이상의 보석을 가지고 그 다리를 지나려고 하면 다리가 무너진다.
<출력값>
첫째 줄에 주울 수 있는 보석의 최대 개수를 출력한다.

<문제 2002>
대한민국을 비롯한 대부분의 나라에서는 터널 내에서의 차선 변경을 법률로 금하고 있다. 조금만 관찰력이 있는 학생이라면 터널 내부에서는 차선이 파선이 아닌 실선으로 되어 있다는 것을 알고 있을 것이다. 이는 차선을 변경할 수 없음을 말하는 것이고, 따라서 터널 내부에서의 추월은 불가능하다.
소문난 명콤비 경찰 대근이와 영식이가 추월하는 차량을 잡기 위해 한 터널에 투입되었다. 대근이는 터널의 입구에, 영식이는 터널의 출구에 각각 잠복하고, 대근이는 차가 터널에 들어가는 순서대로, 영식이는 차가 터널에서 나오는 순서대로 각각 차량 번호를 적어 두었다.
N개의 차량이 지나간 후, 대근이와 영식이는 자신들이 적어 둔 차량 번호의 목록을 보고, 터널 내부에서 반드시 추월을 했을 것으로 여겨지는 차들이 몇 대 있다는 것을 알게 되었다. 대근이와 영식이를 도와 이를 구하는 프로그램을 작성해 보자.
<입력값>
입력은 총 2N+1개의 줄로 이루어져 있다. 첫 줄에는 차의 대수 N(1 ≤ N ≤ 1,000)이 주어진다. 둘째 줄부터 N개의 줄에는 대근이가 적은 차량 번호 목록이 주어지고, N+2째 줄부터 N개의 줄에는 영식이가 적은 차량 번호 목록이 주어진다. 각 차량 번호는 6글자 이상 8글자 이하의 문자열로, 영어 대문자('A'-'Z')와 숫자('0'-'9')로만 이루어져 있다.
같은 차량 번호가 두 번 이상 주어지는 경우는 없다.
<출력값>
첫째 줄에 터널 내부에서 반드시 추월을 했을 것으로 여겨지는 차가 몇 대인지 출력한다.

<문제 2003>
N개의 수로 된 수열 A[1], A[2], …, A[N] 이 있다. 이 수열의 i번째 수부터 j번째 수까지의 합 A[i] + A[i+1] + … + A[j-1] + A[j]가 M이 되는 경우의 수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N(1 ≤ N ≤ 10,000), M(1 ≤ M ≤ 300,000,000)이 주어진다. 다음 줄에는 A[1], A[2], …, A[N]이 공백으로 분리되어 주어진다. 각각의 A[x]는 30,000을 넘지 않는 자연수이다.
<출력값>
첫째 줄에 경우의 수를 출력한다.

<문제 2004>
$n \choose m$의 끝자리 $0$의 개수를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 정수 $n$, $m$ ($0 \le m \le n \le 2,000,000,000$, $n \ne 0$)이 들어온다.
<출력값>
첫째 줄에 $n \choose m$의 끝자리 $0$의 개수를 출력한다.

<문제 2005>
밑면이 반지름이 r인 원이고 윗면이 반지름이 R인 사발이 있다. (윗면을 뚫려있다) 그리고 옆면이 직선이다. N개의 사발이 주어져 있을 때, 이 사발을 적절한 순서로 쌓을 때 최소 높이를 구하는 프로그램을 작성하시오. (단 사발의 두께는 무시하는 걸로 하자)
사발의 쌓는 모양을 그림으로 표현하면 대략 다음과 같다.
<입력값>
첫 번째 줄에는 사발의 개수 n이 주어진다. 그리고 두 번째 줄부터 n+1번째 줄까지 각 사발의 정보가 주어지는데 각 줄에는 h, r, R 세 개의 정수가 빈칸을 사이에 두고 차례로 주어진다. h는 높이를 의미하고, r은 밑면의 반지름, R은 윗면의 반지름을 의미한다.
<출력값>
첫째 줄에 최소 높이를 출력한다. 결과를 버림하여 정수값으로 출력한다.

<문제 2006>
Chemistry is all about reactions—you throw a bunch of stuff into a test-tube, heat it up, hoping that it will neither explode or poison you, then cool it down and try to work out whether what you have is what you expected. That’s the easy (and fun) bit—much harder is recording it all. As is usual with skills of this type, chemistry instructors the world over rely on drill—a seemingly endless set of reactions that the students have to complete. The trick is that everything that appears on the left side (the reagents, or ‘input’) must appear on the right side (the products, or ‘output’). This ought to be simple, but generations of chemistry students have demonstrated otherwise.
Professor Plumbius is getting tired of writing the same comments on his student’s worksheets over and over and he wants to automate the process. He wants to be able to enter the equations as written by the students and have the computer produce the comments automatically, thus giving him more time to dream up more equations to give his students to practise on. This is where you come in.
Write a program that will read in a chemistry equation and determine whether it is balanced. If it isn’t, your program must tell the student what elements are out of balance and by how much.
Normally a chemistry equation is written like this:
2H2O + SO2 ←→ H2 + H2SO4
but due to the limitations of computer input we will present it like this:
2H2O + SO2 = H2 + H2SO4
This example shows the essentials of an equation: each side consists of one or more molecules, separated by ‘+’ signs (the spaces are optional). Each molecule may have a multiplier before it which specifies how many instances of that molecule take part in the reaction. A molecule consists of one or more elements. Each element has a symbol, which is either an uppercase letter, e.g., ‘H’, or an uppercase letter followed by a lowercase letter, e.g., ‘Br’. A symbol may be followed by a multiplier specifying how many atoms of that element are present in that part of the molecule. Thus the first term says that there are two instances of a molecule consisting of two atoms of H and one atom of O. (This happens to be water, but you do not need to know that.)
Given that these are exercises handed out to the students, the left hand sides are, by definition, correct. Thus your job is to determine whether all the atoms that appear on the left also appear on the right. If they do, then the equation is balanced. If not, you must report which elements have been created or lost and how much of each.
<입력값>
Input will consist of a number of equations, each on a line by itself. Each line will contain no more than 250 characters. Each equation represents a set of reagents and a set of products, separated by an ‘=’ sign. Each set will consist of one or more molecules, possibly with multipliers, separated by ‘+’ signs. There may be zero or more spaces on either side of the ‘+’ and ‘=’ signs.
The last line of input will be a ‘#’ on a line by itself. This line should not be processed.
<출력값>
There will be at least one line of output for each equation in the input. If the equation is balanced this line will say ‘Equation n is balanced.’, where n is the equation number (starting from 1). If the equation does not balance, then the output line will say ‘Equation n is unbalanced.’ and will be followed by a series of lines of the form
You have <created or destroyed> m <atom or atoms> of element. 
where element is the symbol of the element concerned, m is the number of extra or missing atoms of that element, and ‘atom(s)’ is singular or plural as appropriate. For each unbalanced equation, these lines should be ordered alphabetically by element symbol and terminated by a blank line. (Note that this means that the final line of your output may be a blank line.)

<문제 2007>
N개의 정수가 있을 때 모든 두 수를 한 쌍으로 하여 더한 N×(N-1)/2개의 합을 생각해볼 수 있다. 그러한 N×(N-1)/2개의 합이 주어지면 그것으로 원래 N개의 수들을 구하는 프로그램을 작성하시오.
<입력값>
첫 번째 줄에는 N(2 ≤ N ≤ 100) 이 입력된다. 두 번째 줄에는 N×(N-1)/2개의 합들이 주어진다. 입력으로 주어지는 합은 절댓값이 1,000,000보다 작거나 같은 정수이다.
<출력값>
그러한 합이 나오게 하는 원래 N개의 수를 비내림차순으로 출력한다. 답이 여러 개 존재 할 경우 그 중 하나만 출력하면 되며, 답이 없는 경우 “Impossible” 이라고 출력한다.
출력하는 정수는 -1억보다 크거나 같고, 1억보다 작거나 같아야 한다.

<문제 2008>
사다리 게임을 할 때 사용되는 사다리가 있다. 세로선은 N개가 있고, 가로선은 M개가 있다. 세로선은 맨 왼쪽 것부터 1, 2, …, N의 번호가, 가로선은 맨 위의 것부터 1, 2, …, M으로 번호가 붙어 있다. 같은 높이에는 가로선이 없다고 생각하자.

위의 그림은 N=4, M=3인 한 사다리이다. 이런 사다리가 있으면 A는 3으로, B는 1로, C는 4로, D는 2로 가게 된다.
우리는 이 사다리를 조작해서 우리가 원하는 모양으로 만들고자 한다. 사다리를 조작할 때에는 가로선을 지우거나 새로 그릴 수 있는데, 지울 때는 X만큼의 비용이, 그릴 때는 Y만큼의 비용이 필요하다. 예를 들어 B에서 2로 가고자 한다면 1, 3번 가로선을 지우거나 3번 가로선 밑에 1-2의 가로선을 그리는 방법이 있다.
위의 a번째 위치에서 아래의 b번째 위치로 갈 수 있도록 사다리를 조작할 때, 최소비용을 구하시오.
<입력값>
첫째 줄에 N(1 ≤ N ≤ 100), M(0 ≤ M ≤ 500)이 주어진다. 다음 줄에는 a, b, X, Y(0 ≤ X, Y ≤ 1,000)가 주어진다. 다음 M개의 줄에는 위에서부터 가로선에 대한 정보를 나타내는 정수 p가 주어진다. 이는 p번, p+1번 세로선을 연결하는 가로선을 의미한다.
<출력값>
첫째 줄에 최소 비용을 출력한다.

<문제 2010>
선영이의 집에는 콘센트를 꽂을 수 있는 플러그가 하나밖에 없다. 선영이는 많은 컴퓨터를 가지고 있는데, 컴퓨터의 전원 문제는 어떻게 해결하는 것일까?
하나의 플러그가 있고, N개의 멀티탭이 있다. 각 멀티탭은 몇 개의 플러그로 이루어져 있다고 한다. 최대 몇 대의 컴퓨터를 전원에 연결할 수 있을까?
<입력값>
첫째 줄에 멀티탭의 개수 N이 주어진다. (1 ≤ N ≤ 500,000) 이어서 둘째 줄부터 N개의 줄에 걸쳐 각 멀티탭이 몇 개의 플러그를 꽂을 수 있도록 되어 있는지를 나타내는 자연수가 주어진다. 이 자연수는 1,000을 넘지 않는다.
<출력값>
첫째 줄에 최대로 전원에 연결될 수 있는 컴퓨터의 수를 출력한다.

<문제 2011>
상근이와 선영이가 다른 사람들이 남매간의 대화를 듣는 것을 방지하기 위해서 대화를 서로 암호화 하기로 했다. 그래서 다음과 같은 대화를 했다.

상근: 그냥 간단히 암호화 하자. A를 1이라고 하고, B는 2로, 그리고 Z는 26으로 하는거야.
선영: 그럼 안돼. 만약, "BEAN"을 암호화하면 25114가 나오는데, 이걸 다시 글자로 바꾸는 방법은 여러 가지가 있어.
상근: 그렇네. 25114를 다시 영어로 바꾸면, "BEAAD", "YAAD", "YAN", "YKD", "BEKD", "BEAN" 총 6가지가 나오는데, BEAN이 맞는 단어라는건 쉽게 알수 있잖아?
선영: 예가 적절하지 않았네 ㅠㅠ 만약 내가 500자리 글자를 암호화 했다고 해봐. 그 때는 나올 수 있는 해석이 정말 많은데, 그걸 언제 다해봐?
상근: 얼마나 많은데?
선영: 구해보자!

어떤 암호가 주어졌을 때, 그 암호의 해석이 몇 가지가 나올 수 있는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 5000자리 이하의 암호가 주어진다. 암호는 숫자로 이루어져 있다.
<출력값>
나올 수 있는 해석의 가짓수를 구하시오. 정답이 매우 클 수 있으므로, 1000000으로 나눈 나머지를 출력한다.
암호가 잘못되어 암호를 해석할 수 없는 경우에는 0을 출력한다.

<문제 2012>
2007년 KOI에 N명의 학생들이 참가하였다. 경시일 전날인 예비소집일에, 모든 학생들은 자신이 N명 중에서 몇 등을 할 것인지 예상 등수를 적어서 제출하도록 하였다.
KOI 담당조교로 참가한 김진영 조교는 실수로 모든 학생의 프로그램을 날려 버렸다. 1등부터 N등까지 동석차 없이 등수를 매겨야 하는 김 조교는, 어쩔 수 없이 각 사람이 제출한 예상 등수를 바탕으로 임의로 등수를 매기기로 했다.
자신의 등수를 A등으로 예상하였는데 실제 등수가 B등이 될 경우, 이 사람의 불만도는 A와 B의 차이 (|A - B|)로 수치화할 수 있다. 당신은 N명의 사람들의 불만도의 총 합을 최소로 하면서, 학생들의 등수를 매기려고 한다.
각 사람의 예상 등수가 주어졌을 때, 김 조교를 도와 이러한 불만도의 합을 최소로 하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 자연수 N이 주어진다. (1 ≤ N ≤ 500,000) 둘째 줄부터 N개의 줄에 걸쳐 각 사람의 예상 등수가 순서대로 주어진다. 예상 등수는 500,000 이하의 자연수이다.
<출력값>
첫째 줄에 불만도의 합을 최소로 할 때, 그 불만도를 출력한다.

<문제 2013>
정문이는 2차원 평면에 N개의 선을 그리려 한다. 그런데 선이 너무 많아 하나하나 다 그리려면 매우 힘들다는 것을 깨달았다. 그래서 서로 이어진 선 같은 경우에는 하나의 선으로 생각하여서 그리려 한다.
예를 들어 (1,1) 에서 (3,3)로 가는 선이 있고 (2,2)에서 (4,4)으로 가는 선이 있다면 이는 이어서 그릴 수 있으므로 하나의 선으로 생각할 수 있을 것이다. N개의 선의 정보가 주어져 있을 때, 몇 개의 선으로 그릴 수 있는지 판단하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 선분의 개수 N(1<=N<=10000) 이 주어지고 그리고 둘째 줄부터 N+1번째 줄까지 네 개의 소수가(x1, y1, x2, y2) 주어진다(최대 소숫점 둘째 자리까지). 이 말은 (x1,y1) 에서 (x2,y2)까지 선이 이어진다는 것이다. (좌표는 0 이상 1000 이하이고 선의 길이는 0보다 크다.)
<출력값>
선의 개수를 출력하시오.

<문제 2014>
K개의 소수가 있다. 이때, 이 소수들 중에서 몇 개를 곱해서 얻게 되는 수들이 있을 것이다. 소수들을 선택할 때에는 같은 수를 선택해도 되며, 주어지는 소수 자체도 포함시키자.
예를 들어 세 소수가 2, 5, 7이었다면, 이러한 곱들을 오름차순으로 나타내 보면, 2, 4, 5, 7, 8, 10, 14, 16, 20, 25, 28, 32, 35, 등이 된다.
K개의 소수가 주어졌을 때, 이러한 소수의 곱들 중에서 N번째 수를 구해 보자. 단 정답은 231보다 작은 자연수이다.
<입력값>
첫째 줄에 K(1 ≤ K ≤ 100), N(1 ≤ N ≤ 100,000)이 주어진다. 다음 줄에는 K개의 소수가 오름차순으로 주어진다. 같은 소수가 여러 번 주어지는 경우는 없으며, 주어지는 소수는 모두 541보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 문제에서 설명한 대로 소수의 곱을 나열했을 때, N번째 오는 것을 출력한다.

<문제 2015>
A[1], A[2], ..., A[N]의 N개의 정수가 저장되어 있는 배열이 있다. 이 배열 A의 부분합이란 1 ≤ i ≤ j ≤ N인 정수 i와 j에 대해 A[i]부터 A[j]까지의 합을 말한다.
N과 A[1], A[2], ..., A[N]이 주어졌을 때, 이러한 N×(N+1)/2개의 부분합 중 합이 K인 것이 몇 개나 있는지를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 정수 N과 K가 주어진다. (1 ≤ N ≤ 200,000, |K| ≤ 2,000,000,000) N과 K 사이에는 빈칸이 하나 있다. 둘째 줄에는 배열 A를 이루는 N개의 정수가 빈 칸을 사이에 두고 A[1], A[2], ..., A[N]의 순서로 주어진다. 주어지는 정수의 절댓값은 10,000을 넘지 않는다.
<출력값>
첫째 줄에 합이 K인 부분합의 개수를 출력한다.

<문제 2016>
태현이는 네 명의 친구와 5대 5 미팅에 참여하게 되었다. 미팅 자리에서 각 사람의 소개가 끝나고, 각자의 짝을 정할 시간이 되었는데, 태현이가 다음과 같은 방법을 제안하였고, 모두 이에 찬성하였다.

태현이가 1번, 나머지남학생이 2~5번, 여학생이 6~10번이라고 하자.
우선 각자 상대방 5명에 대한 선호도 순위를 매겨서 쓴다. 이때 2명 이상의 상대에게 같은 선호도를 적용해도 안 되며, 5명의 모든 상대에 대해서 순위를 매겨야 한다. 태현이의 선호도는 6 7 8 9 10 이다. 즉 6번 여학생을 가장 좋아하고, 차례로 7~10번 여학생을 좋아한다.
6번 여학생부터 선호도 리스트를 보면서 가장 좋아하는 남학생에게 프러포즈를 한다. 이때 그 남학생이 자신에게 퇴짜를 놓은 적이 있다면 그 다음 순위의 남학생에게 프러포즈를 한다.
남학생은 프러포즈를 받을지 퇴짜를 놓을지를 결정하는데, 현재 자신에게 짝이 없으면 무조건 프러포즈를 받아들여서 그 여학생과 잠정적으로 짝이 된다. 하지만 현재 짝이 있으면 두 명에 대한 자신의 선호도를 비교해서 더 좋아하는 여학생과 잠정적으로 짝이 되고 다른 여학생에게는 퇴짜를 놓게 된다.
이렇게 해서 10번까지 짝짓기를 하는 것을 한 라운드라고 하면, 퇴짜를 받은 여학생들만 다음 라운드에 다시 짝짓기에 참여한다.
모든 학생들이 잠정적으로 짝을 찾을 때까지 이 과정을 반복하며 마지막에 서로의 짝이 최종 짝이 된다.

각자 자기가 선호하는 리스트를 적어서 주선자인 태현이에게 주었다. 태현이는 종이와 연필을 갖고 옆 테이블로 자리를 옮겨서 위의 알고리즘을 적용하였다. 문득 태현이는 자신의 선호도를 바꾸면 좀 더 좋아하는 여학생과 짝이 될 수 있지 않을까 하는 고민에 빠졌다. 즉, 태현이의 선호도는 6 7 8 9 10이지만, 이를 적지 않고 다른 선호도를 적으면 더 좋아하는 여학생과 짝이 될 수 있지 않을까 하는 고민에 빠졌다.
각 학생이 적어 낸 선호도 리스트가 주어졌을 때, 태현이가 자신의 선호도를 적당히 바꿔 적어서 원래 선호도 리스트로 맺어지는 여학생보다 더 좋아하는 여학생과 맺어질 수 있는지를 알아내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 테스트 데이터의 개수 T(1≤T≤10)가 주어진다. 각각의 테스트 데이터는 9줄로 이루어진다. 앞의 네 줄은 차례로 2~5번 학생의 선호도 목록이고, 뒤의 다섯 줄은 차례로 6~10번 여학생의 선호도 목록이다. 태현이는 6 7 8 9 10이며, 이는 입력으로는 주어지지 않는다.
<출력값>
T개의 줄에 차례로 각 데이터의 답을 출력한다. 가능할 경우에는 YES를, 불가능할 경우에는 NO를 출력한다.

<문제 2017>
농부 장길산은 자신의 밭을 감싸는 울타리를 관리하고 있다. 밭은 가로 세로 N미터인 정사각형 평지이다. (2<=N<=500000) 밭 경계의 한쪽 끝 좌표는 (0, 0)이며, 맞은편 끝 좌표는 (N, N)이다. 또한 경계는 x, y 축에 평행하다.
울타리를 나타내는 말뚝은 일단 밭의 네 모서리에 박혀 있고, 그 사이 네 변 구간에도 1미터 간격으로 박혀 있다. 따라서 말뚝은 총 4N개가 있다. 이 문제에서 말뚝은 땅 위로 솟아 있는 홀쭉한 선분이며 반지름, 즉 굵기가 없다고 가정한다. 길산은 밭 안 어느 위치에 서서 사방을 돌아볼 때, 거기서 밭의 끝 경계에 있는 말뚝을 몇 개까지 볼 수 있나 알고 싶어 한다.
그의 밭 안에는 R (1<=R<=30000)개의 커다란 바위가 있어서 그의 시야를 일부 가린다. 바위는 밑면과 윗면이 같은 볼록다각형으로 구성된 기둥이며, 높이가 충분히 높기 때문에 길산은 바위 너머로 있는 말뚝을 볼 수 없다. 바위들은 영역이 서로 겹치지 않으며, 꼭짓점이나 선분이 접하지도 않는다. 한 바위가 다른 바위 안이나 위에 있지도 않다.
길산이 가진 밭(울타리)의 크기, 길산이 밭 안에 있는 위치, 그리고 각 바위들에 대한 정보가 들어왔을 때, 그가 그 위치에서 고개만 돌려서 볼 수 있는 울타리 말뚝의 총 개수를 계산하는 프로그램을 작성하시오. 바위를 구성하는 임의의 한 정점과 농부와 일직선을 이루는 말뚝은 농부에게 보이지 않는다.
<입력값>
첫 줄에는 N과 R의 값이 순서대로 들어있다. 다음 줄에는 장길산의 x, y 위치가 순서대로 들어있다. 그리고 다음 줄에는 R개의 바위에 대한 정보가 순서대로 들어온다.
  바위에 대한 정보는 다각형을 기술하는 것과 같으므로, 가장 먼저 이 바위의 꼭짓점 개수를 나타내는 p가 있다. (3<=p<=20) 그리고 다음 p 줄에는 다각형을 구성하는 x y 좌표가 순서대로 들어온다. 꼭짓점의 좌표들은 모두 서로 값이 다르며 반시계 방향이다.
  아래 예제의 (70, 40), (75, 40), (80, 40)처럼, 정점 좌표가 일직선 상에 있는 경우도 있을 수 있다.
<출력값>
길산이 그 위치에서 볼수 있는 말뚝의 개수를 한 줄에다 출력하면 된다. 아래의 예제를 살펴보면, 농부는 (60, 50) 위치에 있는데 (70, 40) 위치의 바위 꼭짓점 때문에 (100, 10)부터. 또 (70, 60) 위치의 바위 꼭짓점 때문에 (100, 90)까지, 경계에 있는 81개의 말뚝이보이지 않게 된다. 따라서 정답은 400에서 81을 뺀 319이다.

<문제 2018>
어떠한 자연수 N은, 몇 개의 연속된 자연수의 합으로 나타낼 수 있다. 당신은 어떤 자연수 N(1 ≤ N ≤ 10,000,000)에 대해서, 이 N을 몇 개의 연속된 자연수의 합으로 나타내는 가지수를 알고 싶어한다. 이때, 사용하는 자연수는 N이하여야 한다.
예를 들어, 15를 나타내는 방법은 15, 7+8, 4+5+6, 1+2+3+4+5의 4가지가 있다. 반면에 10을 나타내는 방법은 10, 1+2+3+4의 2가지가 있다.
N을 입력받아 가지수를 출력하는 프로그램을 작성하시오.
<입력값>
첫 줄에 정수 N이 주어진다.
<출력값>
입력된 자연수 N을 몇 개의 연속된 자연수의 합으로 나타내는 가지수를 출력하시오

<문제 2019>
정수 좌표로 이루어진 선분들의 정보를 입력받아 이 선분들의 좌표를 실제로 도화지에 그린다면, 이 그림은 모두 몇 개의 다각형으로 이루어져 있는지를 알려주는 프로그램을 작성하시오. 
  여기서 말하는 다각형이란 각 변이 세 개 이상의 직선으로 이루어진 단일폐도형을 말하며, 두 다각형이 겹치게 되면서 생기는 부분에 대한 도형은 다각형으로 인정하지 않는다. 즉, 입력된 좌표로 구성된 선분들만을 이용해서 만들어진 다각형만을 인정한다. 만약 다각형에 그 다각형을 이루지 않는 선분이 연결되어 있으면 다각형이 아니라고 판단한다.

예를 들어 입력으로 들어온 선분을 종이 위에 그려봤을 때, 위 그림과 같이 그려졌다면 2가지 다각형이 존재하는 것이고, 답으로 2를 출력하면 된다.
<입력값>
첫째 줄에는 선분의 개수 N(1≤N≤60)이 들어온다. 다음에는 각 선분의 좌표가 N줄에 걸쳐서 입력으로 들어온다. 선분의 좌표는 "(한 쪽 끝점의 가로 좌표, 세로 좌표, 다른 쪽 끝점의 가로 좌표, 세로 좌표)"의 순서로 들어오며, 한 줄에 하나의 선분에 관한 정보가 들어온다. 좌표의 범위는 모두 1부터 10000까지의 정수이다.
<출력값>
첫째 줄에 다각형의 개수를 출력하시오.

<문제 2020>
길이 n(1≤n≤1,000)인 염기서열이 있다. 이는 A, G, C, T로 구성되어 있는 문자열이라 생각할 수 있다. 주어진 염기서열의 부분 염기서열은, 염기서열을 문자열로 생각했을 때 부분문자열과 같이 정의되어 있다. 예를 들면 "AGCT"의 부분 염기서열은 "AG", "GC", "AGC", "AGCT" 등이 있다.
  주의할 점은, 부분 염기서열의 문자들이 원래 염기서열에서 순서대로 나타나야 한다는 것이다. 예를 들면, "AC"는 C가 A다음에 오지 않기 때문에 "AGCT"의 부분 염기서열이 아니다.
  이와 같은 부분 염기서열들 중에서 m(1≤m≤n)번 이상 나타나는 부분 염기서열이 있다. 예를 들어 "AGAG"가 있을 때, "AG"와 "A"는 각각 두 번씩 나타나는 부분 염기서열이다. 이와 같이 m번 이상 나타나는 부분 염기서열들의 개수와, K번째의 부분 염기서열을 알고자 한다. 염기 서열들의 순서는, 길이가 짧은 것이 더 앞에 오며, 같은 길이일 때는 사전 식으로 앞서는 것이 앞에 온다.
<입력값>
첫째 줄에 세 정수 n, m, K가 주어진다. 다음 줄에는 염기서열이 주어진다. K는 가능한 개수를 넘지 않는다.
<출력값>
첫째 줄에 m번 이상 나타나는 부분 염기서열의 개수를 출력한다. 다음 줄에 K번째의 부분 염기서열을 출력한다.

<문제 2021>
어떤 도시의 지하철 노선에 대한 정보가 주어졌을 때, 출발지에서 목적지까지의 최소 환승 경로를 구하는 프로그램을 작성하시오. 실제 경로를 구할 필요는 없고, 환승 회수만을 구하면 된다.
<입력값>
첫째 줄에 역의 개수 N(1≤N≤100,000), 노선의 개수 L(1≤L≤100,000)이 주어진다. 다음 L개의 줄에는 각 노선이 지나는 역이 순서대로 주어지며 각 줄의 마지막에는 -1이 주어진다. 마지막 줄에는 출발지 역의 번호와 목적지 역의 번호가 주어진다. 역 번호는 1부터 N까지의 정수로 표현된다. 각 노선의 길이의 합은 1,000,000을 넘지 않는다.
<출력값>
첫째 줄에 최소 환승 회수를 출력한다. 불가능한 경우에는 -1을 출력한다.

<문제 2022>
아래의 그림과 같이 높은 빌딩 사이를 따라 좁은 길이 나있다. 두 개의 사다리가 있는데 길이가 x인 사다리는 오른쪽 빌딩의 아래를 받침대로 하여 왼쪽 빌딩에 기대져 있고 길이가 y인 사다리는 왼쪽 빌딩의 아래를 받침대로 하여 오른쪽 빌딩에 기대져 있다. 그리고 두 사다리는 땅에서부터 정확하게 c인 지점에서 서로 교차한다. 그렇다면 두 빌딩은 얼마나 떨어져 있는 걸까?
<입력값>
첫째 줄에 차례대로 x, y, c에 해당하는 양의 실수 세 개가 입력된다. 수는 소수점 여섯째 자리까지 주어질 수 있다.
<출력값>
두 빌딩사이에 너비가 되는 수치를 출력한다. 절대/상대 오차는 10-3까지 허용한다.

<문제 2023>
수빈이가 세상에서 가장 좋아하는 것은 소수이고, 취미는 소수를 가지고 노는 것이다. 요즘 수빈이가 가장 관심있어 하는 소수는 7331이다.
7331은 소수인데, 신기하게도 733도 소수이고, 73도 소수이고, 7도 소수이다. 즉, 왼쪽부터 1자리, 2자리, 3자리, 4자리 수 모두 소수이다! 수빈이는 이런 숫자를 신기한 소수라고 이름 붙였다.
수빈이는 N자리의 숫자 중에서 어떤 수들이 신기한 소수인지 궁금해졌다. N이 주어졌을 때, 수빈이를 위해 N자리 신기한 소수를 모두 찾아보자.
<입력값>
첫째 줄에 N(1 ≤ N ≤ 8)이 주어진다.
<출력값>
N자리 수 중에서 신기한 소수를 오름차순으로 정렬해서 한 줄에 하나씩 출력한다.

<문제 2024>
X축 위에 여러 개의 짧은 선들이 흩어져 있다. 이 선들은 [Li, Ri]로 나타내는데 이는 선이 Li에서 시작해 Ri에서 끝남을 의미한다. 우리는 이들 중 적은 수의 선들만을 이용해서 [0, M]을 완전히 덮어 버리고 싶다. 최소 개수의 선들을 이용하여 [0, M]을 덮어버리는 프로그램을 작성하시오.
<입력값>
각 테스트 케이스는 M(1 ≤ M ≤ 50,000) 과 "Li Ri"(|Li|, |Ri| ≤ 50,000, i ≤ 100,000)쌍으로 구성이 된다. 각각은 다른 행으로 분리되어 있다. 입력은 "0 0"으로 끝난다.
<출력값>
[0, M]을 덮는데 필요한 선의 개수를 출력한다. 만약 선을 덮는 방법이 존재하지 않으면 “0”을 출력하면 된다.

<문제 2025>
N×N(6 ≤ N ≤ 666)크기의 체스판의 한 위치에서 Knight가 이동을 하여 체스판의 모든 칸들을 방문하려 한다. 이때, 한 번 방문했던 칸은 방문하지 않으면서 모든 칸을 방문하려 한다.
<입력값>
첫째 줄에 N이 주어진다. 다음 줄에는 시작 위치가 주어진다.
<출력값>
N×N개의 줄에 이동한 위치들을 차례로 출력한다. 답이 없는 경우에는 첫째 줄에 좌표 대신에 -1을 두 개 출력한다.

<문제 2026>
원장선생님께서는 1부터 N까지 번호가 붙은 N(K ≤ N ≤ 900)명의 학생들 중에서 K(1 ≤ K ≤ 62)명의 학생들을 소풍에 보내려고 한다. 그런데 원장선생님께서는 중간에 싸움이 일어나면 안되므로 소풍을 갈 학생들이 모두 서로 친구 사이이기를 원한다. 원장선생님께서는 이러한 일을 이번에 조교로 참가한 고은이에게 친구 관계에 대한 정보를 F(1 ≤ F ≤ 5,600)개를 주시며 K명을 선발하라고 부탁하였다.
고은 조교를 도와 소풍을 가게 될 K명의 학생들을 결정하시오.
<입력값>
첫째 줄에 공백으로 분리된 세 정수 K, N, F가 주어진다. 다음 F개의 줄에는 서로 친구 관계인 두 사람의 번호가 주어진다. 친구 관계는 상호적인 관계이므로 2번 학생이 4번 학생을 좋아하면 4번 학생도 2번 학생을 좋아한다. 같은 친구 관계가 여러 번 주어지는 경우는 없다.
<출력값>
만약 K명의 친구 관계인 학생들이 존재하지 않는다면 -1을 출력한다. 그 외의 경우에는, K개의 줄에 학생들의 번호를 증가하는 순서로 한 줄에 한 개씩 출력한다. 여러 경우가 존재한다면 첫 번째 학생의 번호가 제일 작은 것을 출력한다. 첫 번째 학생의 번호가 같은 경우라면, 두 번째 학생의 번호가 작은 경우를 출력하고, 이와 같은 식으로 출력한다.

<문제 2027>
n*m 크기의 도화지에 그림이 그려져 있다. 그 중 L자 모양인 그림이 있을 것이다. L자 모양은 왼쪽 아래 점을 공유하는 두 직사각형이 합쳐진 모양이다. 아래 조각의 너비는 위의 조각의 너비보다 넓어야 하며, 위의 조각은 아래 조각보다 상하로 길어야 한다. L자를 회전하거나 대칭시키는 ‘ㄱ’자 등은 생각하지 않기로 하며, 단순한 직사각형은 L자 모양이 아니다. 예를 들어서  L자 모양을 몇 개 그려보면 아래와 같다.

L 모양을 가진 그림 중 가장 넓이가 큰 것을 찾아 그 넓이를 출력하는 프로그램을 작성하여라.
<입력값>
첫째 줄에 n, m이 주어진다. 다음 n개의 줄에는 m개의 정수(0 또는 1)가 붙어서 입력으로 주어진다. n,m 제한은 150
<출력값>
첫째 줄에 L자 모양 조각의 최대 넓이를 출력한다.

<문제 2028>
어떤 자연수 N을 제곱했을 때, 그 제곱수의 맨 뒷자리에 원래의 수 N이 다시 나타나면, 우리는 그 수 N을 자기복제수라고 한다.
예를 들면, 5의 제곱은 52는 25이고 25의 맨 뒷자리에 원래의 수 5가 나타나므로 5는 자기복제수이다. 또 다른 예로, 76의 제곱은 5776이고 5776의 맨 뒷자리에 76이 나타나므로 76 또한 자기복제수이다.
자연수 N이 주어졌을 때, 그 수가 자기복제수인지 아닌지를 알아내는 프로그램을 작성하시오.
<입력값>
입력의 첫 줄에는 테스트 케이스의 개수 T (1 ≤ T ≤ 20)가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있으며, 자연수 N (1 ≤ N ≤ 1000)이 주어진다.
<출력값>
각 테스트 케이스에 대해, 주어진 자연수가 자기복제수이면 YES를 아니면 NO를 출력한다.

<문제 2029>
24개의 성냥이 아래 그림과 같이 3x3 크기의 격자에 배치되어 있다. 두 개의 연속된 '-'는 가로로 놓은 성냥을 나타내고, 두 개의 연속된 '|'는 세로로 놓은 성냥을 나타낸다.

+--+--+--+
|..|..|..|
|..|..|..|
+--+--+--+
|..|..|..|
|..|..|..|
+--+--+--+
|..|..|..|
|..|..|..|
+--+--+--+
위 그림에서 검정색으로 표시된 부분이 바로 24개의 성냥을 나타낸다. '+'는 두 개 이상의 성냥이 만날 수 있는 부분들을 나타낸 것으로, 위의 그림과 같이 총 16개가 위치하고 있다. 그 외의 칸은 배경으로, 모두 '.'으로 나타낸다.
위의 그림과 같이 24개의 성냥을 모두 배치하면, 찾을 수 있는 정사각형이 총 14개라는 것을 알 수 있다. (9개+4개+1개) 하지만 몇 개의 성냥을 제거하면, 찾을 수 있는 정사각형의 개수가 줄어들기도 한다. 예를 들어 아래와 같은 경우는 24개 중 5개의 성냥을 제거하여 14개 중 4개의 정사각형만을 남겨 둔 경우이다.

+--+--+--+
|..|..|..|
|..|..|..|
+--+--+..+
|.....|..|
|.....|..|
+--+--+..+
|........|
|........|
+--+--+--+
이처럼 성냥의 배치를 알면, 이 배치가 24개 중 A개의 성냥을 제거하여 14개 중 B개의 정사각형만을 남겨 둔 배치라는 것을 구할 수 있다. (1≤A≤24, 1≤B≤14인 정수) 성냥의 배치가 주어졌을 때, A와 B를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄부터 열 개의 줄에 걸쳐 성냥의 배치가 위의 예제와 같은 형식으로 들어온다. 각 줄에는 10개의 문자가 있다. 입력은 '-', '|', '+', '.'만으로 이루어져 있으며, 항상 위에 주어진 형식에 맞는 배치만이 입력으로 주어진다.
<출력값>
첫째 줄에 A와 B를 빈 칸을 사이에 두고 출력한다.

<문제 2030>
After the programming contest team MSX decides to grab a bite at the Burger King. It turns out it's a rather busy evening there: each counter has a queue of people waiting to order their meals and more people keep pouring in. Since they're rather hungry from a long day of programming, team MSX wants to order food as soon as possible.
Team member Menno suggests that, in order to get their food as fast as possible, they should join the shortest queue. Team member Sarah disagrees: she notices that some employees are considerably slower than their colleagues, hence the team should join the queue of the fastest employee. Team member Xenon, however, notices that every now and then, some employees switch with their colleagues. If a customer was being helped during the change, this takes time, since the new employee has to start all over again in helping the customer. If the customer's order would have been finished at the moment of the change, though, the customer's order is finished first and the new employee immediately continues serving the next customer without delay. Besides that, the service speed is also dependent on the type of customer: a family takes considerably more time to help than a middle-aged man.
Team MSX decides it's best to work dynamically. All team members have a strong predictive ability, which allows them to know how much time an employee will need to help a certain customer. As they enter the Burger King, they calculate for each queue hoe long it will take until all customers in that queue have been helped. They then join the queue that will be the first one to be empty. When the situation changes, for example when the employee at a counter changes, they reevaluate which queue they should join to be able to order as soon as possible. If it turns out it's more effective to join another queue, they will not hesitate. If team MSX has to choose from multiple queues that would be equally effective, they choose the queue with the lowest identification number, unless they're in one of those queues themselves, in which case they will not switch queues. Of course, when the team switches queues, they join the end of the new queue. The switching itself takes no time at all.
Given a set of employees, queues of customers and a schedule of events, figure out how many minutes it takes before the team can order their well-earned diner if they choose their queues optimally.
<입력값>
The first line of input consists of the integer number n (0 < n ≤ 10000), the number of test cases;
Then, for each test case:
	
A line with one positive integer m (1 ≤ m ≤ 10): the number of queues;
For each queue two lines:
		
A line with three positive integer numbers i (0 ≤ i < m): the (identification-) number of the queue, ic (0 < ic ≤ 30): the number of customers in the queue at the moment that team MSX enters the Burger King, and ec (0 ≤ ec ≤ 10): the minimum amount of minutes that the employee for queue i takes to help a customer. The numbers are separated by a space;
A line with ic positive integer numbers, separated by spaces, where each number represents a customer in queue i and the value (0 ≤ value ≤ 15) represents the amount of extra minutes it takes for an employee to help this customer. The first customer in the list is the one that is standing in front of the employee (and will immediately be helped by the employee) while the last one is at the end of the queue.


A line with one positive integer v (0 ≤ v ≤ 100): the number of events taking place;
Then for each event a line containing one of the following:
		
For the event of a new customer joining a queue: The string "join" and three positive integer numbers tv (0 < tv ≤ 300), the moment (beginning of the minute) at which the event occurs, iv (0 ≤ iv < m), the queue at which a new customer joins and cv (0 ≤ cv ≤ 15), the amount of extra minutes it takes for an employee to help this customer. The string and numbers are separated by spaces. A new customer always takes place last in line;
For the event of an employee being replaced by another: the string "change" and three positive integer numbers tv (1 ≤ tv ≤ 300), the moment (beginning of the minute) at which the event occurs, iv (0 ≤ iv < m), the queue at which the employee will be replaced by a new one and ev (0 ≤ ev ≤ 10), the minimum amount of minutes that the new employee for queue iv takes to help a customer.
The string and numbers are separated by spaces.





No more than one event takes place in the same minute. In addition, there will never be more than 30 customers in a queue (excluding team MSX) at any time.
<출력값>
For each test case the output contains one line with a single integer: the number of minutes team MSX needs to wait before they can order their food.

<문제 2031>
최근 심모 양(17)은 친구 사모 양(17)이 알바를 하는 허브차 카페에서 독특한 경험을 했습니다. 바로 다이어트 효과가 있는 김네마 실베스터라는 허브를 알게 된 건데요, 신기하게도 김네마 실베스터 차를 마시면 일시적으로 단맛을 느끼지 못하게 된다고 합니다. '김네마 다이어트'를 시작하기로 마음먹은 심모 양은 자신의 식습관을 고려해서 미래 T 분 동안 먹을 N 종류의 음식에 대해 각각의 음식을 먹을 시각을 분 단위로 표시한 길이 N의 목록을 만들었습니다. 김네마 실베스터 차 한 잔을 마시면 D 분 동안 다이어트 효과가 유지되는데, 심모 양은 총 K 잔의 김네마 실베스터 차를 적당한 타이밍에 마셔서 다이어트 효과가 유지되는 동안 음식을 먹는 횟수를 최대로 하기로 했습니다.
예를 들어 D = 5, K = 2이고 심모 양의 목록이 다음과 같다고 합시다.
9, 15, 7, 12, 14, 9, 3
이때 심모 양이 두 잔의 차를 3분, 9분에 마시면 첫 번째 잔은 3분에 먹는 음식부터 7분까지 먹는 음식까지에 (8분에 먹는 음식에는 효과가 있지 않습니다), 두 번째 잔은 9분에 먹는 음식부터 13분에 먹는 음식까지에 효과가 있습니다. 따라서 효과가 적용되는 횟수는 총 5번입니다.
9, 15, 7, 12, 14, 9, 3
한 편 두 잔의 차를 7분, 12분에 마시면 다음과 같이 효과가 적용되는 횟수가 6번이 되고, 이때가 최대입니다.
9, 15, 7, 12, 14, 9, 3
<입력값>
첫 번째 줄에 4개의 자연수 T, N, D, K가 주어집니다. (1 ≤ T ≤ 109, 1 ≤ N ≤ 106, 1 ≤ D ≤ 109, 1 ≤ K ≤ 10)
두 번째 줄에 N 종류의 음식 각각을 먹을 시각을 나타내는 N 개의 자연수 a1, ..., aN이 주어집니다. (1 ≤ ai ≤ T)
<출력값>
첫 번째 줄에 심모 양이 적당한 타이밍에 김네마 실베스터 차를 마셨을 때 효과가 적용되는 횟수의 최댓값을 출력합니다.

<문제 2032>
전쟁의 승리를 기념하여 전쟁터에 피라미드를 세우려고 한다. 피라미드는 가로로 a칸, 세로로 b줄인 직사각형 형태로 면적을 차지하며, 또한 피라미드 안에는 가로로 c칸, 세로로 d줄인 작은 방을 하나 만들어 전사자들의 시신과 유품 무기를 안치할 예정이다.
왕의 건축가들은 전쟁터의 지형을 가로로 m칸, 세로로 n줄인 직사각형 격자로 나누고, 각 정사각형 칸의 고도를 정수로 측량해 냈다. 피라미드와 내부 방은 모두 이 격자의 칸에 정확히 맞춰진 형태로 지을 것이다. 내부 방이 차지하는 칸은 고도를 바꿀 수 없지만, 그 외에 피라미드의 터가 차지하는 칸들은 본격적인 건축 작업을 위해 고도를 평준화하게 된다. 즉, 높은 곳의 모래를 낮은 곳에다 부어서 모든 칸들의 고도를 고도의 전체 평균값으로 바꾼다. (물론 방이 차지하는 칸의 고도는 제외한 평균) 방은 크기만 정해져 있기 때문에, 사방으로 피라미드와 외부 사이에 한 칸 이상의 간격만 확보된다면, 피라미드 내부의 어느 위치에다 만들어도 괜찮다. 즉, 꼭 중심부가 아니어도 된다는 것이다.
건축가들은 피라미드를 전쟁터의 어디에다 짓고 내부 방은 그 안의 어디에다 만들면, 피라미드 터의 최종 평균 고도가 가장 높아질 수 있는지를 고심하고 있다. 전쟁터, 피라미드, 내부 방의 크기와 전쟁터의 각 칸의 고도가 주어지면, 터의 평균 고도를 최대화할 수 있는 피라미드와 방 위치를 계산하는 프로그램을 작성하시오.

위의 그림은 m=8, n=5인 전쟁터의 한 예이다. 각 칸의 숫자들은 전쟁터의 위치별 고도이다. 그리고 회색 영역은 피라미드가 지어질 터이며, 그 안의 흰색 영역은 내부 방이 들어가는 공간으로, a=5, b=3, c=2, d=1인 경우이다. 전쟁터의 크기와 고도 정보가 그림과 같고, 만들고자 하는 피라미드와 방의 크기와 그림과 같을 때, 그림과 같이 위치를 선정하는 것이 평균 고도가 약 5.4로 최대가 되는 경우이다.
<입력값>
첫째 줄에 m(3 ≤ m ≤ 1,000)과 n(3 ≤ n ≤ 1,000), 그리고 a(3 ≤ a ≤ m)와 b(3 ≤ b ≤ n), 마지막으로 c(1 ≤ c ≤ a-2)와 d(1 ≤ d ≤ b-2)가 빈 칸을 사이에 두고 순서대로 주어진다. 이어서 둘째 줄부터는 n개의 줄에 걸쳐 각 칸의 고도를 나타내는 m개의 자연수가 빈 칸을 사이에 두고 주어진다. 고도의 크기는 100을 넘지 않는다.
<출력값>
첫째 줄에는 피라미드를 지을 터의 좌측 상단 위치를, 둘째 줄에는 피라미드 내부의 방의 좌측 상단 위치를 출력한다. 위치는 가로, 세로를 나타내는 두 좌표를 빈 칸을 사이에 두고 순서대로 출력하면 된다. 최적해가 여러 개 존재하더라도 그 중 하나만 출력하면 된다.

<문제 2033>
정수 N이 주어져 있을 때 이 수가 10보다 크면 일의 자리에서 반올림을 하고, 이 결과가 100보다 크면 다시 10의 자리에서 반올림을 하고, 또 이 수가 1000보다 크면 100의 자리에서 반올림을 하고.. (이하 생략) 이러한 연산을 한 결과를 출력하시오.
<입력값>
첫째 줄에 정수 N이 주어진다. (0 ≤ N ≤ 99,999,999)
<출력값>
첫째 줄에 위와 같은 연산을 한 결과를 출력하시오.

<문제 2034>
서양 음악의 음계는 도레미파솔라시의 칠음계이다. 각각의 음은 차례로 영어 알파벳 CDEFGAB에 대응된다(도다레라미마파바솔사라가시나도다를 생각하면 됨). 이 문제에서는 이러한 일곱 음만을 다루기로 한다.

하지만 모든 음이 이 일곱으로만 구성된 것은 아니다. 피아노에는 위의 그림과 같이 검은 건반이 있으며, 검은 건반은 인접한 흰 건반과 반음의 차이가 난다. 즉, C와 D사이에 있는 검은 건반은 C, D와 반음 차이가 난다. 검은 건반이 사이에 없는 경우에는, 붙어 있는 두 흰 건반이 반음 차이가 난다. 예를 들어 B, C는 반음 차이가 나며, E, F는 반음 차이가 난다.
이러한 반음 차이를 이용하여, 두 음 사이의 거리를 정의할 수 있다. F로부터 -1만큼 떨어진(왼쪽으로 반음) 음은 E이고, F로부터 4만큼 떨어진(오른쪽으로 반음 네 번) 음은 A이다. 이 문제에서는 칠음(흰 건반)만을 따지므로, F로부터 1만큼 떨어진 음은 없다.
이러한 거리들을 모으면 하나의 악보가 된다. 예를 들어 2 2 1 2 2 2 1과 같은 악보는, 차례로 CDEFGABC를 누르는 악보이다. 즉, 이 악보는 첫 음이 C이고 끝 음이 C인 악보가 된다. 하지만 이 악보는 첫 음이 D일 수는 없는데, 그 경우 DE 다음에 검은 건반이 눌리게 되기 때문이다. 악보가 주어졌을 때, 가능한 첫 음과 끝 음의 쌍을 모두 구해내는 프로그램을 작성하시오. 피아노는 좌우로 무한히 길다고 가정한다.
<입력값>
첫째 줄에 악보의 길이를 나타내는 정수 n(1≤n≤10,000)이 주어진다. 다음 n개의 줄에는 절댓값이 20을 넘지 않는 정수로 악보가 주어진다.
<출력값>
첫째 줄부터 차례로 첫 음과 끝 음을 출력한다. 여러 경우가 가능할 때에는 알파벳이 작은 경우부터 출력한다.

<문제 2035>
숫자로 이루어진 문자열이 있다. 이 숫자를 적절히 나누어서 증가수열을 만들고자 한다. 예를 들어 3546을 나눈다면 3,5,46 또는 35,46으로 나눌 수 있다. 이 증가수열 중 마지막 숫자를 가장 작게 하려 할 때, 어떻게 나누어야 하는지 구하는 프로그램을 작성하시오. (단, 앞자리에 0이 오는 것을 허용한다.)
<입력값>
첫째 줄에 문자열이 주어진다. (단, 이 문자열의 자릿수는 80자리를 넘지 않는다)
<출력값>
수열의 마지막 숫자를 출력하시오. (앞자리에 0이 있는 경우에는 0을 생략하고 출력한다.)

<문제 2036>
n개의 정수로 이루어진 수열이 있다. 이 수열에서 한 정수를 제거하거나, 또는 두 정수를 제거할 수 있다. 한 정수를 제거하는 경우에는 그 정수가 점수가 되고, 두 정수를 제거하는 경우에는 두 정수의 곱이 점수가 된다. 이를 반복하여 수열에 아무 수도 남지 않게 되었을 때, 점수의 총 합의 최대를 구하는 프로그램을 작성하시오.
예를 들어 -1, 5, -3, 5, 1과 같은 수열이 있다고 하자. 먼저 1을 제거하고, 다음으로는 5와 5를 제거하고, 다음에는 -1과 -3을 제거했다고 하자. 이 경우 각각 점수가 1, 25, 3이 되어 총 합이 29가 된다.
<입력값>
첫째 줄에 정수 n(1 ≤ n ≤ 100,000)이 주어진다. 다음 n개의 줄에는 절댓값이 1,000,000을 넘지 않는 정수가 n개 주어진다.
<출력값>
첫째 줄에 최대 점수를 출력한다.

<문제 2037>
오른쪽 그림과 같은 핸드폰 자판이 있다. 이 자판을 이용하여 어떤 영어 메시지를 치려고 할 때, 걸리는 최소 시간을 구하는 프로그램을 작성하시오.
단, 1번은 누를 경우에는 공백이 찍힌다고 하자. 그리고 만약에 AC라는 문자를 치려 한다면 A를 치고 난 후 일정 시간을 기다린 후 C를 치면 된다.
하나의 문자를 입력하려면, 버튼을 눌러야 한다. 버튼을 누르면 버튼에 쓰여 있는 문자가 입력되며, 버튼을 누를 때 마다 다음 문자로 바뀌게 된다. 예를 들어, 2를 누르면 A, 2번 누르면 B, 3번 누르면 C이다. 공백을 연속으로 누를 때는 기다릴 필요가 없다.
<입력값>
첫째 줄에 p와 w가 주어진다. (1 ≤ p, w ≤ 1,000) p는 버튼을 한번 누르는데 걸리는 시간이고, w는 AC와 같은, 같은 숫자인 문자를 연속으로 찍기 위해 기다리는 시간을 의미한다. 그리고 둘째 줄에는 적을 문자열이 주어진다. 단, 이 문자열의 길이는 1000보다 작고, 맨 앞과 맨 뒤에 공백이 들어오는 경우는 없다고 가정하여도 좋다. 문자열은 알파벳 대문자와 띄어쓰기만으로 이루어져 있다.
<출력값>
첫째 줄에 메시지를 적는데 걸리는 시간을 출력한다.

<문제 2038>
Golomb 수열이란 모든 k에 대해 k가 수열상에서 f(k)번 등장하는 단조증가 수열이다. 단조증가 수열이란 k값이 증가함에 따라 f(k)값이 감소하지 않는 수열을 말한다. 여기서 k와 f(k)는 모두 자연수이다.
골롱 수열은 유일하게 결정될 수밖에 없다. 잘 생각해 보시길 ..
n이 주어졌을 때 f(n)을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 n(1≤n≤2,000,000,000)이 주어진다.
<출력값>
첫째 줄에 f(n)을 출력한다.

<문제 2039>
0과 1로 차 있는 n×m 크기의 격자가 있다. 뱀은 1들의 연속이라고 볼 수 있다. 구체적으로 정의하자면 뱀은 이 격자 안에서 다음과 같은 조건을 만족하는 것이다.

1이 들어 있는 칸을 뱀 격자라고 한다.
뱀의 시작점과 끝점을 제외하고는 뱀 안에 있는 뱀 격자는 동서남북 방향으로 두 개의 뱀 격자와 만난다. 뱀의 양 끝점은 한 개의 뱀 격자와 만난다고 가정하여도 좋다.

그리고 maximal snake란, 위의 조건을 만족하는 뱀들 중, 뱀의 양 끝 중 한 군데에 1을 추가시킨다면 더 이상 위의 조건을 만족시키지 않는 뱀을 의미한다. 예를 들면 아래 그림에서 가장 왼쪽에 있는 곳에서는 하나의 maximal snake가 있고, 두 번째에는 maximal snake가 없으며 세 번째에는 세 개의 maximal snake가 있다.

n×m 격자가 주어져 있을 때, 몇 개의 maximal snake가 있는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 n, m(1 ≤ n,m ≤ 200) 이 주어진다. 그리고 n+1줄에 걸쳐 격자의 정보가 주어진다.
<출력값>
첫째 줄에 maximal snake의 수를 출력하시오.

<문제 2040>
순서대로 나열된 n개의 수를 두고, A와 B 두 사람이 번갈아가며 진행하는 게임이 있다. 편의상 나열된 수를 순서대로 a_1, a_2, ..., a_n이라고 하자.
게임은 A부터 시작하는데, A는 a_n을 포함하여 연속된, 하나 이상의 수를 선택해 가야 한다. a_n 하나만 선택할 수도 있고, a_1부터 a_n까지 모두를 선택할 수도 있다. a_(n-2)와 a_n와 같이 수를 가져갈 수는 없다. 왜냐하면 연속되어 있지 않기 때문이다. a_(n-2)를 가져가려면 반드시 a_(n-1)과 a_n도 가져가야 하는 것이다.
A가 규칙에 따라 a_k부터 a_n까지의 수를 선택해 갔다면, B는 A와 마찬가지로 a_(k-1)을 포함한 연속된 하나 이상의 수를 선택해 간다. 이런 식으로 서로 번갈아가며 게임이 진행되고, 수가 하나도 남지 않게 되면 게임은 끝난다. A와 B 중 선택해 간 수의 합이 적은 사람이 승리하게 된다. 합이 같은 경우에는 비기는 것으로 한다.
예를 들어 n=5이고 수가 10 7 2 4 2 라고 하자. A가 2를 가져갔다. B는 2와 4를 가져갔다. A가 7을 가져갔다. B가 10을 가져가고 게임이 끝났다. A가 가져간 수의 합은 9이고 B가 가져간 수의 합은 16이 되어 A가 이기게 된다.
A와 B는 모두 게임에서 이기기 위해 최선을 다한다고 한다. n개의 수가 주어졌을 때 이 수 게임의 승자를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 n이 주어진다. (1<=n<=3,000) 이어서 세 개의 줄에는 처음에 주어지는 n개의 정수가 각각 주어진다. 주어지는 정수의 절댓값은 10,000 이하이다.
<출력값>
첫째 줄부터 셋째 줄까지, 입력의 각 경우에 해당되는 승자(A 또는 B)를 각각 차례대로 출력한다. 비기는 경우에는 D를 출력한다. (Draw)

<문제 2041>
N×M 크기의 격자에 적절히 수를 채우려 한다. 단, 인접한 수들의 차이로 1부터 (2NM-N-M)까지의 수가 한 번씩 나오도록 채우려 한다. N=2, M=2인 경우를 예로 들면 다음과 같은 방법이 있다.

위와 같이 채우면 인접한 수들의 차이로 1, 2, 3, 4가 모두 한 번씩 나오게 된다. N과 M이 주어질 때 위의 조건을 만족하며 수를 채우는 프로그램을 작성하시오.
<입력값>
첫 줄에 정수 N과 M(1 ≤ N, M ≤ 1,000)이 주어진다.
<출력값>
N개의 줄에 걸쳐 답을 출력한다. 답이 여러 가지가 있다면 그중 한 가지만 출력한다. 1 이상 2×109 이하의 정수만 채울 수 있다.

<문제 2042>
어떤 N개의 수가 주어져 있다. 그런데 중간에 수의 변경이 빈번히 일어나고 그 중간에 어떤 부분의 합을 구하려 한다. 만약에 1,2,3,4,5 라는 수가 있고, 3번째 수를 6으로 바꾸고 2번째부터 5번째까지 합을 구하라고 한다면 17을 출력하면 되는 것이다. 그리고 그 상태에서 다섯 번째 수를 2로 바꾸고 3번째부터 5번째까지 합을 구하라고 한다면 12가 될 것이다.
<입력값>
첫째 줄에 수의 개수 N(1 ≤ N ≤ 1,000,000)과 M(1 ≤ M ≤ 10,000), K(1 ≤ K ≤ 10,000) 가 주어진다. M은 수의 변경이 일어나는 횟수이고, K는 구간의 합을 구하는 횟수이다. 그리고 둘째 줄부터 N+1번째 줄까지 N개의 수가 주어진다. 그리고 N+2번째 줄부터 N+M+K+1번째 줄까지 세 개의 정수 a, b, c가 주어지는데, a가 1인 경우 b(1 ≤ b ≤ N)번째 수를 c로 바꾸고 a가 2인 경우에는 b(1 ≤ b ≤ N)번째 수부터 c(b ≤ c ≤ N)번째 수까지의 합을 구하여 출력하면 된다.
입력으로 주어지는 모든 수는 -263보다 크거나 같고, 263-1보다 작거나 같은 정수이다.
<출력값>
첫째 줄부터 K줄에 걸쳐 구한 구간의 합을 출력한다. 단, 정답은 -263보다 크거나 같고, 263-1보다 작거나 같은 정수이다.

<문제 2043>
N×M 배열에 수들이 쓰여 있다. 이 배열의 칸들을 인접(상하좌우)한 두 개의 칸으로 묶으려고 한다. 이때, 묶인 수들의 차이의 총 합이 최대가 되도록 하려 한다. 수들을 묶을 때 하나의 수는 오직 한 번만 묶여야 하며, 묶이지 않은 수도 물론 있을 수도 있다. 또, 수들을 묶을 때 그 차이가 T보다 큰 경우에는 묶을 수 없다.

예를 들어 왼쪽의 2×2 배열(T=9)을 두 가지 방법으로 묶을 수 있는데, 가운데와 같은 묶은 경우에는 묶인 수들의 차이의 총 합이 0(=|1-1| + |10-10|)이 되지만, 오른쪽은 18(=|1-10| + |1-10|)이 된다. 그리고 오른쪽의 방법이 최적해가 된다. 만일 T=8이라면, 오른쪽과 같이 묶을 수 없으므로, 최적해는 0이 된다.
주어진 배열에서 위의 조건을 만족하면서 수들을 묶을 때, 묶인 수들의 차이의 총 합을 최대로 하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N, M(1≤N, M≤30), T(0≤T≤10,000,000)가 주어진다. 다음 N개의 줄에는 M개의 정수로 배열의 모양이 주어진다. 배열을 이루는 각각의 수는 절댓값이 1,000,000을 넘지 않는다.
<출력값>
첫째 줄에 묶인 수들의 차이의 총 합을 출력한다.

<문제 2044>
text-mode windows의 개발자인 동혁이는 "cascade mode (계단형 배치)" 부분을 코딩하다가 고심에 빠졌다. text-mode windows에서 하나의 window는 다음과 같이 ‘+’, ‘-’, ‘|’, ‘.’, 그리고 알파벳 소문자로 이루어져 있다.

+--|abcdef|---+
|.............|
|.............|
|.............|
|.............|
+-------------+

모든 window는 위와 같은 형태를 지키고 있으며, title을 기록할 수 있을 정도로 window는 넓다. (즉, title의 길이보다 모든 window는 적어도 6 이상은 가로로 길다. +-|, |-+가 들어가야 하므로) title은 가로로 정확히 가운데에 표시되어 있으며, 만일 위의 경우와 같이 window의 길이가 홀수인 경우 오른쪽이 왼쪽보다 하나 더 길다.
text-mode windows의 screen-shot이 주어졌다. 어떤 두 개의 window도 서로 겹치지 않게 배치되어 있다고 하자. 이때, 동혁이를 도와 다음과 같이 "cascade mode"로 window를 정리해 주는 프로그램을 작성하시오.

모든 window의 가로, 세로 크기는 변하지 않아야 한다.
모든 window들은 title의 알파벳 순서로 정렬한다.
모든 window들을 왼쪽 위 꼭짓점이 화면 전체의 왼쪽 위 꼭짓점이 되도록 옮긴다. 그리고 나서, 순서대로 한 칸씩 오른쪽 아래로 내려 배치한다.
<입력값>
첫째 줄에 스크린의 세로 길이 M과 가로 길이 N이 주어진다. (10≤M, N≤100) 이어서 M개의 줄에는 각각 N개의 문자열이 주어지는데, 이는 screen-shot을 나타내 주는 정보이다. 배경 그림 같은 것은 없고 모두 ‘.’으로 표시되며, 모든 window의 title의 길이는 1 이상 10 이하이다. M과 N은 "cascade mode"로 window를 모두 정리할 수 있을 만큼 충분히 크다고 가정해도 좋다.
<출력값>
M개의 줄에 걸쳐 "cascade mode"로 window를 모두 정리한 화면을 출력한다.

<문제 2045>
3 by 3 크기의 마방진을 생각하자. 마방진이란 가로, 세로, 대각선 위의 수들의 합이 모두 같은 성질을 가지고 있다. 몇 가지 마방진을 예로 들면 다음과 같다.

생일빵을 맞은 정신을 잃은 동주와 세준이는 실수로 마방진에서 몇 개의 수를 지워 버리고야 말았다. 불쌍한 동주와 세준이를 도와, 마방진을 다시 완성해 보자. 마방진을 이루는 수들은 모두 20,000을 넘지 않는 자연수이다.
<입력값>
첫째 줄부터 셋째 줄까지 마방진을 이루는 아홉 개의 수가 각 줄에 세 개씩 주어진다. 입력되는 수들 사이에는 빈 칸이 있으며, 지워진 수는 0으로 입력된다. 0의 개수는 3개 이하이다.
<출력값>
완성된 마방진을 입력과 같은 형식으로 세 줄에 걸쳐 출력한다.

<문제 2046>
이어달리기 경기가 서울에서 열린다. 경기 규칙은 다음과 같다.

각 팀은 정확히 N 명의 선수로 이루어진다.
D 일 동안 가장 긴 거리를 달린 팀이 우승한다.
날마다 각 팀에서 한 명씩 달린다.
주자 교체는 하루가 시작될 때에만 가능하다.
각 팀에 소속된 선수는 최소 1일, 최대 3일을 달려야 한다.
한 번 교체된 선수는 다시 참가할 수 없다.

'칙칙폭폭' 팀이 이어달리기에 참가하기로 했다. '칙칙폭폭' 팀의 감독은 N 명의 선수가 D일 동안 경기에 나설 순서는 정했지만, 누가 정확히 며칠씩 달릴지는 아직 정하지 못했다. 감독은 각 선수의 기록을 보고서 누가 며칠씩 달릴지를 결정하고자 한다. 각 선수의 기록은 세 숫자로 이루어진다. i(i=1,2,3) 번째 숫자는 각 주자가 i 일 연속해서 달릴 때 갈 수 있는 거리를 나타낸다. (단위는 킬로미터.) 예를 들어 어느 선수의 기록이 (4,7,9)라면, 이 선수는 하루 달리면 4 킬로미터, 이틀 달리면 7 킬로미터, 사흘 달리면 9 킬로미터를 갈 수 있다. 모든 기록 (a,b,c)는 부등식 a ≤ b ≤ c을 만족한다.
감독은 '칙칙폭폭' 팀이 D일 동안 갈 수 있는 최장 거리를 알고 싶다. 예를 들어, N=3, D=4이고 세 선수의 기록이 (4,7,8), (2,4,6), (4,5,6)이라고 하자. 그렇다면 이 팀이 4일 동안 갈 수 있는 최장 거리는 13킬로미터이다. 첫 선수가 이틀 동안 (1,2 일차) 7 킬로미터, 둘째 선수가 하루 동안 (3 일차) 2 킬로미터, 셋째 선수가 하루동안 (4 일차) 4 킬로미터를 가면 된다.
'칙칙폭폭' 팀이 D 일 동안 갈 수 있는 최장거리를 알려주는 프로그램을 작성하라.
<입력값>
입력은 T 개의 테스트 케이스로 구성된다. 입력 첫 줄에 테스트 케이스의 개수 T가 입력된다. 각 테스트 케이스는 N+2줄로 구성된다. 테스트 케이스의 첫 줄에는 '칙칙폭폭' 팀의 선수의 숫자를 나타내는 정수 N (1≤ N ≤ 50)이 주어진다. (단위는 명) 둘째 줄에는 이어달리기 대회가 진행되는 기간을 나타내는 정수 D (1≤ D ≤150)이 주어진다. (단위는 일) 이어서 N 줄 동안 각 선수의 기록이 주어진다. 선수의 기록이 주어지는 순서는 선수가 경기에 출전하는 순서이다.
<출력값>
각 테스트 케이스마다 한 줄씩 출력한다. 각 줄에는 D 일 동안 달릴 수 있는 거리를 나타내는 정수 하나가 출력되어야 한다. 기록에 오류가 있거나, 대회 규칙에 따라 선수를 편성하는 것이 불가능 할 경우에는 -1을 출력한다.

<문제 2047>
유명한 영웅 백준은 퀘스트를 받아 혼자 모험을 하는 중에 미로를 발견하였다. 미로 주변으로 길이 없으므로 백준은 반드시 미로를 통과해야 한다.
백준은 이 미로를 잘 모르기 때문에 길이 나누어지면 그 중 무작위로 길을 택해 그쪽으로 이동할 것이다. 또한 백준은 완벽한 기억력을 가졌기 때문에 같은 길을 두 번 들어서는 일은 없고 더 이상 길이 없을 거라고 확신했을 때만 왔던 길을 돌아갈 것이다. 즉, 왔던 길을 돌아가기 전까지 안 가본 길은 다 둘러볼 것이다.
백준의 동료인 당신은 백준이 떠나고 뒤늦게 미로의 정보를 가지고 있는 지도를 발견하고는 백준이 미로를 탈출하는데 얼마나 걸릴지 궁금해서 걸음의 기댓값을 구하고자 한다. 당신은 미로를 잘 살펴본 결과 미로는 같은 지점으로 돌아오는 사이클이 없고 2×2 이상의 공간이 없다는 것을 알았다. 미로에는 입구와 출구가 각각 하나만 있고 길 옆에 출구가 있더라도 길이 나누어져 있다고 가정한다.
아래의 간단한 지도의 예를 보자.

##s###
#....#
#t####
입구는 "s"로 표시되어 있고 출구는 "t"로 표시되어 있다. 
입구에서 남쪽으로 1칸 이동했을 때 길이 갈라지는데 여기서 서쪽을 선택하고 2칸 이동하면 출구를 찾을 수 있다. 반면 동쪽을 선택했을 시 4칸 이동하여 다시 돌아오고 남은길이 서쪽밖에 없으므로 서쪽으로 2칸 이동하면 출구를 찾을 수 있다.
따라서 백준이 입구에서 출구까지 나가는데 걸음의 기댓값은 \( 1 + \frac{1}{2} \cdot (4 + 2) + \frac{1}{2} \cdot 2 = 5 \) 이다.
<입력값>
첫째 줄에는 테스트 케이스의 개수 n (0 < n ≤ 100) 이 주어진다.
각 테스트 케이스에 대해서
	
첫째 줄에는 미로의 크기를 나타내는 두 정수 3 ≤ h, w ≤ 96 가 주어진다. 
다음 줄부터 h번에 걸쳐 문자가 w개 주어진다.
		
#은 벽이다.
s와 t는 각각 입구와 출구다.
.은 길이다.


미로의 경계는 입구와 출구를 제외하고 전부 벽이다.
입구와 출구는 항상 미로의 경계에 있다.
<출력값>
i번째 테스트 케이스에 대해 i번째 줄에 걸음의 기댓값을 반올림하여 둘째 자리까지 출력한다.

<문제 2051>
A와 B로 나누어져 있는 이분 그래프가 입력으로 주어진다. A에는 정점이 N개가 있고, B에는 정점이 M개가 있다. 정점은 A의 정점은 1번부터 N번, B의 정점도 1번부터 M번가지 번호가 매겨져 있다. A의 i번 정점은 Ai로, B의 j번 정점은 Bj로 표시한다.
이 그래프의 최소 버텍스 커버(Minimum Vertex Cover)를 구하는 프로그램을 작성하시오.
버텍스 커버란 정점(Vertex)들의 집합으로, 주어진 그래프에서 버텍스 커버에 포함된 정점들을 제거하면 간선이 하나도 남지 않게 되는 집합을 말한다. 최소 버텍스 커버는 이와 같은 집합들 중 크기(정점의 개수)가 최소인 것을 말한다.
그래프에서 정점을 제거할 때는, 그 정점에 연결된 모든 간선도 함께 제거하게 된다.
<입력값>
첫째 줄에 N과 M이 주어진다. (1 ≤ N, M ≤ 1,000)
둘째 줄부터 N개의 줄에 Ai와 연결되어 있는 정점의 개수가 주어지고, 그 개수만큼 Bj의 j가 주어진다.
<출력값>
첫째 줄에 최소 버텍스 커버의 크기를 출력한다.
둘째 줄에는 A에서 최소 버텍스 커버에 포함되어 있는 정점의 개수를 출력하고, 포함되어 있는 정점의 번호(Ai에서 i)를 출력한다.
셋째 줄에는 B에서 최소 버텍스 커버에 포함되어 있는 정점의 개수를 출력하고, 포함되어 있는 정점의 번호(Bj에서 j)를 출력한다.

<문제 2052>
자연수 N(1≤N≤250)이 주어졌을 때, 2의 -N승을 계산하는 프로그램을 작성하시오. 즉, 1/(2^N)을 계산하는 것이다.
<입력값>
첫째 줄에 N이 주어진다.
<출력값>
첫째 줄에 답을 출력한다. 답을 출력할 때에는 예제와 같이 0.xyz… 의 형식으로 출력하며, 뒤에 0을 덧붙이지 않는다.

<문제 2053>
N 개의 반직선이 있다. 각 반직선의 시작점은 y축 선상에 있고, y축과 평행한 반직선은 없다. 각 반직선은 y=Ai*x+Bi의 꼴로 주어진다. 각 반직선은 양수 x에 대해서만 정의된다.
Q개의 질문에 답을 하는 문제를 작성하라. 각 질문은 '직선 y=Cj*x + Dj이 N 개의 반직선과 이루는 교점의 x 좌표 값의 최댓값은 무엇인가?'이다.
<입력값>
입력 첫 줄에는 반직선의 개수를 나타내는 자연수 N이 주어진다. 다음 N 줄마다 반직선 방정식의 계수를 나타내는 두 개의 정수 Ai, Bi가 주어진다. 다음 줄에는 문제의 개수를 타나내는 자연수 Q가 주어진다. 다음 Q 줄에는 두 개의 정수 E, F가 주어진다. 만약 직전 질문의 직선(y = Cj-1*x + Dj-1)이 N 개의 반직선과 이루는 교점이 적어도 한 개 있었거나 이것이 첫 번째 질문이라면 Cj = E, Dj = F 이다. 그렇지 않으면 Cj = E ^ (229-1) and Dj = F ^ (229-1) 이다. (^는 XOR 연산자.)
제한 사항

입력되는 모든 숫자는 정수이다.
-2000000000 < Ai, Bi, Ci, Di < 2000000000
임의의 i, j (i≠j)에 대하여 Ai≠Aj
임의의 i, j에 대하여 Ai≠Cj
임의의 i, j에 대하여 Bi≠Dj
0 < N, Q < 50001
<출력값>
Q개의 질문에 대하여 하나의 실수 x를 소수점 이하 적어도 6자리까지 출력하라. x는 질문에서 주어진 직선이 N 개의 반직선과 이루는 교점의 x 좌표 값의 최댓값이다. 만약 직선이 N 개의 반직선과 이루는 교점이 하나도 없다면 "No cross"를 출력하라.

<문제 2054>
한 초등학교 선생님이 학생들을 위한 계산 문제를 만들고 있었다. 특히 이 선생님은 답이 같지만 문제는 다른 경우를 매우 좋아한다. 그래서 어느 날에는 답이 2,000이 되는 계산 문제들을 열심히 만들고 있었다.
문제를 다 만든 후, 학생들에게 나눠주기 위해서 출력을 해 보았는데, 프린터에 문제가 생겨서 숫자만 인쇄가 되고 연산자는 인쇄가 되지 않았다. 선생님은 당황했지만, 기억을 더듬어 문제를 다시 복원할 수 있었다. 하지만 선생님은, 오히려 이러한 상황에서 답이 2,000이 되는 문제를 만들어내는 것이 더 재미있다고 느끼게 되었다.
예를 들어 2100-100이라는 문제는 2100100으로 인쇄가 되었는데, 2*100*10+0과 같은 식으로 문제를 만들 수도 있었다. 선생님은 문제를 만들 때 다음의 조건들을 만족하는 문제만을 만든다.
(1) 수를 쓸 때는, 0이 아닌 경우에는 0으로 시작하지 않는다. 즉, 2*10*0100과 같은 경우는 0100이 0으로 시작하기 때문에 올바른 경우가 아니다. 또한 0을 쓸 때에는 0을 한 번만 쓴다. 따라서 2*1000+000은 올바른 경우가 아니다.
(2) 연산자를 쓸 때에는 이항 연산자만 사용하고 단항 연산자를 사용하지 않는다. 즉, 수 앞에 부호를 나타내기 위한 +나 -는 사용하지 않는다. 따라서 2*-100*-10+0과 같은 경우는 올바른 경우가 아니다.
(3) 연산자는 +, -, *만 사용한다. 나눗셈의 경우에는 답이 정수가 아닐 수도 있기 때문에 문제로 내지 않았다. 물론 각각의 연산자들의 우선순위와 같은 연산법칙은 일반적으로 사용되는 방법을 따른다.
인쇄된 결과가 주어졌을 때, 한 개 이상의 연산자를 추가하여 답이 2,000이 되도록 하는 문제를 모두 구해내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 인쇄된 결과가 공백 없이 주어진다. 이 길이는 9자를 넘지 않는다.
<출력값>
한 줄에 하나씩 답을 출력한다. 답이 여러 개일 경우에는 각각을 하나의 문자열로 생각하여 사전 순서대로 출력한다.

<문제 2055>
삼각형이란 세 개의 변으로 이루어진 면적이 양수인 도형이다. 격자 삼각형이란 삼각형의 세 꼭짓점의 좌표가 정수로 표현되는 삼각형을 말한다. 격자의 범위가 N×M으로 주어질 때, 가능한 삼각형의 개수를 구하는 프로그램을 작성하시오. 예를 들어 N=1, M=2일 경우에는 다음과 같은 18개의 경우가 있다.
<입력값>
첫째 줄에 두 정수 N, M(1≤N, M≤1,000)이 주어진다.
<출력값>
첫째 줄에 답을 출력한다.

<문제 2056>
수행해야 할 작업 N개 (3 ≤ N ≤ 10000)가 있다. 각각의 작업마다 걸리는 시간(1 ≤ 시간 ≤ 100)이 정수로 주어진다.
몇몇 작업들 사이에는 선행 관계라는 게 있어서, 어떤 작업을 수행하기 위해 반드시 먼저 완료되어야 할 작업들이 있다. 이 작업들은 번호가 아주 예쁘게 매겨져 있어서, K번 작업에 대해 선행 관계에 있는(즉, K번 작업을 시작하기 전에 반드시 먼저 완료되어야 하는) 작업들의 번호는 모두 1 이상 (K-1) 이하이다. 작업들 중에는, 그것에 대해 선행 관계에 있는 작업이 하나도 없는 작업이 반드시 하나 이상 존재한다. (1번 작업이 항상 그러하다)
모든 작업을 완료하기 위해 필요한 최소 시간을 구하여라. 물론, 서로 선행 관계가 없는 작업들은 동시에 수행 가능하다.
<입력값>
첫째 줄에 N이 주어진다.
두 번째 줄부터 N+1번째 줄까지 N개의 줄이 주어진다. 2번째 줄은 1번 작업, 3번째 줄은 2번 작업, ..., N+1번째 줄은 N번 작업을 각각 나타낸다. 각 줄의 처음에는, 해당 작업에 걸리는 시간이 먼저 주어지고, 그 다음에 그 작업에 대해 선행 관계에 있는 작업들의 개수(0 ≤ 개수 ≤ 100)가 주어진다. 그리고 선행 관계에 있는 작업들의 번호가 주어진다.
<출력값>
첫째 줄에 모든 작업을 완료하기 위한 최소 시간을 출력한다.

<문제 2057>
음 아닌 정수 N(≤1,000,000,000,000,000,000)이 주어졌을 때, 이 수를 서로 다른 정수 M(M ≥ 1)개의 팩토리얼의 합으로 나타낼 수 있는지 알아내는 프로그램을 작성하시오. 예를 들어 2=0!+1!로 나타낼 수 있지만, 5는 이와 같은 방식으로 나타낼 수 없다.
<입력값>
첫째 줄에 정수 N이 주어진다.
<출력값>
입력으로 주어진 수를 서로 다른 정수 M개의 팩토리얼의 합으로 나타낼 수 있으면 YES, 없으면 NO를 출력한다.

<문제 2058>
잘 알려져 있듯, 각각의 원자들은 어떤 특정한 에너지 상태(혹은 에너지 준위)에 놓일 수 있다. 각각의 상태는 그 상태에서 그 원자가 갖는 에너지로 나타낼 수 있다. 어떤 원자가 높은 에너지 상태에서 낮은 에너지 상태로 변할 때, 두 상태의 에너지 차이만큼의 에너지를 갖는 양성자가 방출된다. 역으로, 낮은 에너지 상태에서 높은 에너지 상태로 변하기 위해서는, 두 상태의 에너지 차이만큼의 에너지를 갖는 양성자가 필요하다.
과학자들은 오랜 연구를 통해서 원자의 각 에너지 상태에서의 에너지를 알아낼 수 있었다. 또한, 하나의 양성자가 가질 수 있는 에너지의 종류들도 모두 알아낼 수 있었다. 또한 이 문제에서 다루게 될 원자의 경우에는, 에너지 상태가 변할 때 오직 한 개의 양성자만이 출입할 수 있음을 알게 되었다. 또한 원자가 어떤 특정 에너지 상태(A)에서 다른 에너지 상태(B)로 변할 수 있는 방법은 한 가지 뿐이고, 이 방법을 역으로 적용(양성자를 받아들인 경우는 양성자를 내쏘고, 양성자를 내쏘는 경우는 양성자를 받아들임)하면 B에서 A로도 상태가 변할 수 있음을 알게 되었다. 물론, A->B->C->B->C->D 와 같은 경우처럼 같은 상태를 반복하는 경우는 고려하지 않는다.
예를 들어 세 개의 에너지 상태를 갖는 원자가, 각 상태에서 2, 4, 6만큼의 에너지를 갖는다고 하자. 또한 실험을 통해서, 양성자가 가질 수 있는 에너지가 2, 3임을 알게 되었다고 하자. 이 경우 원자는 양성자를 받아들이며 2->4->6의 상태로 변할 수 있고, 반대로 양성자를 내쏘며 6->4->2의 상태로 변할 수도 있다.
과학자들은 이러한 원자를 가지고 실험을 시작했다. 우선 실험을 위해서 몇 개(제한 없음)의 원자와 몇 개(제한 없음)의 양성자를 준비하고, 이 양성자들을 이용하여 각 원자의 에너지 상태를 조절한다. 에너지 상태가 다 조절된 후에는 이 원자들을 컨테이너 안에 집어넣고 관찰을 하게 된다. 이때, 컨테이너 안에 들어간 원자들이 서로 같은 에너지 상태에 있거나, 어떤 한 개의 원자가 한 개의 양성자를 받아들이거나 내쏘아서 다른 원자와 같은 에너지 상태에 도달할 수 있다면, 이 경우는 실험에서 위험이 발생할 수 있다. 따라서 이러한 경우는 허용되지 않는데, 그러면서도 컨테이너 안의 원자들의 에너지들의 총 합이 최대가 되도록 하려 한다.
원자의 각 에너지 상태에서의 에너지와 양성자가 가질 수 있는 에너지가 주어졌을 때, 컨테이너 안의 원자들의 에너지들의 총 합의 최대를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 두 정수 N(1≤N≤200), M(1≤M≤200)이 주어진다. 다음 N개의 줄에는 원자의 각 에너지 상태에서의 에너지가 주어진다. 물론 두 상태에서의 에너지가 같은 경우는 없다. 다음 M개의 줄에는 양성자가 가질 수 있는 에너지가 주어진다. 각 에너지는 1,000,000이하의 자연수이다.
<출력값>
첫째 줄에 답을 출력한다.

<문제 2059>
N(1≤N≤1,000)개의 작업으로 이루어진 공정이 있다. 이 공정을 완수하기 위해서는 각각의 작업을 모두 수행하여야 한다.
각각의 작업은 한 대의 기계를 이용하여 수행하게 된다. 기계를 이용하여 어떤 특정 작업을 끝낸 이후에는, 바로 어떤 특정 작업을 수행할 수도 있다. 예를 들어 1번 작업이 종료된 후에 바로 2번 작업을 수행할 수 있는 식이다. 즉, 어떤 작업을 연속적으로 처리하기 위해서는, 그 직전에 수행된 작업이 영향을 받게 된다. 물론, 이를 위해서 제일 첫 번째 작업을 수행하기 전에, 작업들의 순서를 정해서 기계에 입력을 해 두어야 한다.
기계는 작업을 매우 빠른 속도로 처리하기 때문에 실제 작업들이 수행되는 시간은 매우 짧다. 하지만 작업을 시작하기 전에, 기계에 작업 순서를 입력해야 하는데, 이 과정이 복잡하기 때문에 매우 오랜 시간이 걸리게 된다. 단 한 개의 작업만을 처리하는 경우에도, 이러한 작업을 입력하는데 걸리는 시간 역시 매우 길다고 가정하자. 따라서 작업 순서를 입력하는 회수를 최소로 하려 한다. 단, 한 번 수행된 작업을 다시 수행하는 경우가 있어서는 안 되며, 모든 작업을 모두 한 번씩만 수행해야 한다.
작업 순서는 꼭 추이적이진 않을 수도 있다. 예를 들어서 1번 작업이 끝난 이후에 바로 2번 작업을 수행할 수 있고, 2번 작업이 끝난 이후에 3번 작업이 처리될 수도 있다고 하자. 이 경우에 1번 작업이 끝난 이후에 3번 작업을 바로 수행할 수 있는 것은 아닐 수도 있다. 또한 1번 작업이 끝난 이후에 2, 3번 작업을 수행할 수 있다고 하더라도, 1 2 3 순서대로 작업을 수행할 수 있는 것은 아니다. 즉, 2번 작업이 끝난 이후에 3번 작업을 수행할 수 있어야 1 2 3 순서대로 작업을 수행할 수 있다. 또한 영향을 받는 것은 직전 단계에서 수행된 작업이므로, 1번 작업이 끝난 이후에 3번 작업을 수행할 수 있는 것이 아니더라도, 1 2 3 순서대로 작업을 수행할 수도 있다.
단, 각각의 작업 사이에는 어느 정도의 순서 관계가 존재하기 때문에, 서로 다른 두 작업 A, B에 대해서, A가 끝난 이후에 B를 수행할 수 있거나, B가 끝난 이후에 A를 수행할 수 있다(두 경우 모두 성립할 수도 있다).
<입력값>
첫째 줄에 정수 N이 주어진다. 다음 N개의 줄에는 N개의 정수(0 또는 1)가 주어진다. i번째 줄의 j번째 정수가 1일 경우, i번째 작업이 완료된 후 j번 작업을 수행할 수 있음을 의미한다.
<출력값>
첫째 줄에 작업 순서의 입력 회수의 최솟값 X를 출력한다. 다음 X개의 줄에는 각각의 작업 순서를 출력한다. 첫 번째 정수 Y는 작업의 개수이고, 다음 Y개의 정수는 작업 순서를 나타낸다.

<문제 2060>
거액 사기도박 혐의로 체포된 아기염소들은 구치소에서 저녁밥을 먹기 위해 줄을 선다. 아기염소들은 각각 저마다의 번호판을 달고 있고, 줄 서는 순서는 이 번호판의 번호에 의해 정해진다. 아기염소들은 그다지 영리하지 않기 때문에, 번호는 0과 1로만 이루어진 이진수 형태를 띤다. 각각의 번호의 길이는 31비트를 넘지 않는다.
아기염소들은 우리가 예상하는 이런 순서로 줄을 서지 않는다. 0, 1, 10, 11, 100, ......
그 대신, 다음과 같은 규칙에 의한 우선순위에 따른다.

번호판에서 1의 총 개수가 더 적은 아기염소가 밥을 먼저 먹는다.
1의 총 개수가 서로 같을 경우, 번호를 이진수로 보았을 때 더 작은 번호의 아기염소가 밥을 먼저 먹는다. (위에서 우리가 예상했던 순서와 같다)

따라서 1000 (1이 1개)은 110 (1이 2개) 보다 우선순위가 먼저다. 100번부터 1111번까지의 모든 아기염소들을 순서대로 나열해보면 다음과 같다.
100, 1000, 101, 110, 1001, 1010, 1100, 111, 1011, 1101, 1110, 1111
번호가 정확히 0번인 아기염소를 제외하고는, 어떤 아기염소의 번호도 0으로 시작할 수 없다.
A번부터 B번까지 염소가 있을 때, 우선순위에 따라 정렬했을 때, X번째 염소의 번호를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 A가, 둘째 줄에 B가 주어진다.
셋째 줄에, 우리가 그 번호를 구하고자 하는 아기염소의 위치가 주어진다. (물론 첫 번째 아기염소는 1번이다)
<출력값>
첫째 줄에, 해당 위치에 있는 아기염소의 번호를 출력한다.

<문제 2061>
암호화 방식 중에는 소수를 이용하는 것들이 많다. 보통은 매우 큰 두 개의 소수를 선택하고, 두 소수를 곱한 값을 암호화에서의 키로 사용하고는 한다. 이러한 방법이 좋은 이유는 일반적으로 매우 큰 수를 소인수분해 하는 것이 어렵기 때문이다.
소수를 택할 때 큰 수를 택하면, 이 둘을 곱해서 얻어지는 키 값도 커지게 된다. 하지만 그 반대는 성립하지 않을 수도 있다. 즉, 키 값이 매우 큰 경우에도 이를 소인수분해 하는 것은 쉬울 수도 있다.
따라서 암호문이 크랙되지 않도록 하기 위해서는, 키 값이 적절히 큰 수들의 곱으로 이루어져 있는지를 확인해야 할 필요가 있다. 키 값 K(4≤K≤10^100)와 정수 L(2≤L≤1,000,000)이 주어졌을 때, K를 인수분해 했을 때, 항상 L 이상의 값으로만 이루어져 있는지를 확인하고 싶다. 물론 인수분해 할 때 1로 나누는 경우는 고려하지 않는다.
예를 들어 K=143인 경우, 이는 11과 13의 곱으로 이루어져 있다. 즉, 이를 인수분해 하는 방법은 11×13, 143의 두 가지 경우뿐이다. 따라서 L이 11일 경우에는 인수분해 했을 때 나온 수들이 모두 L 이상이므로 좋은 경우지만, L이 12이상일 경우에는 좋은 암호가 아니다.
K와 L이 주어졌을 때, 좋은 암호인지 판단하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 두 정수 K, L이 주어진다.
<출력값>
좋은 암호인 경우에는 GOOD을 출력한다. 나쁜 암호일 경우에는 BAD를 출력하고, K의 가장 작은 (1 아닌) 인수를 출력한다.

<문제 2062>
Nils와 Mikael은 곱하기 게임을 하고 있다. 이 게임은 K(1≤K≤6)개의 카드와 한 개의 실수 X(1<X<10,000)를 가지고 진행된다. 각각의 카드에는 0.9 이하의 실수가 적혀 있고, 두 사람은 이 카드를 함께 사용하게 된다.
게임은 두 사람이 번갈아가며 진행하는데, 각 턴에서 각 사람은 한 장의 카드를 선택할 수 있다. 카드를 선택하면 그 카드에 적혀 있는 실수를 X에 곱해서 새로운 X를 얻게 된다. 그러면 그 다음 사람도 한 장의 카드를 선택하고, 그 카드에 적혀 있는 실수를 이전 단계에서 만들어진 X에 곱하고, 또 새로운 X를 얻게 된다. 카드를 선택할 때에는 K개의 카드 중에서 반드시 하나를 선택해야 하며, 이전 단계에서 사용되었던 카드도 얼마든지 선택할 수 있다.
이와 같이 게임이 진행되면, 실수 X의 값이 점점 줄어들게 된다. 이와 같이 X를 줄여 나가다가, 먼저 X가 1 이하가 되도록 만드는 사람이 이 게임의 승자가 된다.
게임은 Nils가 먼저 시작하게 된다. 두 사람은 모두 이 게임에 익숙하기 때문에, 각 단계에서 최선을 다해 게임을 진행하게 된다. 이러한 상황에서 이 게임의 승자를 가려내는 프로그램을 작성하시오.
실수 연산을 하다 보면 오차(rounding-error)가 발생할 수 있는데, 채점을 할 때에는 이러한 문제가 생기는 입력 데이터는 사용하지 않는다. 즉, 입력 값을 미세하게 조절했을 때 답이 바뀌는 경우는 입력으로 주어지지 않는다.
<입력값>
첫째 줄에 채점 데이터의 개수 T(1≤T≤10)가 주어진다. 다음 T개의 줄에는 각 데이터가 주어진다. 먼저 실수 X와 정수 K가 주어지고, 다음에는 각 카드에 적혀있는 실수들이 K개 주어진다. 각 실수들은 유효 숫자가 6개를 넘지 않는다.
<출력값>
각각의 데이터에 대해 승자를 출력한다.

<문제 2063>
N(1≤N≤20)개의 반원 모양의 철사들이 있다. 이들 중 몇 개를 택해서 붙였을 때, 하나의 연결된 모양(폐곡선)을 만들 수 있는지 알아내는 프로그램을 작성하시오. 두 개의 반원 모양의 철사는 그 끝을 임의의 각도로 붙일 수 있지만(즉, 각각의 반원을 얼마든지 회전할 수 있다), 중간에 다른 철사와 겹치는 부분이 있어서는 안 된다.
<입력값>
첫째 줄에 데이터의 개수 K(1≤K≤30)가 주어진다. 각 데이터의 첫째 줄에는 N이 주어지고, 그 다음 줄에는 각 반원의 반지름을 나타내는 실수가 N개 주어진다. 각 실수는 0부터 10,000,000의 범위 안에 있으며, 소숫점 아래 셋째 자리까지 입력될 수 있다.
<출력값>
각 데이터에 대해서 가능한 경우에는 YES, 불가능한 경우에는 NO를 출력한다.

<문제 2064>
네트워크에 연결되어 있는 컴퓨터들은 각각 하나의 IP 주소를 갖게 된다. 그리고 이러한 IP 주소를 갖는 컴퓨터들이 여러 개 모여서 하나의 IP 네트워크를 구성하게 된다. IP 네트워크는 ‘네트워크 주소’와 ‘네트워크 마스크’라는 두 개의 정보로 표현된다.
IP 주소는 네 개의 바이트로 구성되어 있으며, 각각을 10진수로 나타내고(앞에 0을 붙이지 않은 형태로) 사이에 점을 찍어 주소를 표현한다. 바이트이기 때문에 각각의 수는 0부터 255까지의 값을 갖게 된다. 네트워크 주소와 네트워크 마스크 역시 같은 형식으로 나타낸다.
IP 네트워크에 대해 올바르게 이해하기 위해서는 위와 같은 주소를 2진수로 이해하면 된다. 즉, 각각의 바이트를 8자리의 이진수로 나타내고, 이를 네 개 붙여놓은(앞에서부터) 32자리의 이진수를 생각해 보자. IP 네트워크에는 기본적으로 2^m 개의 컴퓨터(혹은 IP 주소)가 할당될 수 있다. 이 경우의 네트워크 주소는 앞의 32-m 자리가 임의의 수(0 또는 1)로 구성되어 있고, 뒤의 m자리는 0으로 채워지게 된다. 네트워크 마스크는 앞의 32-m 자리가 1로 채워져 있고, 뒤의 m자리는 0으로 채워지게 된다. 이와 같은 IP 네트워크에는 앞의 32-m 자리가 네트워크 주소와 일치하는 모든 IP들이 포함되게 된다.
예를 들어 네트워크 주소가 194.85.160.176이고, 네트워크 마스크가 255.255.255.248인 경우를 생각해 보자. 이 경우, 이 네트워크에는 194.85.160.176부터 194.85.160.183까지의 8개의 IP 주소가 포함된다.
어떤 네트워크에 속해있는 IP 주소들이 주어졌을 때, 네트워크 주소와 네트워크 마스크를 구해내는 프로그램을 작성하시오. 답이 여러 개인 경우에는 가장 크기가 작은(포함되는 IP 주소가 가장 적은, 즉 m이 최소인) 네트워크를 구하도록 한다.
<입력값>
첫째 줄에 정수 n(1≤n≤1,000)이 주어진다. 다음 n개의 줄에는 각 컴퓨터의 IP 주소가 주어진다.
<출력값>
첫째 줄에 네트워크 주소를, 둘째 줄에 네트워크 마스크를 출력한다.

<문제 2065>
강을 사이에 두고 위치한 두 정박장 사이를 한 대의 나룻배가 오가고 있다. 두 정박장은 강을 기준으로 왼쪽(left), 오른쪽(right)으로 구분한다. 제일 처음에는 나룻배가 왼쪽 정박장에 위치해 있다. 이 나룻배는 한번에 최대 M(1≤M≤10,000)명의 사람을 태울 수 있으며, 한 쪽 정박장에서 다른 쪽 정박장으로 이동하는데 양쪽 방향 모두 t(1≤t≤10,000)만큼의 시간이 걸린다. 나룻배는 손님을 한 쪽 정박장에서 다른 쪽 정박장으로 실어 나르며 두 정박장 사이를 움직인다.
나룻배가 어떤 정박장에 도착하게 되면, 그 정박장으로 가고자 하는 사람들을 우선 모두 내려준다. 그 다음에는, 그 정박장에서 기다리고 있던 손님들을 배에 태울 수 있는 데까지 태운다. 손님이 배에 타는데 드는 시간은 없다고 가정하며, 가장 오래 기다린 사람이 먼저 배를 타게 된다. 손님을 다 태운 후에는 반대쪽 정박장으로 이동하게 된다. 만약 기다리던 손님이 없다면, 나룻배가 그 정박장에서 다음 손님을 기다리게 된다. 만약 기다리던 중 반대 쪽 정박장에 손님이 도착하면, 그 쪽 정박장으로 이동하게 된다.
각각의 손님들이 어느 정박장에 언제 도착하는지에 대한 정보가 주어질 때, 각 손님들이 원하는 곳에 도착하게 되는 시간을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 세 정수 M, t, N(1≤N≤10,000)이 주어진다. 다음 N개의 줄에는 각각의 손님이 정박장에 도착하는 시간과 도착하는 정박장의 위치가 주어진다.
<출력값>
N개의 줄에, 입력받은 순서대로 각 손님이 목적지에 도착하게 되는 시간을 출력한다.

<문제 2066>
한 벌의 트럼프 카드 중 36장의 카드를 이용하여 하는 놀이가 있다. 각각의 카드들은 4장씩, 9개의 그룹으로 나눠서 놓이게 된다. 카드를 놓을 때에는 앞면(무늬와 숫자가 적혀 있는 면)이 보이도록 놓게 된다. 각각의 카드는 두 개의 문자로 나타낼 수 있는데, 하나는 숫자(6~9, T, J, Q, K, A)와 무늬를 나타내는 문자(S, D, H, C)로 이루어진다.
이 놀이의 목적은 이 카드들 중에서 두 장의 카드를 들어내는 과정을 18번 반복하여 모든 카드를 들어내는 것이다. 카드를 들어낼 때에는 서로 다른 그룹에 있는 카드들로 들어내야 하며, 각 그룹의 제일 위에 있는 카드만을 들어낼 수 있다. 또한 아무렇게나 들어낼 수 있는 것이 아니라, 숫자가 같은 경우만 들어낼 수 있다.
예를 들어 9개의 그룹의 제일 위에 놓여 있는 카드들이 차례로 KS, KH, KD, 9H, 8S, 8D, 7C, 7D, 6H라고 해 보자. 이 경우에는 들어낼 수 있는 조합이 5가지 있는데, 각각 (KS, KH), (KS, KD), (KH, KD), (8S, 8D), (7C, 7D)이다.
당신은 이 놀이를 처음 해 보기 때문에 들어낼 수 있는 조합이 여러 개 있는 경우에는 그 중 하나를 랜덤하게, 그리고 같은 확률로 택해서 들어내기로 하였다. 위의 예에서는 다섯 가지의 경우를 택할 확률이 각각 0.2가 되는 것이다. 이와 같이 놀이를 진행했지만, 당신은 매우 높은 확률로 이 놀이에 성공(모든 카드를 들어냄)하게 되었다. 당신은 이를 이상하게 느끼고, 카드들의 초기 상태가 주어졌을 때, 이 놀이에 성공할 확률을 구해보려 한다.
카드들의 초기 상태가 주어졌을 때, 이 놀이에 성공할 확률을 구해내는 프로그램을 작성하시오.
<입력값>
9개의 줄에 4개의 문자열로 각각의 카드에 대한 정보가 주어진다. 각각의 줄에는 각각의 그룹에 있는 카드들이, 밑에 있는 카드부터 위에 있는 카드 순서대로 주어진다.
<출력값>
첫째 줄에 놀이에 성공할 확률을 출력한다. 절대/상대 오차는 10-6까지 허용한다.

<문제 2067>
한 회사는 한 건물에 사무실을 두고 있다. 각각의 직원들은 서로 다른 층에 있는 자신의 사무실에서 일을 처리하게 된다. 그런데 이 건물에는 엘리베이터가 한 대밖에 없어서 사람들이 많은 불편을 겪고 있다. 특히 출근 시간에는 많은 사람들이 비슷한 시간에 엘리베이터에 몰리기 때문에 더욱 효율이 떨어진다. 따라서 회사에서는 출근 시간에 맞춰서 엘리베이터를 미리 정해져 있는 층에만 서면서 운행하려 한다.
엘리베이터는 한 층을 올라갈 때마다 4초가 걸린다. 따라서 1층부터 31층까지 운행하면 120초가 걸리게 된다. 만약 엘리베이터가 한 층에 서면, 그 층에서 10초간 서 있게 된다. 따라서 1층부터 31층까지 매 층에서 서면서 운행하면 410초가 걸리게 된다. 이는 제일 마지막 층에 도착하는 시간이 기준이므로, 제일 마지막 층에서는 10초를 계산하지 않는다. 또한 계단을 이용할 수도 있는데, 계단을 이용하여 한 층을 이동할 경우에는 20초가 걸리게 된다. 따라서 1층부터 31층까지 걸어서 올라가면 600초가 걸리게 된다. 사람들은 걷는 것을 매우 싫어하기 때문에, 그들의 사무실이 위치한 층에 제일 가까운 층에서 내린 뒤 계단을 이용하려 한다.
회사에서는 출근 시간에 사람들이 내리는 층들을 우선 조사하였다. 회사에서는 제일 마지막 사람이 도착하는 시간을 최소로 하기로 하였다. 예를 들어, 직원들이 4, 5, 10층에 내려야 하는 경우를 생각해 보자. 이때에는 4층과 10층에 서는 경우가 최적이 된다. 4층에 내리는 직원들은 12초에 도착하게 되고, 10층에 도착하는 사람들은 46초에 도착하게 된다. 5층으로 가려는 사람들은 4층에서 함께 내려서 한 층을 걸어 올라가면 32초에 도착하게 된다. 따라서 제일 마지막 사람은 46초에 도착하는 사람이 된다.
사람들이 서고자 하는 층이 주어질 때, 제일 마지막 사람이 도착하는 시간의 최소를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 정수 N(1≤N≤30)이 주어진다. 다음 줄에는 N개의 정수로, 사람들이 서고자 하는 층들이 주어진다. 이 건물은 31층이기 때문에 사람들은 2층 이상 31층 이하에서 서고자 하며, 같은 층에 대한 정보는 한 번씩만 주어진다(중복 없이).
<출력값>
첫째 줄에 답을 출력한다.

<문제 2068>
염소 자전거 팀은 N(1<=N<=20)명의 자전거 주자들로 이루어져 있다. 그들은 최대한 이른 시간에 결승점까지 도착할 수 있도록 하는 사이클링 전략을 세우고자 한다.
이번 염소들은 매우 영리하기 때문에, 혼자 달리지 않고 무리지어 달림으로써 공기저항을 줄인다. 그들이 1분당 x바퀴(x는 정수)의 속력으로 달릴 때, 선두 주자는 1분당 x*x만큼의 에너지를 소비하는 반면 나머지 모든 주자들은 1분당 x만큼의 에너지만 소비한다. 선두 주자를 교체하는 일은 1분마다 한 번씩 가능하고, 교체 과정에서는 시간과 에너지가 전혀 소비되지 않는다. 또한 개개인의 염소들은 레이스를 도중에 포기할 수 있다.
이번 레이스에서 우리의 염소 팀은 트랙을 총 D(1<=D<=100)바퀴 돈다. 모든 염소는 각각 똑같이 E(1<=E<=100)만큼의 에너지가 있는 상태에서 출발한다.
경주를 마칠 수 있는 가장 이른 시간을 구하시오. 결승선을 끊는 염소 주자는 한 마리로 충분하다. 정확히 k(k는 정수)분 정각에 결승선을 통과하지 못하는 경우에는 k+1분 정각에 레이스를 마치며, 남은 시간 동안 트랙을 돌 에너지도 여전히 필요하다. N, D, E는 모두 정수이다.
<입력값>
첫 줄에 세 개의 정수 N, E, D가 들어온다.
<출력값>
우리의 염소 팀이 레이스를 마칠 수 있는 가장 이른 시간(정수)를 첫 줄에 출력한다. 에너지가 적어서 레이스를 마칠 수 있는 방법이 없는 경우에는 0을 첫 줄에 출력한다.

<문제 2069>
맑은 날 울릉도에서 태백산맥을 바라보면 수평선 위로 N개의 산봉우리가(N<=100,000) 보인다.  다음은 N=5인 경우의 예이다.
                   /\
      /\          /  \  /\
     /  \/\    /\/    \/  \
    /    \ \  /  \    /    \
  -----------------------------
각각의 산들은 높이가 밑변 길이의 2배인 이등변삼각형이다. 산은 밑변 꼭짓점의 정수 x좌표(1<=x좌표<=32,767) 두 개로 표현된다.
울릉도에서 바라본 산맥의 보이는 면적을 계산하여라.
<입력값>
첫째 줄에 N이 입력된다.
둘째 줄부터 N+1번째 줄까지, 각각의 줄에는 산 하나를 표현하는 왼쪽 꼭짓점의 x좌표, 아래쪽 꼭짓점의 x좌표가 공백을 사이에 두고 입력된다.
<출력값>
첫째 줄에 산맥의 보이는 면적을 출력한다. 답은 부호 있는 32비트 정수 범위 안에 있다.

<문제 2070>
어떤 수열이 주어졌을 때, 이 수열을 회전하면 여러 가지 수열을 얻을 수 있다. 이와 같이 수열을 회전하면서 얻은 수열들이 모두 원래의 수열보다 같거나 크면, 원래의 수열을 목걸이 수열이라 부른다. 예를 들어 01011은 목걸이 수열인데, 이는 10110, 01101, 11010, 10101, 01011 중에서 제일 작은 것이 원래의 01011이기 때문이다.
0과 1로 구성된 수열 S가 주어졌을 때, 이를 목걸이 수열들로 분해할 수 있다. 가장 간단한 방법은 각각의 숫자 단위로 분해하는 것인데, 그 외에도 다음의 조건을 만족하도록 분해할 수도 있다.
(1) 분해된 각각의 목걸이 수열들이 감소하는 순서대로 나타난다.
(2) 분해된 각각의 목걸이 수열들에 대해서, 인접한 두 개의 목걸이 수열을 붙였을 때 목걸이 수열을 이루지 않는다.
예를 들어 11101111011과 같은 수열이 있다고 했을 때, 이 수열은 (111)(01111)(011)로 분해할 수 있다. 이 경우 각각이 목걸이 수열임은 자명하고, 111 > 01111 > 011이 성립하며, 11101111과 011110111 중 어느 것도 목걸이 수열이 아니므로 위의 두 조건을 만족하는 예가 된다.

  0과 1로 이루어진 수열이 주어졌을 때, 위의 두 조건을 만족하도록 목걸이 수열들로 분해하는 방법을 찾아내는 프로그램을 작성하시오.
수열 사이의 대소 관계는 사전식 순서로 정의한다. 즉, A < B의 관계가 성립하는 경우는 A 뒤에 몇 글자를 붙이면 B가 되는 경우나, A와 B가 앞의 몇 개의 숫자가 같고 그 다음 숫자는 B에 있는 숫자가 더 큰 경우이다. 예를 들면 001 < 0010, 1101011 < 11011000이 성립한다. 이진수의 크기가 아님에 주의한다.
<입력값>
첫째 0과 1로 이루어진 수열이 주어진다. 수열은 공백 없이 붙어서 주어지며, 그 길이는 1이상 100이하이다.
<출력값>
첫째 줄에 목걸이 수열로 분해한 방법을 출력한다. 이를 위해서 각각의 목걸이 수열을 괄호로 묶어서 출력한다.

<문제 2071>
바둑은 검은 돌과 흰 돌을 이용하여 진행하는 게임으로, 바둑판에 서로 번갈아가며 돌을 놓은 뒤, 집의 크기를 견주는 놀이이다. 바둑의 승패를 가리기 위해서는 이러한 집의 크기를 계산하는 것이 중요하다. 따라서 당신은 집의 크기를 계산하는 훈련을 하려 한다.
혼자 놀기에는 바둑판이 너무 크기 때문에, 우선 바둑판의 크기를 N(1≤N≤15)으로 한정한다. 따라서 바둑돌을 놓을 수 있는 위치는 N×N개가 된다. 또한 혼자 놀기 때문에 바둑판에는 검은 돌만을 놓는다고 하자. 이때에는 바둑돌이 놓이지 않은 위치가 모두 집이 되는데, 따라서 이 문제에서는 검은 돌로 완전히 둘러싸인 부분만을 집으로 치기로 한다. 즉, 집은 다음의 조건을 만족하는 부분들을 말한다.

집인 위치에는 돌이 놓여있지 않다.
바둑판의 테두리는 완전히 둘러싸일 수 없기 때문에 집이 아니다.
집의 상하좌우는 집이거나 검은 돌이 놓여 있어야 한다.
집이 아닌 곳의 상하좌우는 집이 아니다.

예를 들어서 아래와 같은 그림에서는 집의 크기가 3이 된다.

바둑판에 대한 정보가 주어졌을 때, 집의 크기를 계산하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 정수 N이 주어진다. 다음 줄에는 N개의 정수로, 위에서부터 아래로 각 행에 놓여 있는 돌의 개수가 주어진다. 다음 줄에는 N개의 정수로, 왼쪽부터 오른쪽까지 각 열에 놓여 있는 돌의 개수가 주어진다. 다음 줄에는 2×N-1개의 정수로, 왼쪽 위부터 오른쪽 아래까지, / 형태의 대각선 줄에 놓여있는 돌의 개수가 주어진다. 그 다음 줄에는 왼쪽 아래부터 오른쪽 위까지, ＼ 형태의 대각선 줄에 놓여있는 돌의 개수가 주어진다. 잘못된 입력은 주어지지 않으며, 항상 바둑판을 복원하는 방법이 유일한 경우만 입력으로 주어진다. 대각선은 45도의 대각선만 생각한다.
<출력값>
첫째 줄에 집의 크기를 출력한다.

<문제 2072>
19x19크기의 바둑판에, 돌을 놓을 좌표가 주어지면 이 게임이 몇 수만에 끝나는 지를 알아보려고 한다. 사용하고자 하는 바둑판의 모양은 위의 그림과 같으며, (1, 1)이 가장 왼쪽 위의 좌표이고 (19, 19)가 가장 오른쪽 아래의 좌표이다. 오목은 흑 또는 백이 5개의 돌을 가로, 세로, 혹은 대각선으로 연속으로 놓았을 경우 게임이 끝나게 된다. 즉, 다음 그림과 같은 경우를 말한다.

게임은 흑이 먼저 시작하며, 한수씩 서로 번갈아 가며 두게 된다. 다음 좌표들과 같이 차례로 돌을 놓으며 게임을 진행한다고 하자. (홀수번째는 흑, 짝수번째는 백)
1 - (3,3)                 2 - (2,3)
 3 - (3,4)                 4-  (2,2)
 5 - (3,2)                 6 - (3,1)
 7 - (3,5)                 8 - (2,4)
 9 - (2,5)                10 - (2,1)
11 - (1,5)                12 - (4,1)
13 - (4,5)                14 - (5,5) 
15 - (1,4)                16 - (5,1)
17 - (1,3)                18 - (1,1) 
19 - (5,3)                20 - (5,2) 
21 - (1,2)                22 - (5,4) 
23 - (4,2)                24 - (4,4) 
25 - (4,3)               
위의 순서대로 바둑판에 돌을 놓으면 아래의 왼쪽 그림과 같이 된다.

그런데 생각해보면, 위의 좌표대로 돌을 놓았을 때 오른쪽 그림처럼 18번째의 돌을 놓는 것으로서 게임이 끝나 버리는 것을 알 수 있다. 이 경우, 답은 18이다.
바둑판에 돌을 놓는 좌표가 입력될 때, 몇 번째 수에서 오목이 끝나는지를 찾는 프로그램을 작성하시오. 오목을 두다 보면 다음과 같이 돌이 5개를 거치지 않고 6개 이상의 돌이 나란히 놓이는 경우가 발생할 수 있다. 이런 overline의 경우에는 승리를 인정하지 않고 오목이 계속된다는 것에 주의하라.
<입력값>
첫째 줄에 바둑판에 놓이는 돌의 개수 N(1≤N≤100)이 주어진다. 그 다음 N줄에는 놓이는 돌의 좌표들이 차례로 주어진다. (홀수번째는 흑, 짝수번째는 백)
<출력값>
첫째 줄에 몇 번째 수에서 승패가 갈리는지를 출력한다. 승패가 갈리지 않는 경우에는 -1을 출력한다.

<문제 2073>
아기염소들이 언덕에서 풀을 뜯고 놀다 보면 항상 도중에 목이 마르곤 했다. 그들은 불편함을 참지 못하고 수도관을 설치하여 거리 D(7<=D<=100,000)만큼 떨어진 곳의 강에서 물을 끌어오기로 했다. 근처의 인간 마을에서 P개(1<=P<=350)의 파이프를 매입했는데, 각각은 길이 Li와 용량 Ci로 나타낼 수 있다. (Li와 Ci는 모두 24비트 양의 정수이다)
파이프들은 일렬로 이어서 수도관 하나로 만들 수 있으며, 이때 수도관의 용량은 그것을 이루는 파이프들의 용량 중 최솟값이 되고, 수도관의 길이는 파이프들 길이의 총합이다.
수도관을 한 개 만들어 총 길이가 정확히 D와 같게 할 때, 가능한 최대 수도관 용량을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 D와 P가 주어진다. 두 번째 줄부터 P개의 줄이 차례로 주어지고, 각 줄마다 Li와 Ci가 주어진다. (길이 합이 D가 되게 하는 수도관의 부분집합이 적어도 하나 존재한다)
<출력값>
가능한 최대 수도관 용량을 첫째 줄에 출력한다.

<문제 2074>
x의 P승을(1 ≤ P ≤ 20,000) 최대한 빠르게 계산하고자 한다. 그런데 계산결과가 굉장히 크므로 여기서는 계산 도중 값을 저장하는 데 있어 두 개의 변수만을 사용한다.
두 변수 중 하나는 x로, 다른 하나는 1로 초기화되어 있다. 우리가 쓸 수 있는 연산은, 현재 저장되어 있는 값들을 서로 곱하거나 나누어서 그 결과값을 임의의 변수에 저장하는 것이다. 최종 결과가 저장되는 위치는 아무래도 좋다.
예를 들어 x9을 계산하고자 할 때, 다음과 같은 방법이 가능하다.



연산 회수
0
1
2
3
4


변수1
x
x
x
x5
x9


변수2
1
x2
x4
x4
x4



P를 입력받아, xP를 구하기 위한 최소 연산 회수를 구하여라.
<입력값>
첫째 줄에 P가 들어온다.
<출력값>
최소 연산 회수를 출력한다.

<문제 2075>
N×N의 표에 수 N2개 채워져 있다. 채워진 수에는 한 가지 특징이 있는데, 모든 수는 자신의 한 칸 위에 있는 수보다 크다는 것이다. N=5일 때의 예를 보자.



12
7
9
15
5


13
8
11
19
6


21
10
26
31
16


48
14
28
35
25


52
20
32
41
49



이러한 표가 주어졌을 때, N번째 큰 수를 찾는 프로그램을 작성하시오. 표에 채워진 수는 모두 다르다.
<입력값>
첫째 줄에 N(1 ≤ N ≤ 1,500)이 주어진다. 다음 N개의 줄에는 각 줄마다 N개의 수가 주어진다. 표에 적힌 수는 -10억보다 크거나 같고, 10억보다 작거나 같은 정수이다.
<출력값>
첫째 줄에 N번째 큰 수를 출력한다.

<문제 2076>
2차원 벡터는 (x, y)와 같이 표현될 수 있다. 이러한 벡터들의 합을 정의할 수 있는데, (x1, y1), (x2, y2), ..., (xn, yn)의 합벡터는 (x1+x2+...+xn, y1+y2+...+yn) 이 된다. 또한 2차원 벡터 하나의 크기를 정의할 수 있는데, 벡터 (x, y)의 크기는 x*x+y*y이 된다.
평면상에 N개의 벡터들이 주어져 있다. 이 중에 몇 개를 임의로 골라서, 고른 벡터들의 합벡터의 크기를 최대로 하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 벡터의 개수 N(1≤N≤30,000)이 주어진다. 다음 N개의 줄에는 벡터 (x, y)가 주어지는데, x와 y 사이에는 빈칸이 하나 있다. 모든 좌표의 절댓값은 30000을 넘지 않는다. (0, 0)은 입력에서 주어지지 않는다고 가정해도 좋다.
<출력값>
최대 합벡터의 크기를 출력한다.

<문제 2078>
다음과 같은 귀납적인 규칙에 의해서 만들어지는 무한한 크기의 이진 트리를 생각하자. 각각의 노드에는 두 정수의 순서쌍이 할당되어 있다.

루트에는 (1, 1)이 할당된다.
어떤 노드가 (a, b)가 할당되었을 때, 그 노드의 왼쪽 자식에는 (a+b, b)가 할당되고, 오른쪽 자식에는 (a, a+b)가 할당된다.

우리는 어떤 노드가 주어졌을 때, 루트에서 그 노드로 이동하는 최단 경로를 찾으려 한다. 하지만 최단 경로가 매우 길 수도 있기 때문에, 왼쪽 자식으로 이동하는 회수와 오른쪽 자식으로 이동하는 회수를 찾으려고 한다.
입력으로 두 정수 A, B가 주어졌을 때, 루트에서 (A, B)가 할당된 노드까지 최단 경로로 이동할 때, 왼쪽 자식으로 이동하는 회수와 오른쪽 자식으로 이동하는 회수를 구해내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 두 정수 A, B(1≤A, B≤2,000,000,000)가 주어진다. 잘못된 입력은 주어지지 않는다고 가정한다.
<출력값>
첫째 줄에 두 정수 L, R을 출력한다. 각각은 왼쪽으로 이동한 회수, 오른쪽으로 이동한 회수를 나타낸다.

<문제 2079>
팰린드롬(palindrome)이란 앞에서부터 읽으나 뒤에서부터 읽으나 같은 단어를 말한다. 'aba'나 'a'와 같은 단어는 팰린드롬이며, 'abaccbcb'나 'anavolimilana'와 같은 단어는 팰린드롬이 아니다.
만일 어떤 단어가 팰린드롬이 아니라면, 그 단어는 여러 개의 팰린드롬으로 나누어질 수 있을 것이다. 단어가 주어졌을 때 이를 여러 개의 팰린드롬으로 나누되, 나누어진 팰린드롬의 개수가 최소가 되도록 나누려고 한다.
예를 들어 abaccbcb라는 문자는 aba, cc, bcb와 같이 세 개의 문자열로 나누면 각각 팰린드롬이 된다. 하지만 두 개의 문자열로 나누어서는 결코 각각이 모두 팰린드롬이 될 수 없다. 따라서 이 경우의 답은 3이다. 마찬가지로 anavolimilana와 같은 문자열은 ana, v, o, limil, ana의 다섯 개의 문자열로 나누면 각각 팰린드롬으로 만들 수 있으며, 네 개로 나누어서는 각각이 모두 팰린드롬이 되도록 만들 수 없다. 따라서 이 경우의 답은 5이다.
문자열이 주어졌을 때, 이 문자열을 최소 개수의 팰린드롬으로 나누는 프로그램을 작성하시오. 문자열 자체가 팰린드롬이라면 굳이 나눌 필요는 없다.
<입력값>
첫째 줄에 단어가 입력으로 들어온다. 단어는 영어 소문자로만 이루어져 있으며, 그 길이는 2,000을 넘지 않는다.
<출력값>
주어진 문자열을 최소 개수의 팰린드롬으로 나누었을 때, 그 개수를 출력한다.

<문제 2080>
N(1≤N≤100,000)개의 선분이 주어졌을 때, 서로 겹치는 서로 다른 선분 쌍의 개수를 알아내는 프로그램을 작성하시오. 두 선분이 겹친다는 말은, 두 선분에 공통적으로 포함되는 점들이 무한 개 존재한다는 의미이다. 즉, 선분의 끝점만 닿아 있는 경우는 겹치는 경우가 아닌 것이다.
<입력값>
첫째 줄에 정수 N이 주어진다. 다음 N개의 줄에는 각 선분의 양 끝점의 x, y좌표를 나타내는 네 정수가 주어진다. 각 좌표는 0이상 1,000,000의 값을 가지며, 한 선분의 양 끝점이 같은 경우는 주어지지 않는다.
<출력값>
첫째 줄에 답을 출력한다.

<문제 2082>
코레스코 콘도의 각 방에는 디지털 시계가 설치되어 있다. 디지털 시계에는 4개의 숫자가 표현될 수 있으며, 이것은 'hh:mm'의 형식으로 시간을 표현한다. 즉, 앞의 두 자리는 시간을, 뒤의 두 자리는 분을 표현한다. 시간은 00:00부터 23:59까지의 24시 체계를 쓴다.
디지털 시계의 각 숫자는 15개의 발광다이오드로 표현이 된다. 5x3형태로 배열되어 있는 발광 다이오드들 중 특정한 몇 칸이 켜져서 숫자를 나타내는 것이다. 다음과 같다. #은 불이 켜져 있는 다이오드를, .은 그렇지 않은 다이아몬드를 나타낸다.
# # #   . . #   # # #   # # #   # . #   # # #   # # #   # # #   # # #     # # #
# . #   . . #   . . #   . . #   # . #   # . .   # . .   . . #   # . #     # . #
# . #   . . #   # # #   # # #   # # #   # # #   # # #   . . #   # # #     # # #
# . #   . . #   # . .   . . #   . . #   . . #   # . #   . . #   # . #     . . #
# # #   . . #   # # #   # # #   . . #   # # #   # # #   . . #   # # #     # # #
그런데 투숙객이 아침에 일어나서 시계를 보니 몇 개의 발광다이오드가 고장나 불이 켜지지 않은 것을 발견했다. (켜지지 않아야 하는 발광다이오드가 켜진 경우는 없다)모든 투숙객은 자신이 부지런하고 믿는 사람들이기 때문에 투숙객은 가능하면 현재 시각을 빠른 시각(00:00에 가까운 시각이 늘 빠른 시각이다)으로 생각하고 싶다.
일부 발광다이오드가 고장난 디지털 시계의 네 숫자가 주어졌을 때, 이러한 배치가 가능한 가장 빠른 시각을 구하는 프로그램을 작성하시오.
<입력값>
각 줄에는 15개의 문자가 다음과 같이 주어진다. 네 번째 문자마다 공백이 한 칸씩 주어지고, 그 외에는 '#' 또는 '.'이 주어진다. 입력되는 순서는 시계의 배치된 순서와 같다.
<출력값>
이러한 배치가 가능한 가장 빠른 시각을 출력한다.

<문제 2083>
올 골드 럭비 클럽의 회원들은 성인부 또는 청소년부로 분류된다.
나이가 17세보다 많거나, 몸무게가 80kg 이상이면 성인부이다. 그 밖에는 모두 청소년부이다. 클럽 회원들을 올바르게 분류하라.
<입력값>
각 줄은 이름과 두 자연수로 이루어진다. 두 자연수는 순서대로 나이와 몸무게를 나타낸다. 입력의 마지막 줄은 # 0 0 이다. 이 입력은 처리하지 않는다.
이름은 알파벳 대/소문자로만 이루어져 있고, 길이는 10을 넘지 않는다.
<출력값>
입력 받은 각 회원에 대해 이름과 분류를 출력한다. 성인부 회원이면 'Senior', 청소년부 회원이면 'Junior'를 출력한다.

<문제 2084>
방향성 없는 그래프에서 어떤 정점에 물려 있는 변의 수를 차수(degree)라고 한다. 예를 들어 아래 갈은 그래프에서 정점 A와 D의 차수는 3, B와 C의 차수는 2이다.

그래프가 주어졌을 때, 정점의 차수들을 정점 번호 순서대로 나열하면 하나의 수열을 얻을 수 있다. 이러한 수열을 차수열(degree sequence)라고 하는데, 위와 같은 그래프의 차수열은 3, 2, 2, 3이라고 할 수 있다. 임의의 그래프의 차수열이 주어졌을 때, 이러한 차수열을 갖는 그래프를 구하는 프로그램을 작성하시오. 그래프의 간선은 방향성이 없으며, 자기 자신으로 돌아오는 간선은 없어야 한다. 그래프가 반드시 연결되어 있을 필요는 없으나, 차수열이 정점 순서대로 반드시 대응되어야 한다.
<입력값>
첫째 줄에 N(2≤N≤2,000)이 주어진다. 다음 줄에는 차수열을 이루는 N개의 음 아닌 정수가 빈칸을 사이에 두고 주어진다.
<출력값>
첫째 줄부터 N개의 줄에 걸쳐 그래프의 인접 행렬을 출력한다. 인접 행렬은 0 또는 1로 이루어지며, 답이 여러 개인 경우는 그 중에 하나만 출력하면 된다. 그래프가 존재하지 않는 경우에는 첫째 줄에 -1만을 출력한다.

<문제 2085>
우리는 보통 10진법을 사용하지만 컴퓨터에서는 2, 8, 16진법이 사용된다. 그 외에도 여러 가지 진법을 생각해 볼 수 있다. 16진법의 경우에는 두 자리 수들을 알파벳 문자들로 나타내지만, 이 문제에서는 수 형태로 생각하기로 한다. 각각의 수들은 공백으로 구분하고, 전체를 괄호로 둘러 싼 다음에 그 뒤에는 진법을 적는다. 예를 들어 16진법으로 1A8D는 (1 10 8 13)16이 된다.
공백이나 괄호를 생략하면 전체가 숫자로 구성된 문자열이 된다. 위의 예는 11081316이 된다. 만약 수가 이와 같은 형태로 주어진다면, 여기에 공백과 괄호를 적절히 추가하면 여러 가지 방법으로 수를 표현할 수 있다. 예를 들어 1234는 네 가지로 표현할 수 있는데, 각각 (1 2 3)4, (12)34, (1 2)34, (1)234가 된다.
숫자로 된 문자열이 주어졌을 때, 가능한 표현 방법을 모두 구해내는 방법을 구하시오. 만약 실제 값이 같더라도 다른 형태로 표현된다면 여러 번 세도록 한다.
단, 표현 방법들 중 불필요한 0이 사용되는 경우는 세지 않는다. 예를 들어 (0 3 6)8, (1 02 3)6, (3 2 1)07은 세지 않는다.
<입력값>
첫째 줄에 숫자로 구성된 문자열이 주어진다. 그 길이는 35자를 넘지 않는다.
<출력값>
첫째 줄에 답을 출력한다.

<문제 2086>
제 1항과 제 2항을 1이라 하고, 제 3항부터는 앞의 두 항의 합을 취하는 수열을 피보나치(fibonacci) 수열이라고 한다. 예를 들어 제 3항은 2이며, 제 4항은 3이다.
피보나치 수열의 a번째 항부터 b번째 항까지의 합을 구하는 프로그램을 작성하시오. 수가 매우 커질 수 있으므로 마지막 아홉 자리만을 구하도록 한다. 즉 1,000,000,000으로 나눈 나머지를 구하면 된다.
<입력값>
첫째 줄에 a와 b(1≤a≤b≤9,000,000,000,000,000,000)이 주어진다.
<출력값>
첫째 줄에 구한 합을 출력한다.

<문제 2087>
어린 왕자는 전문적인 해커이다. 어린 왕자는 최근에 n-bit로 이루어진 이진 암호문을 알아내기 위해 혈안이 되어 있다. 이 암호문을 알아내기 위한 단서를 한 가지 얻었는데, n개의 숫자들과 이 암호문을 이용해서 암호화된 숫자를 알아낸 것이다.
암호화된 숫자 K = a1t1 + a2t2 + ... + antn 으로 표현된다. 여기서 t1 ~ tn은 0 또는 1로 우리가 알아내려고 하는 n-bit의 이진 암호문을 순서대로 이루는 숫자들이다.
어린 왕자는 a1 ~ an과 K를 알고 있다. 이진 암호문을 알아내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 bit의 수 n (5 ≤ n ≤ 40)이 주어진다. 둘째 줄부터 n개의 줄에 a1 ~ an이 각 줄에 1개씩 주어진다. 마지막 줄에는 K가 주어진다. a1 ~ an은 모두 자연수이며, n개의 수 전체의 합은 2,000,000,000을 넘지 않는다.
<출력값>
첫째 줄에 n-bit의 이진 암호문을 출력한다. 답이 여러 개일 경우 하나만 출력한다.

<문제 2088>
몇 개의 정점으로 이루어진 트리가 있다. 이 트리는 루트가 있는 트리이며, 각 정점은 몇 개의 자식 정점을 가질 수 있다. 각각의 정점에는 알파벳 대문자가 적혀 있다. 같은 문자가 여러 정점에 적혀 있을 수도 있다.
이 트리를 루트부터 시작해서 탐색하는데, 어떤 한 정점에서는 그 정점의 자식들 중 왼쪽 자식들부터 차례대로 방문해 나간다. 이와 같이 탐색하면 하나의 경로를 얻을 수 있다. 주의할 점은, 자식이 있는 정점의 경우에는 여러 번 방문될 수도 있는데(제일 처음 방문할 때와, 자식 정점을 방문하고 다시 돌아올 때), 그러한 경우에 한 정점이 여러 번 경로에 나타날 수도 있다는 것이다.

위의 그림은 경로가 ABABABA인 경우를 모두 나타낸 것이다. 아래쪽이 루트를 의미하며, 위로 연결된 것이 자식 노드를 의미한다. 위의 그림에서는 왼쪽 자식을 왼쪽에 나타냈는데, 대부분의 사람이 생각하는 그림처럼 루트가 위에 있는 그림으로 고치려면, 좌우 대칭을 해야 한다. 물론 답에는 변화가 없다.
경로가 주어졌을 때, 그러한 경로를 갖는 트리의 개수를 구해내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 경로가 주어진다. 이는 알파벳 대문자로만 이루어지며, 그 길이가 300자를 넘지 않는다.
<출력값>
첫째 줄에 트리의 개수를 1,000,000,000으로 나눈 나머지를 출력한다.

<문제 2089>
-2진법은 부호 없는 2진수로 표현이 된다. 2진법에서는 20, 21, 22, 23이 표현 되지만 -2진법에서는 (-2)0 = 1, (-2)1 = -2, (-2)2 = 4, (-2)3 = -8을 표현한다. 10진수로 1부터 표현하자면 1, 110, 111, 100, 101, 11010, 11011, 11000, 11001 등이다.
10진법의 수를 입력 받아서 -2진수를 출력하는 프로그램을 작성하시오.
<입력값>
첫 줄에 10진법으로 표현된 수 N이 주어진다.
<출력값>
-2진법 수를 출력한다.

<문제 2090>
N개의 수 A[1], …, A[N]의 조화평균은 1/(1/A[1] + 1/A[2] + … + 1/A[N]) 으로 정의된다. 즉, 각각의 수들을 뒤집어서(분모와 분자) 모두 더한 뒤, 그 값을 다시 뒤집는 것이다. 예를 들어 1, 2, 4의 조화평균을 구하면 4/7이 된다.
N개의 자연수 A[1], …, A[N]이 주어졌을 때, 그 조화평균을 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 자연수 N(1≤N≤9)이 주어진다. 다음 줄에는 차례로 A[1], …, A[N]이 주어진다. 각 수들은 자연수이며, 100을 넘지 않는다.
<출력값>
첫째 줄에 분수 형태로 답을 출력한다. 답을 표현하는 방법이 여러 가지 있을 수 있는데, 그 중에서 가장 적은 수의 문자(숫자 및 /)를 사용하는 답을 출력하고, 그러한 경우가 여럿 있다면 사전 식으로 제일 앞서는 것을 출력한다.

<문제 2091>
찰리는 돈을 좀 가지고 있다. 그는 특히 동전에 관심이 좀 있어서 동전을 여러 개 가지고 있다. 그런데 동전이 자꾸 쌓여가자, 그는 처리에 곤란을 느끼고 이 동전들을 처분하기로 마음먹었다.
찰리는 1센트짜리 동전을 A개, 5센트(nickel)짜리 동전을 B개, 10센트(dime)짜리 동전을 C개, 25센트(quarter)짜리 동전을 D개 가지고 있다. 찰리는 이를 이용하여 X원짜리 커피를 사려 하는데, 이때 사용하는 동전의 개수를 최대로 하려 한다.
이러한 정보가 주어질 때, 사용하는 동전의 개수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 다섯 정수 X(1 ≤ X ≤ 10,000), A, B, C, D(0 ≤ A, B, C, D ≤ 10,000)가 주어진다.
<출력값>
첫째 줄에 답을 출력한다. Cent의 수, nickel의 수, dime의 수, quarter의 수를 출력한다. 불가능한 경우에는 0을 네 개 출력한다.

<문제 2092>
1부터 T(1 ≤ T ≤ 200)까지의 범위에 있는 수들이 총 A개 있다. 이들 중 K개를 골라서 집합을 만들 때, 가능한 집합의 개수를 세려 한다. 단, K의 범위는 1 ≤ S ≤ K ≤ B ≤ A로 한다. 즉, 두 정수 S, B를 입력받아서 K=S일 경우, …, K=B일 경우의 집합의 개수를 모두 더하려고 한다.
예를 들어 T=3, 수들이 1, 1, 2, 2, 3인 경우를 생각해 보면, 각기 다음의 경우가 있다.

K=1 : {1}, {2}, {3}
K=2 : {1, 1}, {1, 2}, {1, 3}, {2, 2}, {2, 3}
K=3 : {1, 1, 2} {1, 1, 3} {1, 2, 2} {1, 2, 3} {2, 2, 3}
K=4 : {1, 2, 2, 3} {1, 1, 2, 2} {1, 1, 2, 3}
K=5 : {1, 1, 2, 2, 3}

따라서 S=2, B=3일 경우의 답은 10이 된다.
우리가 일반적으로 이야기하는 집합은 같은 원소를 허용하지 않는다. 이 문제에서의 집합은 같은 원소가 없다는 사실 보다는, 집합의 각 원소들의 순서를 바꾸어도 같은 집합이라는 사실에 주목하여 풀도록 한다. 즉, {1, 1, 2}는 하나의 집합이고, {1, 2, 1}은 이와 같은 집합이다.
<입력값>
첫째 줄에 네 정수 T, A, S, B가 주어진다. 다음 줄에는 A개의 수가 차례로 주어진다. (1 ≤ A ≤ 4000)
<출력값>
첫째 줄에 답을 1,000,000으로 나눈 나머지를 출력한다.

<문제 2093>
알파벳 소문자, +, -, *(곱하기), /(나누기), 그리고 괄호로 이루어진 수식을 생각하자. 보다 엄밀하게, 그리고 귀납적으로 다음과 같이 정의할 수 있다.

알파벳 소문자들은 <문자>이다.
<항>, <수식>+<항>, <수식>-<항>은 모두 <수식>이다.
<인자>, <항>*<인자>, <항>/<인자>는 모두 <항>이다.
<문자>, (<수식>)은 모두 <인자>이다.

즉, 알파벳 소문자들이 <문자>인 것이고, <수식>에 괄호를 친 것들과 <문자>들이 <인자>인 것이고, <인자>들이 *나 /로 연결된 것들이 <항>인 것이고, <항>들이 +나 -로 연결된 것들이 <수식>인 것이다. 잘 따져보면 우리가 일반적으로 생각하는 수식들이 이 규칙에 꼭 맞게 들어맞는 것을 알 수 있다.
이러한 수식에서 최대한 많은 괄호를 제거하려 한다. 괄호를 제거하는 규칙들은 다음과 같다.

A, B가 <수식>인 경우, A+(B)는 A+B로 고칠 수 있다.
A, B가 <수식>인 경우, A-(B)는 A-C로 고칠 수 있다. C는 B에서 +와 -를 뒤바꿔야 하는 경우들을 뒤바꾼 것이다.
A, B가 <항>인 경우, A*(B)는 A*B로 고칠 수 있다.
A, B가 <항>인 경우, A/(B)는 A/C로 고칠 수 있다. C는 B에서 *와 /를 뒤바꿔야 하는 경우들을 뒤바꾼 것이다.

각 경우의 예제들은 다음과 같다.

a-g/h+(b+c-d+e*(f+h-i))는 a-g/h+b+c-d+e*(f+h-i)로 고칠 수 있다.
a-g/h-(b+c-d+e*(f+h-i))는 a-g/h-b-c+d-e*(f+h-i)로 고칠 수 있다.
x/(y+z)*(a*(b-c)/d/(e/f))는 x/(y+z)*a*(b-c)/d/(e/f)로 고칠 수 있다.
x/(y+z)/(a*(b-c)/d/(e/f))는 x/(y+z)/a/(b-c)*d*(e/f)로 고칠 수 있다.

당신은 이런 규칙들을 최대한 많이 적용하여, 최소 개수의 괄호만을 남기려고 한다. 수식이 주어졌을 때, 최소 개수의 괄호만 남아있는 수식을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 길이가 1,000을 넘지 않는 수식이 공백 없이 주어진다.
<출력값>
첫째 줄에 최소 개수의 괄호만 남아있는 수식을 공백 없이 출력한다.

<문제 2094>
기상청에서는 매 해마다 그 해에 내린 비의 양을 측정하여 발표하는데, 이를 그 해의 강수량이라 한다. 이를 토대로 사람들은 어느 해에 몇 년 만에 비가 가장 많이 왔다는 식의 이야기를 하곤 한다. 하지만 사람은 자신의 경험과 감각에 의존하여 이야기하기 때문에, 이러한 이야기가 때론 거짓이 되기도 한다. 따라서 당신은, 기상청의 공식적인 측정 결과를 바탕으로 이러한 이야기들의 진실 여부를 가려내려 한다. 때로는 기상청의 공식적인 발표 자료를 구할 수 없기 때문에, 참과 거짓을 가려내지 못하는 경우도 생길 수도 있다.
편의를 위해 사람들의 이야기를 “X년도에는 Y년도 이후 가장 많은 비가 내렸다”는 형태로 한정하기로 하자. 이러한 이야기는 다음의 조건들이 만족될 때 참이 된다.

Y년도, X년도, 그리고 그 사이의 모든 년도들의 강수량에 대한 정보가 알려져 있다.
X년도의 강수량은 Y년도의 강수량 이하이다.
Y < Z < X를 만족하는 모든 Z들에 대해서, Z년도의 강수량은 X년도보다 적다.

강수량에 대한 정보가 알려져 있지 않은 년도에 대해서 강수량을 잘 가정할 경우에 위의 세 조건이 만족된다면, 이러한 경우는 사람들의 이야기가 가능한 경우가 된다. 그 외의 경우는 거짓이 된다.
강수량에 대한 정보와 사람들의 이야기에 대한 정보가 주어졌을 때, 참, 가능, 거짓 여부를 가려내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 정수 n(1 ≤ n ≤ 50,000)이 주어진다. 다음 n개의 줄에는 두 정수 y(0 ≤ |y| ≤ 1,000,000,000), r(1 ≤ r ≤ 1,000,000,000)이 주어지는데, 이는 y년도의 강수량이 r이라는 의미이다. 이러한 정보는 y가 증가하는 순서대로 주어진다. 그 다음 줄에는 정수 m(1 ≤ m ≤ 10,000)이 주어진다. 그 다음 m개의 줄에는 사람들의 이야기에 대한 정보를 나타내는 두 정수 Y, X(-1,000,000,000 ≤ Y < X ≤ 1,000,000,000)가 주어진다.
<출력값>
m개의 줄에 각 사람들의 이야기에 대한 답을 출력한다. 참일 경우에는 true를, 가능할 경우에는 maybe를, 불가능한 경우에는 false를 출력한다.

<문제 2095>
N(1≤N≤30,000)개의 좌석으로 되어 있는 기차가 있다. 편의상 좌석에 1번부터 N번까지의 번호가 붙어있다고 하자. 철도 회사에서는 명절을 맞이하여 귀성하는 가족들에게 기차 티켓을 팔기로 하였다. 문제를 단순화하기 위해서, 편의상 모든 가족들은 L(1≤L≤100)명으로 이루어져 있다고 가정하자.
각 가족들은 다들 자신이 원하는 좌석이 있다. 즉, 각 가족들은 기차의 특정 좌석부터 연달아 L개의 좌석 티켓을 구매하려 한다. 이와 같이 구매하더라도 기차 티켓의 가격에는 차이가 없지만, 서비스에 만족한 고객들이 추후에 다시 기차를 이용할 가능성이 있기 때문에, 잠재적인 이익이 2만큼 발생하는 것으로 간주한다. 만약 가족에게 기차 티켓을 팔지 못하면 잠재적인 이익이 발생하지 않으며, 기차 티켓을 팔되 원하는 자리가 아닌 경우에는 잠재적 이익이 1이 된다.
각 가족들이 원하는 좌석이 주어졌을 때, 최대의 잠재적 이익을 구해내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 세 정수 N, L, M(1 ≤ M ≤ 100,000)이 주어진다. 다음 줄에는 M개의 정수 z(1 ≤ z ≤ N-L+1)가 주어진다. 이는 그 가족이 z번 좌석부터 z+L-1번 좌석까지를 구매하기를 원한다는 의미이다.
<출력값>
첫째 줄에 최대 잠재적 이익을 출력한다.

<문제 2096>
N줄에 0 이상 9 이하의 숫자가 세 개씩 적혀 있다. 내려가기 게임을 하고 있는데, 이 게임은 첫 줄에서 시작해서 마지막 줄에서 끝나게 되는 놀이이다.
먼저 처음에 적혀 있는 세 개의 숫자 중에서 하나를 골라서 시작하게 된다. 그리고 다음 줄로 내려가는데, 다음 줄로 내려갈 때에는 다음과 같은 제약 조건이 있다. 바로 아래의 수로 넘어가거나, 아니면 바로 아래의 수와 붙어 있는 수로만 이동할 수 있다는 것이다. 이 제약 조건을 그림으로 나타내어 보면 다음과 같다.

별표는 현재 위치이고, 그 아랫 줄의 파란 동그라미는 원룡이가 다음 줄로 내려갈 수 있는 위치이며, 빨간 가위표는 원룡이가 내려갈 수 없는 위치가 된다. 숫자표가 주어져 있을 때, 얻을 수 있는 최대 점수, 최소 점수를 구하는 프로그램을 작성하시오. 점수는 원룡이가 위치한 곳의 수의 합이다.
<입력값>
첫째 줄에 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 N개의 줄에는 숫자가 세 개씩 주어진다. 숫자는 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 중의 하나가 된다.
<출력값>
첫째 줄에 얻을 수 있는 최대 점수와 최소 점수를 띄어서 출력한다.

<문제 2097>
당신은 N개의 조약돌을 가지고 있다. 이 조약돌을 좌표평면의 격자점 위에 아무렇게나 떨어뜨렸다. 격자점이란, x좌표와 y좌표 모두가 정수인 지점을 말한다. 이를테면 (1, 1)이나 (0, -9)는 격자점이며, (-2, 3.5)이나 (π, 7.14)는 격자점이 아니다.
모든 조약돌을 포함하는 가장 작은 직사각형을 생각할 수 있다. 예를 들어 세 개의 조약돌을 (2,4), (4, 8), (5,5)에 떨어뜨렸다면, 이 세 조약돌을 모두 포함하는 가장 작은 직사각형은 가로 3, 세로 4인 직사각형이다. 이 경우 직사각형의 둘레는 14가 된다. 직사각형의 가로와 세로 길이는 반드시 1 이상이어야 한다.
조약돌의 개수 N이 주어졌을 때, 조약돌을 좌표평면의 격자점에 적절히 떨어뜨려서 모든 조약돌을 포함하는 직사각형의 둘레를 최소로 하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 조약돌의 개수 N(1≤n≤500,000,000)이 주어진다.
<출력값>
첫째 줄에 최소 둘레를 출력한다.

<문제 2098>
외판원 순회 문제는 영어로 Traveling Salesman problem (TSP) 라고 불리는 문제로 computer science 분야에서 가장 중요하게 취급되는 문제 중 하나이다. 여러 가지 변종 문제가 있으나, 여기서는 가장 일반적인 형태의 문제를 살펴보자.
1번부터 N번까지 번호가 매겨져 있는 도시들이 있고, 도시들 사이에는 길이 있다. (길이 없을 수도 있다) 이제 한 외판원이 어느 한 도시에서 출발해 N개의 도시를 모두 거쳐 다시 원래의 도시로 돌아오는 순회 여행 경로를 계획하려고 한다. 단, 한 번 갔던 도시로는 다시 갈 수 없다. (맨 마지막에 여행을 출발했던 도시로 돌아오는 것은 예외) 이런 여행 경로는 여러 가지가 있을 수 있는데, 가장 적은 비용을 들이는 여행 계획을 세우고자 한다.
각 도시간에 이동하는데 드는 비용은 행렬 W[i][j]형태로 주어진다. W[i][j]는 도시 i에서 도시 j로 가기 위한 비용을 나타낸다. 비용은 대칭적이지 않다. 즉, W[i][j] 는 W[j][i]와 다를 수 있다. 모든 도시간의 비용은 양의 정수이다. W[i][i]는 항상 0이다. 경우에 따라서 도시 i에서 도시 j로 갈 수 없는 경우도 있으며 이럴 경우 W[i][j]=0이라고 하자.
N과 비용 행렬이 주어졌을 때, 가장 적은 비용을 들이는 외판원의 순회 여행 경로를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 도시의 수 N이 주어진다. (2 ≤ N ≤ 16) 다음 N개의 줄에는 비용 행렬이 주어진다. 각 행렬의 성분은 1,000,000 이하의 양의 정수이며, 갈 수 없는 경우는 0이 주어진다. W[i][j]는 도시 i에서 j로 가기 위한 비용을 나타낸다.
항상 순회할 수 있는 경우만 입력으로 주어진다.
<출력값>
첫째 줄에 외판원의 순회에 필요한 최소 비용을 출력한다.

<문제 2099>
The game of death는 확률성과 함께 전략이 요구되는 게임인데, N명의 사람들이 원을 이루고 모여 앉은 후 시작된다. 사람들에게는 1번부터 N번까지 번호가 매겨져 있다고 하자.
각 사람은 자신의 양 손을 이용해서 동시에 두 명의 사람을 가리킨다. 자기 자신은 가리킬 수 없으나 자신이 가리키는 두 사람이 꼭 다를 필요는 없다. 그리고 첫 사람이 자연수 K를 하나 정한 뒤에, 자신의 가리키고 있는 두 사람 중 한 사람을 지목한다. 첫 번째로 지목된 사람은 마찬가지로 자신이 가리키고 있는 두 사람 중 한 사람을 지목한다. 마찬가지로 지목된 사람이 같은 방법으로 사람들 지목해 나가며, K번째로 지목된 사람이 걸리게 되는 게임이다.
예를 들어 N=4이고 K=2인 경우를 생각해 보자. 1번 사람은 2번과 4번 사람을 지목했고, 2번 사람은 1번과 3번을, 3번 사람은 1번과 4번을, 그리고 4번 사람은 2번과 2번을 지목했다고 하자. 4번 사람이 시작했을 때 1번이 걸릴 수 있으나, (4->2->1) 1번 사람이 시작했을 때는 4번 사람이 걸릴 수 없다.
N과 K, 그리고 각 사람이 지목한 두 사람에 대한 정보가 주어졌을 때, a번 사람이 시작했을 때 b번 사람이 걸리는 경우가 있는지 없는지를 알아내는 프로그램을 작성하시오. a와 b의 쌍은 M개 주어진다.
<입력값>
첫째 줄에 세 정수 N(2<=N<=200)과 K(1<=K<=1,000,000)와 M(1<=M<=1,000,000)이 주어진다. 다음 N개의 줄에 걸쳐 각 사람이 지목한 두 명의 사람이 번호로 주어진다. 다음 M개의 줄에 걸쳐 각 줄에 a와 b가 주어진다.
<출력값>
M개의 줄에, 입력받은 순서대로 a번 사람으로 시작해서 b번 사람이 걸리는 경우가 있으면 'death'를, 걸리게 할 수 없으면 'life'를 출력한다.

<문제 2100>
매우(거의 무한할 정도로) 큰 공장이 하나 있다. 이 공장은 벽으로 둘러싸인 사각형 모양을 하고 있다. 이 공장에는 N(1≤N≤100)개의 굴뚝이 있는데, 각각의 굴뚝들은 어떤 특정한 모양을 하고 있다. 몇 개의 굴뚝들은 서로 같은 모양을 하고 있기도 하다.
이 공장에서는 최신 기술을 이용한 개발이 진행되고 있는데, 이 기술의 보안을 유지하기 위해서 한 대의 감시 로봇을 사용하고 있다. 감시 로봇은 x축을 따라서 움직이게 되는데, 로봇의 위치가 어디인지를 알아야 할 필요가 있다. 그런데 로봇 안에 들어있는 위치 센서가 좋지 않을뿐더러, 건물의 크기가 매우 크기 때문에, 위치를 직접 알려주지는 못하고, 로봇이 굴뚝을 관찰한 순서가 주어지게 된다.
로봇은 우선 x축 위에서, 왼쪽(x좌표가 음의 무한대인 쪽)을 바라보고 서 있다. 그리고 로봇은 시계방향으로 오른쪽(x좌표가 양의 무한대인 쪽)까지 돌게 된다. 로봇은 돌면서 자신이 보게 되는 굴뚝의 모양을 차례대로 알려주게 된다. 모든 굴뚝들의 높이는 같기 때문에, 로봇이 보고 있는 방향에 여러 굴뚝이 있다면 제일 앞에 있는 굴뚝만을 보게 된다.
공장 측에서는 이와 같은 방법을 이용하면 로봇의 위치를 구해낼 수 있을 거라 생각했지만, 답이 유일하게 나오는 것이 아니라 여러 구간의 형태로 나옴을 알게 되었다. 따라서 공장 측에서는, 이와 같은 구간들을 구하려고 한다.
로봇이 굴뚝을 관찰한 순서와 각 굴뚝의 위치가 주어졌을 때, 로봇이 있을 수 있는 위치를 구해내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 굴뚝의 개수 N이 주어진다. 다음 줄에는 로봇이 굴뚝을 관찰한 순서대로 굴뚝의 모양이 주어진다. 건물에 없는 굴뚝을 본 경우나, 굴뚝을 N개 미만으로 본 경우는 입력으로 주어지지 않는다. 다음 N개의 줄에는 각 굴뚝의 모양을 나타내는 문자와, 굴뚝의 x(-100≤x≤100), y(0<y≤100)좌표가 주어진다. 굴뚝의 모양은 알파벳 대문자로 표현되며, 모든 좌표는 정수이다.
<출력값>
첫째 줄에 구간의 개수 K가 주어진다. 다음 K개의 줄에는 두 개의 실수로 구간의 왼쪽, 오른쪽 끝점을 출력한다. 건물의 크기는 매우 크다고(무한하다고) 가정하며, 건물의 양 끝점의 경우에는 좌표 대신에 *을 출력한다. 좌표를 출력할 때에는 소수점 아래 넷째 자리까지 출력한다(다섯째 자리에서 반올림)

<문제 2101>
회색조로 표현되는 이미지가 있다. 각 칸의 색깔은 0부터 255까지의 정수로 표현된다. 이러한 이미지를 흑백으로 근사시키려 한다. 이때 원래 그림과의 비슷한 정도를 나타내는 값이 이러한 근사 이미지의 에너지가 된다. 근사 이미지의 에너지는 다음과 같이 계산된다.

어떤 칸의 색깔이 X일 때, 그 칸을 흑색으로 근사시키면 에너지가 |X - A|가 된다.
어떤 칸의 색깔이 X일 때, 그 칸을 백색으로 근사시키면 에너지가 |X - B|가 된다.
어떤 칸의 색깔이 X이고, 그에 인접한 칸의 색깔이 Y이고, 두 칸을 서로 다른 색으로 근사시키면 에너지가 |X-Y|가 된다.

근사 이미지의 에너지는 이러한 에너지들의 총 합이 된다. 여기서 A, B(0≤A, B≤255)는 입력으로 주어지는 상수이다. 예를 들어 아래와 같은 2×2 크기의 이미지를 근사시킨 경우를 살펴보자. A=0, B=10이다.



3 (흑)
7 (백)


6 (백)
2 (흑)



이 경우, 우선 각 칸에 대해서 3+3+4+2의 에너지가 나오고, 인접해있는 칸들에 의해서 4+3+5+4의 에너지가 나온다. 따라서 이때의 에너지는 28이 된다. 하지만 모두 흑색으로 할 경우에는 18이 되고 이 경우가 최소의 에너지가 된다.
이미지가 주어졌을 때, 최소의 에너지를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 네 정수 n, m(1≤n, m≤20), A, B가 주어진다. 다음 n개의 줄에는 m개의 정수로 이미지가 주어진다.
<출력값>
첫째 줄에 최소 에너지를 출력한다.

<문제 2102>
수영이는 고대 유적을 탐사하던 도중 보석을 발견했다. 유적 속에는 N(1≤N≤100,000)개의 보석들이 일렬로 놓여 있었다. 각각의 보석의 가치는 다를 수 있기 때문에, 수영이는 가급적 많은 이득을 얻을 수 있도록 보석을 가져가려 한다. 이때, 다음 세 가지의 조건이 만족되어야 한다.

보석들과 함께 함정이 설치되어 있기 때문에 1번 보석이 놓여있는 곳부터, N번 보석이 놓여 있는 곳까지 순서대로 이동해야 한다. 물론 1번 보석부터 N번 보석까지가 차례로 놓여있다고 가정하며, 보석을 줍다가 도중에 뒤로 돌아갈 수 없는 것이다. 각각의 보석이 놓여 있는 위치에서 수영이는 두 가지 선택을 할 수 있는데, 그 자리에 있는 보석을 줍거나 줍지 않고 그 다음 보석이 놓여 있는 곳으로 이동하게 된다.
또한 보석들과 함께 경보 장치가 설치되어 있는데, 이 장치는 보석을 한 개 주우면 작동하게 된다. 보석을 한 개 더 줍게 되면 이 경보 장치는 유적을 무너뜨리도록 설계되어 있다. 단, 경보 장치를 속일 수 있는 방법이 있는데, M(1≤M≤N)개 이상의 연속적인 보석을 줍게 되면 경보 장치가 인식하지 못하게 된다. 따라서 보석을 줍기 시작하면 그 위치에 있는 보석을 포함하여 M개 이상의 보석을 연속적으로 주워야 하고, 줍기를 멈춘 후에는 다시 줍기 시작할 수 없다. 즉, 보석을 주울 기회는 오직 한 번 뿐이며, 보석을 주울 때에는 연속적으로 M개 이상 주워야 한다.
주운 보석들의 가치의 합이 크더라도, 보석의 개수가 많다면 무게가 많이 나가서 힘들 수도 있다. 물론, 보석들의 가치의 합이 충분히 크다면 무거움을 감수할 수도 있다. 따라서 수영이는 주운 보석들의 가치의 평균이 최대가 되도록 하려 한다.

보석들의 개수가 매우 많기 때문에, 수영이는 이 문제를 컴퓨터를 이용하여 풀기로 하였다. 보석들에 대한 정보가 주어졌을 때, 위의 조건들을 만족하면서 보석을 주울 때, 가치의 평균의 최댓값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 두 정수 N, M이 주어진다. 다음 N개의 줄에는 차례로 각 보석의 가치가 주어진다. 각 보석의 가치는 0이상 2,000이하의 정수이다.
<출력값>
첫째 줄에 가치의 평균의 최댓값을 1,000배 한 정수를 출력한다. 반올림 문제가 생길 수 있으므로, 정수 연산을 하여 1,000×(가치의 총 합)/(보석의 개수)을 출력하도록 한다.

<문제 2103>
직교다각형(orthogonal polygon)이란 모든 변이 x축이나 y축에 평행한 다각형을 말한다. 이러한 직교다각형은 직선으로 쭉 나가다가 꺾이는 형태의 모양을 하게 된다.
직교다각형의 모든 꼭짓점(꺾이는 점)들이 주어졌을 때, 직교다각형을 복원하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 점의 개수 N(1≤N≤100,000)이 주어진다. 다음 N개의 줄에는 각 점의 x, y(0≤x, y≤10,000)좌표가 주어진다. 이 점들은 직교다각형을 이루는 순서대로 주어지지 않을 수도 있으며, 같은 점이 여러 번 주어지지는 않는다. 하지만 항상 직교다각형을 이루는 형태만 입력으로 주어진다.
<출력값>
첫째 줄에 직교다각형의 길이를 출력한다.

<문제 2104>
크기가 N(1≤N≤100,000)인 1차원 배열 A[1], …, A[N]이 있다. 어떤 i, j(1≤i≤j≤N)에 대한 점수는, (A[i]+…+A[j])×Min{A[i], …, A[j]}가 된다. 즉, i부터 j까지의 합에다가 i부터 j까지의 최솟값을 곱한 것이 점수가 된다.
배열이 주어졌을 때, 최대의 점수를 갖는 부분배열을 골라내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 정수 N이 주어진다. 다음 줄에는 A[1], …, A[N]을 나타내는 정수들이 주어진다. 각각의 정수들은 음이 아닌 값을 가지며, 1,000,000을 넘지 않는다.
<출력값>
첫째 줄에 최대 점수를 출력한다.

<문제 2105>
양 손을 사용할 수 있는 박성원숭이 N마리가 나무에 매달려 있다. 1번 박성원숭이는 꼬리로 나뭇가지에 매달려 있고 다른 박성원숭이들은 다른 박성원숭이를 손에 붙들고 있거나/고 다른 박성원숭이들의 손에 붙들려 있다(붙들리면서 붙들 수도 있음). 그런데 이 박성원숭이들은 0초부터 매 초마다 어떤 박성원숭이하나가 왼손 혹은 오른손을 놓게 된다. 그렇게 되면 의지할 곳이 없는 박성원숭이들은 ‘즉시’ 바닥으로 떨어지게 된다. 우리는 각각의 박성원숭이들이 ‘언제’ 땅에 떨어지는지 알고 싶다. 물론 떨어지지 않는 박성원숭이(이를테면 1번 박성원숭이)들도 있을 수 있다.
<입력값>
첫 줄에 박성원숭이들의 수 N(1<=N<=200,000)과 박성원숭이들이 손을 놓게 되는 가짓수 M(1<=M<=400,000)이 주어진다. 다음 N개의 줄에 걸쳐서 각 박성원숭이의 ‘왼손’에 잡혀있는 다른 박성원숭이의 번호와(없을 경우 -1) ‘오른손’에 잡혀있는 박성원숭이의 번호(없을 경우 -1)가 각각 순서대로 주어진다. 다음 M개의 줄에 걸쳐서 손을 놓는 박성원숭이의 번호와 왼손을 놓는지 오른손을 놓는지 나타내는 숫자 1(왼손) 혹은 2(오른손)가 주어진다.
<출력값>
각 줄에 각 박성원숭이가 언제 땅에 떨어지는지 출력한다. 떨어지지 않는다면 -1을 출력한다.

<문제 2106>
저번에 붙잡힌 아기염소 사기도박단 멤버 중에는 특히 죄질이 무거운 흑염소가 있어, 그를 격리시켜서 다른 염소들과 떨어뜨려 놓으려고 한다. 평평한 언덕 위에는 직사각형 모양의 울타리가 N(1 <= N <= 250,000) 개 설치되어 있어서, 흑염소를 이 안으로 들여보내 감금시키고자 한다. 이 직사각형 모양의 울타리들은 서로 겹치거나 닿는 부분이 전혀 없다. 하지만 어떤 울타리가 다른 어떤 울타리 주변을 둘러싸는 형태는 존재할 수 있다.
흑염소는 매우 영리하고 탈출에 능하기 때문에 최대한 많은 울타리가 그를 둘러싸도록 해야 한다. 그를 언덕 위에 배치할 때, 얼마나 많은 울타리가 그를 둘러싸도록 할 수 있는지, 그리고 그러한 위치가 언덕에 몇 개나 있는지를 알고 싶다.
<입력값>
첫째 줄에 N이 들어온다.
둘째 줄부터 N+1줄까지 총 N줄에 울타리의 정보가 한 줄에 하나씩 들어온다. 울타리의 정보는 X1 Y1 X2 Y2의 형태로 주어지는데, 이는 울타리의 왼쪽 위 꼭짓점의 좌표와 오른쪽 아래 꼭짓점의 좌표를 나타낸다. 모든 좌표의 범위는 1 이상 1,000,000,000 이하의 정수이고, X1<X2이고 Y1<Y2이다.
<출력값>
첫째 줄에 두 개의 정수를 출력한다. 하나는 그를 둘러쌀 수 있는 최대 울타리 개수, 그리고 다른 하나는 그러한 위치의 개수이다.

<문제 2107>
수직선상에 N(1 <= N <=25,000)개의 구간이 있다. 구간의 양 끝점은 각각 정수 좌표 한 개로 나타내어진다. 구간은 겹칠 수 있고, 어떤 구간이 다른 구간을 완전히 포함할 수도 있지만, 모든 구간은 다른 구간과 서로 자신의 끝점을 공유하지 않는다. (하나의 위치는 최대 하나의 구간의 어떤 끝점만이 될 수 있다.) 어떤 한 구간이 다른 구간들을 최대한 많이 포함하고 있는 개수를 찾으시오.
      *-----------*
      |           |
*-----------*
|           |
| *-*   *-* |
| | |   | | |
1 2 3 4 5 6 7 8 9 10
구간들의 배치가 위와 같은 경우, 답은 1-7구간이 포함하고 있는 다른 구간의 개수 2(2-3구간, 5-6구간)이다.
<입력값>
첫째 줄에 N이 들어온다.
둘째 줄부터 N+1번째 줄까지 N개의 줄마다 각각 해당 구간을 나타내는 두 정수 A, B가 들어온다. (1 <= A < B <= 2,000,000,000)
<출력값>
어떤 한 구간이 다른 구간들을 최대한 많이 포함하고 있는 개수를 출력하시오.

<문제 2108>
수를 처리하는 것은 통계학에서 상당히 중요한 일이다. 통계학에서 N개의 수를 대표하는 기본 통계값에는 다음과 같은 것들이 있다. 단, N은 홀수라고 가정하자.

산술평균 : N개의 수들의 합을 N으로 나눈 값
중앙값 : N개의 수들을 증가하는 순서로 나열했을 경우 그 중앙에 위치하는 값
최빈값 : N개의 수들 중 가장 많이 나타나는 값
범위 : N개의 수들 중 최댓값과 최솟값의 차이

N개의 수가 주어졌을 때, 네 가지 기본 통계값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 수의 개수 N(1 ≤ N ≤ 500,000)이 주어진다. 그 다음 N개의 줄에는 정수들이 주어진다. 입력되는 정수의 절댓값은 4,000을 넘지 않는다.
<출력값>
첫째 줄에는 산술평균을 출력한다. 소수점 이하 첫째 자리에서 반올림한 값을 출력한다.
둘째 줄에는 중앙값을 출력한다.
셋째 줄에는 최빈값을 출력한다. 여러 개 있을 때에는 최빈값 중 두 번째로 작은 값을 출력한다.
넷째 줄에는 범위를 출력한다.

<문제 2109>
한 저명한 학자에게 n(0 ≤ n ≤ 10,000)개의 대학에서 강연 요청을 해 왔다. 각 대학에서는 d(1 ≤ d ≤ 10,000)일 안에 와서 강연을 해 주면 p(1 ≤ p ≤ 10,000)만큼의 강연료를 지불하겠다고 알려왔다. 각 대학에서 제시하는 d와 p값은 서로 다를 수도 있다. 이 학자는 이를 바탕으로, 가장 많은 돈을 벌 수 있도록 순회강연을 하려 한다. 강연의 특성상, 이 학자는 하루에 최대 한 곳에서만 강연을 할 수 있다.
예를 들어 네 대학에서 제시한 p값이 각각 50, 10, 20, 30이고, d값이 차례로 2, 1, 2, 1 이라고 하자. 이럴 때에는 첫째 날에 4번 대학에서 강연을 하고, 둘째 날에 1번 대학에서 강연을 하면 80만큼의 돈을 벌 수 있다.
<입력값>
첫째 줄에 정수 n이 주어진다. 다음 n개의 줄에는 각 대학에서 제시한 p값과 d값이 주어진다.
<출력값>
첫째 줄에 최대로 벌 수 있는 돈을 출력한다.

<문제 2110>
도현이의 집 N개가 수직선 위에 있다. 각각의 집의 좌표는 x1, ..., xN이고, 집 여러개가 같은 좌표를 가지는 일은 없다.
도현이는 언제 어디서나 와이파이를 즐기기 위해서 집에 공유기 C개를 설치하려고 한다. 최대한 많은 곳에서 와이파이를 사용하려고 하기 때문에, 한 집에는 공유기를 하나만 설치할 수 있고, 가장 인접한 두 공유기 사이의 거리를 가능한 크게 하여 설치하려고 한다.
C개의 공유기를 N개의 집에 적당히 설치해서, 가장 인접한 두 공유기 사이의 거리를 최대로 하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 집의 개수 N (2 ≤ N ≤ 200,000)과 공유기의 개수 C (2 ≤ C ≤ N)이 하나 이상의 빈 칸을 사이에 두고 주어진다. 둘째 줄부터 N개의 줄에는 집의 좌표를 나타내는 xi (0 ≤ xi ≤ 1,000,000,000)가 한 줄에 하나씩 주어진다.
<출력값>
첫째 줄에 가장 인접한 두 공유기 사이의 최대 거리를 출력한다.

<문제 2111>
나무(tree, 트리)란 연결된 무향 그래프의 일종으로, 모든 간선이 어떤 사이클에도 속하지 않는 그래프이다. 이와 비슷하게, 선인장이란 연결된 무향 그래프의 일종으로, 모든 간선이 최대 한 개의 사이클에만 속할 수 있는 그래프이다.
선인장과 나무의 차이점 중 하나는, 선인장의 스패닝 서브그래프를 택했을 때 선인장이 되는 경우가 여럿 있다는 것이다(트리의 스패닝 서브트리는 자기 자신 한 개 뿐이다). 스패닝 서브그래프란 주어진 그래프의 서브그래프의 일종으로, 모든 정점들이 연결되는 경우를 의미한다. 당신은 이러한 스패닝 서브그래프(원래 그래프 자신도 포함)의 개수를 알아내려 한다.

예를 들어, 위와 같은 그래프의 경우에는 35개의 스패닝 서브그래프가 선인장이 된다.
선인장이 주어졌을 때, 스패닝 서브선인장의 개수를 구해내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 두 정수 N(1≤N≤20,000), M(0≤M≤1,000)이 주어진다. 이는 그래프의 정점이 N개라는 의미이다. 선인장의 간선들은 서로 다른 간선들로 이루어진 경로로 표현되는데, M이 그 경로의 개수이다. 각 줄의 첫 번째 정수는 경로에 포함된 정점의 개수이다. 여러 경로에서 하나의 정점이 여러 번 나타날 수는 있지만, 한 간선은 입력 파일 전체에 딱 한 번만 나타난다.
<출력값>
첫째 줄에 답을 출력한다. 만약 선인장이 아닌 경우에는 0을 출력한다.

<문제 2112>
문자열 A의 부분 문자열이란, A에 속하는 하나 또는 그 이상의 문자(연속하지 않아도 된다)를 이용해서 만든 새로운 문자열이다. 이때, A에서의 순서를 그대로 유지해야 된다.
두 문자열 A와 B가 주어진다. 이때, A의 부분 문자열이면서, B의 부분 문자열이 아닌 가장 짧은 부분 문자열을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 문자열 A, 둘째 줄에 문자열 B가 주어진다. 문자열은 알파벳 소문자로만 이루어져 있고, 길이는 1000보다 작거나 같다. 항상 정답이 존재하는 경우만 입력으로 주어진다.
<출력값>
첫째 줄에 A의 부분 문자열이면서, B의 부분 문자열이 아닌 가장 짧은 부분 문자열의 길이를 출력한다.

<문제 2114>
최근에 개장한 동물원에 새로 사자 우리를 신축할 계획이다. 우리는 직각 다각형 모양을 이룬다. 직각 다각형이라는 것은 모든 변이 x축이나 y축에 평행 또는 일치하는 단순 다각형을 말한다. 한 변은 유리로 만들어 속이 들여다보이도록 하고, 나머지는 모두 콘크리트로 만들 예정이다. 이는 여름에는 사자들이 우리 바깥에 있어서 관람하는데 지장이 없지만, 겨울에는 사자가 우리 안에 있어서 유리벽면을 통하여 관람할 수 있도록 하기 위함이다. 아래 그림에서 실선은 콘크리트로, 그리고 점선은 유리로 설치한 변을 나타낸다.

사자 우리를 나타내는 직각 다각형과 유리로 설치한 한 변이 주어질 때, 유리변의 어느 위치에서든지 들여다볼 수 있는 내부 영역을 찾는 프로그램을 작성하시오. 물론 관람자가 유리 벽면을 따라 움직이면 더 많은 영역을 볼 수 있겠지만, 어느 위치에서든지 볼 수 있는 영역을 찾는 것임에 유의한다. 우리 내부에 장애물은 없다고 가정한다.
<입력값>
첫째 줄에 우리를 나타내는 직각 다각형의 꼭짓점의 수 n(4<=n<=10,000)이 주어진다. 둘째 줄부터 마지막 줄까지 개의 줄에는 한 줄에 하나씩 사자 우리를 나타내는 직각 다각형의 꼭짓점의 x, y좌표가 반시계방향으로 주어진다. 유리로 설치한 변은 입력된 첫째 점과 둘째 점을 잇는 변이다. 꼭짓점의 좌표는 모두 정수이고 절댓값이 10,000을 넘지 않는다. 입력되는 정수들 사이에는 빈칸이 하나 이상 있다.
<출력값>
유리 벽면의 어느 위치에서든 보이는 내부 영역을 나타내는 다각형의 둘레의 길이를 소수 둘째 자리까지 반올림하여 출력한다. 0도 반드시 출력해야 한다. (ex. 25.00, 8.70 등)

<문제 2115>
갤러리의 지도는 M*N의 정사각형 격자로 표현될 수 있다. 어떤 정사각형들은 벽으로 구성되어 있고, 다른 정사각형들은 빈 공간으로 구성되어 있다. 벽을 회색, 빈 공간을 흰색으로 표현하면 다음 그림과 같다.

갤러리에 그림을 걸려고 한다. 그림의 길이는 정사각형의 변의 길이의 두 배이다. 반드시 빈 공간과 인접해 있는 벽에만 그림을 걸 수 있으며, 그림들은 서로 겹칠 수 없다. 갤러리의 맵이 주어졌을 때, 최대로 걸 수 있는 그림의 개수를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 갤러리의 세로 길이 M과 가로 길이 N이 주어진다. (1<=M, N<=1,000) 다음 M개의 줄에는 각각 N개의 문자가 주어진다. 문자는 'X' 또는 '.'이며 'X'는 벽을, '.'는 빈 공간을 나타낸다.
  입력되는 모든 데이터에서 적어도 첫 줄과 마지막 줄, 첫 열과 마지막 열은 모두 벽이다.
<출력값>
최대 그림 개수를 출력한다.

<문제 2116>
천수는 여러 종류의 주사위를 가지고 쌓기 놀이를 하고 있다. 주사위의 모양은 모두 크기가 같은 정육면체이며 각 면에는 1부터 6까지의 숫자가 하나씩 적혀있다. 그러나 보통 주사위처럼 마주 보는 면에 적혀진 숫자의 합이 반드시 7이 되는 것은 아니다.
주사위 쌓기 놀이는 아래에서부터 1번 주사위, 2번 주사위, 3번 주사위, … 의 순서로 쌓는 것이다. 쌓을 때 다음과 같은 규칙을 지켜야 한다: 서로 붙어 있는 두 개의 주사위에서 아래에 있는 주사위의 윗면에 적혀있는 숫자는 위에 있는 주사위의 아랫면에 적혀있는 숫자와 같아야 한다. 다시 말해서, 1번 주사위 윗면의 숫자는 2번 주사위 아랫면의 숫자와 같고, 2번 주사위 윗면의 숫자는 3번 주사위 아랫면의 숫자와 같아야 한다. 단, 1번 주사위는 마음대로 놓을 수 있다.
이렇게 쌓아 놓으면 긴 사각 기둥이 된다. 이 사각 기둥에는 4개의 긴 옆면이 있다. 이 4개의 옆면 중에서 어느 한 면의 숫자의 합이 최대가 되도록 주사위를 쌓고자 한다. 이렇게 하기 위하여 각 주사위를 위 아래를 고정한 채 옆으로 90도, 180도, 또는 270도 돌릴 수 있다. 한 옆면의 숫자의 합의 최댓값을 구하는 프로그램을 작성하시오.
<입력값>
첫줄에는 주사위의 개수가 입력된다. 그 다음 줄부터는 한 줄에 하나씩 주사위의 종류가 1번 주사위부터 주사위 번호 순서대로 입력된다. 주사위의 종류는 각 면에 적혀진 숫자가 그림1에 있는 주사위의 전개도에서 A, B, C, D, E, F 의 순서로 입력된다. 입력되는 숫자 사이에는 빈 칸이 하나씩 있다. 주사위의 개수는 10,000개 이하이며 종류가 같은 주사위도 있을 수 있다.
<출력값>
첫줄에 한 옆면의 숫자의 합이 가장 큰 값을 출력한다.

<문제 2117>
N(1≤n≤32767)명의 사람들이 잔치에서 춤을 추게 되었다. 처음에는 1번부터 N번까지의 사람들이 차례대로, 둥글게 손을 잡고 서 있다. 그리고 춤이 끝날 때에는 이 순서가 반대(거꾸로, 뒤집힌)가 되어야 한다. 물론 사람들이 모두 손을 놓고 다시 자리를 잡으면 되겠지만, 그렇게 하면 둥그런 모양이 깨지게 된다. 따라서 자리를 바꿀 때에는, 서로 손을 잡고 있는 두 명의 사람만 자리를 바꿀 수 있다.
예를 들어 n=6인 경우를 보자. 맨 처음의 순서는 (1 2 3 4 5 6)이 된다. 둥글게 서 있기 때문에 1번과 6번도 손을 잡고 있다. 이제 (1 2 3 4 5 6) -> (6 2 3 4 5 1) -> (2 6 3 4 5 1) -> (1 6 3 4 5 2) -> (1 6 3 5 4 2) -> (1 6 5 3 4 2) -> (1 6 5 4 3 2)의 순서대로 바꾸면 자리가 반대가 된다. (6 5 4 3 2 1)이 되는 게 맞겠지만, 어차피 둥글게 서 있기 때문에 (1 6 5 4 3 2)와 같은 경우도 순서는 반대가 되는 게 맞다.
가급적이면 자리를 최소로 바꾸려고 한다. 최소로 자리를 바꾸려면 어떻게 해야 할까?
<입력값>
첫째 줄에 n이 주어진다.
<출력값>
첫째 줄에 최소 자리바꿈 회수를 출력한다.

<문제 2118>
1번부터 N번까지의 지점이 있다. 각각의 지점들은 차례로, 그리고 원형으로 연결되어 있다. 이 지점들 중 두 곳에 두 개의 탑을 세우려고 하는데, 두 탑의 거리가 최대가 되도록 만들려고 한다.
지점들이 원형으로 연결되어 있기 때문에, 두 지점 사이에는 시계방향과 반시계방향의 두 경로가 존재한다. 두 지점 사이의 거리를 잴 때에는, 이러한 값들 중에서 더 작은 값을 거리로 한다.
연결되어 있는 두 지점 사이의 거리가 주어졌을 때, 두 탑의 거리의 최댓값을 계산하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 지점의 개수 N(2≤N≤50,000)이 주어진다. 다음 N개의 줄에는 차례로 두 지점 사이의 거리가 정수로 주어진다. 전체 거리의 총 합은 1,000,000,000을 넘지 않는다.
<출력값>
첫째 줄에 답을 출력한다.

<문제 2119>
다음과 같은 가상의 프로그래밍 언어 L이 있다.

L 프로그램의 각 줄은 순서대로 1부터 N(1≤N≤100,000)의 번호가 붙어 있다.
각 줄에는 정확히 한 개의 명령어만 들어간다.
프로그램은 첫 번째 줄부터 수행된다.
가능한 명령은 ifgo, jump, pass, loop, die의 다섯 가지만 있다.
각 줄을 수행할 때마다 그 줄의 번호가 출력된다. 그 명령이 입력을 받는 명령일 경우에도 줄 번호가 먼저 출력된다.
ifgo 명령은 다른 명령의 줄 번호를 의미하는 한 개의 인자를 갖는다. 이 명령을 수행하면 한 비트의 입력을 받는다. 만약 입력이 1이면 명령에 지시된 줄 번호로 이동한다. 만약 입력이 0이면 다음 줄로 이동한다.
jump 명령은 다른 명령의 줄 번호를 의미하는 한 개의 인자를 갖는다. 이 명령을 수행하면 명령에 지시된 줄 번호로 이동한다.
pass 명령은 인자가 없는 명령이다. 이 명령을 수행하면 아무 것도 하지 않고, 줄 번호만 출력한 다음에 다음 줄로 이동한다.
die 명령은 인자가 없는 명령이다. 이 명령을 수행하면 줄 번호를 출력한 다음에 프로그램이 끝난다. 이 명령은 반복문 안에서는 사용되지 않는다.
loop 명령은 반복문을 수행할 때 사용되는데, 두 개의 인자 l, c를 갖는다. l은 반복문이 시작되는 줄 번호이고, c는 반복 회수이다. l은 항상 loop 명령이 있는 줄 번호보다 작은 값을 갖는다. 이 명령을 수행하면 l번째 줄부터 loop 명령이 있는 줄까지를 c-1번 수행한다. 반복문이 끝난 다음에는 그 다음 줄로 이동한다.
ifgo, jump 명령은 그 명령이 있는 반복문의 범위에서만 이동할 수 있다. 즉, 두 명령이 반복문 안에 있는 경우, 그 반복문의 범위 밖으로 이동할 수 없다. 또한, 반복문 안에 두 명령어가 있고, 그 다음 줄에 또다른 반복문이 있는 경우, 안쪽 반복문 안으로 이동할 수는 없다. 예를 들면 다음과 같은 경우는 잘못된 프로그램이다.
반복문 안에 반복문이 들어갈 경우, 안쪽 반복문이 바깥쪽 반복문에 완전히 포함되어야 한다. 즉, 안쪽 반복문의 시작 줄 번호가 바깥쪽 반복문의 시작 줄 번호보다 커야 한다(같은 경우도 안 됨). 그 외의 형태로 두 반복문이 겹치는 경우는 없다.
프로그램의 제일 마지막 줄이 수행되었을 때, 그 명령이 die가 아닌 경우 프로그램은 첫 번째 줄부터 다시 수행된다.
프로그램을 알아보기 쉽게 하기 위해 각 줄에 스페이스나 탭이 여러 개 들어갈 수도 있다.
각 줄의 최대 길이는 스페이스나 탭을 포함하여 80자를 넘지 않는다.

L로 짠 프로그램이 주어졌을 때, 그 프로그램이 최대 몇 번이나 줄 번호를 출력하는지 계산하는 프로그램을 작성하시오. Ifgo 명령의 경우, 입력값에 따라서 출력 회수가 변할 수 있는데, 출력 회수가 최대가 되는 입력이 주어진다고 가정한다.
<입력값>
첫째 줄에 N이 주어진다. 다음 N개의 줄에 L 프로그램이 첫째 줄부터 차례대로 주어진다.
<출력값>
첫째 줄에 최대 출력 회수를 출력한다. 답은 항상 1,000,000,000이하이며, 이를 넘어가는 경우는 무한 번 수행되는 경우로 infinity를 출력하도록 한다.

<문제 2120>
셋이서 할 수 있는 재미있는 놀이가 있다. 2차원 평면상에 있는 N개의 점 중 3개를 적절히 선택해서 정수 길이의 변을 가진 직각 삼각형들을 찾는 놀이이다.
이를 테면, 점이 (0,0) (3,0) (3,4) (0,4)의 4개가 있고, 각 변의 길이가 (3,4,5)인 직각 삼각형을 찾는다면 총 4가지 조합으로 직각 삼각형을 만들 수 있을 것이다.
<입력값>
첫 줄에 점의 수 N(1<=N<=500,000)과 직각 삼각형의 세 변의 길이 A, B, C(1<=A<B<C)가 모두 정수로 주어진다. 다음 N줄에 걸쳐서 점들의 좌표가 주어지는데 좌표 값의 범위는 -1,000,000,000 이상 1,000,000,000이하이다. 항상 C2 = A2 + B2인 올바른 입력이 주어진다. N개 점들의 좌표는 모두 다르다.
<출력값>
가능한 모든 경우의 수를 출력한다.

<문제 2121>
네 사람이서 2차원 평면상의 N개의 점을 이용해서 할 수 있는 놀이가 있다. 바로 각 사람이 1개씩의 점을 적절히 선택해서 변이 x축 혹은 y축에 평행한 직사각형을 만드는 일이다. 물론 그냥 만들면 재미가 없기 때문에 가로의 길이가 A 세로의 길이가 B인 직사각형을 몇 가지나 만들 수 있는지 알아보기로 했다.
예를 들어 점이 A(0,0) B(2,0) C(0,3) D(2,3) E(4,0) F(4,3)의 6개가 있고, 만들고 싶은 직사각형이 가로가 2, 세로가 3인 직사각형이라면 (A,B,C,D) (B,D,E,F)의 두 가지 경우가 가능하다. 모든 경우의 수를 구해보자.
<입력값>
첫 줄에 점들의 개수 N(5<=N<=500,000)이 주어진다. 둘째 줄에 만들고 싶은 직사각형의 가로 길이 A와 세로 길이 B가 주어진다. 다음 N줄에 걸쳐서 점들의 좌표가 정수로 주어진다. 이 값의 범위는 -1,000,000,000이상 1,000,000,000이하이다. N개 점들의 좌표는 각각 다르다.
<출력값>
첫 줄에 가능한 모든 경우의 수를 출력한다. 이 수는 int 범위 이내이다.

<문제 2122>
사람들이 N명 있다. 이 중 여섯 명을 뽑아서 둥글게 둥글게 놀이를 하려고 한다. 단 서로 손을 잡아야 하기 때문에 이 여섯 명은 둥글게 섰을 때 서로 양쪽에 있는 사람을 알고 있어야 한다. 또 같은 여섯 명일지라도 그 순서에 따라서 다른 둥그런 모양이 될 수 있다. 하지만 시계방향과 반시계방향으로 순서가 반대인 경우에는 같은 경우로 생각한다. 이를테면, (1-2-3-4-5-6-1)과 (1-6-5-4-3-2-1)의 경우는 한 가지로 친다. 하지만 순서가 달라지는 (1-2-3-4-5-6-1)과 (1-2-4-3-5-6-1)은 다른 경우로 친다.
우린 몇 가지 방법으로 둥글게 둥글게 놀이를 할 수 있을지 궁금하다. 가능한 가짓수를 모두 구해보자.
<입력값>
첫 줄에 후보들의 수 N(6<=N<=150)이 주어진다. 그리고 서로 아는지에 관한 관계가 인접행렬로 주어진다. A가 B를 알면 물론 B도 A를 안다.
<출력값>
첫 줄에 가능한 모든 경우의 수를 출력한다. 단, 답이 클 수 있으므로 9901로 나눈 나머지를 출력한다.

<문제 2123>
N (1 <= N <= 50,000) 명의 곡예사들로 인간 탑을 쌓으려고 한다. 한 사람이 한 층을 이루게 되어, 탑은 총 N층이 된다. 어떤 층에 있는 사람은 그보다 높은 층에 있는 모든 사람들의 몸무게의 합만큼을 견뎌야 한다.
각각의 곡예사들은 두 가지 정보로 나타내어지는데, 하나는 몸무게 (1 <= W_i <= 10,000) 이고, 다른 하나는 버티는 힘 (1 <= S_i <= 1,000,000,000) 이다. 그리고 어떤 탑이 있을 때, 각각의 곡예사들에 대해 위험도를 계산할 수 있는데, 이는 (그보다 높은 층에 있는 모든 사람들의 몸무게의 합) - (그의 버티는 힘) 과 같다. 각각의 곡예사들의 위험도들 중에서 가장 큰 값을 최대 위험도라고 한다.
탑 쌓기에 참여하는 곡예사들이 정해졌을 때, 이들을 쌓는 방법은 여러 가지가 있을 수 있다. 그 중 최대 위험도의 가능한 최솟값을 구하시오.
<입력값>
첫째 줄에 N이 들어온다.
둘째 줄부터 N+1번째 줄까지 N개의 줄이 차례대로 들어온다. 각 줄에서는 두 정수 W_i, S_i가 공백으로 구분되어 들어온다.
<출력값>
첫째 줄에 가능한 최대 위험도의 최솟값을 출력한다.

<문제 2124>
A×B×C(1≤A≤20, 1≤B, C≤6) 크기의 삼차원 공간이 있다. 이는 밑면의 넓이가 A×B 크기의 직사각형이고, 높이 제한이 C라는 의미이다. 이러한 공간 안에 1×1×1 크기의 블록을 쌓으려고 한다. 이때 다음의 두 조건이 만족되어야 한다.
(1) 어떤 칸에 블록을 쌓을 때에, 그 칸의 왼쪽 칸보다 높게 쌓을 수는 없다.
  (2) 어떤 칸에 블록을 쌓을 때에, 그 칸의 위쪽 칸보다 높게 쌓을 수는 없다.
예를 들어서 A=3, B=5, C=5일 때, 다음과 같은 식으로 블록을 쌓을 수 있다. 각 칸은 그 왼쪽 칸과 위쪽 칸 이하의 높이로 블록을 쌓았다. 아래의 예에서도 확인할 수 있듯, 블록을 쌓지 않는 칸이 있을 수도 있다.

A, B, C가 주어졌을 때, 블록을 쌓는 경우의 수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 세 정수 A, B, C가 주어진다.
<출력값>
첫째 줄에 답을 1,000,000,000,000,000,000으로 나눈 나머지를 출력한다.

<문제 2125>
좀은 옷(천으로 된)을 좀먹고 사는 벌레이다. 한 마리의 좀이 천으로 된 옷감 위에 놓여있다. 좀은 매우 작기 때문에, 천의 크기는 무한한 것으로 가정한다. 또, 천의 곳곳에는 다른 재질의 옷감으로 기워져 있는 부분이 N군데 있다. 기워져 있는 부분은 항상 볼록다각형 모양을 이루고 있는데, 이러한 볼록다각형들이 서로 닿아 있거나 겹쳐져 있을 수도 있다.
이 좀은 어떤 특정한 위치(옷감 위의)로 이동하려 하는데, 옷감을 좀먹으며 이동해야 하기 때문에 천으로 된 부분만을 지나며 이동해야 한다. 다른 재질의 옷감으로 기울 때에는 천으로 된 실을 사용했기 때문에, 기워져 있는 부분의 테두리(볼록다각형의 각 변들)는 지날 수 있다고 가정하자. 만약 두 볼록다각형의 변이 맞닿아 있는 부분이 있다면, 이러한 부분 역시 지날 수 있다고 하자. 하지만 실제로 기워진 부분 위(볼록다각형의 내부)는 절대로 지날 수 없다.
좀이 목적지까지 이동할 때의 최소 거리를 구해내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 다섯 정수 N, X, Y, U, V가 주어진다. 이는 좀의 현재 위치가 (X, Y)이고, 이동하려는 곳이 (U, V)라는 의미이다. 다음 N개의 줄에는 기워진 부분들을 의미하는 볼록다각형이 주어진다. 각 줄에 처음에는 볼록다각형의 꼭짓점의 개수 M이 주어지고, 그 다음 M개의 점들의 x, y좌표가 차례로 주어진다. 모든 볼록다각형의 꼭짓점의 합은 300을 넘지 않으며, 모든 좌표는 -10,000이상 10,000이하의 정수이다.
<출력값>
첫째 줄에 답을 출력한다. 절대/상대 오차는 10-3까지 허용한다. 만약 이동할 수 없다면 -1을 출력한다.

<문제 2126>
N(4≤N≤400)개의 정점과 M(1≤M≤10,000)개의 양방향 간선들이 있다. 그런데 지진이 일어나서 모든 간선들이 끊어져 버렸다. 이제 이 간선들 중 몇 개를 복원하여 임의의 정점에서 다른 임의의 정점으로 이동하는 경로가 존재하도록 만들려고 한다.
복원 비용으로는 F(1≤F≤2,000,000,000)원이 주어져 있다. 각각의 간선들에는 그 간선을 복원하는데 걸리는 시간 t(1≤t≤2,000,000,000)와 그 간선을 복원하는데 필요한 비용 c(1≤c≤2,000,000,000)가 필요하다. 두 정점을 잇는 간선을 복원하는 방법이 여러 가지일 수 있어서, 같은 간선인데 복원 비용이나 시간이 다를 수 있다. 복원 비용이 F를 넘게 되더라도, 복원하는 방법은 항상 존재하도록 입력이 주어진다.
간선들을 복원했을 때, 시간당 얻게 되는 이득이 최대가 되도록 하는 방법을 찾으라.
<입력값>
첫째 줄에는 세 정수 N, M, F가 주어진다. 다음 M개의 줄에는 간선의 정보를 나타내는 i, j, c, t가 주어진다. i, j는 정점의 번호이고, c는 비용, t는 시간이다.
<출력값>
첫째 줄에 시간당 얻게 되는 최대의 이득을 소숫점 아래 넷째 자리까지 출력한다. 만약 이득이 양수가 아니면 0.0000을 출력한다.

<문제 2127>
From time to time, customers of the First Goldfields Bank of Pembroke make dramatic errors with their banking transactions. For example, they might add an extra zero and transfer \$10,000 to someone else when they only intended to transfer \$1,000. The bank theorises that this is related to the large sums of money and large drinking budgets associated with a successful goldfield, and plans to introduce transaction limits to detect and prevent serious errors.
Each transaction is a request to transfer an amount of money from one account to another. There are two different kinds of transactions: if the transfer is between two accounts owned by the same customer, then it is an inter-account transfer (IAT); otherwise, when transferring money to someone else’s account, the transaction is known as a payment.
The bank has invited each customer to specify a maximum instruction limit and a daily exposure limit for each kind of transaction, with the expectation that most customers will want to set higher limits for inter-account transfers than for general payments.
These limits are applied as follows:

A transaction will fail if its value exceeds the applicable maximum instruction limit.
A transaction will fail if the applicable daily exposure limit is exceeded when its value is added to the total value of the customer’s previously successful transactions of the same kind that day. (But later transactions might succeed if they are for smaller amounts.)

Your task is to write the program to enforce these limits.
<입력값>
Each line of the input file is a banking record, consisting of a number of fields separated by commas (‘,’). There are four types of banking record, distinguished by the first field:

'1’ records are customer records, which have six fields. The second field is the customer name, consisting of exactly eight uppercase letters. The remaining fields are amounts; from left to right they are the customer’s IAT maximum instruction limit, IAT daily exposure limit, general payment maximum instruction limit, and general payment daily exposure limit.
‘2’ records are account records, which have three fields. The third field is the account number, consisting of exactly six digits (‘0’ to ‘9’). These records specify that the account is owned by the customer named by the second field.
‘5’ records are instruction records and have a total of six fields, representing a transaction. The second through sixth fields are: the date of the transaction, in the format YYYYMMDDhhmmss; the customer making the transaction; the source account (from which the money is to come); the amount; and the destination account.
The ‘9’ record terminates the input file, and has just one field.

All amounts in the input data are dollars and cents values written with a decimal point (‘.’) and two cents digits (but no commas), with a maximum value of \$9,999,999.99. All ‘1’ records appear before all ‘2’ records, which appear before all ‘5’ records, which appear before the ‘9’ record.
All customer names appearing in ‘2’ or ‘5’ records will be valid customers who have been listed in exactly one ‘1’ record, and all account numbers appearing in ‘5’ records will be valid accounts which have been listed in exactly one ‘2’ record. Furthermore, the ‘5’ records will appear in increasing datestamp order. There will be no more than 50 customers and 200 accounts.
The bank does not accept transactions between 23:00 and 06:00, believing that customers will be more than usually impaired during these periods—especially at weekends. Hence such times do not appear in the input file.
<출력값>
Output must contain one line for each input ‘5’ record, starting with ‘INSTRUCTION n: ’, where n is the instruction number (starting from 1), followed by one of the following messages, as appropriate:
‘NOT OWNER’ if the source account is not owned by the customer;
‘IAT MAX EXCEEDED’ or ‘PAYMENT MAX EXCEEDED’ if the transaction amount exceeds the applicable maximum instruction limit;
‘IAT DEL EXCEEDED’ or ‘PAYMENT DEL EXCEEDED’ if the transaction amount would cause the applicable daily exposure limit to be exceeded;
or ‘IAT OK’ or ‘PAYMENT OK’ if the transaction is successful.
If a transaction fails both limit tests, output only the ‘. . . MAX EXCEEDED’ message.

<문제 2128>
학생들은 지금 치르고 있는 모의고사가 마지막일 것으로 생각하고 있겠지만, 모의고사가 끝난 뒤에는 사실 마지막 조별 시합이 있다. 마지막 조별 시합에서는 A조와 B조의 두 개의 조로 나뉘어 시합을 하게 되는데, 이번에는 각 학생들이 잘 푸는 알고리즘 문제에 따라서 조를 나누기로 하였다.
학생들은 총 N(1≤N≤1,000)명이 있고, 알고리즘 문제의 종류는 D(1≤D≤15)종류이다. 조를 나눌 때에는 학생들의 점수가 어느 정도가 되도록 해야 하기 때문에, A조 학생들이 풀 수 있는 서로 다른 문제들의 총 가짓수가 K(1≤K≤D)개 이하가 되도록 하려 한다. 이 기준을 만족하도록 A조를 뽑고, 나머지 학생들을 B조에 넣으려 한다. 조별 시합에서는 조별 토론 시간이 있기 때문에, 그 조에 있는 학생들 중 한 명이라도 문제를 풀 수 있으면 나머지 학생들도 문제를 풀 수 있게 된다.
이러한 조건으로는 A조와 B조의 우열을 바로 알기 힘들기 때문에, 우선 A조가 최대 몇 몇까지 가능한지를 알아보려 한다. 학생들에 대한 정보가 주어졌을 때, A조의 최대 인원수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 세 정수 N, D, K가 주어진다. 다음 N개의 줄에는 차례로 1번 학생부터 N번 학생까지의 정보가 주어진다. 각 줄의 첫 번째 정수는 그 학생이 풀 수 있는 알고리즘 문제의 개수이고, 다음에는 그 학생이 풀 수 있는 알고리즘 문제들의 번호가 주어진다. 알고리즘 문제들의 번호는 1부터 D까지의 정수로 나타낸다.
<출력값>
첫째 줄에 답을 출력한다.

<문제 2129>
N(1≤N≤100)개의 도시들로 이루어진 나라가 있다. 이들 중 몇 개의 도시들은 서로 도로로 연결되어 있다. 당신은 당신의 취미 생활인 자동차 드라이브를 즐기려고 한다. 각각의 도시는 0, 1, 2, …, N-1의 번호가 붙어 있고, 현재 당신은 S번 도시에 위치하고 있으며, 당신은 T번 도시로 이동하려 한다.
각각의 도로는 그 도로의 길이와, 그 도로를 이용할 때 생기는 피로도가 있다. 피로도 값은 때로는 음수일 수도 있는데, 이는 그 도로를 드라이브 할 때 만족감을 얻는 경우이다. 또한 같은 도시들을 연결하는 도로라 하더라도, 어느 방향으로 운전하느냐에 따라 마주치는 경치가 다르기 때문에 피로도 역시 달라질 수 있다.
당신은 가능하면 피로도 값의 총 합을 최소로 하는 경로로 이동하려 한다. 그런 경우가 여러 가지 있다면 길이의 총 합이 최소인 경로를 찾으려고 한다. 단, 당신은 이동을 할 때, 각각의 도시에 연결된 도로들 중 피로도가 최소인 도로만을 이용할 수 있다.

예를 들어 위와 같은 경우를 보자. 각 도로 위에 []로 둘러싸인 값이 그 도로의 길이이고, 좌우의 값은 각 방향으로 그 도로를 이용할 때의 피로도이다. 위의 예에서의  최적해는 0-2-4-3-5가 된다. 이때의 피로도 합은 2(=-1+3+0+0)이고, 길이는 50(5+10+5+30)이다. 0-1-4-3-5 역시 피로도 합이 2이지만, 이는 길이가 51이기 때문에 최적해는 아니다. 0-3-5와 같은 경로는 피로도 합이 0이지만, 각 도시에 연결된 도로들 중 피로도가 최소인 도로만 이용한다는 조건에 어긋나므로 답이 될 수 없다.
각 도로들에 대한 정보를 입력받아 최적해를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 네 정수 N, M(0≤M≤5,000), S, T가 주어진다. 다음 M개의 줄에는 각 도로에 대한 정보를 나타내는 다섯 정수 u, v, a, c, b 가 주어진다. 이는 u번 도시와 v번 도시를 연결하는 길이 c의 도로가 있고, u->v 방향으로는 피로도가 a, v->u 방향으로는 피로도가 b라는 의미이다. 길이는 1이상 100이하의 정수이고, 피로도는 -100이상 100이하의 정수이다. 두 도시 사이에 여러 개의 도로가 있을 수도 있다.
<출력값>
첫째 줄에 피로도 총 합과 길이 총 합을 출력한다. 만약 최적해가 없다면 VOID를 출력한다. 만약 답이 무한히 작아질 수 있다면 UNBOUND를 출력한다.

<문제 2130>
N(1≤N≤50,000)개의 수조가 있다. 각각의 수조는 3차원 공간상에 존재한다. 수조에 대한 정보는 수조가 위치한 높이 b(0≤b≤1,000,000), 수조 자체의 높이 h(1≤h≤40,000), 수조의 가로길이 w(1≤w≤40,000), 수조의 세로길이 d(1≤d≤40,000)로 표현된다. 모든 수조의 아래에는 파이프가 달려 있고, 모든 파이프들은 하나로 연결되어 있다.
이러한 수조에 부피 V(1≤V≤2,000,000,000)만큼의 물을 넣으려고 한다. 수조들은 모두 파이프로 연결되어 있기 때문에, 전체 수조들의 제일 아래부터 차례로 물이 차게 된다. 문제의 편의를 위해서 파이프의 크기는 무시하기로 하자. 즉, 물은 파이프에는 들어가지 않고 수조에만 채워지는 것으로 간주한다. 이와 같이 물을 채웠을 때, 최종 수면의 높이를 구하려고 한다. 예를 들어 아래와 같은 경우에는 최종 수면의 높이 17이 된다.

수조들에 대한 정보와 물의 양이 주어졌을 때, 최종 수면의 높이를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 정수 N이 주어진다. 다음 N개의 줄에는 각 수조의 b, h, w, d값이 주어진다. 제일 마지막 줄에는 물의 부피가 주어진다. 모든 입력은 정수이다.
<출력값>
첫째 줄에 최종 수면의 높이를 소수점 아래 둘째 자리까지 출력한다. 셋째 자리에서 반올림한다. 만약 물의 양이 많을 경우에는 OVERFLOW를 출력한다.

<문제 2131>
한 회사에서 지뢰 탐사용 로봇을 출시하였다. 이 회사의 로봇 제품은 명령에 따라 움직이거나, 혹은 돌거나, 혹은 지뢰를 찾아보게 된다. 이러한 명령은 총 네 가지 종류로 정리되어 있는데, 각각은 다음과 같다.
(1) Forward : 로봇이 한 칸 앞으로 이동한다.
  (2) Turn Left : 로봇이 왼쪽으로 90도만큼 회전한다.
  (3) Turn Right : 로봇이 오른쪽으로 90도만큼 회전한다.
  (4) Scan : 로봇의 한 칸 앞에서 지뢰를 찾아본다.
회전은 90도 단위로 하게 되는데, 이는 로봇의 성능의 한계 때문에 지형을 격자 형태로 인식하여 처리하기 때문이다. 또한, 회전을 항상 90도 단위로 해야 하기 때문에 뒤로 돌기 위해서는 두 번의 회전 명령을 내려야 한다.
지뢰 탐사에 로봇을 사용하는 아이디어가 획기적이었기 때문에, 여러 국가의 국방부에서 이 로봇에 대한 관심을 보이게 되었다. 하지만 중국에서 이 로봇과 똑같은 제품을 더 싼 가격에 내놓게 되었고, 이에 대응하기 위해 회사에서는 새로운 로봇 개발에 박차를 가하였다. 새로운 로봇은 다음의 두 종류의 명령에 따라 움직이게 된다.
(1) Move [방향] [N] : 로봇이 [방향] 쪽으로 [N]칸 이동한다. [방향]은 Forward, Back, Left, Right 중의 하나이며 N은 양의 정수이다. 만약 [방향]이 Forward가 아니라면, 그 쪽으로 먼저 회전을 한 뒤에 움직이게 된다(움직인 뒤에는 회전한 방향을 유지한다).
  (2) Scan [방향] : 로봇이 [방향] 쪽의 한 칸 앞에서 지뢰를 찾아본다. [방향]은 Forward, Back, Left, Right 중의 하나이다. 만약 [방향]이 Forward가 아니라면, 그 쪽으로 먼저 회전을 한 뒤에 지뢰를 찾아보게 된다(지뢰를 찾아본 뒤에는 회전한 방향을 유지한다).
회사 측에서는 명령의 종류를 줄여서 더욱 효율적으로 지뢰 탐사를 수행할 수 있다는 사실을 홍보하려 한다. 이를 위해서 구형 로봇을 동작시키기 위해 필요한 명령 회수와, 똑같은 작업을 수행하기 위한 신형 로봇의 명령 회수를 비교해 보려 한다.
구형 로봇에서 수행한 명령들이 주어졌을 때, 이와 같은 동작을 하도록 하기 위해 신형 로봇에 입력해야 하는 최소 개수의 명령을 찾아내는 프로그램을 작성하시오. 구형 로봇과 신형 로봇은 같은 위치에서, 같은 방향을 향해 있는 상태에서 동작을 시작하며, 지뢰들을 같은 순서대로, 같은 위치를 찾아보아야 한다. 중간에 지나는 위치는 다르더라도 Scan을 수행하는 위치만 일치하면 되는 것으로 한다. 또, 만약 같은 위치에 대해서 여러 번 Scan을 수행하는 입력이 주어진다면, 출력 역시 같은 위치에 대해서 여러 번 Scan을 수행해야 한다. 로봇 자체는 지뢰에 대한 방어 장치가 있기 때문에, Scan을 수행해야 하는 위치를 지나 갈 수도 있다.
<입력값>
첫째 줄에 구형 로봇에서 수행한 명령의 개수 N(1≤N≤100,000)이 주어진다. 다음 N개의 줄에는 각각의 명령이 위에 있는 형식대로, 한 줄에 하나씩 주어진다.
<출력값>
첫째 줄에 신형 로봇에서 필요한 최소 개수의 명령을 출력한다.

<문제 2132>
전산학(Computer science)에서 트리란 사이클이 없는 그래프를 말한다. 트리(Tree)라는 이름이 의미하듯, 이러한 구조는 나무의 모습에서 유래한다. 즉, 트리의 각 간선(edge)들이 나무의 가지를 나타내고, 각 정점(node)들은 가지가 갈라지는 지점을 의미한다. 또한 트리의 루트는 나무의 뿌리를 의미한다. 이러한 구조는 일반적인 나무의 구조에 해당하지만, 트리 자체의 성질에 주목하면 실제 나무와는 다소 다른 구조가 되기도 한다.
우리가 생각하려는 나무는 루트가 없는 트리이다. 이때 트리의 각각의 간선은 나무의 가지에 해당하고, 트리의 각 정점은 나무 위에서 열매가 매달려있는 지점을 의미한다. 각각의 정점에는 몇 개의 열매가 매달려 있다. 물론 열매 없이 가지가 갈라지는 경우도 있으므로, 이러한 경우는 그 노드에 0개의 열매가 매달려 있다고 생각하기로 하자.
이러한 나무 위에 한 마리의 벌레가 있다. 이 벌레는 임의의 정점에서 이동하기 시작한다. 벌레가 한 정점에 있을 때에는, 그 정점에 있는 열매들을 먹을 수 있다. 열매들을 다 먹은 후에는 가지를 따라서 다른 정점으로 이동한다. 만약 이동할 수 있는 가지가 여러 개 있다면 그 중 하나를 임의로 선택하지만, 한 번 지났던 가지는 다시 지날 수 없다. 벌레의 이동은 더 이상 이동할 수 있는 정점이 없을 때에 끝난다.
나무의 모양이 주어졌을 때, 벌레가 최대로 먹을 수 있는 열매의 수와 이때 어느 정점에서 이동을 시작해야 하는지를 알아내는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 트리의 정점의 개수를 나타내는 정수 n(1≤n≤10,000)이 주어진다. 다음 줄에는 차례로 1번, 2번, …, n번 정점에 매달려 있는 열매의 개수가 주어진다. 다음 n-1개의 줄에는 트리의 각 간선을 나타내는 서로 다른 두 자연수 A, B(1≤A, B≤n)가 주어진다. 이는 트리의 A번 정점과 B번 정점이 연결되어 있음을 의미한다. 나무에 매달려 있는 열매의 총 개수는 2^31-1 (2,147,483,647)개를 넘지 않는다. 즉, 32-bit int를 사용하면 된다.
<출력값>
첫째 줄에 벌레가 먹을 수 있는 열매의 최대 개수와, 이때 이동을 시작할 정점의 번호를 출력한다. 답이 여러 개 있을 경우에는 정점의 번호가 가장 작은 경우를 출력한다.

<문제 2133>
3×N 크기의 벽을 2×1, 1×2 크기의 타일로 채우는 경우의 수를 구해보자.
<입력값>
첫째 줄에 N(1 ≤ N ≤ 30)이 주어진다.
<출력값>
첫째 줄에 경우의 수를 출력한다.

<문제 2134>
n(1≤n≤10,000)층짜리의 창고를 가지고 있는 한 회사가 있다. 이 회사에서는 이번에 새로 m(1≤m≤10,000)층짜리의 창고를 하나 마련하여 새 창고로 이전을 하려 한다.
기존의 창고에서 보관 중이던 물품들을 모두 새 창고로 옮길 수 있다면 좋겠지만, 새로운 창고가 더 클 수도, 작을 수도 있다. 이러한 경우에는 우선 최대한 많은 물품을 옮기려고 한다. 편의상 모든 물품들은 같은 크기라고 가정한다. 이러한 물품들이 기존의 창고의 각 층에 몇 개씩 보관되어 있었는지에 대한 정보가 주어지고, 새로운 창고의 각 층에 최대 몇 개씩 보관할 수 있는지에 대한 정보도 주어진다.
한편, 건물의 구조적 특징 때문에 물품을 옮길 때에는 사람이 직접 옮기는 방식을 이용하여야 한다. 이를 위해서 회사에서는 k(1≤k≤10,000)명의 인부를 고용하였다. 각 인부는 우선 기존 창고의 a번 층으로 이동하고, 한 개의 물품을 들어 올린 다음, 이를 새로운 창고의 b번 층으로 옮기게 된다. 창고를 오르고 내려올 때에는 층수에 비례하는 시간이 들기 때문에, 이러한 작업을 완료하는 데에는 총 a+b 만큼의 시간이 든다. 각각의 인부는 이러한 작업을 여러 번 반복하게 되고, 회사에서는 각 인부들에게 그 인부가 일 하는데 든 총 시간만큼의 비용을 지불하기로 하였다. 모든 인부들은 오래 일을 하여 그만큼 많은 돈을 받으려고 하기 때문에, 항상 물품은 한 개씩만 움직인다고 하자.
회사 측에서는 우선 최대한 많은 물품을 옮기기를 원한다. 그 다음으로는, 이 물품들을 옮기는 데 드는 비용을 최소로 하려 한다. 이를 도와주는 프로그램을 작성하시오.
<입력값>
첫째 줄에 세 정수 n, m, k가 주어진다. 다음 줄에는 n개의 정수로 기존 창고의 각 층에 보관되어 있는 물품의 개수가 1층부터 n층의 순서로 주어진다. 다음 줄에는 m개의 정수로 새 창고의 각 층에 보관할 수 있는 물품의 개수가 1층부터 m층의 순서로 주어진다. 각 층에 보관되어 있는, 그리고 보관할 수 있는 물품의 개수는 10,000개를 넘지 않는다.
<출력값>
첫째 줄에 두 정수 x, y를 출력한다. x는 옮길 수 있는 최대 물품의 개수이고, y는 이때 드는 비용의 최솟값이다.

<문제 2135>
어떤 문자열에서 특정한 패턴이 반복될 경우, 이를 이용하여 문자열을 좀 더 짧게 나타낼 수도 있다. 이러한 방법을 압축 기법이라고 하는데, 문자열을 압축하기 위한 여러 가지 효율적인 방법들이 연구되었다. RLE(Run Length Encdoing) 방법은 이러한 압축 방법 중 가장 기초적인 방법이다. RLE는 문자열에서 어떤 문자가 반복될 경우, 이 문자를 한 번만 저장하고 그 대신 반복 회수를 저장하는 방법이다. 이를 이용하면 abccddd는 abc2d3와 같이 압축될 수 있다.
문자 대신 문자열을 이용하면 RLE를 좀 더 개선할 수 있다. 예를 들어 주어진 문자열에서 S라는 문자열이 k번 반복될 경우, 이를 k(S)와 같은 식으로 표현할 수 있다. 예를 들어 letsgogogo는 lets3(go)와 같이 압축될 수 있다. 이 경우 원래 문자열의 길이는 10이지만 압축된 문자열의 길이는 9가 된다. 압축된 문자열의 길이를 계산할 때에는 괄호와 k를 나타낼 때 필요한 길이도 포함해서 계산한다. 또, 압축을 중첩해서 할 수도 있는데, 예를 들어 nowletsgogogoletsgogogo는 now2(lets3(go))로, nowletsgogogoletsgogogoandrunrunrun 은 now2(lets3(go))and3(run)으로 압축될 수 있다. 이렇게 개선된 RLE방법에서 abc2d3로는 압축할 수 없고, ab2(c)3(d) 로만 압축할 수 있다.
문자열이 주어졌을 때, 이를 압축하는 방법은 여러 가지가 있을 수 있다. 그 중 가장 짧은 방법의 길이를 알아내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 알파벳 소문자로 이루어진 문자열이 주어진다. 문자열의 길이는 200자를 넘지 않으며 공백 없이 주어진다.
<출력값>
첫째 줄에 최소 길이를 출력한다. 압축하지 않는 경우가 더 짧은 경우에는 원래 문자열의 길이를 출력한다.

<문제 2136>
길이가 L(1≤L≤1,000,000,000)인 막대기 위에 N(1≤N≤100,000)마리의 개미들이 서로 다른 위치에 살고 있다. 개미들은 크기가 매우 작기 때문에 이 문제에서는 개미가 크기가 없는 점이라고 생각하자. 각각의 개미의 위치는 x좌표로 표시되며, 좌표값은 0보다 크고 L보다 작은 값으로 표현된다.
각각의 개미는 왼쪽, 혹은 오른쪽으로 움직이고 있다. 모든 개미들은 똑같은 속도로, 1초에 한 칸씩 움직인다. 개미들이 움직이는 도중에 서로 부딪히는 경우가 생길 수도 있다. 두 마리의 개미가 서로 부딪혔을 때, 두 마리의 개미는 모두 즉시 방향을 바꾸어 다시 움직이게 된다.
개미들이 이동하다가 0인 위치나 L인 위치에 도달하게 되면, 그 개미는 막대기 아래로 떨어지게 된다. 개미들의 초기상태가 주어졌을 때, 가장 마지막에 떨어지는 개미와 그 개미가 떨어지는 시각을 알아내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 두 정수 N, L이 주어진다. 다음 N개의 줄에는 각 개미의 초기 위치가 주어진다. 초기 위치가 양수로 주어지는 경우는 그 값이 그 개미의 위치가 되며, 그 개미는 오른쪽으로 움직이고 있다. 초기 위치가 음수로 주어지는 경우에는 그 절댓값이 그 개미의 위치가 되며, 그 개미는 왼쪽으로 움직이고 있다. 예를 들어 3이 주어지는 경우에는 3인 위치에서 오른쪽으로 움직이고 있고, -7인 경우에는 7인 위치에서 왼쪽으로 움직이고 있다.
<출력값>
첫째 줄에 두 정수 i, t를 출력한다. i는 가장 마지막에 떨어지는 개미의 번호이다. 개미의 번호는 입력에서 주어지는 순서대로 1, 2, …, N이다. t는 가장 마지막에 떨어지는 개미가 바닥에 떨어지는 시간이다. 가장 마지막에 떨어지는 개미가 여러 마리인 경우는 없다고 가정한다.

<문제 2137>
컴퓨터가 기본적으로 지원하는 것은 이진수에 기반한 정수 뿐이기 때문에, 이를 이용하여 실수(소수)를 표현하기 위한 방법이 연구되어 왔다. 여러 가지 방법들 중에서 현재는 부동 소수점 방식이 채택되어 널리 사용되고 있다. 하지만 이 방법은 오차 등의 문제가 있는 완벽하지 못한 방법이다.
당신은 실수를 다루는 프로그램을 하나 설계하게 되었는데, 이 프로그램 안에서 기약분수를 이용하여 실수를 표현하기로 하였다. 프로그램을 설계하는 과정에서 실수들의 대소 비교에 대해 살펴보게 되었고, 이 과정에서 한 실수에 가장 가까운 분수가 무엇인지 알아보고 싶어졌다.
기약분수 하나가 주어졌을 때, 이 분수에 가장 가까운 기약분수를 구하는 프로그램을 작성하시오. 가장 가깝다는 말은, 물론 두 분수가 표현하는 실수의 차이가 최소이며, 자기 자신과는 달라야 한다. 또, 그러한 기약분수가 여러 가지인 경우 가장 작은 것이다.
우리가 다루는 분수들은 분모와 분자가 모두 1 이상 32767 이하라고 가정하자. 기약분수란 분모와 분자의 최대 공약수가 1인 분수를 말한다.
<입력값>
첫째 줄에 분수를 표현하는 분자와 분모가 주어진다. (단, 분자는 분모보다 작다)
<출력값>
첫째 줄에 우리가 찾는 분수를 표현하는 분자와 분모를 공백으로 구분해 출력한다.

<문제 2138>
N개의 스위치와 N개의 전구가 있다. 각각의 전구는 켜져 있는(1) 상태와 꺼져 있는 (0) 상태 중 하나의 상태를 가진다. i(1<i<N)번 스위치를 누르면 i-1, i, i+1의 세 개의 전구의 상태가 바뀐다. 즉, 꺼져 있는 전구는 켜지고, 켜져 있는 전구는 꺼지게 된다. 1번 스위치를 눌렀을 경우에는 1, 2번 전구의 상태가 바뀌고, N번 스위치를 눌렀을 경우에는 N-1, N번 전구의 상태가 바뀐다.
N개의 전구들의 현재 상태와 우리가 만들고자 하는 상태가 주어졌을 때, 그 상태를 만들기 위해 스위치를 최소 몇 번 누르면 되는지 알아내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 자연수 N(2≤N≤100,000)이 주어진다. 다음 줄에는 전구들의 현재 상태를 나타내는 숫자 N개가 공백 없이 주어진다. 그 다음 줄에는 우리가 만들고자 하는 전구들의 상태를 나타내는 숫자 N개가 공백 없이 주어진다.
<출력값>
첫째 줄에 답을 출력한다. 불가능한 경우에는 -1을 출력한다.

<문제 2139>
우리는 일상생활에서 휴가 일수를 계산하는 것 처럼 두 날짜 사이의 기간을 계산해야 하는 경우가 많다.
이때, 계산을 하는 가장 간단한 방법은 적당한 날짜를 잡은 뒤 계산할 날짜가 될 때까지 하루가 지날 때마다 계속 카운트를 하는 것이다.
이 문제에서는 해당하는 연도의 1월 1일을 시작하는 기준으로 잡을 것이다.
예를 들어 2005년 8월 13일은 총 225일이다. 그리고 그 1년 전인 2004년 8월 13일은 총 226일인데, 2004년은 윤년이기 때문이다.
윤년은 해당하는 연도가 4로 나누어 떨어지며 100으로는 나누어지는 연도는 제외하며, 그 중에서도 400으로 나누어 떨어지는 연도는 다시 포함한다. 그러므로 2000년이나 1976년은 윤년이다. 그러나, 1900년이나 1977년과 같은 경우는 윤년이 아니다.
또한 여러분은 28일로 이루어진(윤년에는 29일) 2월, 30일로 이루어진 4월, 6월 , 9월, 11월을 제외한 모든 달은 31일로 이루어져 있다는 것을 알고 있다.
이 문제에서, 여러분은 주어진 날짜를 카운트해야 한다.
<입력값>
입력은 한 줄의 날짜로 이루어진다.
각 날짜는 일, 월, 년이 공백을 두고 주어지며, 일과 월은 항상 유효하며, 연도는 항상 1700과 2200사이의 값으로만 주어진다.
0 0 0이 입력되면 프로그램을 종료한다.
<출력값>
각 줄에 날짜에 해당하는 날의 수를 출력한다.

<문제 2140>
지뢰찾기는 N×N에서 이뤄지는 게임이다. 보드의 곳곳에는 몇 개의 지뢰가 숨겨져 있고, 지뢰가 없는 칸에는 그 칸과 인접(상하좌우 및 대각선)해 있는 8개의 칸들에 몇 개의 지뢰가 숨겨져 있는지에 대한 정보가 주어진다. 게이머는 게임을 진행하면서 보드의 칸을 하나씩 열게 된다. 만약 그 칸에 지뢰가 있다면 게임이 끝나고, 없는 경우에는 그 칸에 적혀있는 숫자, 즉 그 칸과 인접해 있는 8개의 칸들 중 몇 개의 칸에 지뢰가 있는지를 알 수 있게 된다.
이 문제는 보드의 테두리가 모두 열려있고, 그 외는 모두 닫혀있는 상태에서 시작한다. 예를 들어 다음과 같은 경우를 보자.



1
1
1
0
0


2
#
#
#
1


3
#
#
#
1


2
#
#
#
1


1
2
2
1
0



#는 닫혀있는 칸을 나타낸다. 이러한 보드가 주어졌을 때, 닫혀있는 칸들 중 최대 몇 개의 칸에 지뢰가 묻혀있는지 알아내는 프로그램을 작성하시오. 위의 예와 같은 경우에는 다음과 같이 6개의 지뢰가 묻혀있을 수 있다.



1
1
1
0
0


2
*
 
 
1


3
*
*
*
1


2
*
*
 
1


1
2
2
1
0
<입력값>
첫째 줄에 N(1≤N≤100)이 주어진다. 다음 N개의 줄에는 N개의 문자가 공백 없이 주어지는데, 이는 게임 보드를 의미한다.
<출력값>
첫째 줄에 묻혀있을 수 있는 지뢰의 최대 개수를 출력한다.

<문제 2141>
수직선과 같은 일직선상에 N개의 마을이 위치해 있다. i번째 마을은 X[i]에 위치해 있으며, A[i]명의 사람이 살고 있다.
이 마을들을 위해서 우체국을 하나 세우려고 하는데, 그 위치를 어느 곳으로 할지를 현재 고민 중이다. 고민 끝에 나라에서는 각 사람들까지의 거리의 합이 최소가 되는 위치에 우체국을 세우기로 결정하였다. 우체국을 세울 위치를 구하는 프로그램을 작성하시오.
각 마을까지의 거리의 합이 아니라, 각 사람까지의 거리의 합임에 유의한다
<입력값>
첫째 줄에 N(1≤N≤100,000)이 주어진다. 다음 N개의 줄에는 X[1] A[1], X[2] A[2], …, X[N] A[N]이 주어진다. 범위는 |X[i]|≤1,000,000,000, 0≤A[i]≤1,000,000,000 이며 모든 입력은 정수이다.
<출력값>
첫째 줄에 우체국의 위치를 출력한다. 가능한 경우가 여러 가지인 경우에는 더 작은 위치를 출력하도록 한다.

<문제 2142>
정수로 이루어진 N×M(1 ≤ N, M ≤ 500) 크기의 2차원 배열이 있다. 이러한 2차원 배열이 정돈되어 있다는 말은, 1 ≤ i < k ≤ m, 1 ≤ j < l ≤ n를 만족하는 모든 i, j, k, l 에 대해서 A[i][j] + A[k][l] ≤ A[i][l] + A[k][j]가 성립하는 경우를 말한다.
2차원 배열이 주어졌을 때, 이러한 배열이 정돈된 배열인지 확인하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 배열의 개수 T(1 ≤ T ≤ 10)가 주어진다. 다음 줄에는 배열에 대한 입력이 T개 주어진다. 각 배열에서 첫째 줄에는 두 정수 N, M이 주어진다. 다음 N개의 줄에는 M개의 정수로 배열의 각 원소가 주어진다. 입력은 A[1][1], A[1][2], …, A[1][M], A[2][1], A[2][2], …, A[2][M], …, A[N][M] 순서대로 주어진다.
<출력값>
T개의 줄에, 주어진 순서대로 답을 출력한다. 정돈된 배열인 경우에는 YES를 출력하고, 아닌 경우에는 NO를 출력한다. 반드시 대소문자에 주의하도록 한다.

<문제 2143>
한 배열 A[1], A[2], …, A[n]에 대해서, 부 배열은 A[i], A[i+1], …, A[j-1], A[j] (단, 1 ≤ i ≤ j ≤ n)을 말한다. 이러한 부 배열의 합은 A[i]+…+A[j]를 의미한다. 각 원소가 정수인 두 배열 A[1], …, A[n]과 B[1], …, B[m]이 주어졌을 때, A의 부 배열의 합에 B의 부 배열의 합을 더해서 T가 되는 모든 부 배열 쌍의 개수를 구하는 프로그램을 작성하시오.
예를 들어 A = {1, 3, 1, 2}, B = {1, 3, 2}, T=5인 경우, 부 배열 쌍의 개수는 다음의 7가지 경우가 있다.

T(=5) = A[1] + B[1] + B[2]
      = A[1] + A[2] + B[1]
      = A[2] + B[3]
      = A[2] + A[3] + B[1]
      = A[3] + B[1] + B[2]
      = A[3] + A[4] + B[3]
      = A[4] + B[2]
<입력값>
첫째 줄에 T(-1,000,000,000 ≤ T ≤ 1,000,000,000)가 주어진다. 다음 줄에는 n(1 ≤ n ≤ 1,000)이 주어지고, 그 다음 줄에 n개의 정수로 A[1], …, A[n]이 주어진다. 다음 줄에는 m(1≤m≤1,000)이 주어지고, 그 다음 줄에 m개의 정수로 B[1], …, B[m]이 주어진다. 각각의 배열 원소는 절댓값이 1,000,000을 넘지 않는 정수이다.
<출력값>
첫째 줄에 답을 출력한다. 가능한 경우가 한 가지도 없을 경우에는 0을 출력한다.

<문제 2144>
평면상에 N(1≤N≤100)개의 점들이 있다. 당신은 이 점들 중 K(1≤K≤500)개의 점들을 방문하려고 한다. 같은 점을 여러 번 반복할 수 있지만, 한 점을 연속으로 두 번 방문할 수는 없다. 즉, 어느 한 점으로 이동했으면 그 점에서 다른 점으로 이동해야 한다는 것이다. 각각의 점들은 x, y좌표를 가지며, 0≤x, y≤1,000,000을 만족한다.
또한 이 평면에는 F개의 울타리도 있다. 각각의 울타리는 두 점을 잇는 선분으로 표현된다. 이 울타리들끼리는 서로 교차하지 않으며, 각 울타리에는 높이 h(1≤h≤1,000)가 있다. 높이가 h인 울타리를 넘을 때 성공할 확률은 1/h이다.
한 점에서 한 점으로 이동할 때에는 직선으로만 이동한다. 직선으로 이동하는 도중에 울타리를 만나게 된다면 그 울타리를 넘어야 한다. 만약 여러 울타리를 넘게 된다면 이 울타리들을 모두 성공적으로 넘을 확률은, 각각을 성공적으로 넘을 확률들의 곱이 된다. 만약 울타리가 직선 이동 경로 위에 평행하게 존재한다면, 이를 성공적으로 넘을 확률은 1이다. 또, 울타리의 끝 점만을 살짝 스쳐 지나갈 경우는 울타리를 넘을 필요가 없다.
N개의 점들 외에는 별도로 시작점이 하나 있다. 이동할 때에는 이 시작점에서 시작하여 이 시작점에서 끝나야 한다. K개의 점들을 계산할 때에는 이 시작점과 끝점을 제외하고 생각한다. 이 점에서 이동을 시작하여 K개의 점들을 지나고 이 점에서 이동을 끝낼 때, 울타리들을 성공적으로 넘을 확률을 최대로 하여라.
<입력값>
첫째 줄에 다섯 정수 N, K, F, x, y가 주어진다. x, y는 시작점의 좌표이다. 다음 N개의 줄에는 각 점의 좌표가 주어진다. 다음 F개의 줄에는 다섯 개의 정수로 울타리에 대한 정보가 주어진다. 앞의 두 정수는 울타리의 한 끝점이고, 그 다음 두 정수는 다른 한 끝점이고, 마지막 정수는 높이 h이다.
<출력값>
첫째 줄에 최대인 확률을 출력한다. 출력은 %.4e로 하면 된다.

<문제 2145>
초등학생인 도겸이는 숫자를 좋아한다. 어느 날 도겸이는 숫자 책을 보다가 간단한 놀이를 하나 생각해냈다. 숫자 놀이의 규칙은 다음과 같다.

주어진 숫자의 각 자릿수를 더한다.
결과가 한 자릿수가 될 때 까지 규칙1을 반복한다.

예를들어, 숫자 673에 규칙을 적용해보면 결과는 7이 된다 ; 6 + 7 + 3 = 16, 1 + 6 = 7 
도겸이는 당신과 함께 숫자놀이를 하고싶어한다. 도겸이가 주는 숫자들을 풀어보자.
<입력값>
각 줄에 숫자 N이 주어진다. N은 100,000보다 작은 양의 정수이다. 마지막 입력은 0이며, 0에 대한 결과는 출력하지 않는다.
<출력값>
한 줄에 하나씩 한 자릿수 결과를 출력한다.

<문제 2146>
여러 섬으로 이루어진 나라가 있다. 이 나라의 대통령은 섬을 잇는 다리를 만들겠다는 공약으로 인기몰이를 해 당선될 수 있었다. 하지만 막상 대통령에 취임하자, 다리를 놓는다는 것이 아깝다는 생각을 하게 되었다. 그래서 그는, 생색내는 식으로 한 섬과 다른 섬을 잇는 다리 하나만을 만들기로 하였고, 그 또한 다리를 가장 짧게 하여 돈을 아끼려 하였다.
이 나라는 N×N크기의 이차원 평면상에 존재한다. 이 나라는 여러 섬으로 이루어져 있으며, 섬이란 동서남북으로 육지가 붙어있는 덩어리를 말한다. 다음은 세 개의 섬으로 이루어진 나라의 지도이다.

위의 그림에서 색이 있는 부분이 육지이고, 색이 없는 부분이 바다이다. 이 바다에 가장 짧은 다리를 놓아 두 대륙을 연결하고자 한다. 가장 짧은 다리란, 다리가 격자에서 차지하는 칸의 수가 가장 작은 다리를 말한다. 다음 그림에서 두 대륙을 연결하는 다리를 볼 수 있다.

물론 위의 방법 외에도 다리를 놓는 방법이 여러 가지 있으나, 위의 경우가 놓는 다리의 길이가 3으로 가장 짧다(물론 길이가 3인 다른 다리를 놓을 수 있는 방법도 몇 가지 있다).
지도가 주어질 때, 가장 짧은 다리 하나를 놓아 두 대륙을 연결하는 방법을 찾으시오.
<입력값>
첫 줄에는 지도의 크기 N(100이하의 자연수)가 주어진다. 그 다음 N줄에는 N개의 숫자가 빈칸을 사이에 두고 주어지며, 0은 바다, 1은 육지를 나타낸다. 항상 두 개 이상의 섬이 있는 데이터만 입력으로 주어진다.
<출력값>
첫째 줄에 가장 짧은 다리의 길이를 출력한다.

<문제 2147>
월드 학원 캠프 때에는 학생들의 성적순으로 자리를 배치한다. n명의 학생들은 직선으로 배치된 책상에 앉아 있는데, 각 학생들은 점수가 오름차순으로 배치되어 있다. 점수가 같은 학생들은 붙어 있다.
단, 자리를 배치할 때 전체적인 순서보다도 각 학생의 양옆에 앉게 되는 학생을 중요하게 따지기로 한다. 따라서 {10 20 20 30} 뿐만 아니라 {20 20 30 10}, {20 30 10 20}, {30 10 20 20}도 모두 학생들이 성적순으로 앉은 것이다. 하지만 성적이 오름차순으로 배열되므로 {30 20 20 10}과 같은 경우는 성적순으로 앉은 것이 아니다. 즉, 학생들을 성적으로 오름차순으로 배열하되, 이를 회전하는 경우도 허용하는 것이다.
오늘 하루도 학생들은 열심히 공부를 하였다. 그리고 성적에 따라 내일의 자리 배치를 하려 했는데, 그만 한 문제의 채점이 늦어지는 바람에 모든 학생들이 자러 간 뒤에야 채점 결과가 나왔다. 그래서 조교가 학생들의 자리를 배치해 주기로 했다.
조교는 물론 팔이 두 개밖에 없으므로 한 번에 최대 두 대까지의 컴퓨터만 들 수 있다. 컴퓨터를 들고 한 칸을 이동할 때에는 들고 있는 컴퓨터의 개수만큼 힘이 든다. 또, 컴퓨터 한 대를 자리에서 들어 올리거나, 자리에 놓을 때에는 10만큼의 힘이 든다.
학생들의 성적이 주어졌을 때, 성적순으로 자리배치 할 때 드는 최소의 힘을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 학생의 수 n(2≤n≤400)이 주어진다. 다음 줄에는 각 학생의 점수가 주어진다. 각 학생의 점수는 2,000,000을 넘지 않는 정수이다. 범위가 큰 이유는 소수로 나타나는 학생의 점수를 정수화하기 위해서 적당한 수를 곱했기 때문이다.
<출력값>
첫째 줄에 드는 최소의 힘을 출력한다.

<문제 2148>
In a rugby-mad country such as New Zealand, fans eagerly await the ranking of the teams in league tables such as the Super 12 (soon to be the Super 14). These rankings are really only meaningful at the end of a round, when all teams have played the same number of games.
A team is awarded 4 points for each win, 2 points for each draw and 0 for each loss. Any team scoring 4 or more tries in a game is awarded a bonus point, as is any team that loses a game by less than 8 points. At the end of a round we can produce a table showing the relative standings of each team, i.e. a table sorted in descending order of points. If two or more teams have the same number of points, then apply the following rules there are no tied teams:

Sort in descending order of spread, i.e. the cumulative difference between total points scored and total points against.
Sort in descending order of the total number of tries they scored.
Sort in ascending alphabetic sequence.
<입력값>
Input will consist of the results for a single league and will consist of the names of the competing teams and details of each game. The list of competing teams will be a series of no more than 20 lines each containing a single name(20) and terminated by a line consisting of a single ‘#’. This will be followed by a series of lines giving the results of each game, also terminated by a line consisting of a single ‘#’. Each game will start with the names of the two teams (home side first) followed by 4 integers representing, in order: the score of the home team, the score of the away team, the number of tries scored by the home team, and the number of tries scored by the away team (see the sample input). Note that there will not be any indication of the end of a round, it is determined by the number of competing teams (which will always be even), i.e. a round will end when every team has played exactly one game.
<출력값>
Output will consist of a league table for each round. The first line of the league table will consist of the word ‘Round’ followed by a space and the number of the round (a running number starting at 1). This will be followed by the teams listed in order of their standing, according to the rules outlined above. Each line consists of the name of the team, followed by, starting in column 22 and right justified in fields of widths as specified in parentheses, their points (2), their cumulative score since the beginning of the league (4), the cumulative score of the teams they have played (4), the total number of tries that they have scored (3) and the total number of tries scored against them (3). Leave a blank line between rounds. See the sample output below.

<문제 2149>
어떤 문장을 키를 이용하여 다음과 같이 암호화하려 한다. 암호화하기 전의 문장을 평문이라 하며, 암호화 된 문장은 암호문이라고 한다. 키, 평문, 암호문은 모두 영어 대문자로 된 공백 없는 문장이다.
키의 길이를 N이라고 했을 때, 우선 평문을 N 글자씩 잘라서 다음과 같이 나열한다. 예를 들어 평문이 MEETMEBYTHEOLDOAKTREENTH 이고, 키가 BATBOY라고 해 보자.






B


A


T


B


O


Y




M


E


E


T


M


E




B


Y


T


H


E


O




L


D


O


A


K


T




R


E


E


N


T


H






제일 윗줄은 이해를 돕기 위해 키를 다시 한 번 쓴 것이다. 이제 이 행렬(배열)을 열(Column) 단위로 정렬을 하는데, 정렬을 하는 키준은 키의 문자로 한다. 즉 BATBOY를 정렬하여 ABBOTY와 같이 정렬하는 것이다. B와 같이 여러 번 나타나는 문자의 경우에는 원래의 행렬에서 더 왼쪽에 있었던 것을 먼저 쓴다. 정렬을 한 행렬은 다음과 같다.






A


B


B


O


T


Y




E


M


T


M


E


E




Y


B


H


E


T


O




D


L


A


K


O


T




E


R


N


T


E


H






B는 두 가지가 있기 때문에 더 왼쪽에 있었던 (B)MBLR이 먼저 나왔다. 이제 이와 같이 정렬한 행렬을 열 번호가 작은 것 먼저, 열 번호가 같다면 행 번호가 작은 것 순으로 나열하면 암호문이 된다. 즉 위와 같은 경우의 암호문은 EYDEMBLRTHANMEKTETOEEOTH 가 된다.
키와 암호문이 주어졌을 때, 이를 이용하여 평문을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 키가 주어지고, 둘째 줄에 암호문이 주어진다. 키와 암호문은 모두 영어 대문자로만 되어 있으며, 암호문의 길이가 항상 키의 길이의 배수라고 하자. 키의 길이는 10자 이하이며 암호문의 길이는 100자 이하이다.
<출력값>
첫째 줄에 평문을 출력한다.

<문제 2150>
방향 그래프가 주어졌을 때, 그 그래프를 SCC들로 나누는 프로그램을 작성하시오.
방향 그래프의 SCC는 우선 정점의 최대 부분집합이며, 그 부분집합에 들어있는 서로 다른 임의의 두 정점 u, v에 대해서 u에서 v로 가는 경로와 v에서 u로 가는 경로가 모두 존재하는 경우를 말한다.

예를 들어 위와 같은 그림을 보자. 이 그래프에서 SCC들은 {a, b, e}, {c, d}, {f, g}, {h} 가 있다. 물론 h에서 h로 가는 간선이 없는 경우에도 {h}는 SCC를 이룬다.
<입력값>
첫째 줄에 두 정수 V(1 ≤ V ≤ 10,000), E(1 ≤ E ≤ 100,000)가 주어진다. 이는 그래프가 V개의 정점과 E개의 간선으로 이루어져 있다는 의미이다. 다음 E개의 줄에는 간선에 대한 정보를 나타내는 두 정수 A, B가 주어진다. 이는 A번 정점과 B번 정점이 연결되어 있다는 의미이다. 이때 방향은 A → B가 된다.
정점은 1부터 V까지 번호가 매겨져 있다.
<출력값>
첫째 줄에 SCC의 개수 K를 출력한다. 다음 K개의 줄에는 각 줄에 하나의 SCC에 속한 정점의 번호를 출력한다. 각 줄의 끝에는 -1을 출력하여 그 줄의 끝을 나타낸다. 각각의 SCC를 출력할 때 그 안에 속한 정점들은 오름차순으로 출력한다. 또한 여러 개의 SCC에 대해서는 그 안에 속해있는 가장 작은 정점의 정점 번호 순으로 출력한다.

<문제 2151>
채영이는 거울을 들여다보는 것을 참 좋아한다. 그래서 집 곳곳에 거울을 설치해두고 집 안을 돌아다닐 때마다 거울을 보곤 한다.
채영이는 새 해를 맞이하여 이사를 하게 되었는데, 거울을 좋아하는 그녀의 성격 때문에 새 집에도 거울을 매달만한 위치가 여러 곳 있다. 또한 채영이네 새 집에는 문이 두 개 있는데, 채영이는 거울을 잘 설치하여 장난을 치고 싶어졌다. 즉, 한 쪽 문에서 다른 쪽 문을 볼 수 있도록 거울을 설치하고 싶어졌다.
채영이네 집에 대한 정보가 주어졌을 때, 한 쪽 문에서 다른 쪽 문을 볼 수 있도록 하기 위해 설치해야 하는 거울의 최소 개수를 구하는 프로그램을 작성하시오.
거울을 설치할 때에는 45도 기울어진 대각선 방향으로 설치해야 한다. 또한 모든 거울은 양면 거울이기 때문에 양 쪽 모두에서 반사가 일어날 수 있다. 채영이는 거울을 매우 많이 가지고 있어서 거울이 부족한 경우는 없다고 하자.
거울을 어떻게 설치해도 한 쪽 문에서 다른 쪽 문을 볼 수 없는 경우는 주어지지 않는다.
<입력값>
첫째 줄에 집의 크기 N (2 ≤ N ≤ 50)이 주어진다. 다음 N개의 줄에는 N개의 문자로 집에 대한 정보가 주어진다. ‘#’는 문이 설치된 곳으로 항상 두 곳이며, ‘.’은 아무 것도 없는 것으로 빛은 이 곳을 통과한다. ‘!’은 거울을 설치할 수 있는 위치를 나타내고, ‘*’은 빛이 통과할 수 없는 벽을 나타낸다.
<출력값>
첫째 줄에 설치해야 할 거울의 최소 개수를 출력한다.

<문제 2152>
평소 일로 바쁘던 태희는 휴가를 통해 여행을 다녀오기로 하였다. 우선 태희는 사전 조사를 통해서 여행하려는 도시를 N(1≤N≤10,000)개 선택하였다. 태희는 비행기를 이용하면 충분히 여행할 수 있을거라 생각했지만, 짐을 꾸리던 중 비행기가 모든 도시들 사이를 다니는 것은 아님을 알게 되었다.
태희는 다시 비행로에 대해 조사를 하였고, 총 M(1≤M≤100,000)개의 비행로가 존재함을 알게 되었다. 각각의 비행로는 한 방향으로의 서비스만을 제공한다. 태희는 S(1≤S≤N)번 도시에서 시작해서 T(1≤T≤N)번 도시에서 여행을 끝내기로 하였다. 그리고 태희는 도시와 항공로에 대한 정보를 바탕으로 여행 계획을 세우기로 하였다.
도시와 비행로에 대한 정보가 주어졌을 때, S번 도시에서 T번 도시로 여행을 할 때 최대로 방문할 수 있는 도시의 개수를 구하는 프로그램을 작성하시오. 각각의 도시는 여행 중에 몇 번이든 방문할 수 있으며, 같은 항공로를 여러 번 이용할 수도 있다. 물론 같은 도시를 여러 번 방문하는 경우는 한 번만 생각하기로 한다.
<입력값>
첫째 줄에 네 정수 N, M, S, T가 주어진다. 다음 M개의 줄에는 각각의 비행로에 대한 정보를 나타내는 서로 다른 두 정수 A, B(1≤A, B≤N)가 주어진다. 이는 A번 도시에서 B번 도시로 이동하는 항공로가 존재함을 의미한다.
<출력값>
첫째 줄에 방문할 수 있는 도시의 최대 개수를 출력한다. 만약 여행 계획을 목표대로 세울 수 없다면 0을 출력한다.

<문제 2153>
소수란 1과 자기 자신으로만 나누어떨어지는 수를 말한다. 예를 들면 1, 2, 3, 5, 17, 101, 10007 등이 소수이다. 이 문제에서는 편의상 1도 소수로 하자.
알파벳 대소문자로 이루어진 영어 단어가 하나 있을 때, a를 1로, b를 2로, …, z를 26으로, A를 27로, …, Z를 52로 하여 그 합을 구한다. 예를 들어 cyworld는 합을 구하면 100이 되고, abcd는 10이 된다.
이와 같이 구한 수가 소수인 경우, 그 단어를 소수 단어라고 한다. 단어가 주어졌을 때, 그 단어가 소수 단어인지 판별하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 단어가 주어진다. 단어의 길이는 20자 이하이다. 주어지는 단어는 알파벳 소문자와 대문자만으로 이루어져 있다.
<출력값>
아래의 예제와 같은 형식으로 출력을 한다. 소수 단어인 경우에는 It is a prime word.를, 아닌 경우에는 It is not a prime word.를 출력한다.

<문제 2154>
1부터 N까지의 수를 이어서 쓰면 다음과 같이 새로운 하나의 수를 얻을 수 있다.

1234567891011121314151617181920212223...

이렇게 만들어진 새로운 수에서 N이 등장하는 위치를 알고 싶다. 물론 1부터 N까지의 수를 이어 쓰는 것이므로 수의 가장 끝부분에서 N이 항상 등장하게 되지만, 그보다 일찍 등장하는 경우도 있다.
예를 들어 N=151인 경우, 다음과 같이 앞에서 20번째 숫자부터 151이 등장하게 된다.

1234567891011121314151617181920212223...

N이 주어졌을 때, N이 가장 먼저 등장하는 위치를 알아내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N(1 ≤ N ≤ 100,000)이 주어진다.
<출력값>
첫째 줄에 N이 가장 먼저 등장하는 위치를 출력한다. 앞에서부터 몇 번째인지를 출력하면 된다.

<문제 2155>
위의 그림과 같은 삼각형이 있다. 작은 삼각형들은 1부터 시작해서 위와 같은 규칙으로 번호가 쭉 매겨져 있다. 이와 같은 그림에서, A가 적혀 있는 삼각형에서 B가 적혀 있는 삼각형으로 이동하려 한다.
한 삼각형에서 다른 삼각형으로 이동할 때에는 삼각형들의 변을 통해서만 움직일 수 있으며, 꼭짓점을 통해서는 다른 삼각형으로 이동할 수 없다. 또한 삼각형의 밖으로 이동할 수도 없다. 이와 같이 이동을 할 때, 도중에 지나는 변의 개수가 그 경로의 길이가 된다.
A와 B가 주어졌을 때, 가장 짧은 경로의 길이를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 두 정수 A, B(1≤A, B≤1,000,000,000)가 주어진다.
<출력값>
첫째 줄에 답을 출력한다.

<문제 2156>
효주는 포도주 시식회에 갔다. 그 곳에 갔더니, 테이블 위에 다양한 포도주가 들어있는 포도주 잔이 일렬로 놓여 있었다. 효주는 포도주 시식을 하려고 하는데, 여기에는 다음과 같은 두 가지 규칙이 있다.

포도주 잔을 선택하면 그 잔에 들어있는 포도주는 모두 마셔야 하고, 마신 후에는 원래 위치에 다시 놓아야 한다.
연속으로 놓여 있는 3잔을 모두 마실 수는 없다.

효주는 될 수 있는 대로 많은 양의 포도주를 맛보기 위해서 어떤 포도주 잔을 선택해야 할지 고민하고 있다. 1부터 n까지의 번호가 붙어 있는 n개의 포도주 잔이 순서대로 테이블 위에 놓여 있고, 각 포도주 잔에 들어있는 포도주의 양이 주어졌을 때, 효주를 도와 가장 많은 양의 포도주를 마실 수 있도록 하는 프로그램을 작성하시오. 
예를 들어 6개의 포도주 잔이 있고, 각각의 잔에 순서대로 6, 10, 13, 9, 8, 1 만큼의 포도주가 들어 있을 때, 첫 번째, 두 번째, 네 번째, 다섯 번째 포도주 잔을 선택하면 총 포도주 양이 33으로 최대로 마실 수 있다.
<입력값>
첫째 줄에 포도주 잔의 개수 n이 주어진다. (1≤n≤10,000) 둘째 줄부터 n+1번째 줄까지 포도주 잔에 들어있는 포도주의 양이 순서대로 주어진다. 포도주의 양은 1,000 이하의 음이 아닌 정수이다.
<출력값>
첫째 줄에 최대로 마실 수 있는 포도주의 양을 출력한다.

<문제 2157>
N개의 도시가 동쪽에서 서쪽으로 순서대로 위치해 있다. 제일 동쪽에 있는 도시는 1번 도시이며, 제일 서쪽에 있는 도시는 N번 도시이다.
당신은 이와 같은 도시 중에서 M개 이하의 도시를 지나는 여행을 계획하려 한다. 여행 경로는 반드시 1번 도시에서 시작해서 N번 도시에서 끝나야 한다. 물론 이 두 도시도 M개의 도시에 포함된다. 당신은 시차에 매우 민감하기 때문에, 한 번 서쪽으로 이동했다가 다시 동쪽으로 이동하면 몸이 대단히 아프다. 그래서 당신은 계속 서쪽으로만, 즉 도시 번호가 증가하는 순서대로만 이동하기로 하였다.
한편, 모든 도시에서 다른 모든 도시로 이동할 수 있는 건 아니다. 각각의 도시에서 다른 도시로 이동할 때에는 비행기를 타고 이동해야 하는데, 때로는 비행 항로가 개설되지 않았을 수도 있다. 또한 당신은 비행기를 아무렇게나 타려는 것이 아니라, 최대한 맛있는 기내식만 먹으면서 이동하려 한다(사실 이게 여행의 목적이다).
항로 개설 여부와 해당 항로에서 제공되는 기내식의 점수가 주어졌을 때, 먹게 되는 기내식의 점수의 총 합이 최대가 되도록 하시오.
<입력값>
첫째 줄에 N(1 ≤ N ≤ 300), M(2 ≤ M ≤ N), K(1 ≤ K ≤ 100,000)가 주어진다. K는 개설된 항공로의 개수이다. 다음 K개의 줄에는 각 항공로에 대한 정보를 나타내는 세 정수 a, b, c(1 ≤ a, b ≤ N, 1 ≤ c ≤ 10,000)가 주어진다. 이는 a번 도시에서 b번 도시로 이동하는 항로가 있고, 서비스되는 기내식의 점수가 c점이라는 의미이다. 서쪽에서 동쪽으로 이동하는 항로가 입력될 수도 있고, 같은 도시 쌍 사이에 항로가 여러 개 있을 수도 있지만, 날아다니다 다시 원래 도시로 돌아오는 a=b 와 같은 입력은 없다.
<출력값>
첫째 줄에 기내식 점수의 총 합의 최댓값을 출력한다.

<문제 2158>
다해는 평소 산악자전거 타기를 즐긴다. 다해는 오랜 시간동안 운동을 하는 것도 좋아하지만, 때로는 되도록 짧은 시간동안 산악자전거 타기를 마치기를 원하기도 한다.
산의 모습은 R(1≤R≤100)행 C(1≤C≤100)열의 행렬로 표현된다. 행렬의 각 수는 그 위치의 높이(고도)를 나타낸다. 다해는 현재 행렬의 (1, 1) 위치에 있고, (R, C) 위치로 이동하려 한다. 다해의 (1, 1)위치에서의 초기 속도는 V(1≤V≤1,000,000)이다. 행렬에서의 움직임은 위, 아래, 왼쪽, 오른쪽의 네 방향으로만 가능하다고 하자. 속도가 V라는 의미는 단위시간동안 V칸을 움직일 수 있다는 의미이다.
자전거를 타고 이동하다보면 높이 차이에 의해 속도가 가속되기도 하고 감속되기도 한다. 현재 위치의 높이가 A이고, 이동하려는 위치의 높이가 B일 때, 속도는 배가 된다(2^(A-B) 배). 실제로는 이동하는 도중에 속도가 변하게 되지만, 문제의 편의를 위해서 이동을 완전히 마친 후에 속도가 변하는 것으로 생각하자. 즉, 이동을 할 때에는 처음의 속도를 가지고 이동하는 것으로 한다.
산의 높이에 대한 정보와 초기 속도가 주어졌을 때, (1, 1)의 위치에서 (R, C)의 위치로 이동할 때 필요한 최소 시간을 구해내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 세 정수 V, R, C가 주어진다. 다음 R개의 줄에는 C개의 정수로 행렬이 주어진다. 행렬의 각 수는 -25이상 25이하의 정수이다.
<출력값>
첫째 줄에 이동에 필요한 최소 시간을 출력한다. 절대/상대 오차는 10-2까지 허용한다.

<문제 2159>
프랑스에서 공부를 하고 돌아온 선아는 자신이 그렇게도 되고 싶어 했던 파티셰가 되었다. 케익 배달 전문업체 보나뻬띠에 취직한 선아는 친절하게도 자신이 만든 케익을 고객들에게 직접 배달을 하려 한다. N명의 고객에게 케익을 배달하는데 주문이 들어온 순서대로 배달하기를 원하며 고객이 케익을 받을 수 있을 만큼 충분히 가까이까지 배달한다.
N명의 고객의 위치는 순서대로 100,000×100,000 격자의 정수 좌표로 주어지고 처음 출발하게 되는 보나뻬띠의 위치도 정수 좌표로 주어진다. 선아는 격자 위에서 상하좌우로만 움직이며 고객에게 케익을 전달하기 위해서는 그 고객의 위치까지 가거나 고객의 상하좌우 인접 격자점에 가야 한다. 이때 선아가 최단거리를 이동하여 입력된 순서대로 배달을 끝낼 수 있는 거리를 계산하는 프로그램을 작성하시오. 여기서 거리는 격자 상의 칸 수를 말한다.

위의 예에서 선아는 11칸을 움직여서 세 명의 고객에게 배달을 마칠 수 있다. 선아는 반드시 고객들에게 순서대로 배달을 하며 순서에 어긋난 사람에게 배달을 할 수 있는 위치에 있더라도 케익을 주지 않고 순서대로 배달을 한다. 고객의 위치는 중복이 될 수도 있다.
<입력값>
첫째 줄에 N이 주어지고 둘째 줄에는 선아가 일하는 레스토랑의 위치가, 셋째 줄부터는 N명의 위치가 X와 Y로 주어진다. 두 좌표 사이에는 공백이 하나 이상 있다.
  (1 ≤ N, X, Y ≤ 100,000)
<출력값>
첫째 줄에 최단 거리를 출력한다.

<문제 2160>
N(2≤N≤50)개의 그림이 있다. 각각의 그림은 5×7의 크기이고, 두 가지 색으로 되어 있다. 이때 두 가지의 색을 각각 ‘X’와 ‘.’으로 표현하기로 하자. 이러한 그림들이 주어졌을 때, 가장 비슷한 두 개의 그림을 찾아내는 프로그램을 작성하시오. 두 개의 그림에서 다른 칸의 개수가 가장 적을 때, 두 개의 그림이 가장 비슷하다고 하자.

예를 들어 위와 같은 두 개의 그림이 주어졌을 때, 색칠한 부분이 서로 다르게 된다. 위의 그림은 5개의 칸이 서로 다르다. 이와 같이 서로 다른 칸의 개수가 가장 작은 경우를 찾는 것이다.
<입력값>
첫째 줄에 N이 주어진다. 다음 5×N개의 줄에 7개의 문자로 각각의 그림이 주어진다.
<출력값>
첫째 줄에 가장 비슷한 두 그림의 번호를 출력한다. 그림의 번호는 입력되는 순서대로 1, 2, …, N이다. 번호를 출력할 때에는 작은 것을 먼저 출력한다. 입력은 항상 답이 한 가지인 경우만 주어진다.

<문제 2161>
N장의 카드가 있다. 각각의 카드는 차례로 1부터 N까지의 번호가 붙어 있으며, 1번 카드가 제일 위에, N번 카드가 제일 아래인 상태로 순서대로 카드가 놓여 있다.
이제 다음과 같은 동작을 카드가 한 장 남을 때까지 반복하게 된다. 우선, 제일 위에 있는 카드를 바닥에 버린다. 그 다음, 제일 위에 있는 카드를 제일 아래에 있는 카드 밑으로 옮긴다.
예를 들어 N=4인 경우를 생각해 보자. 카드는 제일 위에서부터 1234 의 순서로 놓여있다. 1을 버리면 234가 남는다. 여기서 2를 제일 아래로 옮기면 342가 된다. 3을 버리면 42가 되고, 4를 밑으로 옮기면 24가 된다. 마지막으로 2를 버리고 나면, 버린 카드들은 순서대로 1 3 2가 되고, 남는 카드는 4가 된다.
N이 주어졌을 때, 버린 카드들을 순서대로 출력하고, 마지막에 남게 되는 카드를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 정수 N(1≤N≤1,000)이 주어진다.
<출력값>
첫째 줄에 버리는 카드들을 순서대로 출력한다. 제일 마지막에는 남게 되는 카드의 번호를 출력한다.

<문제 2162>
N개의 선분들이 2차원 평면상에 주어져 있다. 선분은 양 끝점의 x, y 좌표로 표현이 된다.
두 선분이 서로 만나는 경우에, 두 선분은 같은 그룹에 속한다고 정의하며, 그룹의 크기는 그 그룹에 속한 선분의 개수로 정의한다. 두 선분이 만난다는 것은 선분의 끝점을 스치듯이 만나는 경우도 포함하는 것으로 한다.
N개의 선분들이 주어졌을 때, 이 선분들은 총 몇 개의 그룹으로 되어 있을까? 또, 가장 크기가 큰 그룹에 속한 선분의 개수는 몇 개일까? 이 두 가지를 구하는 프로그램을 작성해 보자.
<입력값>
첫째 줄에 N(1≤N≤3,000)이 주어진다. 둘째 줄부터 N+1번째 줄에는 양 끝점의 좌표가 x1, y1, x2, y2의 순서로 주어진다. 각 좌표의 절댓값은 5,000을 넘지 않으며, 입력되는 좌표 사이에는 빈칸이 하나 이상 있다.
<출력값>
첫째 줄에 그룹의 수를, 둘째 줄에 가장 크기가 큰 그룹에 속한 선분의 개수를 출력한다.

<문제 2163>
정화는 N×M 크기의 초콜릿을 하나 가지고 있다. 초콜릿은 금이 가 있는 모양을 하고 있으며, 그 금에 의해 N×M개의 조각으로 나눠질 수 있다.
초콜릿의 크기가 너무 크다고 생각한 그녀는 초콜릿을 친구들과 나눠 먹기로 했다. 이를 위해서 정화는 초콜릿을 계속 쪼개서 총 N×M개의 조각으로 쪼개려고 한다. 초콜릿을 쪼갤 때에는 초콜릿 조각을 하나 들고, 적당한 위치에서 초콜릿을 쪼갠다. 초콜릿을 쪼갤 때에는 금이 가 있는 위치에서만 쪼갤 수 있다. 이와 같이 초콜릿을 쪼개면 초콜릿은 두 개의 조각으로 나눠지게 된다. 이제 다시 이 중에서 초콜릿 조각을 하나 들고, 쪼개는 과정을 반복하면 된다.
초콜릿을 쪼개다보면 초콜릿이 녹을 수 있기 때문에, 정화는 가급적이면 초콜릿을 쪼개는 횟수를 최소로 하려 한다. 초콜릿의 크기가 주어졌을 때, 이를 1×1 크기의 초콜릿으로 쪼개기 위한 최소 쪼개기 횟수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 두 정수 N, M(1≤N, M≤300)이 주어진다.
<출력값>
첫째 줄에 답을 출력한다.

<문제 2164>
N장의 카드가 있다. 각각의 카드는 차례로 1부터 N까지의 번호가 붙어 있으며, 1번 카드가 제일 위에, N번 카드가 제일 아래인 상태로 순서대로 카드가 놓여 있다.
이제 다음과 같은 동작을 카드가 한 장 남을 때까지 반복하게 된다. 우선, 제일 위에 있는 카드를 바닥에 버린다. 그 다음, 제일 위에 있는 카드를 제일 아래에 있는 카드 밑으로 옮긴다.
예를 들어 N=4인 경우를 생각해 보자. 카드는 제일 위에서부터 1234 의 순서로 놓여있다. 1을 버리면 234가 남는다. 여기서 2를 제일 아래로 옮기면 342가 된다. 3을 버리면 42가 되고, 4를 밑으로 옮기면 24가 된다. 마지막으로 2를 버리고 나면, 남는 카드는 4가 된다.
N이 주어졌을 때, 제일 마지막에 남게 되는 카드를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 정수 N(1 ≤ N ≤ 500,000)이 주어진다.
<출력값>
첫째 줄에 남게 되는 카드의 번호를 출력한다.

<문제 2166>
2차원 평면상에 N(3 ≤ N ≤ 10,000)개의 점으로 이루어진 다각형이 있다. 이 다각형의 면적을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N이 주어진다. 다음 N개의 줄에는 다각형을 이루는 순서대로 N개의 점의 x, y좌표가 주어진다. 좌표값은 절댓값이 100,000을 넘지 않는 정수이다.
<출력값>
첫째 줄에 면적을 출력한다. 면적을 출력할 때에는 소수점 아래 둘째 자리에서 반올림하여 첫째 자리까지 출력한다.

<문제 2167>
2차원 배열이 주어졌을 때 (i, j) 위치부터 (x, y) 위치까지에 저장되어 있는 수들의 합을 구하는 프로그램을 작성하시오. 배열의 (i, j) 위치는 i행 j열을 나타낸다.
<입력값>
첫째 줄에 배열의 크기 N, M(1 ≤ N, M ≤ 300)이 주어진다. 다음 N개의 줄에는 M개의 정수로 배열이 주어진다. 배열에 포함되어 있는 수는 절댓값이 10,000보다 작거나 같은 정수이다. 그 다음 줄에는 합을 구할 부분의 개수 K(1 ≤ K ≤ 10,000)가 주어진다. 다음 K개의 줄에는 네 개의 정수로 i, j, x, y가 주어진다(i ≤ x, j ≤ y).
<출력값>
K개의 줄에 순서대로 배열의 합을 출력한다. 배열의 합은 231-1보다 작거나 같다.

<문제 2168>
한 변의 길이가 1cm인 정사각형 모양의 타일이 있다. 이 타일들을 가로가 xcm, 세로가 ycm인 직사각형 모양의 벽에 빈틈없이 붙였다. x와 y는 정수이다.
이 직사각형에 하나의 대각선을 그렸다. 직사각형에 붙어 있는 x*y개의 타일 중에는 대각선이 그려진 타일도 있고, 그렇지 않은 타일도 있다. x*y개의 타일 중에서 대각선이 그려져 있는 타일의 개수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 가로의 길이 xcm와 세로의 길이 ycm가 주어진다. x와 y는 1,000,000,000 이하의 자연수이다. x와 y 사이에는 빈칸이 하나 이상 있다.
<출력값>
첫째 줄에 대각선이 그려져 있는 타일의 개수를 출력한다.

<문제 2169>
NASA에서는 화성 탐사를 위해 화성에 무선 조종 로봇을 보냈다. 실제 화성의 모습은 굉장히 복잡하지만, 로봇의 메모리가 얼마 안 되기 때문에 지형을 N×M 배열로 단순화 하여 생각하기로 한다.
지형의 고저차의 특성상, 로봇은 움직일 때 배열에서 왼쪽, 오른쪽, 아래쪽으로 이동할 수 있지만, 위쪽으로는 이동할 수 없다. 또한 한 번 탐사한 지역(배열에서 하나의 칸)은 탐사하지 않기로 한다.
각각의 지역은 탐사 가치가 있는데, 로봇을 배열의 왼쪽 위 (1, 1)에서 출발시켜 오른쪽 아래 (N, M)으로 보내려고 한다. 이때, 위의 조건을 만족하면서, 탐사한 지역들의 가치의 합이 최대가 되도록 하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N, M(1≤N, M≤1,000)이 주어진다. 다음 N개의 줄에는 M개의 수로 배열이 주어진다. 배열의 각 수는 절댓값이 100을 넘지 않는 정수이다. 이 값은 그 지역의 가치를 나타낸다.
<출력값>
첫째 줄에 최대 가치의 합을 출력한다.

<문제 2170>
매우 큰 도화지에 자를 대고 선을 그으려고 한다. 선을 그을 때에는 자의 한 점에서 다른 한 점까지 긋게 된다. 선을 그을 때에는 이미 선이 있는 위치에 겹쳐서 그릴 수도 있는데, 여러 번 그은 곳과 한 번 그은 곳의 차이를 구별할 수 없다고 하자.
이와 같은 식으로 선을 그었을 때, 그려진 선(들)의 총 길이를 구하는 프로그램을 작성하시오. 선이 여러 번 그려진 곳은 한 번씩만 계산한다.
<입력값>
첫째 줄에 선을 그은 횟수 N(1 ≤ N ≤ 1,000,000)이 주어진다. 다음 N개의 줄에는 선을 그을 때 선택한 두 점의 위치 x, y(-1,000,000,000 ≤ x < y ≤ 1,000,000,000)가 주어진다.
<출력값>
첫째 줄에 그은 선의 총 길이를 출력한다.

<문제 2171>
2차원 평면 위에 N(1≤N≤5,000)개의 점들이 있다. 이런 점들 중 서로 다른 네 개의 점을 잡아서 연결하면 사각형이 만들어진다. 이러한 사각형들 중에서, x축과 y축에 평행한 직사각형의 개수를 구하는 프로그램을 작성하시오. 직사각형의 넓이는 양수이어야 한다.
<입력값>
첫째 줄에 N이 주어진다. 다음 N개의 줄에는 각 점의 x, y좌표가 주어진다. 좌표의 범위는 -1,000,000,000 이상 1,000,000,000 이하이며, 두 점의 좌표가 같은 경우는 없다.
<출력값>
첫째 줄에 직사각형의 개수를 출력한다.

<문제 2172>
N×N배열에 0부터 9까지의 숫자들이 적혀 있다. 이 배열의 임의의 한 칸에서 시작하여, 매번 인접(상하좌우 및 대각선)해 있는 8개의 칸들 중 하나로 이동하여 총 L칸(시작하는 칸을 포함하여)을 이동하면 하나의 경로가 완성된다. 이때 지나온 순서대로 각 칸에 적혀 있는 숫자를 나열한 것이 팰린드롬이 될 때, 그 경로를 팰린드롬 경로라 한다.
단, 팰린드롬 경로에서는 똑같은 칸을 여러 번 지날 수도 있다. 하지만 같은 자리에 연속으로 계속 있는 것은 안 되고, 매번 8개의 칸들 중 하나로 반드시 이동해야 하지만, 다시 그 칸으로 돌아와서 그 칸을 지나는 것은 허용한다는 것이다.
배열이 주어졌을 때, 팰린드롬 경로의 개수를 구하는 프로그램을 작성하시오.
팰린드롬이란 앞에서부터 읽으나, 뒤에서부터 읽으나 같은 수열을 말한다. 예를 들어 {1}, {1 1}, {1 3 1} 등은 팰린드롬이다.
<입력값>
첫째 줄에 N(1 ≤ N ≤ 20), L(1 ≤ L ≤ 20)이 주어진다. 다음 N개의 줄에는 N개의 정수로 배열의 숫자들이 주어진다.
<출력값>
첫째 줄에 팰린드롬 경로의 개수를 출력한다. 이 값은 231-1보다 작거나 같다.

<문제 2173>
(주) 넝심에서는 양파링의 아성에 도전할 만한 아이디어 과자인 양파깡을 만들어냈다. 양파깡은 기존의 양파링과는 달리 직사각형의 모양을 갖는 과자이다. 그런데 (주) 넝심의 과자 기술은 그리 발달된 것이 아니라서 양파깡의 모양을 바로 만들지 못한다. 그래서 궁여지책으로 생각한 것이 넙적한 과자판을 만들어서 양파깡의 모양으로 잘라내는 방법이다.
양파깡으로 잘라내기 전에 먼저 과자판에 소스(양념가루)를 골고루 뿌려야 하는데, 공정상의 실수로 소스가 엉망으로 뿌려지게 되었다. 이 소스는 많으면 많을수록 과자의 맛이 좋다고 한다.
과자판은 NxN크기의 정사각 배열로서 표현될 수 있으며, 각각의 요소는 그 부분에 뿌려진 소스의 양을 나타낸다. 양수는 원래 기준치 소스양보다  많이 뿌려졌음을, 음수는 그 반대를 나타낸다. 다음은 10x10크기의 과자판의 예이다.

양파깡은 다음과 같이 가운데가 빈 직사각형 모양으로 생겼다. (꼭 가운데에 빈 공간이 있어야 한다. 즉, 양파깡은 최소 3x3이상의 크기를 가져야 한다.) 양파깡은 도중에 끊어지지 않은 모양이어야 한다.

양파깡의 맛은 잘라낸 부분의 소스의 양들의 합으로 정의된다. 위의 양파깡의 맛은 3 + 5 + (-1) + (-2) + 4 + (-5) + 3 + 7 + 1 + 0 + (-6) + 4 + 3 + 2 + 4 + (-3) + 1 + (-2) = 18 이다.
당신은 (주) 넝심의 수석 프로그래머로써 상사의 명령에 따라 과자판으로부터 양파깡을 잘라내는 프로그램을 만들어야 한다. 상사가 원하는 프로그램은 다음과 같다.
(1) 현재 만들어질 수 있는 양파깡 중에서 가장 맛있도록 양파깡을 잘라내야 한다.
(2) 이런 방법으로 M번 반복하여 M개의 양파깡을 잘라낸다.
(3) 만들어진 모든 양파깡 들은 도중에 끊어지지 않고 가운데가 빈 모양이어야 한다.
양파깡이 도중에 끊어지지 않아야 한다는 말은 과자판에서 양파깡들이 서로 겹치지 않아야 된다는 말과 같은 뜻이다.
예로 위의 과자판에서 4개의 양파깡을 만들어 내는 문제를 생각해 보자. 첫 번째로 만들 수 있는 가장 맛 좋은 양파깡은 (3, 1)-(10, 9) 위치에서 잘라내면 만들 수 있다. 이때의 양파깡의 맛은 48이다.

과자판에서 양파깡을 잘라내면 다음과 같은 모양이 된다.

이 과자판에서 가장 맛 좋은 양파깡을 찾아보면 (7, 5)-(9, 7) 부분을 잘라내면 된다. 이 양파깡의 맛은 6이다.

이런 식으로 4개의 양파깡을 만들어 내면 된다.
NxN(3≤N≤30)개의 과자판이 주어질 때, 상사의 요구를 만족시는 프로그램을 작성하시오.
<입력값>
맨 첫줄에는 과자판의 크기 N과 잘라낼 양파깡의 개수 M(1≤M≤30)이 빈 칸을 사이에 두고 주어진다. 다음 줄부터는 과자판이 NxN의 형태로 빈칸을 사이에 두고 주어진다. 각 소스의 수는 -100이상 100이하의 정수이다.
<출력값>
첫 번째 줄부터 잘라낸 순서대로 양파깡의 정보를 M줄 만큼 출력한다. 만약 상사의 요구를 만족하는 양파깡을 M개 잘라내는 것이 불가능하다면 맨 첫줄에 0만을 출력한다.
양파깡의 정보는 처음에 양파깡의 맛을 출력하고, 그 뒤에 양파깡의 위치를 출력한다. 양파깡의 위치는 왼쪽 위의 좌표를 나타내는 두 숫자(행, 열의 순서)와 오른쪽 아래의 좌표를 나타내는 두 숫자를 차례대로 쓴다.
항상 답이 유일한 경우만 입력으로 주어진다.

<문제 2174>
가로 A(1≤A≤100), 세로 B(1≤B≤100) 크기의 땅이 있다. 이 땅 위에 로봇들이 N(1≤N≤100)개 있다.

로봇들의 초기 위치는 x좌표와 y좌표로 나타난다. 위의 그림에서 보듯 x좌표는 왼쪽부터, y좌표는 아래쪽부터 순서가 매겨진다. 또한 각 로봇은 맨 처음에 NWES 중 하나의 방향을 향해 서 있다. 초기에 서 있는 로봇들의 위치는 서로 다르다.
이러한 로봇들에 M(1≤M≤100)개의 명령을 내리려고 한다. 각각의 명령은 순차적으로 실행된다. 즉, 하나의 명령을 한 로봇에서 내렸으면, 그 명령이 완수될 때까지 그 로봇과 다른 모든 로봇에게 다른 명령을 내릴 수 없다. 각각의 로봇에 대해 수행하는 명령은 다음의 세 가지가 있다.

L: 로봇이 향하고 있는 방향을 기준으로 왼쪽으로 90도 회전한다.
R: 로봇이 향하고 있는 방향을 기준으로 오른쪽으로 90도 회전한다.
F: 로봇이 향하고 있는 방향을 기준으로 앞으로 한 칸 움직인다.

간혹 로봇들에게 내리는 명령이 잘못될 수도 있기 때문에, 당신은 로봇들에게 명령을 내리기 전에 한 번 시뮬레이션을 해 보면서 안전성을 검증하려 한다. 이를 도와주는 프로그램을 작성하시오.
잘못된 명령에는 다음의 두 가지가 있을 수 있다.

Robot X crashes into the wall: X번 로봇이 벽에 충돌하는 경우이다. 즉, 주어진 땅의 밖으로 벗어나는 경우가 된다.
Robot X crashes into robot Y: X번 로봇이 움직이다가 Y번 로봇에 충돌하는 경우이다.
<입력값>
첫째 줄에 두 정수 A, B가 주어진다. 다음 줄에는 두 정수 N, M이 주어진다. 다음 N개의 줄에는 각 로봇의 초기 위치(x, y좌표 순) 및 방향이 주어진다. 다음 M개의 줄에는 각 명령이 명령을 내리는 순서대로 주어진다. 각각의 명령은 명령을 내리는 로봇, 명령의 종류(위에 나와 있는), 명령의 반복 회수로 나타낸다. 각 명령의 반복 회수는 1이상 100이하이다.
<출력값>
첫째 줄에 시뮬레이션 결과를 출력한다. 문제가 없는 경우에는 OK를, 그 외의 경우에는 위의 형식대로 출력을 한다. 만약 충돌이 여러 번 발생하는 경우에는 가장 먼저 발생하는 충돌을 출력하면 된다.

<문제 2175>
사각형 모양의 땅이 있다. 이 땅을 둘로 잘라서, 잘라진 두 다각형의 넓이를 최대한 비슷하게 하려고 한다.

땅을 자를 때에는 위의 그림처럼 각 꼭짓점이나 그 중점만을 이용할 수 있다.
<입력값>
첫째 줄에 사각형의 네 꼭짓점의 좌표가 순서대로(시계방향이나 반시계방향으로) 주어진다. 각 꼭짓점의 좌표는 절댓값이 10,000을 넘지 않는 정수이다.
입력으로 주어지는 사각형은 볼록 사각형 (모든 각이 180도보다 작은 사각형) 이다.
<출력값>
첫째 줄에 두 면적을 출력한다. 작은 면적을 먼저 출력하도록 한다. 절대/상대 오차는 10-3까지 허용한다.

<문제 2176>
그래프의 한 정점 S에서 다른 한 정점 T로 이동하려 한다. 이동할 때 T에 가까워지며 이동하는 경우, 이를 합리적인 이동경로라 한다. 물론 이러한 경로는 최단경로가 아닐 수도 있다.
그래프가 주어졌을 때 가능한 합리적인 이동경로의 개수를 구하는 프로그램을 작성하시오. S=1, T=2 인 경우로 한다.
<입력값>
첫째 줄에 정점의 개수 N(1<N≤1,000), 간선의 개수 M이 주어진다. 다음 M개의 줄에는 각 간선에 대한 정보를 나타내는 세 정수 A, B, C가 주어진다. 이는 A번 정점과 B번 정점이 길이 C(0 < C ≤ 10,000)인 간선으로 연결되어 있다는 의미이다. 두 정점은 최대 한 개의 간선으로만 연결될 수 있다. 간선은 방향성이 없다.
<출력값>
첫째 줄에 답을 출력한다. 답은 2147483647을 넘지 않는다.

<문제 2177>
한 회사에서 이번에 새로운 소프트웨어를 개발하였다. 개발이 예정 출시일보다 한 달 일찍 완료되었기 때문에, 한 달 동안은 새 소프트웨어를 테스트하는데 주력하기로 하였다. 테스트 과정에서 버그가 발견되면 수정을 해야 하기 때문에, 개발팀 대신 새로운 테스트팀을 조직하기로 하였고, 이를 위해 필요한 인력을 새로 구하기로 하였다.
테스트는 가급적 많은 인력이 동원되면 좋기 때문에, 회사에서는 최대한 많은 인력을 구하기로 하였다. 하지만 회사의 자산은 한정되어 있고, 한 달 동안의 최저임금이 정해져 있기 때문에 구할 수 있는 인력도 한정되게 된다.
게다가 회사에서 보유중인 자산이 현금 자산이기 때문에 구할 수 있는 인력은 더욱 한정되게 된다. 예를 들어 최저임금이 5원이고, 회사에서 1원짜리와 10원짜리로 11원을 보유하고 있다고 하자. 현금 자산이 아니라면 11원을 반으로 나눠 두 명의 인력을 고용할 수 있지만, 현금 자산이기 때문에 고용할 수 있는 인력은 한 명이 된다. 즉, 한 명의 인력에게 10원짜리 하나를 주게 되면 남는 돈이 1원 뿐이기 때문에 더 이상의 인력을 고용할 수 없다.
물론, 큰 단위의 화폐를 작은 단위의 화폐로 바꾸는 경우는 고려하지 않는다. 또, 화폐 단위는 배수적이라고 가정하자. 즉, 화폐의 각 단위가 다음으로 큰 단위를 나눈다고 가정하자. 예를 들어 화폐 단위가 1, 5, 10, 100원인 경우에는 1이 5를 나누고, 5가 10을 나누고, 10이 100을 나누기 때문에 배수적인 화폐 단위가 된다.
회사가 현재 보유중인 자산과 최저 임금에 대한 정보가 주어졌을 때, 고용할 수 있는 최대 인력의 수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 회사가 보유하고 있는 화폐 종류의 수와 최저임금을 나타내는 두 정수 N(1≤N≤20), C(1≤C≤100,000,000)가 주어진다. 다음 N개의 줄에는 회사가 보유하고 있는 자산에 대한 정보를 나타내는 두 정수 V(1≤V≤100,000,000), B(1≤B≤1,000,000)가 주어진다. 이는 회사가 V원짜리 화폐를 B개 보유하고 있다는 의미이다.
<출력값>
첫째 줄에 고용할 수 있는 최대 인력의 수를 출력한다.

<문제 2178>
N×M크기의 배열로 표현되는 미로가 있다.



1
0
1
1
1
1


1
0
1
0
1
0


1
0
1
0
1
1


1
1
1
0
1
1



미로에서 1은 이동할 수 있는 칸을 나타내고, 0은 이동할 수 없는 칸을 나타낸다. 이러한 미로가 주어졌을 때, (1, 1)에서 출발하여 (N, M)의 위치로 이동할 때 지나야 하는 최소의 칸 수를 구하는 프로그램을 작성하시오. 한 칸에서 다른 칸으로 이동할 때, 서로 인접한 칸으로만 이동할 수 있다.
위의 예에서는 15칸을 지나야 (N, M)의 위치로 이동할 수 있다. 칸을 셀 때에는 시작 위치와 도착 위치도 포함한다.
<입력값>
첫째 줄에 두 정수 N, M(2 ≤ N, M ≤ 100)이 주어진다. 다음 N개의 줄에는 M개의 정수로 미로가 주어진다. 각각의 수들은 붙어서 입력으로 주어진다.
<출력값>
첫째 줄에 지나야 하는 최소의 칸 수를 출력한다. 항상 도착위치로 이동할 수 있는 경우만 입력으로 주어진다.

<문제 2179>
N개의 영단어들이 주어졌을 때, 가장 비슷한 두 단어를 구해내는 프로그램을 작성하시오.
두 단어의 비슷한 정도는 두 단어의 접두사의 길이로 측정한다. 접두사란 두 단어의 앞부분에서 공통적으로 나타나는 부분문자열을 말한다. 즉, 두 단어의 앞에서부터 M개의 글자들이 같으면서 M이 최대인 경우를 구하는 것이다. "AHEHHEH", "AHAHEH"의 접두사는 "AH"가 되고, "AB", "CD"의 접두사는 ""(길이가 0)이 된다.
접두사의 길이가 최대인 경우가 여러 개일 때에는 입력되는 순서대로 제일 앞쪽에 있는 단어를 답으로 한다. 즉, 답으로 S라는 문자열과 T라는 문자열을 출력한다고 했을 때, 우선 S가 입력되는 순서대로 제일 앞쪽에 있는 단어인 경우를 출력하고, 그런 경우도 여러 개 있을 때에는 그 중에서 T가 입력되는 순서대로 제일 앞쪽에 있는 단어인 경우를 출력한다.
<입력값>
첫째 줄에 N(2 ≤ N ≤ 20,000)이 주어진다. 다음 N개의 줄에 알파벳 소문자로만 이루어진 길이 100자 이하의 서로 다른 영단어가 주어진다.
<출력값>
첫째 줄에 S를, 둘째 줄에 T를 출력한다. 단, 이 두 단어는 서로 달라야 한다. 즉, 가장 비슷한 두 단어를 구할 때 같은 단어는 제외하는 것이다.

<문제 2180>
여기는 울릉도 소방서이다. 소방차가 한 대 밖에 없어서 여러 차례 중앙 정부에 소방차 증차를 요청하였으나 아직도 증차가 실현되지 않고 있다. 그런데 오늘 믿어지지 않는 엄청난 일이 발생하고 말았다. 여러 건의 화재가 동시에 발생한 것이다. 소방서의 고민은 한 대의 소방차를 이용하여 어떤 순서로 화재를 진압하는 것이 모든 화재를 진압하는데 걸리는 시간을 최소화하느냐는 것이다. 지체할 시간이 없다. 그 순서를 아주 빨리 정해야 한다. 당신의 도움이 필요하다.
다행히 다음과 같은 정보를 얻을 수 있다. 한 화재 사건에 소방차 도착이 늦으면 늦을수록 화재를 진압하는데 걸리는 시간이 같거나 길어진다. 화재의 종류에 따라서, 화재 발생 후 소방차가 t초 후에 도착하면 화재를 진압하는데 걸리는 시간은 at +b와 같이 1차 함수의 형태로 나타나게 된다. 물론 a와 b는 음수는 아니다. 화재 종류별로 a, b의 값이 일반적으로 다르게 나타나게 된다.
모든 화재 사건은 시각 0에서 발생하였다. 당신은 모든 화재를 진압하는데 걸리는 최소 시간이 얼마인지를 알고 싶다. 소방차의 이동 시간은 고려하지 않고 0으로 가정하며, 한 화재 진압이 완전히 끝나기 전에는 소방차가 다른 화재 현장으로 이동할 수 없다.
<입력값>
첫째 줄에 화재 발생 건수 n이 주어진다. n은 200,000 이하의 양의 정수이다. 둘째 줄부터 n개의 줄에 각각 한 줄에 한 쌍씩 a와 b가 입력된다. a와 b는 40,000 이하의 음이 아닌 정수이다.
<출력값>
첫째 줄에 모든 화재를 진압하는데 걸리는 최소 시간을 40,000으로 나눈 나머지를 출력한다.

<문제 2181>
You happen to own a dog, a labrador. Because your pet tends to get lazy and fat without enough exercise, you often take your buddy out for a walk in the local park.
As you already get enough exercise yourself and don't feel like running after your dog, you have bought a very long rope to tie your labrador to. Assume it has infinite length. You find yourself a nice place to sit down, holding one end of the rope, and let your dog run free (while still attached to the other end of the rope). While your pet runs through the park the rope could wind around the flagpole that is standing in the middle of the park. You let this happen, but in order not to get entangled, you occasionally jump over the line when it passes the place where you sit.
Your job is, given the points to where the dog runs successively, to determine how many entire times the rope has been wrapped around the flagpole when the dog has finished its walk (so round your answer down to an integer). You may assume that your dog always takes the shortest path to the next point. When this path goes right through the flagpole, the dog always goes around it counterclockwise. For this problem we lay a coordinate map (-109 ≤ x; y ≤ 109) over this park. The flagpole is at point (0; 0).
<입력값>
The first line of input consists of the integer number n (0 < n ≤ 10000), the number of test cases;
Then, for each test case:
	
A line with an integer number m (0 < m ≤ 1000), the number of points the dog's walk consists of;
Then, m lines with two integer numbers xi; yi;(-109≤ xi; yi ≤ 109; (xi; yi) ≠ (0; 0)), the coordinates of the i'th point the dog will run to.
<출력값>
For each test case, the output contains one line with one integer number: the number of entire windings the rope has made around the flagpole after you sit down at (x1; y1) and let your dog make the walk (x1; y1) -> (x2; y2) ->...->(xm; ym).

<문제 2183>
N(1≤N≤26)명의 사람이 테니스 시합을 하려 한다. 테니스 게임은 두 명이 하는 것이 일반적이지만, 이 문제에서는 테니스 규칙을 조금 변경하여 N명이 함께 플레이하는 형태가 된다. 즉, N명의 선수들이 모두 하나의 코트에 올라 게임을 진행하는 형식이다.
기본적으로 하나의 시합은 여러 개의 세트로 이루어진다. 각각의 세트는 다시 여러 개의 게임으로 이루어진다. 각각의 게임은 다시 여러 개의 턴으로 이루어진다. 즉 게임에서 이기기 위해서는 먼저 턴을 이기고, 이를 통해 게임을 이긴 뒤, 다시 이를 통해 세트를 이기면 된다.
시합을 하다 보면 서브를 하는 사람이 중요한데, 서브는 각 턴에서 순서대로 하고, 각 게임에서는 이전 게임에서 제일 먼저 서브를 했던 사람의 다음 사람부터 서브를 하고, 각 세트의 첫 번째 게임의 첫 턴에서는 이전 세트의 첫 게임에서 처음 서브를 한 사람의 다음 사람이 서브를 하게 된다. 예를 들어 N=3일 때 서브를 하는 순서는 다음과 같다. 각각의 사람은 알파벳 대문자로 A부터 차례로 표현된다.

[1 세트]
	
게임 1 : A, B, C, A, …
게임 2 : B, C, A, …
게임 3 : C, A, B, …
게임 4 : A, B, C, …
…


[2 세트]
	
게임 1 : B, C, A, B, …
게임 2 : C, A, B, …
게임 3 : A, B, C, A, …
…


…

각 게임의 승자를 가리는 규칙은 다음과 같다. 먼저 각각의 선수들은 0점에서 각 게임을 시작하게 된다. 각 선수들이 하나의 턴에서 이길 경우, 그 선수의 점수의 변화 및 게임의 승자에 대한 규칙은 다음과 같다. 규칙의 우선순위는 (1) > (2) > (3) > (4) 순서이다.

만약 x의 현재 점수가 3점이고 다른 선수들이 모두 2점을 넘지 못했으면 x가 그 게임을 이기게 된다.
만약 x의 현재 점수가 4점이면 x가 그 게임을 이기게 된다.
만약 x가 아닌 선수의 현재 점수가 4점이면 그 선수는 1점을 잃게 된다.
위의 경우가 아닌 경우 x가 단순히 1점을 얻게 된다.

하나의 세트의 승자는 최소 6개의 게임을 이겼으며, 다른 모든 선수들보다 최소 두 게임을 더 이긴 선수가 된다. 또한 시합의 승자는 최소 3개의 세트를 이긴 선수가 된다. 단, 어떤 세트에서 하나의 선수가 모든 게임을 이긴 경우에는 두 개의 세트를 이긴 것으로 친다.
테니스 시합이 진행될 때, 각 게임의 승자가 주어졌을 때, 최종 승자를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 정수 N와 스트링 S가 주어진다. S는 각 게임에서의 승자를 차례대로 나열한 스트링이다. 단순히 각 게임의 승자만을 나열한 것이기 때문에, 어디까지가 어떤 세트이고 어떤 게임인지를 알기 위해서는 이 스트링을 위의 규칙대로 분석하여야 한다. 스트링의 길이는 100,000을 넘지 않는다. 주어지는 입력이 잘못된 경우는 없다고 가정한다.
<출력값>
첫째 줄에 승자를 출력한다.

<문제 2184>
월드 식품에서는 김치를 만들어 여러 도시들에 배달 판매하는 일을 하고 있다. 각각의 도시들과 김치 공장은 1차원 직선상의 점에 위치해 있다. 각 도시는 정수 좌표로 나타난다.
배달을 할 때에는 공장에서 N(1≤N≤1,000)포기의 김치를 들고 시작한다. 그리고 1차원 직선을 따라 왼쪽이나 오른쪽으로 움직인다. 이동을 할 때에는 1초에 한 칸씩 움직일 수 있다. 또한 어떤 도시에 도착했을 때 김치는 0의 시간에 배달되는 것으로 생각한다. 즉 도시에 도착하기만 하면 배달이 완료되는 것으로 생각한다. 또한 김치를 배달하는 순서는 상관이 없다.
각각의 김치는 모두 t=0 의 시각에 공장에서 출발된다. 각각의 김치는 1초에 1만큼씩 쉬게 되는데, 김치가 쉬게 될 경우 소비자가 불만을 토로할 수 있다. 따라서 월드 식품에서는 각 도시에 김치가 도착했을 때의 김치의 쉰 정도의 합을 최소로 하려 한다.
각 도시의 위치 및 김치 공장의 위치(x좌표)가 주어졌을 때, 모든 도시에 김치를 배달할 때의 김치의 쉰 정도의 합의 최솟값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 두 정수 N, L이 주어진다. L은 김치 공장의 x좌표이다. 다음 N개의 줄에는 김치를 배달할 도시의 x좌표가 주어진다. 모든 좌표는 1이상 1,000,000이하의 정수이다.
<출력값>
첫째 줄에 답을 출력한다.

<문제 2185>
2차원 평면상에 N(0≤N≤5,000)개의 직사각형들이 주어졌을 때, 이 직사각형들의 합집합을 구하는 프로그램을 작성하시오.

예를 들어 왼쪽은 7개의 직사각형이 주어진 모습이고, 오른쪽 그림은 그 직사각형의 합집합을 구한 예이다. 이러한 합집합을 구하면 하나의 다각형이 나오는데, 이 다각형의 둘레의 길이를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 직사각형의 개수 N이 주어진다. 다음 N개의 줄에는 각 사각형의 정보를 나타내는 네 정수 x1, y1, x2, y2가 주어진다. 이는 사각형의 대각선으로 마주 보는 두 꼭짓점의 좌표가 (x1, y1), (x2, y2)라는 의미이다. 좌표의 범위는 -10,000이상 10,000이하로 한다.
<출력값>
첫째 줄에 답을 출력한다.

<문제 2186>
알파벳 대문자가 한 칸에 한 개씩 적혀있는 N×M 크기의 문자판이 있다. 편의상 모든 문자는 대문자라 생각하자. 예를 들어 아래와 같은 문자판을 보자.



K
A
K
T


X
E
A
S


Y
R
W
U


Z
B
Q
P



이 문자판의 한 칸(아무 칸이나 상관없음)에서 시작하여 움직이면서, 그 칸에 적혀 있는 문자들을 차례대로 모으면 하나의 단어를 만들 수 있다. 움직일 때는 상하좌우로 K개의 칸까지만 이동할 수 있다. 예를 들어 K=2일 때 아래의 그림의 가운데에서는 'X' 표시된 곳으로 이동할 수 있다.



 
 
X
 
 


 
 
X
 
 


X
X
 
X
X


 
 
X
 
 


 
 
X
 
 



반드시 한 칸 이상 이동을 해야 하고, 같은 자리에 머물러 있을 수 없다. 또, 같은 칸을 여러 번 방문할 수 있다.
이와 같은 문자판과 K, 그리고 하나의 영단어가 주어졌을 때, 이와 같은 영단어를 만들 수 있는 경로가 총 몇 개 존재하는지 알아내는 프로그램을 작성하시오.
위의 예에서 영단어가 BREAK인 경우에는 다음과 같이 3개의 경로가 존재한다. 앞의 수는 행 번호, 뒤의 수는 열 번호를 나타낸다.

(4, 2) (3, 2) (2, 2) (1, 2) (1, 1)
(4, 2) (3, 2) (2, 2) (1, 2) (1, 3)
(4, 2) (3, 2) (2, 2) (2, 3) (1, 3)
<입력값>
첫째 줄에 N(1 ≤ N ≤ 100), M(1 ≤ M ≤ 100), K(1 ≤ K ≤ 5)가 주어진다. 다음 N개의 줄에는 M개의 알파벳 대문자가 주어지는데, 이는 N×M 크기의 문자판을 나타낸다. 다음 줄에는 1자 이상 80자 이하의 영단어가 주어진다. 모든 문자들은 알파벳 대문자이며, 공백 없이 주어진다.
<출력값>
첫째 줄에 경로의 개수를 출력한다. 이 값은 int 범위이다.

<문제 2187>
평면에 N(1 ≤ N ≤ 1,000)개의 점들이 있다. 각각의 점들은 정수 값으로 어떤 가중치 S(1 ≤ S ≤ 2,000,000)를 가지고 있다. 또 각각의 점들은 (r, c)의 좌표를 갖는데 이는 (행, 열) 순이다. 또한 1 ≤ r ≤ 2,000,000과 1 ≤ c ≤ 2,000,000가 성립한다.
이제 우리는 세로로 A(1 ≤ A ≤ 2,000,000), 가로로 B(1 ≤ B ≤ 2,000,000)만큼의 직사각형을 쳐서 이 중 몇 개의 점들을 이 사각형 안에 포함시키려고 한다. 이때, 사각형 안에 포함된 점들 중, “S의 최대-S의 최소”가 최대가 되도록 하려 한다.
예를 들어 다음과 같은 경우를 보자.

이는 예제 데이터와 같은 경우고, 회색 부분처럼 선택했을 때, 가중치 최대-가중치 최소가 7이 되고 이 경우가 이 값이 최대가 되는 경우이다.
<입력값>
첫째 줄에 세 정수 N, A, B가 주어진다. 다음 N개의 줄에는 각 점의 r(세로좌표), c(가로좌표), S(가중치)를 나타내는 세 정수가 주어진다.
<출력값>
첫째 줄에 가중치 최대 - 가중치 최소가 최대가 될 경우의 이 값을 출력한다.

<문제 2188>
농부 존은 소 축사를 완성하였다. 축사 환경을 쾌적하게 유지하기 위해서, 존은 축사를 M개의 칸으로 구분하고, 한 칸에는 최대 한 마리의 소만 들어가게 계획했다.
첫 주에는 소를 임의 배정해서 축사를 운영했으나, 곧 문제가 발생하게 되었다. 바로 소가 자신이 희망하는 몇 개의 축사 외에는 들어가기를 거부하는 것이다.
농부 존을 도와 최대한 많은 수의 소가 축사에 들어갈 수 있도록 하는 프로그램을 작성하시오. 축사의 번호는 1부터 M까지 매겨져 있다.
<입력값>
첫째 줄에 소의 수 N과 축사의 수 M이 주어진다. (1 ≤ N, M ≤ 200)
둘째 줄부터 N개의 줄에는 각 소가 들어가기 원하는 축사에 대한 정보가 주어진다. i번째 소가 들어가기 원하는 축사의 수 Si (0 ≤ Si ≤ M)이 먼저 주어지고, 이후 Si개의 축사 번호가 주어진다. 같은 축사 번호가 두 번 이상 주어지는 경우는 없다.
<출력값>
첫째 줄에 축사에 들어갈 수 있는 소의 최댓값을 출력한다.

<문제 2189>
Matheos the magician wishes to organise her considerable collection of squares into categories based on the amount of magical power that each one possesses. A square is a table of numbers with an equal number of rows and columns and each square has an associated sum (S), the sum of the first column. Matheos wishes to categorise them based on the following properties:
Not Magick : At least one row or column does not sum to S.
Semi-Magick Square : Each row and column sums to S but at least one of the diagonals doesn’t.
Weakly-Magick Square : All the rows, columns and diagonals sum to S.
Strongly-Magick Square : All the rows, columns and diagonals sum to S, and the numbers are distinct (i.e. no number is duplicated).
Magically-Magick Square : All the rows, columns and diagonals sum to S, the numbers are distinct and they are consecutive (i.e. they form a sequence with no gaps).
Thus



2
3


3
2



is a Semi-Magick square because each row and column adds up to 5, but the diagonals don’t.
and



8
1
6


3
5
7


4
9
2



is a Magically-Magick square because each row, column and diagonal adds up to 15, each number is distinct, and the numbers are consecutive (i.e. 1 2 3 4 5 6 7 8 9).
Your task is to help Matheos by writing a program to read and evaluate a sequence of squares. For each square your program is to output a message to say whether it is Magically-Magick, Strongly-Magick, Weakly-Magick, Semi-Magick, or has no magical properties at all.
<입력값>
Input will consist of a sequence of squares. Each square starts with an integer, n, specifying the square’s size (number of rows and columns; 2 ≤ n ≤ 8) on a line by itself, followed by n lines, each with n integers. The sequence of squares is terminated by a line containing a zero (0).
<출력값>
Output for each square is a single line starting with the word ‘Square’ followed by a space, a sequence number (starting at 1) and a colon (:). This is then followed by another space and then one of following massages ‘Magically-Magick Square’, ‘Strongly-Magick Square’, ‘Weakly-Magick Square’, ‘Semi-Magick Square’, or ‘Not a Magick Square’ as appropriate.

<문제 2190>
2차원 평면상에 N(1≤N≤100)개의 점들이 있다. 여기에 가로 길이가 A(0≤|A|≤2,000,000,000), 세로 길이가 B(0≤|B|≤2,000,000,000)인 직사각형을 쳐서 이 중 몇 개의 점들을 이 사각형 안에 포함시키려고 한다. 이때, 사각형 안에 포함된 점들의 개수가 최대가 되도록 하려 한다. 점들의 최대 개수를 알아내는 프로그램을 작성하시오.
사각형의 테두리상에 위치한 점들도 사각형 안에 포함된 점으로 친다.
<입력값>
첫째 줄에 세 정수 N, A, B가 주어진다. 다음 N개의 줄에는 차례로 각 점의 x, y좌표가 주어진다. 각 좌표의 절댓값은 2,000,000,000을 넘지 않는다.
<출력값>
첫째 줄에 답을 출력한다.

<문제 2191>
N(1≤N≤100)마리의 들쥐들과 M(1≤M≤100)개의 땅굴이 있다. 각각의 들쥐는 2차원 평면상의 한 위치에 있고, 각각의 땅굴들도 2차원 평면상의 한 점에 위치한다.
들쥐들을 잡아먹는 매가 들쥐들을 습격했을 때, 쥐들은 매를 피하기 위해서 땅굴 속으로 숨을 수 있다. 모든 쥐들이 땅굴에 숨을 수 있다면 매에 잡아먹히는 쥐가 한 마리도 없겠지만, 각각의 땅굴에는 한 마리의 쥐만 들어갈 수 있을뿐더러 매가 도착하는 시간과 쥐들이 땅굴로 도망치는 속도가 있기 때문에 항상 모든 쥐들이 도망갈 수 있는 것은 아니다.
매는 현재를 기준으로 S(1≤S≤100)초가 지난 후에 지상에 도착한다. 각각의 들쥐들은 매 초당 V(1≤V≤100)만큼의 거리를 움직인다(즉 V가 쥐들의 초속이다). 만약 S초가 되기 전에 들쥐가 땅굴에 도착하게 되면 그 들쥐는 땅굴로 숨을 수 있다. 단, 들쥐가 도착하는 시간이 정확히 S인 경우에도 그 들쥐는 도망칠 수 있는 것으로 간주한다.
들쥐들은 종족 전체의 번영을 위해, 매에 잡아먹히게 되는 들쥐의 수가 최소가 되도록 도망치기로 하였다. 들쥐와 땅굴의 위치, 그리고 들쥐의 속도와 매가 도착하는 시간이 주어졌을 때, 잡아먹히게 되는 들쥐의 최소수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 네 정수 N, M, S, V가 주어진다. 다음 N개의 줄에는 들쥐의 x, y좌표가 주어지고, 그 다음 M개의 줄에는 땅굴의 x, y좌표가 주어진다. 모든 좌표는 절댓값이 1,000을 넘지 않는다.
<출력값>
첫째 줄에 잡아먹히게 되는 들쥐의 최솟값을 출력한다.

<문제 2192>
양의 정수로 구성된 길이 N인 수열 A와 길이 M인 수열 B가 있다. 두 수열에 대해서 게임을 진행하려 한다.
수열 A의 뒤에서부터 K1(≥1)개의 수들의 합을 S1이라 하고, 수열 B의 뒤에서부터 K2(≥1)개의 수들의 합을 S2라 하자. 한 개의 수를 선택할 수도 있고, 수열 전체를 선택할 수도 있다. 이 단계에서의 점수는 (S1 - K1)×(S2 - K2)가 된다. 이때 선택한 수들을 원래 수열에서 제거한다. 즉, 수열 A의 뒤에서부터 K1개의 수들을 제거하고, 수열 B의 뒤에서부터 K2개의 수들을 제거한다. 그리고 남아있는 수열에 대해서 같은 방식으로 게임을 진행한다. 게임은 두 수열을 이루는 수들이 모두 제거됐을 때 끝난다. 이와 같이 게임을 진행했을 때의 전체 점수는, 각 단계에서의 점수의 총 합이 된다.
두 수열이 주어졌을 때, 전체 점수의 최소를 구하는 프로그램을 작성하시오.
수열에서 수들을 제거할 때 1개 이상씩 제거를 하게 된다. 또한 게임은 두 수열을 이루는 수들이 모두 제거됐을 때 끝난다. 즉, 하나의 수열은 모두 제거됐는데 다른 하나의 수열은 모두 제거되지 않은 경우는 게임이 끝난 경우가 아니다. 즉, 하나의 수열만 남게 되는 경우가 있어서는 안 된다.
<입력값>
첫째 줄에 두 정수 N, M(1≤N, M≤2,000)이 주어진다. 다음 줄에는 A를 이루는 수들이 앞에서부터 주어진다. 그 다음 줄에는 B를 이루는 수들이 앞에서부터 주어진다. 두 수열을 이루는 수들은 모두 1,000이하이다.
<출력값>
첫째 줄에 전체 점수의 최솟값을 출력한다.

<문제 2193>
0과 1로만 이루어진 수를 이진수라 한다. 이러한 이진수 중 특별한 성질을 갖는 것들이 있는데, 이들을 이친수(pinary number)라 한다. 이친수는 다음의 성질을 만족한다.

이친수는 0으로 시작하지 않는다.
이친수에서는 1이 두 번 연속으로 나타나지 않는다. 즉, 11을 부분 문자열로 갖지 않는다.

예를 들면 1, 10, 100, 101, 1000, 1001 등이 이친수가 된다. 하지만 0010101이나 101101은 각각 1, 2번 규칙에 위배되므로 이친수가 아니다.
N(1 ≤ N ≤ 90)이 주어졌을 때, N자리 이친수의 개수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N이 주어진다.
<출력값>
첫째 줄에 N자리 이친수의 개수를 출력한다.

<문제 2194>
스타크래프트와 같은 게임을 하다 보면 어떤 유닛을 목적지까지 이동시켜야 하는 경우가 종종 발생한다. 편의상 맵을 N×M 크기의 2차원 행렬로 생각하자. 또한 각각의 유닛은 크기를 가질 수 있는데, 이를 A×B 크기의 2차원 행렬로 생각하자. 아래는 5×5 크기의 맵과 2×2 크기의 유닛에 대한 한 예이다. S는 시작점을 나타내며 E는 끝점을 나타낸다.

유닛은 상하좌우의 네 방향으로만 움직일 수 있다. 단, 유닛의 일부분이 장애물이 설치된 부분(위의 예에서 색이 칠해진 부분)을 지날 경우, 위의 예에서는 시작 위치에서 위로 이동하는 경우는 허용되지 않는다. 위의 예는 유닛을 오른쪽으로 세 칸, 위쪽으로 세 칸 움직이면 목적지에 도달할 수 있고, 이 경우가 가장 적은 이동 회수를 거치는 경우이다. 이동하는 도중에 유닛이 맵 밖으로 나가는 경우는 허용되지 않는다.
맵의 정보와 유닛의 정보가 주어졌을 때, 유닛을 목적지까지 움직이기 위해 필요한 최소의 이동 회수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 다섯 개의 정수 N, M(1 ≤ N, M ≤ 500), A, B(1 ≤ A, B ≤ 10), K(0 ≤ K ≤ 100,000)가 주어진다. 다음 K개의 줄에는 장애물이 설치된 위치(행 번호, 열 번호)가 주어진다. 그 다음 줄에는 시작점의 위치와 도착점의 위치가 주어진다. 시작점의 위치와 도착점의 위치는 제일 왼쪽 제일 위의 한 점만 주어진다. 시작점의 위치와 도착점의 위치는 같지 않다.
<출력값>
첫째 줄에 답을 출력한다. 이동이 불가능한 경우에는 -1을 출력한다.

<문제 2195>
어떤 원본 문자열 S가 주어졌을 때, 이 문자열의 부분을 복사하여 P라는 새로운 문자열을 만들려고 한다. 복사를 할 때에는 copy(s, p) 이라는 함수를 이용하는데, 이는 S의 s번 문자부터 p개의 문자를 P에 복사해서 붙인다는 의미이다.
예를 들어 S="abaabba", P="aaabbbabbbaaa"인 경우를 생각해 보자. 이때는 copy(3, 2), copy(4, 3), copy(2, 2), copy(5, 2), copy(2, 3), copy(1, 1) 를 수행하여 P를 만들 수 있다. 각 단계별로 P는 "aa", "aaabb", "aaabbba", …와 같이 변하게 된다.
이와 같은 copy 연산을 이용하여 S에서 P를 만들려고 하는데, 이때 가능하면 copy 함수를 조금 사용하려고 한다.
S와 P가 주어졌을 때, 필요한 copy 함수의 최소 사용횟수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 S, 둘째 줄에 P가 주어진다. S와 P는 영어 대소문자와 숫자로만 되어 있다. S의 길이는 1,000을 넘지 않으며, P의 길이는 1,000을 넘지 않는다. copy함수만을 이용하여 S에서 P를 만들어낼 수 없는 경우는 입력으로 주어지지 않는다고 가정하자. 각 문자열은 최소한 한 개의 문자로 이루어져 있다고 가정하자.
<출력값>
첫째 줄에 copy 함수의 최소 사용횟수를 출력한다.

<문제 2196>
길이 B(1≤B≤16)인 이진수들이 E(1≤E≤100)개 있다. 이 이진수들을 두 개씩 선택하여 XOR연산을 하여, 어떤 이진수를 만들려고 한다. 이 과정에서 만들어지는 이진수들을 이용하여 XOR연산을 해도 되며, 같은 두 이진수를 XOR연산을 해도 된다.
만약 우리가 만들고자 하는 이진수를 만들 수 없다면, 이 이진수와 제일 가까운 이진수를 만들려고 한다. 제일 가깝다는 것은, 두 이진수들에서 서로 다른 비트의 개수가 최소인 것을 말한다. 만약 여러 개의 이진수가 제일 가까운 경우에는, XOR 연산을 가장 적게 사용하는 이진수를 출력한다. 같은 회수의 연산을 사용한다면 사전식으로 제일 앞에 오는 이진수를 출력한다.
C에서 XOR 연산자는 ^이다. 0^0=0, 0^1=1, 1^0=1, 1^1=0이 된다. 10110과 11101을 XOR 연산을 하면 01011이 된다.
<입력값>
첫째 줄에 B, E가 주어진다. 다음 줄에는 우리가 만들고자 하는 이진수를 나타내는 B개의 정수(0 또는 1)이 주어진다. 다음 E개의 줄에는 각각의 이진수들이 주어진다.
<출력값>
첫째 줄에 사용한 XOR 연산의 회수를 출력한다. 다음 줄에는 이진수를 출력한다. 첫째 줄에 출력한 연산의 회수는 둘째 줄의 이진수를 만들기 위해 사용한 XOR 연산의 회수이다. XOR 연산은 적어도 한 번 해야 한다.

<문제 2197>
N(1≤N≤150)개의 원자로 구성된 분자가 있다. 각각의 원자들은 1부터 N까지의 번호가 붙어 있으며, 모든 원자들이 하나의 분자로 모두 연결되어 있다. 화학 실험을 할 때 결합 반응과 분해 반응에 대한 실험을 쉽게 하기 위해서, 원자들을 총 N-1 개의 결합만을 하고 있다.
실험을 하던 도중에 M개의 원자로 구성된 분자가 필요해졌다. 이 분자의 원자들의 종류는 상관이 없고, 단지 M개의 원자로 구성되어 있기만 하면 된다. 물론 이 역시 M개의 원자들이 하나의 분자로 모두 연결되어 있어야 한다. 이를 위해서, 주어진 분자의 몇 개의 결합을 해제하는 분해 반응을 거쳐야 한다.
한 번의 반응을 거치면 오직 한 개의 결합만이 해제된다. 이를 통해 하나의 분자를 두 개의 분자로 나눌 수 있다. 이제 이 두 개의 분자들 중 하나를 택해서 M개의 원자로 구성된 분자를 얻을 때까지 계속 분해 반응을 진행한다. 이러한 분해 반응을 진행하다 보면 물질의 안정성이 깨질 수도 있기 때문에, 당신은 최소 회수의 분해 반응을 이용하려 한다.
원자들의 연결 상태가 주어졌을 때, M개의 원자로 구성된 분자를 얻어내기 위한 최소 분해 반응 회수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 두 정수 N, M(1≤M≤N)이 주어진다. 다음 N-1개의 줄에는 원자들의 연결 상태를 나타내는 서로 다른 두 정수 A, B(1≤A, B≤N)가 주어진다. 이는 A번 원자와 B번 원자가 결합을 이루고 있다는 의미이다.
<출력값>
첫째 줄에 답을 출력한다.

<문제 2198>
N(1≤N≤10,000)개의 정류장을 지나는 버스가 있다. 정류장은 차례로 1, 2, …, N번의 번호가 붙어 있고, 버스는 1번 정류장에서 출발하여 N번 정류장까지 간 후, 다시 1번 정류장으로 돌아오게 된다.
버스회사에서는 주기적으로 1번 정류장에서 버스를 출발시켜서 모든 손님들이 버스를 이용할 수 있도록 하고 있었는데, 겨울철에 눈이 많이 오는 바람에 한 대의 버스밖에 운행하지 못 하게 되었다. 불행 중 다행으로 회사에서는 고객들이 버스를 이용하는 구간을 K(1≤K≤50,000)개 조사해 둔 상태이다.
버스는 최대 C(1≤C≤100)명을 태울 수 있다. 회사 측에서는 사전에 조사해 둔 자료를 바탕으로, 한 바퀴를 도는(1번 정류장에서 N번 정류장까지 갔다가 다시 1번 정류장으로 돌아오는) 동안 가급적이면 많은 고객들을 목적지까지 태워 주려고 한다. 각 정류장에서 버스는 사람을 내려 줄 수도 있고, 사람을 태울 수도 있다. 단, 버스에 한 밴 태운 고객들은 목적지에 도착하기 전에는 내려줄 수 없다.
목적지까지 태워줄 수 있는 고객의 최대 수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 세 정수 K, N, C가 주어진다. 다음 K개의 줄에는 고객들의 버스 이용 구간을 나타내는 세 정수 S, E(1≤S, E≤N), M(1≤M≤C)이 주어진다. S와 E는 서로 다르며, 이는 S번 정류장에서 E번 정류장까지 가려는 고객이 M명 있다는 의미이다.
<출력값>
첫째 줄에 답을 출력한다.

<문제 2200>
다항식을 계산하기 위해 고안된 계산기가 있다. 이 계산기에는 0부터 9까지의 숫자와 +, ×(곱하기), x, =의 14개의 키가 있다.
예를 들어 이 계산기를 이용하여 x^3 + x + 11을 계산하려면 x, ×, x, ×, x, +, x + 1, 1, = 을 누르면 된다. 또 x^3 + 2x^2 + 11을 계산하기 위해서는 x, +, 2, ×, x, ×, x, +, 1, 1, = 을 누르면 된다.
일반적인 계산기라면 x, +, 2, ×, x, ×, x, +, 1, 1, = 을 x + 2x^2 + 11로 인식하겠지만, 이 계산기는 추가 메모리가 없기 때문에 계산을 할 때에 계산 직전에 계산기에 저장되어 있던 값에 계산을 한다. 즉 x, +, 2, ×, x, ×, x, +, 1, 1, = 을 입력하면 계산기에는 차례로 x, x+2, x^2+2x, x^3+2x^2, x^3+2x^2+11 이 입력되는 것이다.
문제를 단순하게 하기 위해서 최고차항의 계수는 항상 1이라고 가정하자. 또 음수 계수는 고려하지 않기로 하자.
다항식이 주어졌을 때, 이 계산기로 주어진 다항식을 계산하려면 계산기를 최소 몇 번 눌러야 하는지를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 다항식의 차수 N(1≤N≤10,000)이 주어진다. 다음 줄에는 다항식의 계수가 최고차항부터 주어진다. 최고차항의 계수는 항상 1이며 모든 계수는 0 이상이다. 모든 계수는 1,000,000,000을 넘지 않는다.
<출력값>
첫째 줄에 계산기를 누르는 최소 횟수를 출력한다.

<문제 2201>
0과 1로만 이루어진 수를 이진수라 한다. 이러한 이진수 들 특별한 성질을 갖는 것들이 있는데, 이들을 이친수(pinary number)라 한다. 이친수는 다음의 성질을 만족한다.

이친수는 0으로 시작하지 않는다.
이친수에서는 1이 두 번 연속으로 나타나지 않는다. 즉, 11을 부분 문자열로 갖지 않는다.

예를 들면 1, 10, 100, 101, 1000, 1001 등이 이친수가 된다. 하지만 0010101이나 101101은 각각 (1), (2)번 규칙에 위배되므로 이친수가 아니다.
이와 같은 이친수를 이진수의 크기 순서대로 정렬하여 차례로 번호를 붙인다. 이를테면 첫 번째 이친수는 1, 두 번째 이친수는 10, 네 번째 이친수는 101이 되는 식이다.
자연수 K(1 ≤ K ≤ 1,000,000,000,000,000,000)가 주어졌을 때, K번째 이친수를 찾아내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 K가 주어진다.
<출력값>
첫째 줄에 답을 출력한다.

<문제 2202>
Web site users are often presented with data in tables. Different users may want table rows displayed in different orders. For a web site listing available hotels, possible orders include hotel name, hotel locality, hotel star rating and room rate. For this problem you are to write a piece of support software for possible inclusion in such a site.
<입력값>
Input will consist of a number of data sets. Each data set consists of a heading line, a table section and a sorter section. The heading line contains the title of the data set. The sequence of data sets is terminated by a (heading) line consisting of a single ‘#’. A table section consists of at least 1 and no more than 20 lines, terminated by a line consisting of a single ‘#’. Each line contains between 1 and 10 fields, separated by commas; each field contains a string(20). All lines have the same number of fields and there are no empty fields. A sorter section consists of several sorter lines. Each sorter line contains one or more field sorters separated by commas, each consisting of a field number (a distinct number in the range 1 to the number of fields), and a direction (‘A’ or ‘D’). A sorter section is terminated by a line consisting of ‘0#’.
<출력값>
The output starts with the title of the data set, followed by several groups of lines, indented two spaces and separated by a blank line between groups. Each group consists of the contents of the table section, sorted according to the corresponding sort specification. Sorting is primarily done based on the first field sorter, and the second and subsequent field sorters are only used for those rows with the same value(s) in the field(s) used by previous field sorter(s). If there are still ties (equal elements), the tied elements should appear in the order of the original table. Leave a blank line between the output for successive data sets.

<문제 2204>
꿍은 도비에게 영어단어들을 제시한 후 어떤 단어가 대소문자를 구분하지 않고 사전순으로 가장 앞서는지 맞추면 양말을 주어 자유를 얻게해준다고 하였다.
하지만 인성이 좋지 않은 꿍은 사실 그러고 싶지 않았기 때문에 대소문자를 마구 섞어가며 단어들을 제시했다. 예를 들어, apPle은 Bat보다 앞서지만 AnT보다는 뒤에 있는 단어다.
도비에게 희망은 여러분뿐이다! 여러분이 도비에게 자유를 선물해주도록 하자!
<입력값>
각 테스트케이스는 정수 n (2 ≤ n ≤ 1000) 으로 시작하며 주어지는 단어의 개수를 뜻한다.
다음 각 n줄은 길이가 최대 20인 단어가 주어지며 대소문자의 구분을 없앴을 때 똑같은 단어는 주어지지 않는다.
마지막 입력은 0이 주어진다.
<출력값>
각 줄에 각 테스트케이스에서 사전상 가장 앞서는 단어를 출력한다.

<문제 2205>
질량(또는 무게)가 1, 2, 3, …, n인 납덩어리가 있고, 질량이 1, 2, 3, …, n인 주석덩어리가 있다. 각각의 질량을 갖는 덩어리들은 1개씩밖에 없다. 이제 이 납덩어리와 주석덩어리를 한개씩 녹여 합쳐서 질량이 2의 거듭제곱이 되는 저울추를 n개 만들려고 한다.
질량이 x인 납덩어리와 질량이 y인 주석덩어리를 합친 경우를 (x, y)로 나타내기로 하고, 다음과 같이 녹여 합친 경우를 보자. (1, 1), (2, 2), (3, 5), (4, 4), (5, 3). 각각의 저울추의 질량은 2, 4, 8, 8, 8이 되고 이들은 모두 2의 거듭제곱 꼴이 된다.
n이 주어졌을 때 저울추 n개를 만드는 방법을 하나 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 n(1 ≤ n ≤ 10,000)이 주어진다.
<출력값>
첫째 줄부터 각 줄에 질량이 1인 납덩어리와 합친 주석덩어리의 질량, 질량이 2인 납덩어리와 합친 주석덩어리의 질량, 질량이 3인 납덩어리와 합친 주석덩어리의 질량, …을 n개의 줄에 출력한다.

<문제 2206>
N×M의 행렬로 표현되는 맵이 있다. 맵에서 0은 이동할 수 있는 곳을 나타내고, 1은 이동할 수 없는 벽이 있는 곳을 나타낸다. 당신은 (1, 1)에서 (N, M)의 위치까지 이동하려 하는데, 이때 최단 경로로 이동하려 한다. 최단경로는 맵에서 가장 적은 개수의 칸을 지나는 경로를 말하는데, 이때 시작하는 칸과 끝나는 칸도 포함해서 센다.
만약에 이동하는 도중에 한 개의 벽을 부수고 이동하는 것이 좀 더 경로가 짧아진다면, 벽을 한 개 까지 부수고 이동하여도 된다.
한 칸에서 이동할 수 있는 칸은 상하좌우로 인접한 칸이다.
맵이 주어졌을 때, 최단 경로를 구해 내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N(1 ≤ N ≤ 1,000), M(1 ≤ M ≤ 1,000)이 주어진다. 다음 N개의 줄에 M개의 숫자로 맵이 주어진다. (1, 1)과 (N, M)은 항상 0이라고 가정하자.
<출력값>
첫째 줄에 최단 거리를 출력한다. 불가능할 때는 -1을 출력한다.

<문제 2207>
국제 가위바위보 협회의 회원인 얼드학원의 원장선생님은 가위바위보를 매우 좋아한다. 종종 학생들이 학원에서 딴짓을 하다 걸렸을 경우, 가위바위보 게임을 해서 처벌 여부를 결정하고는 한다.
어느 날 학원에서 N(1≤N≤10,000)명의 학생들이 딴짓을 하다 걸리게 되었다. 걸린 학생의 수가 너무 많아서, 원장선생님은 새로운 방법을 제안했다. 원장선생님이 총 M(1≤M≤10,000)번 가위바위보를 혼자서 하고, 이때 학생들이 원장선생님이 몇 번째에 무엇을 낼지를 알아맞히면 살려주기로 한 것이다.
그런데 찍기에 소질이 있는 얼드학원의 학생들은 모두 원장선생님의 패턴을 파악하여 살게 되었다. 그래서 원장선생님은 학생들에게 한계를 두기로 했다. 즉, 각각의 학생들은 원장선생님이 몇 번째에 무엇을 낼지 선택할 수 있는데, 이러한 선택을 두 종류만 할 수 있도록 제한을 하였다. 즉, 각각의 학생들은 “원장선생님은 세 번째에서는 가위를 내고, 네 번째에서는 바위를 내실 거죠?” 나, “원장선생님은 첫 번째에서는 바위를 내고, 두 번째에서도 바위를 내실 거죠?” 하는 선택을 할 수 있다. 그 대신 둘 다 맞힐 필요는 없고, 둘 중에 하나라도 맞으면 그 학생은 살 수 있다.
그런데 학생들은 원장선생님의 패턴을 파악하여, 원장선생님이 그날의 기분에 따라 보를 내지 않을 거라는 사실을 알게 되었다.
학생들의 선택이 주어졌을 때, 모든 학생들이 살 수 있는지 알아내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 두 정수 N, M이 주어진다. 다음 N개의 줄에는 각각의 학생들의 선택을 나타내는 두 정수 x, y(1≤|x|, |y|≤M)이 주어진다. x가 양수일 경우에는 원장선생님이 x번째에 가위를 낼 거라는 의미이며, 음수일 경우에는 원장선생님이 |x|번째에 바위를 낼 거라는 의미이다. y에 대한 입력도 마찬가지이다.
<출력값>
첫째 줄에 답을 출력한다. 모든 학생들이 살 수 있을 때에는 “^_^”을 출력하고, 살 수 없을 때에는 "OTL"을 출력한다.

<문제 2208>
화영이는 고대 유적을 탐사하던 도중 보석을 발견했다. 유적 속에는 N(1≤N≤100,000)개의 보석들이 일렬로 놓여 있었다. 각각의 보석의 가치는 다를 수 있기 때문에, 화영이는 가급적 많은 이득을 얻을 수 있도록 보석을 가져가려 한다. 이때, 다음 세 가지의 조건이 만족되어야 한다.

보석들은 1번 보석부터 N번 보석까지가 차례대로 놓여 있고, 화영이는 1번 보석이 놓여 있는 곳부터 N번 보석이 놓여 있는 곳까지 순서대로 이동한다. 그런데 보석들 사이사이에는 함정이 설치되어 있어서 보석을 줍다가 도중에 뒤로 돌아갈 수는 없다. 따라서 화영이는 보석이 놓여 있는 위치에서 보석을 줍거나 혹은 그냥 지나치고 다음 보석이 있는 위치로 이동하게 된다.
유적에는 함정뿐 아니라 경보 장치도 설치되어 있다. 이 장치는 유적에 들어온 사람이 보석을 주우면 침입자로 간주하고, 침입자가 보석 줍기를 멈추는 순간 유적을 무너뜨리도록 설계되어 있다. 단, 이 경보 장치는 수를 잘 세지 못하기 때문에 M(1≤M≤N)개 이상의 보석을 연속으로 주우면 헷갈려서 유적을 조금 늦게 무너뜨린다. 따라서 보석을 줍기 시작하면 그 위치에 있는 보석을 포함하여 M개 이상의 보석을 연속적으로 주워야 하고, 보석 줍기를 한 번 멈춘 후에는 다른 보석을 주울 틈도 없이 서둘러서 유적을 빠져나와야 한다.
보석들은 무겁기 때문에, 기왕에 보석을 주워 가는 것이라면 가급적 비싼 보석들로 주워가려 한다. 즉, 주운 보석들의 가치의 총 합을 최대로 하려 한다. 단, 일부 보석들의 가치는 음수일 수도 있다.

보석들의 개수가 매우 많기 때문에, 화영이는 이 문제를 컴퓨터를 이용하여 풀기로 하였다. 보석들에 대한 정보가 주어졌을 때, 위의 조건들을 만족하면서 이동할 때 얻을 수 있는 가치의 총 합의 최댓값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 두 정수 N, M이 주어진다. 다음 N개의 줄에는 차례로 각 보석의 가치가 주어진다. 각 보석의 가치의 절댓값은 2,000이하의 정수이다.
<출력값>
첫째 줄에 가치의 총 합의 최댓값을 출력한다.

<문제 2209>
용인 시는 버스 정류장이 N개 있는 버스 노선을 짜려고 한다. 각 버스 정류장은 거리의 모퉁이에 있다. 용인 시는 현대적으로 설계된 도시이기 때문에 지리 구조가 정사각형 격자 모양으로 짜여 있다. 우리는 이 버스 정류장들 가운데 두 곳을, 중심지로서 H1, H2라는 이름으로 선택하려고 한다. 중심지를 선택하고 나면, 두 중심지 사이에는 버스가 가는 길이 생기며, 중심지를 제외한 나머지 N-2개의 버스 정류장들은 H1 아니면 H2 중 한 곳(두 중심지 모두와 연결되는 것은 아님.)과 직통하게 될 것이다. 이렇게 버스 노선이 결정된다.
이 문제에서 임의의 두 지점 사이의 거리는, 두 곳을 수평 수직 방향으로만 통행하는 가장 가까운 거리이다. 다시 말해, 위치를 (x, y) 좌표로 표현했을 때, 두 지점 (x1, y1)과 (x2, y2)의 거리는 |x1-x2|+|y1-y2|로 정의된다는 뜻이다. 한편, 버스 정류장 A와 B가 같은 중심지 H1과 연결돼 있으면 두 정류장 사이의 거리는 A와 H1 사이의 거리와 H1과 B 사이의 거리의 합이 된다. 그리고 A와 B가 각각 다른 중심지인 H1, H2와 연결돼 있으면 두 정류장 사이의 거리는 A와 H1, H1과 H2, H2와 B 사이의 거리들의 합이 된다.
용인 시의 도시 계획부는, 모든 시민이 도시의 모든 구역에 최대한 빨리 도착할 수 있게 하길 원한다. 따라서 도시 계획자들은 버스 정거장들 중, 서로 가장 멀리 떨어져 있는 두 곳 사이의 거리를 최소화할 수 있게끔 중심지 두 곳을 고르려고 한다. 이 거리를 최소화하게 중심지를 고른 뒤, 서로 거리가 가장 먼 두 정류장 사이의 거리를 계산하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 버스 정류장의 개수인 정수 N(2≤N≤500)이 있다. 그리고 다음 N 개의 줄에는 버스 정류장의 x, y좌표가 있다. (가로 먼저, 다음 세로) 각 좌표들은 5000과 같거나 작은 자연수이다. 정류장들은 모두 서로 다른 위치에 있으며, 겹치는 경우가 없다.
<출력값>
거리가 가장 먼 두 정류장 사이의 거리의 최솟값을 나타내는 자연수 하나를 한 줄에다 출력한다.

<문제 2210>
5×5 크기의 숫자판이 있다. 각각의 칸에는 숫자(digit, 0부터 9까지)가 적혀 있다. 이 숫자판의 임의의 위치에서 시작해서, 인접해 있는 네 방향으로 다섯 번 이동하면서, 각 칸에 적혀있는 숫자를 차례로 붙이면 6자리의 수가 된다. 이동을 할 때에는 한 번 거쳤던 칸을 다시 거쳐도 되며, 0으로 시작하는 000123과 같은 수로 만들 수 있다.
숫자판이 주어졌을 때, 만들 수 있는 서로 다른 여섯 자리의 수들의 개수를 구하는 프로그램을 작성하시오.
<입력값>
다섯 개의 줄에 다섯 개의 정수로 숫자판이 주어진다.
<출력값>
첫째 줄에 만들 수 있는 수들의 개수를 출력한다.

<문제 2211>
N(1 ≤ N ≤ 1,000)개의 컴퓨터로 구성된 네트워크가 있다. 이들 중 몇 개의 컴퓨터들은 서로 네트워크 연결이 되어 있어 서로 다른 두 컴퓨터 간 통신이 가능하도록 되어 있다. 통신을 할 때에는 서로 직접 연결되어 있는 회선을 이용할 수도 있으며, 회선과 다른 컴퓨터를 거쳐서 통신을 할 수도 있다.
각 컴퓨터들과 회선은 그 성능이 차이가 날 수 있다. 따라서 각각의 직접 연결되어 있는 회선을 이용해서 통신을 하는데 걸리는 시간이 서로 다를 수 있다. 심지어는 직접 연결되어 있는 회선이 오히려 더 느려서, 다른 컴퓨터를 통해서 통신을 하는 것이 더 유리할 수도 있다. 직접 연결되어 있는 회선을 사용할 경우에는 그 회선을 이용해서 통신을 하는 데 드는 시간만큼이 들게 된다. 여러 개의 회선을 거치는 경우에는 각 회선을 이용해서 통신을 하는 데 드는 시간의 합만큼의 시간이 걸리게 된다.
어느 날, 해커가 네트워크에 침입하였다. 네트워크의 관리자는 우선 모든 회선과 컴퓨터를 차단한 후, 해커의 공격을 막을 수 있었다. 관리자는 컴퓨터에 보안 시스템을 설치하려 하였는데, 버전 문제로 보안 시스템을 한 대의 슈퍼컴퓨터에만 설치할 수 있었다. 한 컴퓨터가 공격을 받게 되면, 네트워크를 통해 슈퍼컴퓨터에 이 사실이 전달이 되고, 그러면 슈퍼컴퓨터에서는 네트워크를 이용해서 보안 패킷을 전송하는 방식을 사용하기로 하였다. 준비를 마친 뒤, 관리자는 다시 네트워크를 복구하기로 하였다. 이때, 다음의 조건들이 만족되어야 한다.

해커가 다시 공격을 할 우려가 있기 때문에, 최소 개수의 회선만을 복구해야 한다. 물론, 그렇다면 아무 회선도 복구하지 않으면 되겠지만, 이럴 경우 네트워크의 사용에 지장이 생기게 된다. 따라서 네트워크를 복구한 후에 서로 다른 두 컴퓨터 간에 통신이 가능하도록 복구해야 한다.
네트워크를 복구해서 통신이 가능하도록 만드는 것도 중요하지만, 해커에게 공격을 받았을 때 보안 패킷을 전송하는 데 걸리는 시간도 중요한 문제가 된다. 따라서 슈퍼컴퓨터가 다른 컴퓨터들과 통신하는데 걸리는 최소 시간이, 원래의 네트워크에서 통신하는데 걸리는 최소 시간보다 커져서는 안 된다.

원래의 네트워크에 대한 정보가 주어졌을 때, 위의 조건을 만족하면서 네트워크를 복구하는 방법을 알아내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 두 정수 N, M이 주어진다. 다음 M개의 줄에는 회선의 정보를 나타내는 세 정수 A, B, C가 주어진다. 이는 A번 컴퓨터와 B번 컴퓨터가 통신 시간이 C (1 ≤ C ≤ 10)인 회선으로 연결되어 있다는 의미이다. 컴퓨터들의 번호는 1부터 N까지의 정수이며, 1번 컴퓨터는 보안 시스템을 설치할 슈퍼컴퓨터이다. 모든 통신은 완전쌍방향 방식으로 이루어지기 때문에, 한 회선으로 연결된 두 컴퓨터는 어느 방향으로도 통신할 수 있다.
<출력값>
첫째 줄에 복구할 회선의 개수 K를 출력한다. 다음 K개의 줄에는 복구한 회선을 나타내는 두 정수 A, B를 출력한다. 이는 A번 컴퓨터와 B번 컴퓨터를 연결하던 회선을 복구한다는 의미이다. 출력은 임의의 순서대로 하며, 답이 여러 개 존재하는 경우에는 아무 것이나 하나만 출력하면 된다.

<문제 2212>
한국도로공사는 고속도로의 유비쿼터스화를 위해 고속도로 위에 N개의 센서를 설치하였다. 문제는 이 센서들이 수집한 자료들을 모으고 분석할 몇 개의 집중국을 세우는 일인데, 예산상의 문제로, 고속도로 위에 최대 K개의 집중국을 세울 수 있다고 한다.
각 집중국은 센서의 수신 가능 영역을 조절할 수 있다. 집중국의 수신 가능 영역은 고속도로 상에서 연결된 구간으로 나타나게 된다. N개의 센서가 적어도 하나의 집중국과는 통신이 가능해야 하며, 집중국의 유지비 문제로 인해 각 집중국의 수신 가능 영역의 길이의 합을 최소화해야 한다.
편의를 위해 고속도로는 평면상의 직선이라고 가정하고, 센서들은 이 직선 위의 한 기점인 원점으로부터의 정수 거리의 위치에 놓여 있다고 하자. 따라서, 각 센서의 좌표는 정수 하나로 표현된다. 이 상황에서 각 집중국의 수신 가능영역의 거리의 합의 최솟값을 구하는 프로그램을 작성하시오. 단, 집중국의 수신 가능영역의 길이는 0 이상이며 모든 센서의 좌표가 다를 필요는 없다.
<입력값>
첫째 줄에 센서의 개수 N(1<=N<=10,000), 둘째 줄에 집중국의 개수 K(1<=K<=1000)가 주어진다. 셋째 줄에는 N개의 센서의 좌표가 한 개의 정수로 N개 주어진다. 각 좌표 사이에는 빈 칸이 하나 이상 있으며, 좌표의 절댓값은 1,000,000 이하이다.
<출력값>
첫째 줄에 문제에서 설명한 최대 K개의 집중국의 수신 가능 영역의 길이의 합의 최솟값을 출력한다.

<문제 2213>
그래프 G(V, E)에서 정점의 부분 집합 S에 속한 모든 정점쌍이 서로 인접하지 않으면 (정점쌍을 잇는 에지가 없으면) S를 독립 집합(independent set)이라고 한다. 독립 집합의 크기는 정점에 가중치가 주어져 있지 않을 경우는 독립 집합에 속한 정점의 수를 말하고, 정점에 가중치가 주어져 있으면 독립 집합에 속한 정점의 가중치의 합으로 정의한다. 독립 집합이 공집합일 때 그 크기는 0이라고 하자. 크기가 최대인 독립 집합을 최대 독립 집합이라고 한다.
문제는 일반적인 그래프가 아니라 트리(연결되어 있고 사이클이 없는 그래프)와 각 정점의 가중치가 양의 정수로 주어져 있을 때, 최대 독립 집합을 구하는 것이다.
<입력값>
첫째 줄에 트리의 정점의 수 n이 주어진다. n은 10,000이하인 양의 정수이다. 1부터 n사이의 정수가 트리의 정점이라고 가정한다. 둘째 줄에는 n개의 정수 w1, w2, ..., wn이 주어지는데, wi는 정점 i의 가중치이다(1 ≤ i ≤ n). 셋째 줄부터 마지막 줄까지는 에지 리스트가 주어지는데, 한 줄에 하나의 에지를 나타낸다. 에지는 정점의 쌍으로 주어진다. 입력되는 정수들 사이에는 콤마가 없고 대신 빈칸이 하나 혹은 그 이상 있다. 가중치들의 값은 10,000을 넘지 않는 자연수이다.
<출력값>
첫째 줄에 최대 독립집합의 크기를 출력한다. 둘째 줄에는 최대 독립집합에 속하는 정점을 오름차순으로 출력한다. 최대 독립 집합이 하나 이상일 경우에는 하나만 출력하면 된다.

<문제 2214>
테이블 위에 놓인 성냥개비를 생각해 보시오. 예시:

문제는 성냥개비들로 이루어지는 정사각형의 개수를 구하는 것이다. 예를 들어 위의 예시는 2개의 정사각형이 성냥개비로 이루어진다.
<입력값>
입력은 여러 개의 배열로 이루어진다. 각 배열의 첫 번째 줄에는 열과 행의 수를 나타내는 두 개의 정수 r 과 c(1 ≤ r, c ≤ 20)가 주어진다. 그 뒤로는 성냥개비의 배열 상태를 나타내는 2r+1개의 줄이 주어진다. 배열을 나타내는 줄의 홀수 번째 줄은 c개의 문자로 이루어지며, 각각의 문자는 가로 방향으로 놓인 성냥개비를 나타내는 하이픈('–')과 빈 공간을 나타내는 별표('*') 둘 중 하나이다. 배열을 나타내는 짝수 번째 줄은 c+1개의 문자로 이루어지며, 각각의 문자는 세로 방향으로 놓인 성냥개비를 나타내는 막대('|')와 빈 공간을 나타내는 별표('*') 둘 중 하나이다. 0 0이 입력되면 입력이 종료된다.
<출력값>
출력은 각 줄에 각 배열에서 이루어질 수 있는 정사각형의 수 뒤에 한 칸을 띄고 영어 단어 'squares'를 붙여 'X squares'와 같은 형식으로 출력해야 한다.

<문제 2215>
한 회사의 N(1≤N≤1,000)개의 컴퓨터들이 원형 네트워크로 연결되어 있다. 컴퓨터에는 차례로 1, 2, …, N의 번호가 붙어 있는데, x번 컴퓨터는 x-1번 컴퓨터와 x+1번 컴퓨터와 네트워크 회선으로 연결되어 있다. 그리고 1번 컴퓨터는 N번 컴퓨터와 네트워크 회선으로 연결이 되어 있어서 전체적으로 원의 모양으로 연결되어 있다.
이 회사에서는 자주 사용되는 일부 회선을 광섬유로 전환하기로 하였다. 이를 위해 사전 조사를 실시한 결과, p번 컴퓨터와 q번 컴퓨터 사이에 광섬유를 설치해 달라는 요청이 총 P(1≤P≤10,000)개 접수되었다.
p번 컴퓨터와 q번 컴퓨터 사이에 광섬유를 설치하는 방법은 시계 방향과 시계 반대 방향의 두 가지가 있다. 예를 들어 N=3이고, 1번 컴퓨터와 2번 컴퓨터 사이에 광섬유를 설치해 달라는 요청이 있었다고 하자. 이때에 1-2를 연결하는 방법도 있고, 2-3, 3-1을 연결하는 방법도 있다.
 최소 개수의 회선을 광섬유로 전환하여 P개의 요청을 모두 만족시키는 방법을 찾으라.
<입력값>
첫째 줄에 두 정수 N, P가 주어진다. 다음 P개의 줄에는 p, q들이 주어진다.
<출력값>
첫째 줄에 최소 개수 X를 출력한다.

<문제 2216>
알파벳 소문자로 구성된 길이 1 이상의 두 문자열 X, Y가 있다. 이 문자열들의 임의의 위치에 공백을 삽입하여 두 문자열의 길이를 같게 만든 다음, 앞에서부터 한 글자씩 살펴보면서, 같은 위치에 있는 두 문자 X[i], Y[i]에 대해서 다음과 같이 점수를 계산한다.

두 문자가 같은 경우에는 A(>0)점을 받게 된다. 단, 두 문자가 모두 공백인 경우는 허용되지 않는다.
두 문자 중 적어도 하나가 공백인 경우에는 B(<0)점을 받게 된다.
두 문자가 모두 공백이 아니고 서로 다른 경우에는 C(<0)점을 받게 된다.

예를 들어 A=10, B=-1, C=-5인 경우, 다음과 같은 경우들을 살펴보자.



a
 
b
c


 
d
 
c



이 경우 앞에서부터 점수를 계산하면 각각 -1, -1, -1, 10점이 되고 따라서 총점은 7점이 된다.
두 문자열이 주어졌을 때, 공백을 적절히 추가했을 때 얻을 수 있는 최대 총점을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 세 정수 A, B, C (0 < A ≤ 10,000, -10,000 ≤ B, C < 0) 가 주어진다. 그리고 둘째 줄에 X가, 셋째 줄에 Y가 주어진다. 각 문자열의 길이는 3,000자를 넘지 않으며 빈 문자열은 입력으로 주어지지 않는다.
<출력값>
첫째 줄에 최대 총점을 출력한다.

<문제 2217>
N(1 ≤ N ≤ 100,000)개의 로프가 있다. 이 로프를 이용하여 이런 저런 물체를 들어올릴 수 있다. 각각의 로프는 그 굵기나 길이가 다르기 때문에 들 수 있는 물체의 중량이 서로 다를 수도 있다.
하지만 여러 개의 로프를 병렬로 연결하면 각각의 로프에 걸리는 중량을 나눌 수 있다. k개의 로프를 사용하여 중량이 w인 물체를 들어올릴 때, 각각의 로프에는 모두 고르게 w/k 만큼의 중량이 걸리게 된다.
각 로프들에 대한 정보가 주어졌을 때, 이 로프들을 이용하여 들어올릴 수 있는 물체의 최대 중량을 구해내는 프로그램을 작성하시오. 모든 로프를 사용해야 할 필요는 없으며, 임의로 몇 개의 로프를 골라서 사용해도 된다.
<입력값>
첫째 줄에 정수 N이 주어진다. 다음 N개의 줄에는 각 로프가 버틸 수 있는 최대 중량이 주어진다. 이 값은 10,000을 넘지 않는 자연수이다.
<출력값>
첫째 줄에 답을 출력한다.

<문제 2218>
A×1 크기의 상자와 B×1 크기의 상자가 있다. 이 안에 각각 A개, B개의 구슬이 들어 있는데, 각 구슬에는 1부터 N까지의 정수가 적혀 있다.
상자의 제일 아랫부분에는 구멍이 뚫려 있어서, 이 구멍을 통해서 제일 아래 있는 구슬에 적혀 있는 번호를 볼 수도 있고, 구슬을 뺄 수도 있다. 이와 같은 상자 안의 구슬을 이용하여 다음 세 가지 작업 중 하나를 할 수 있다.

A×1 크기의 상자의 제일 아랫부분의 구슬을 뺀다. (점수 없음)
B×1 크기의 상자의 제일 아랫부분의 구슬을 뺀다. (점수 없음)
A×1 크기의 상자의 제일 아랫부분의 구슬과 B×1 크기의 상자의 제일 아랫부분의 구슬을 동시에 뺀다. 그리고 두 개의 구슬에 적혀 있는 수를 이용하여 점수를 계산한 뒤, 총점(0부터 시작)에 이를 더한다.

이와 같은 과정을 두 개의 상자에 구슬이 남아있지 않을 때까지 반복하려 한다. 이때 얻을 수 있는 가장 높은 점수와 그 때 수행한 작업들을 구하는 프로그램을 작성하시오.
예를 들어 다음과 같은 A=B=N=2인 경우를 보자.



-1
2


1
-2






2
2


1
1



위쪽 표는 점수표이고 아래쪽은 상자의 모양이다. 왼쪽 상자에서 1, 오른쪽 상자에서 1을 꺼냈을 때의 점수가 -1점이고, 왼쪽 상자에서 1, 오른쪽 상자에서 2를 꺼냈을 때의 점수가 2점인 식이다. 이때는 2 3 1의 순서로 작업을 수행하면 2점을 얻을 수 있고, 이 경우의 점수가 제일 높다.
<입력값>
첫째 줄에 세 정수 N, A, B(1 ≤ N, A, B ≤ 1,000)가 주어진다. 다음 N개의 줄에는 N개의 정수로 점수표가 주어진다. 다음 줄에는 A개의 정수로 상자 안에 들어 있는 구슬에 적혀있는 번호가 아래쪽 구슬부터 주어진다. 다음 줄에는 B개의 정수로 상자 안에 들어 있는 구슬에 적혀있는 번호가 역시 아래쪽부터 주어진다. 점수표의 점수는 -1,000이상 1,000 이하이다.
<출력값>
첫째 줄에 얻을 수 있는 최대 점수를 출력한다. 다음 줄에는 수행한 순서대로 작업 번호를 출력한다.

<문제 2219>
N(1≤N≤200)개의 컴퓨터로 구성된 네트워크가 있다. 이들 중 몇 개의 컴퓨터들은 서로 네트워크 연결이 되어 있어 서로 다른 두 컴퓨터 간 통신이 가능하도록 되어 있다. 통신을 할 때에는 서로 직접 연결되어 있는 회선을 이용할 수도 있으며, 회선과 다른 컴퓨터를 거쳐서 통신을 할 수도 있다.
각 컴퓨터들과 회선은 그 성능이 차이가 날 수 있다. 따라서 각각의 직접 연결되어 있는 회선을 이용해서 통신을 하는데 걸리는 시간이 서로 다를 수 있다. 심지어는 직접 연결되어 있는 회선이 오히려 더 느려서, 다른 컴퓨터를 통해서 통신을 하는 것이 더 유리할 수도 있다. 직접 연결되어 있는 회선을 사용할 경우에는 그 회선을 이용해서 통신을 하는 데 드는 시간만큼이 들게 된다. 여러 개의 회선을 거치는 경우에는 각 회선을 이용해서 통신을 하는 데 드는 시간의 합만큼의 시간이 걸리게 된다.
어느 날, 해커가 네트워크에 침입하였다. 네트워크의 관리자는 우선 모든 회선과 컴퓨터를 차단한 후, 해커의 공격을 막을 수 있었다. 관리자는 컴퓨터에 보안 시스템을 설치하려 하였는데, 버전 문제로 보안 시스템을 한 대의 컴퓨터에만 설치할 수 있었다. 한 컴퓨터가 공격을 받게 되면, 네트워크를 통해 컴퓨터에 이 사실이 전달이 되고, 그러면 컴퓨터에서는 네트워크를 이용해서 보안 패킷을 전송하는 방식을 사용하기로 하였다. 준비를 마친 뒤, 관리자는 다시 네트워크를 복구하기로 하였다. 이때, 다음의 조건들이 만족되어야 한다.
(1) 해커가 다시 공격을 할 우려가 있기 때문에, 최소 개수의 회선만을 복구해야 한다. 물론, 그렇다면 아무 회선도 복구하지 않으면 되겠지만, 이럴 경우 네트워크의 사용에 지장이 생기게 된다. 따라서 네트워크를 복구한 후에 서로 다른 두 컴퓨터 간에 통신이 가능하도록 복구해야 한다.
(2) 네트워크를 복구해서 통신이 가능하도록 만드는 것도 중요하지만, 해커에게 공격을 받았을 때 빠른 시간에 보안 패킷을 전송하는데 걸리는 시간도 중요한 문제가 된다. 따라서 보안 시스템을 설치할 컴퓨터를 잘 정하는 것이 중요해진다. 해커가 침입할 컴퓨터가 어느 컴퓨터일지 정확히 알 수 없기 때문에, 다른 컴퓨터들과의 통신에 필요한 평균 시간이 최소가 되도록 하는 컴퓨터에 보안 시스템을 설치하기로 하였다.
원래의 네트워크에 대한 정보가 주어졌을 때, 위의 조건을 만족하며 보안 시스템을 설치하는 방법을 알아내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 두 정수 N, M이 주어진다. 다음 M개의 줄에는 회선의 정보를 나타내는 세 정수 A, B, C가 주어진다. 이는 A번 컴퓨터와 B번 컴퓨터가 통신 시간이 C인 회선으로 연결되어 있다는 의미이다. 컴퓨터들의 번호는 1부터 N까지의 정수이며, 1번 컴퓨터는 보안 시스템을 설치할 컴퓨터이다. C값은 항상 양수이다. 또한 모든 통신은 완전쌍방향 방식으로 이루어지기 때문에, 한 회선으로 연결된 두 컴퓨터는 어느 방향으로도 통신할 수 있다.
<출력값>
첫째 줄에 보안 시스템을 설치할 컴퓨터의 번호를 출력한다. 답이 여러 개인 경우에는 가장 번호가 작은 경우를 출력한다.

<문제 2220>
힙은 자료의 추가, 우선순위가 제일 높은 자료의 삭제가 가능한 자료구조이다. 이와 같은 힙에는 두 종류가 있는데, 각각 최소-힙, 최대-힙이다. 이 문제에서는 최대-힙을 다루기로 하자.
이와 같은 최대-힙을 이용하면 O(n log n)정렬인 힙 정렬을 할 수 있다. 우리가 다루기로 한 최대-힙을 이용하면 오름차순 정렬을 할 수 있다. 힙 정렬은 크게 두 개의 단계로 나뉘는데, 첫 번째 단계는 주어진 자료들로 힙을 구성하는 단계이고, 두 번째 단계는 이렇게 구성된 힙에서 최댓값을 계속 제거하는 단계이다.
예를 들어 (5, 4, 2, 1, 3)과 같은 힙을 살펴보자. 이 힙에서 최댓값을 삭제하면 (3, 4, 2, 1)이 되고, 힙의 조건을 맞추기 위해 Swap을 한 번 하면 (4, 3, 2, 1)의 힙을 얻는다. 이 힙에서 최댓값을 삭제하면 (1, 3, 2)이 되고, 힙의 조건을 맞추기 위해 Swap을 한 번 하면 (3, 1, 2)가 된다. 다음 단계에서는 (2, 1), (1)이 되고 힙 정렬이 종료된다. 즉, 힙이 (5, 4, 2, 1, 3)과 같이 구성되어 있었다면, 정렬을 위해 Swap을 두 번 사용하게 된다. 하지만 (5, 4, 3, 2, 1)과 같은 힙은 총 네 번의 Swap을 해야 한다.
n이 주어졌을 때, 1부터 n까지의 수를 한 번씩 사용하여 만들 수 있는 힙들 중에서, 위와 같은 Swap 회수가 최대가 되도록 하는 힙을 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 n이 주어진다. (1 ≤ n ≤ 100,000)
<출력값>
첫째 줄에 n개의 정수로 힙을 출력한다.

<문제 2221>
어떤 회사의 작업 공정은 아래에서 위로(bottom-up) 진행된다. 즉, 말단 사원들이 우선 처음 부분을 진행하고, 작업이 완료되면 그 상사가 작업물을 전달받아 다음 작업을 진행하고, 다시 그 위의 상사가 작업을 마저 진행하는 방식이다. 이러한 작업 공정을 정리하면 다음과 같다.

각각의 직원들은 사장을 제외하고는 한 명의 직속 상사를 가지고 있다.
각각의 직원은 자신의 하사(직속 하사 및 직속 하사의 하사)들이 모두 작업을 완료한 후에 작업을 시작할 수 있다. 말단 직원들의 경우에는 아무 때에나 작업을 시작할 수 있다.
작업은 사장이 작업을 완료한 후에 끝난다.
모든 작업은 시작부터 완료까지 1만큼의 시간이 걸린다고 한다.

이러한 작업 공정을 이용하여 이 회사에서는 작업을 진행하고 있었다. 하지만 경기가 나빠지면서 사장은 일부 직원을 해고하기로 결심하였다. 직원을 해고한 후의 빈 자리는 다른 직원을 이용하여 대체하기로 하였다. 즉, 말단 직원들의 경우에는 자신의 작업을 완료한 후에는 할 일이 없게 되는데, 이때 다른 상사의 작업을 이 직원들이 진행하면 좀 더 적은 수의 직원으로도 작업을 진행할 수 있다. 반대로 말단 직원들을 해고한 후에 사장 등의 상사들이 그 작업을 진행할 수도 있다. 단, 직원들을 해고한 후에도 작업의 효율이 떨어지지 않아야 한다. 즉, 모든 직원이 있었을 때 보다 전체 작업이 완료되는 시간이 늘어나서는 안 된다.
각 직원들의 관계가 주어졌을 때, 전체 작업 완료 시간을 유지하면서 해고할 수 있는 직원의 최대 수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 직원의 수를 나타내는 정수 N(1≤N≤100,000)이 주어진다. 다음 N개의 줄에는 차례로 1번, 2번, …, N번 직원의 직속 상사의 번호가 주어진다. 사장의 경우에는 -1이 주어진다.
<출력값>
첫째 줄에 전체 직원들이 있을 때 필요한 최소 작업 완료 시간을 출력한다. 둘째 줄에 해고할 수 있는 직원의 최대 수를 출력한다.

<문제 2223>
고대 유적을 탐험하던 지민이는 금화가 가득 들어 있는 방을 발견하였다. 지민이는 가져간 주머니에 가득 금화를 담으려고 하였는데, 금화를 주머니에 담을 때 나는 소리 때문에 고대 유적 안의 몬스터들이 움직이게 된다는 사실을 알게 되었다. 다행히도 이 몬스터들은 지능적이지 않아서, 금화를 주워 담는 것을 멈추고 기다리면, 금화가 짤랑거리는 소리가 나지 않기 때문에 다시 원래의 자리로 돌아가고, 다시 소리가 나면 다가오는 식으로 움직인다. 몬스터에게 잡히지 않기 위해서 지민이는 금화를 적당히 주워 담다가 적당히 기다리는 것을 반복하기로 하였다.
지민이는 총 t(0 ≤ t ≤ 1,000,000) 단위의 시간 동안 금화를 주워 담을 수 있다. 또한 한 단위의 시간 동안 x(0 < x ≤ 10)개의 금화를 주워 담을 수 있다. 각각의 몬스터들은 지민이로부터 d(0 < d ≤ 1,000,000)만큼의 거리에 위치해 있으며, 단위 시간동안 s(0 < s ≤ 1,000,000)만큼의 거리를 움직인다. 몬스터가 지민이에게 다가올 때와 원래의 위치로 돌아갈 때 모두 같은 속도로 움직인다.
문제를 간명하게 만들기 위해서 모든 행동은 단위 시간마다 일어난다고 가정하자. 즉 지민이는 1만큼의 시간동안 금화를 줍거나 멈추는 행위 중에서 하나를 선택해야 한다. 몬스터들도 1만큼의 시간동안 다가오거나(지민이가 그 시간에 금화를 줍는 경우), 원래의 위치로 돌아가거나(지민이가 그 시간에 멈춰 있는 경우), 아니면 원래의 위치에서 가만히 있게 된다(지민이가 그 시간에 멈춰 있으며 몬스터가 원래의 위치에 있는 경우). 만약 몬스터가 지민이의 위치에 도착하는 순간 금화를 줍는 행위를 멈추게 되면, 이 역시 몬스터에게 잡히는 것으로 간주한다.
이러한 정보가 주어졌을 때, 지민이가 주워 담을 수 있는 금화의 최대 개수를 구하는 프로그램을 작성하시오. 금화는 무한히 많으며, 금화를 주워 담을 주머니 역시 무한히 크다고 가정한다.
<입력값>
첫째 줄에 세 정수 t, x, m(0 ≤ m < 1,000)이 주어진다. 다음 m개의 줄에는 각 몬스터에 대한 정보를 나타내는 두 정수 d, s가 주어진다.
<출력값>
첫째 줄에 답을 출력한다.

<문제 2224>
수학, 혹은 논리학에서 만약 무엇 이라면 뭣 일 것이다 하는 식의 명제가 널리 쓰인다. 예를 들어 "P이면 Q일 것이다." 라는 명제는 “P => Q” 라는 기호로 표현된다. 이때의 P를 전건, Q를 후건이라고 한다.
논리학에서 어떤 명제를 증명할 때 가장 널리 쓰이는 방법 중 한 가지가 바로 삼단 논법이다. 만약 두 명제 “P => Q", "Q => R" 가 모두 참이면, 명제 "P => R"이 역시 참이 된다. 이러한 방법을 사용했을 때 명제 ”P => R"이 증명되었다고 한다.
어떤 참인 명제가 주어졌을 때, 이 명제가 참이므로 이 명제 자체도 증명될 수 있다고 할 수 있다. 하지만 “P => P”와 같은 명제는 항상 참이 되는데, 이런 식으로 전건과 후건이 같은 경우는 출력하지 않기로 한다.
N개의 참인 명제들이 주어졌을 때, 증명될 수 있는 명제를 모두 구해내는 프로그램을 작성하시오. 명제를 증명하는 방법은 여러 가지가 있을 수 있지만, 위에서 언급한 방법만을 사용하기로 한다.
<입력값>
첫째 줄에 정수 N(1 ≤ N ≤ 10,000)이 주어진다. 다음 N개의 줄에는 참인 명제들이 주어진다. 명제는 "P => Q"의 꼴로 주어지는데, “=>”는 앞뒤가 공백으로 구분되어 있다. P나 Q는 명제를 나타내는 문자인데, 알파벳 대소문자 한 글자씩이 사용될 수 있다. 같은 명제가 여러 번 주어질 수도 있다.
<출력값>
첫째 줄에 출력할 명제의 개수 X개를 출력한다. 다음 X개의 줄에 증명될 수 있는 명제를 한 줄에 하나씩 출력한다. 명제를 출력할 때에는 전건 순으로 정렬하고, 전건이 같은 경우에는 후건 순으로 정렬한다. 알파벳은 대문자가 소문자에 우선한다. 즉, 정렬했을 때 A, B, …, Z, a, b, …, z 순서로 나와야 한다.

<문제 2225>
0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수를 구하는 프로그램을 작성하시오.
덧셈의 순서가 바뀐 경우는 다른 경우로 센다(1+2와 2+1은 서로 다른 경우). 또한 한 개의 수를 여러 번 쓸 수도 있다.
<입력값>
첫째 줄에 두 정수 N(1 ≤ N ≤ 200), K(1 ≤ K ≤ 200)가 주어진다.
<출력값>
첫째 줄에 답을 1,000,000,000으로 나눈 나머지를 출력한다.

<문제 2226>
0과 1로 구성된 이진수가 있다. 이 이진수에서 0을 10으로, 1을 01로 동시에 치환하면 길이가 두 배인 이진수를 얻을 수 있다. 이러한 이진수들을 차례로 나열하면 하나의 이진수 수열이 된다. 편의상 시작 수는 1이라고 하자. 처음 몇 개의 이진수들을 구해 보면,
1 -> 01 -> 1001 -> 01101001 -> …
이 된다.
N이 주어졌을 때, N번째 이진수에서 연속된 0들의 그룹이 몇 개나 있는지 알아내는 프로그램을 작성하시오. N=4일 경우의 이진수는 01101001이고, 따라서 이 안에는 연속된 0들이 세 그룹 있게 된다.
<입력값>
첫째 줄에 정수 N(1≤N≤1,000)이 주어진다.
<출력값>
첫째 줄에 답을 출력한다.

<문제 2227>
The concept of causality is important when monitoring distributed systems. Consider the event of one computer sending a message and the event of that message being received at another computer. Causality tells us that the send event must occur before the receive event. If there were a global clock to timestamp all of the events that occur in a distributed system, then the timestamp of a message receive event would always be greater than the timestamp of a message send event.
However, distributed systems do not have such a global clock, all they have is a collection of idiosyncratic clocks, one in each computer, all ticking at different speeds. All we can say for certain is that each clock never stops and that its (apparent) granularity is fine enough that any sequence of events on a given computer will be given a series of timestamps that is strictly monotonically increasing. Thus it is perfectly feasible to have a message that left A at time 50 arrive at B at time 40 and for the reply to leave B at 45 and arrive at A at 51, where all times are given according to the relevant computer’s clock.
Given send and receive timestamps from a collection of messages exchanged by a group of computers, it is possible to use the concept of causality to make some checks that will detect faulty clocks. Continuing the example above, assume that a second message is sent from B at time 45 on B's clock (i.e. after the arrival of the first message). If A receives this before 51 (on its clock) then at least one clock is faulty, because causality has been breached (apparently), since we know that all clocks increase by at least 1 tick between successive events on the same computer. It is also possible to detect causality violations in longer chains, e.g., A to B, B to C, C to A.
Write a program to process sets of message timestamp data, and for each set say whether causality is violated, i.e. whether there is a cycle of messages, starting and ending at the same computer, where one or more messages has apparently travelled back in time.
<입력값>
Input consists of a number of timestamp sets. Each timestamp set starts with the number of messages in the set (n), followed by n lines of timestamp data, where each line contains: sending computer, send time, receiving computer, and receive time, all separated by whitespace. Times are according to the relevant computer, computers are identified by a single upper case letter and times are integers. The sequence of timestamp sets will be terminated by a line containing a single zero (0).
<출력값>
Output consists of a single line for each timestamp set. This line contains the word ‘OK’ if there is no causality violation or the word ‘Bad’ if there is such a violation.

<문제 2228>
N(1≤N≤100)개의 수로 이루어진 1차원 배열이 있다. 이 배열에서 M(1≤M≤⌈(N/2)⌉)개의 구간을 선택해서, 구간에 속한 수들의 총 합이 최대가 되도록 하려 한다. 단, 다음의 조건들이 만족되어야 한다.

각 구간은 한 개 이상의 연속된 수들로 이루어진다.
서로 다른 두 구간끼리 겹쳐있거나 인접해 있어서는 안 된다.
정확히 M개의 구간이 있어야 한다. M개 미만이어서는 안 된다.

N개의 수들이 주어졌을 때, 답을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 두 정수 N, M이 주어진다. 다음 N개의 줄에는 배열을 이루는 수들이 차례로 주어진다. 배열을 이루는 수들은 -32768 이상 32767 이하의 정수이다.
<출력값>
첫째 줄에 답을 출력한다.

<문제 2229>
알고스팟 캠프에 N(1≤N≤1,000)명의 학생들이 참여하였다. 학생들은 열심히 공부를 하고 있었는데, 어느 날 조별 수업을 진행하기로 하였다. 조별 수업의 목적은 잘 하는 학생들과 덜 잘 하는 학생들을 같은 조로 묶어서 서로 자극을 받으며 공부하도록 만들기 위함이다. 따라서 가급적이면 실력 차이가 많이 나도록 조를 편성하는 것이 유리하다.
하지만 조를 편성할 때 같은 조에 속하게 된 학생들의 나이 차이가 많이 날 경우에는 오히려 부정적인 효과가 나타날 수도 있다. 따라서 선생님들은 우선 학생들을 나이 순서대로 정렬한 다음에, 적당히 학생들을 나누는 방식으로 조를 짜기로 하였다. 조의 개수는 상관이 없다.
각각의 조가 잘 짜여진 정도는 그 조에 속해있는 가장 점수가 높은 학생의 점수와 가장 점수가 낮은 학생의 점수의 차이가 된다. 또한 전체적으로 조가 잘 짜여진 정도는, 각각의 조가 잘 짜여진 정도의 합으로 나타난다. 한 명으로 조가 구성되는 경우에는 그 조의 잘 짜여진 정도가 0이 된다(가장 높은 점수와 가장 낮은 점수가 같으므로).
학생들의 점수가 주어졌을 때, 조가 잘 짜여진 정도의 최댓값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N이 주어진다. 다음 줄에는 N명의 학생들의 점수가 나이 순서대로 주어진다. 각 학생의 점수는 0 이상 10,000 이하의 정수이다.
<출력값>
첫째 줄에 답을 출력한다.

<문제 2230>
N(1≤N≤100,000)개의 수로 이루어진 수열 A[1], A[2], …, A[N]이 있다. 이 수열에서 두 수를 골랐을 때(같은 수일 수도 있다), 그 차이가 M 이상이면서 제일 작은 경우를 구하는 프로그램을 작성하시오.
예를 들어 수열이 {1, 2, 3, 4, 5}라고 하자. 만약 M=3일 경우, 1 4, 1 5, 2 5를 골랐을 때 그 차이가 M 이상이 된다. 이 중에서 차이가 가장 작은 경우는 1 4나 2 5를 골랐을 때의 3이 된다.
<입력값>
첫째 줄에 두 정수 N, M(0≤M≤2,000,000,000)이 주어진다. 다음 N개의 줄에는 차례로 A[1], A[2], …, A[N]이 주어진다. 각각의 A[i]는 0 ≤ |A[i]| ≤ 1,000,000,000을 만족한다.
<출력값>
첫째 줄에 M 이상이면서 가장 작은 차이를 출력한다. 항상 차이가 M이상인 두 수를 고를 수 있다.

<문제 2231>
어떤 자연수 N이 있을 때, 그 자연수 N의 분해합은 N과 N을 이루는 각 자리수의 합을 의미한다. 어떤 자연수 M의 분해합이 N인 경우, M을 N의 생성자라 한다. 예를 들어, 245의 분해합은 256(=245+2+4+5)이 된다. 따라서 245는 256의 생성자가 된다. 물론, 어떤 자연수의 경우에는 생성자가 없을 수도 있다. 반대로, 생성자가 여러 개인 자연수도 있을 수 있다.
자연수 N이 주어졌을 때, N의 가장 작은 생성자를 구해내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 자연수 N(1 ≤ N ≤ 1,000,000)이 주어진다.
<출력값>
첫째 줄에 답을 출력한다. 생성자가 없는 경우에는 0을 출력한다.

<문제 2232>
일직선상에 N(1≤N≤50,000)개의 지뢰가 같은 간격으로 매설되어 있다. 각각의 지뢰는 충격 강도 P(1≤P≤10,000)가 있어서, P를 초과하는 힘을 가하면 P만큼의 힘을 발휘하며 터지게 된다. 어떤 지뢰가 터지게 되면, 그 지뢰의 좌우에 있는 지뢰에 힘을 발휘하게 된다. 예를 들어 다음과 같이 지뢰가 매설된 경우를 보자.
1 2 5 4 3 3 6 6 2
첫 번째의 지뢰를 터트리게 되면 두 번째 지뢰에 1만큼의 힘을 발휘하게 된다. 만약 세 번째의 지뢰를 터뜨리게 되면 2, 4번째 지뢰에 5만큼의 힘을 발휘하게 된다. 따라서 2, 4번째 지뢰도 연쇄 반응을 일으키며 터지고, 다시 1번 지뢰에 2만큼의 힘을, 5번 지뢰에 4만큼의 힘을 발휘하여 연쇄 반응을 일으킨다. 그 후에는 6번 지뢰에 3만큼의 힘을 가하게 되고, 이는 3을 초과하는 힘이 아니기 때문에 연쇄 반응이 멈추게 된다. 정리하면, 세 번째의 지뢰를 직접 터트리고 나면 1~5번 지뢰가 모두 터지게 된다. 다음으로 7, 8번 지뢰를 각각 터트리면 모든 지뢰를 터트릴 수 있다.
지뢰를 직접 터트리는 것은 위험하기 때문에, 당신은 최소의 개수의 지뢰를 직접 터트려서 모든 지뢰를 터트리려 한다. 위의 예에서는 세 개의 지뢰를 직접 터트리면 연쇄 반응에 의해서 모든 지뢰를 터트릴 수 있다.
각 지뢰에 대한 정보가 주어졌을 때, 최소 개수의 지뢰를 직접 터트려서 모든 지뢰를 터트리고자 할 때, 직접 터트려야 하는 지뢰들을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N이 주어진다. 다음 N개의 지뢰는 차례대로 각 지뢰의 충격 강도가 주어진다.
<출력값>
직접 터트려야 하는 지뢰의 번호를 오름차순으로 출력한다.

<문제 2233>
사과나무는 나무(tree)의 일종으로, 각각의 정점에 정확히 한 개의 사과가 있고, 모든 내부 정점(자식이 있는 정점)이 최소 두 개의 자식을 갖는 나무이다. 예를 들면 아래의 그림은 사과나무의 예이다. 나무같이 보이기 위해서 그림은 루트를 아래에 그린다.

이러한 사과나무에 서식하는 벌레를 생각해 보자. 이 벌레는 이 사과나무의 루트에서 DFS 순서로 탐색을 하게 된다. 자식이 여러 개인 경우에는 (뒤집혀진 그림에서) 왼쪽을 먼저 방문하게 된다. 이러한 탐색을 하면서, 새로운 노드를 방문할 때 0을, 모든 자식 노드를 방문하고 리턴할 때 1을 나열하면 하나의 이진 수열이 된다. 위의 그림으로 이진 수열을 만들면 다음과 같다.




			0
			

			0
			

			0
			

			1
			

			0
			

			1
			

			1
			

			0
			

			1
			

			1
			





			a
			

			b
			

			c
			

			 
			

			d
			

			 
			

			 
			

			e
			

			 
			

			 
			



			 
			

			 
			

			 
			

			c
			

			 
			

			d
			

			b
			

			 
			

			e
			

			a
			



이진수의 각 숫자들은 그 숫자가 0이든 1이든 하나의 정점에 대응되게 된다. 즉 0의 경우에는 새로 방문되는 정점에 대응되고, 1의 경우에는 리턴하기 전에 있었던 정점에 대응된다. 위의 표에서는 각 숫자에 대응되는 정점도 표시하였다.
이러한 사과나무에서 썩은 사과가 발견된 경우에는 가지를 잘라 내어야 한다. 만약 우리가 어떤 정점을 제거하면, 그 정점과 그 자손 정점들이 모두 제거되게 된다. 위의 예에서 b를 제거하면 b, c, d가 모두 제거되게 된다.
만약 한 개의 사과가 썩은 경우라면 그 사과를 제거하면 되지만, 두 개의 사과가 썩은 경우라면 문제가 복잡해진다. 사과나무의 성질을 유지하기 위해서, 우리는 오직 한 개의 사과만 제거할 수 있다. 이 경우 루트를 제거하면 되지만, 루트를 제거하게 되면 멀쩡한 사과들을 많이 잃게 된다(제거되는 것은 잃는 것). 따라서 우리는 한 개의 사과를 제거하되, 이를 통해 두 개(이하)의 썩은 사과를 함께 제거하고, 그러면서도 가장 적은 개수의 멀쩡한 사과를 잃도록 잘라야 한다. 위의 예에서 c, d의 사과가 썩은 경우에는 b를 제거하면 된다.
사과나무에 대한 정보가 주어졌을 때, 제거해야 하는 사과를 알아내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 정점의 개수 N(1≤N≤2,000)이 주어진다. 둘째 줄에는 벌레가 만드는 2×N자리의 이진수가 주어진다. 셋째 줄에는 썩은 사과의 위치를 나타내는 두 정수 X, Y가 주어진다. 이는 2×N자리의 이진수에서 X번째의 숫자에 대응되는 정점과, Y번째 숫자에 대응되는 정점에 있는 사과가 썩었다는 의미이다. 이때 두 정점이 서로 같을 수도 있다.
<출력값>
첫째 줄에 제거해야 할 사과를 나타내는 두 정수 i, j를 출력한다. 제거해야 할 사과를 Z라고 했을 때, 이는 Z를 방문할 때의 0의 위치와 Z에서 리턴될 때의 1의 위치가 이진수에서 각각 i, j 번째임을 나타낸다.

<문제 2234>
대략 위의 그림과 같이 생긴 성곽이 있다. 굵은 선은 벽을 나타내고, 점선은 벽이 없어서 지나다닐 수 있는 통로를 나타낸다. 이러한 형태의 성의 지도를 입력받아서 다음을 계산하는 프로그램을 작성하시오.

이 성에 있는 방의 개수
가장 넓은 방의 넓이
하나의 벽을 제거하여 얻을 수 있는 가장 넓은 방의 크기

위의 예에서는 방은 5개고, 가장 큰 방은 9개의 칸으로 이루어져 있으며, 위의 그림에서 화살표가 가리키는 벽을 제거하면 16인 크기의 방을 얻을 수 있다.
성은 m×n(1 ≤ m, n ≤ 50)개의 정사각형 칸으로 이루어진다. 성에는 최소 두 개의 방이 있어서, 항상 하나의 벽을 제거하여 두 방을 합치는 경우가 있다.
<입력값>
첫째 줄에 두 정수 n, m이 주어진다. 다음 m개의 줄에는 n개의 정수로 벽에 대한 정보가 주어진다. 벽에 대한 정보는 한 정수로 주어지는데, 서쪽에 벽이 있을 때는 1을, 북쪽에 벽이 있을 때는 2를, 동쪽에 벽이 있을 때는 4를, 남쪽에 벽이 있을 때는 8을 더한 값이 주어진다. 참고로 이진수의 각 비트를 생각하면 쉽다. 따라서 이 값은 0부터 15까지의 범위 안에 있다.
<출력값>
첫째 줄에 1의 답을, 둘째 줄에 2의 답을, 셋째 줄에 3의 답을 출력한다.

<문제 2235>
Traditionally, simple codes have taken a permutation of the alphabet, numbered each character in the range 01 to 26 (or 00 to 25) and then encrypted the message as a string of digits. It is then relatively easy to conceal the structure of the text by breaking the string into groups of a fixed length.
This problem turns that encoding around and assumes that one has a sequence of digits that one wishes to encrypt (possibly a GPS location that you want to transmit to friend, telling her where a treasure is located). We could do this the simple way and use only 10 characters to encrypt the 10 digits, or we could use all 26 letters and use the additional letters to encrypt suitable pairs of digits. Thus the sequence 941177 could be encoded as 9 4 1 1 7 7 or as 9 4 11 7 7 or as 9 4 1 17 7.
Given a permutation of the upper case letters (which implicitly defines an encoding of the numbers (0)0, (0)1, …, 25) and a sequence of digits, determine the shortest encryption of the sequence as a sequence of letters. Note that decryption of such a sequence may not be unique.
<입력값>
Input will consist of a series of encryption problems. Each problem will begin with a permutation of the uppercase letters, followed by a series of lines each containing a string of between 3 and 20 digits. The string of digits will be terminated by a single zero (‘0’) on a line by itself. The series of problems will be terminated by a line consisting of a ‘#’ on a line by itself. Neither of these lines should be processed.
<출력값>
Output for each problem will consist of a line starting with ‘Problem ’ followed by the problem number, a running number starting at 1. This will be followed by a series of lines, one for each digit sequence in the input for that problem, giving the shortest encoding for that sequence. If there are several such encodings, then choose the lexicographically greatest (i.e. the one that would appear nearest the end of a dictionary if they were to be considered as words). Leave a blank line between successive problems.

<문제 2237>
N개의 양수로 이루어진 수열 {A[1], A[2], …, A[N]}이 있다. 이 수열에 A[i]에서 A[i+1]을 빼는 축소 연산을 적용하려 한다. 축소 연산은 CON이라는 함수로 나타낼 수 있으며, CON(A, i)를 수행하면 {A[1], A[2], …, A[i-1], A[i] - A[i+1], A[i+2], …, A[N]}의 수열을 얻는다.
이와 같은 축소 연산을 N-1번 적용하면, 수열의 길이가 N-1, N-2, …, 1이 되어 결국에는 한 수만 남게 된다. 이와 같은 축소 연산을 적용하여 T라는 수를 만들 수 있는지 알아보려 한다.
예를 들어 {12, 10, 4, 3, 5}라는 수열에 다음과 같은 축소 연산을 적용하면 4를 만들 수 있다.

CON( {12, 10, 4, 3, 5}, 2 ) = {12, 6, 3, 5}
CON( {12, 6, 3, 5}, 3 ) = {12, 6, -2}
CON( {12, 6, -2}, 2 ) = {12, 8}
CON( {12, 8}, 1 ) = {4}
<입력값>
첫째 줄에 N(1≤N≤100), T(0≤|T|≤10,000)이 주어진다. 다음 줄에는 A[1], A[2], … A[N]이 주어진다. A[i]는 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.
<출력값>
첫째 줄부터 사용한 순서대로 축소 연산에서의 i를 출력한다. 항상 가능한 경우만 입력으로 주어지며, 답이 여러 개 존재할 경우에는 임의의 하나를 출력하면 된다.

<문제 2238>
경매는 여러 사람이 하나의 물건을 사려고 할 때, 각 사람이 원하는 가격을 제시하면 그 중 가장 높은 가격으로 물건을 팔게 되는 방식이다. 이러한 고전적인 경매 방식은 꽤 널리 쓰이는데, 최근에는 인터넷 쇼핑몰에서 반대의 경매 방식을 택하기도 한다. 즉, 여러 사람이 가격을 제시하면, 그 중 가장 낮은 가격으로 물건을 팔게 되는 방식도 쓰인다.
하지만 이럴 경우, 모든 사람들이 1원에 물건을 사겠다고 하는 사태가 발생할 수 있다. 따라서 같은 가격을 제시한 사람이 둘 이상일 경우에는 무효로 하는 방식이 쓰인다. 하지만 모든 가격을 여러 사람이 제시하는 경우도 있을 수 있기 때문에, 다음과 같은 방식으로 경매 당첨자를 선택하기로 한다.
우선 가장 적은 수의 사람이 제시한 가격을 찾는다. 이러한 경우가 여럿 있다면, 가장 낮은 가격으로 물건을 팔게 된다. 이때, 그 가격을 제시한 사람들 중에서 가장 먼저 제시한 사람이 물건을 살 수 있게 된다.
각각의 사람들이 제시한 가격이 주어졌을 때, 경매에 낙찰(당첨)되는 사람을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 두 정수 U(1≤U≤10,000), N(1≤N≤100,000)이 주어진다. U는 금액의 상한이고, N은 경매에 참여한 회수이다. 다음 N개의 줄에는 사람 이름 S(공백 없는 알파벳 대소문자 10자 이하)와, 그 사람이 제시한 가격 P(1≤P≤U, 정수)이 경매에 참여한(가격을 제시한) 순서대로 주어진다.
<출력값>
첫째 줄에 낙찰된 사람의 이름과 그 가격을 출력한다.

<문제 2239>
스도쿠는 매우 간단한 숫자 퍼즐이다. 9×9 크기의 보드가 있을 때, 각 행과 각 열, 그리고 9개의 3×3 크기의 보드에 1부터 9까지의 숫자가 중복 없이 나타나도록 보드를 채우면 된다. 예를 들어 다음을 보자.

위 그림은 참 잘도 스도쿠 퍼즐을 푼 경우이다. 각 행에 1부터 9까지의 숫자가 중복 없이 나오고, 각 열에 1부터 9까지의 숫자가 중복 없이 나오고, 각 3×3짜리 사각형(9개이며, 위에서 색깔로 표시되었다)에 1부터 9까지의 숫자가 중복 없이 나오기 때문이다.
하다 만 스도쿠 퍼즐이 주어졌을 때, 마저 끝내는 프로그램을 작성하시오.
<입력값>
9개의 줄에 9개의 숫자로 보드가 입력된다. 아직 숫자가 채워지지 않은 칸에는 0이 주어진다.
<출력값>
9개의 줄에 9개의 숫자로 답을 출력한다. 답이 여러 개 있다면 그 중 사전식으로 앞서는 것을 출력한다. 즉, 81자리의 수가 제일 작은 경우를 출력한다.

<문제 2240>
자두는 자두를 좋아한다. 그래서 집에 자두나무를 심어두고, 여기서 열리는 자두를 먹고는 한다. 하지만 자두는 키가 작아서 자두를 따먹지는 못하고, 자두가 떨어질 때까지 기다린 다음에 떨어지는 자두를 받아서 먹고는 한다. 자두를 잡을 때에는 자두가 허공에 있을 때 잡아야 하는데, 이는 자두가 말랑말랑하여 바닥에 떨어지면 못 먹을 정도로 뭉개지기 때문이다.
매 초마다, 두 개의 나무 중 하나의 나무에서 열매가 떨어지게 된다. 만약 열매가 떨어지는 순간, 자두가 그 나무의 아래에 서 있으면 자두는 그 열매를 받아먹을 수 있다. 두 개의 나무는 그다지 멀리 떨어져 있지 않기 때문에, 자두는 하나의 나무 아래에 서 있다가 다른 나무 아래로 빠르게(1초보다 훨씬 짧은 시간에) 움직일 수 있다. 하지만 자두는 체력이 그다지 좋지 못해서 많이 움직일 수는 없다.
자두는 T(1≤T≤1,000)초 동안 떨어지게 된다. 자두는 최대 W(1≤W≤30)번만 움직이고 싶어 한다. 매 초마다 어느 나무에서 자두가 떨어질지에 대한 정보가 주어졌을 때, 자두가 받을 수 있는 자두의 개수를 구해내는 프로그램을 작성하시오. 자두는 1번 자두나무 아래에 위치해 있다고 한다.
<입력값>
첫째 줄에 두 정수 T, W가 주어진다. 다음 T개의 줄에는 각 순간에 자두가 떨어지는 나무의 번호가 1 또는 2로 주어진다.
<출력값>
첫째 줄에 자두가 받을 수 있는 자두의 최대 개수를 출력한다.

<문제 2241>
아주 오래 전에, 아더왕과 원탁의 기사들은 새 해를 맞이하여 한 곳에 모이곤 했었다. 이와 비슷하게, 체스판에 한 개의 왕과 여러 개의 나이트가 놓여 있고, 이들을 하나의 칸에 모으는 경우를 생각해 보자. 킹와 나이트의 움직임은 대략 다음과 같다.

단순히 킹과 나이트를 한 칸에 모으는 문제라면 쉽겠지만, 이 문제에서는 나이트가 킹을 자신의 말에 태우는 경우를 고려해야 한다. 즉, 킹과 한 개 이상의 나이트가 같은 칸에 놓여있을 때, 킹은 따로 움직일 수도 있고, 아니면 하나의 나이트가 타고 있는 말에 올라탈 수 있다. 킹이 말에 올라타는 것은 하나의 이동으로 세지 않으며, 올라 탄 이후에는 나이트와 똑같이 움직이게 된다. 한 번 말에 오른 킹은 다시 내릴 수는 없다.
나이트가 킹이 있는 곳까지 이동한 뒤에 킹을 태울 수도 있으며, 킹이 나이트가 있는 곳으로 이동하여 말에 오를 수도 있고, 킹과 나이트가 중간의 한 곳에서 만나서 말을 탈수도 있다.
킹과 나이트들의 초기 위치가 주어졌을 때, 이들을 한 칸에 모으기 위한 최소 이동 회수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 체스판의 크기를 나타내는 두 정수 N(1≤N≤40), M(1≤M≤26)이 주어진다. N은 행의 개수, M은 열의 개수이다. 다음 줄에는 킹의 위치를 나타내는 문자 X와 수 Y가 주어진다. X는 알파벳 대문자로 표현되며, 열 번호를 의미한다. Y는 행 번호를 의미한다. 열 번호는 알파벳 A부터 차례대로 매겨진다. 다음 줄부터는 파일의 끝까지 나이트들의 위치가 주어진다. 나이트들의 위치 역시 킹의 위치와 같은 형식으로 주어진다. 파일의 끝은 두 개의 -1로 표현된다. 나이트는 0개일 수도 있고, 체스판을 가득 채울 수도 있다. 물론 같은 위치에는 한 개의 나이트만 있을 수 있다.
<출력값>
첫째 줄에 킹과 나이트들을 한 칸에 모으기 위한 최소 이동 회수를 출력한다. 모이는 칸은 어느 곳이든 가능하다.

<문제 2242>
N(3≤N≤40)개의 막대기들이 있다. 각각의 막대기들은 길이가 서로 같은 수도 있고, 서로 다를 수도 있다. 이러한 막대기들을 연결하여 하나의 삼각형을 만들려고 한다. 이때 사용하지 않는 막대기가 있어서는 안 된다. 즉, 각 막대기들을 적당히 세 그룹으로 나눈 다음, 각 그룹에 있는 막대기들을 일렬로 연결하고, 이를 이용하여 삼각형을 만드는 것이다.
이와 같이 삼각형을 만들었을 때, 가장 큰 삼각형의 넓이를 구해내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 정수 N이 주어진다. 다음 N개의 줄에는 각 막대기의 길이 L(1≤L≤40)이 주어진다.
<출력값>
첫째 줄에 최대 면적을 100배한 값을 소수점 아래에서 버림한 정수를 출력한다. 만약 삼각형을 만들 수 없다면 -1을 출력한다.

<문제 2243>
수정이는 어린 동생을 달래기 위해서 사탕을 사용한다. 수정이는 평소에 여러 개의 사탕을 사서 사탕상자에 넣어두고, 동생이 말을 잘 들을 때면 그 안에서 사탕을 꺼내서 주곤 한다.
각각의 사탕은 그 맛의 좋고 나쁨이 1부터 1,000,000까지의 정수로 구분된다. 1이 가장 맛있는 사탕을 의미하며, 1,000,000은 가장 맛없는 사탕을 의미한다. 수정이는 동생이 말을 잘 들은 정도에 따라서, 사탕상자 안에 있는 사탕들 중 몇 번째로 맛있는 사탕을 꺼내주곤 한다. 예를 들어 말을 매우 잘 들었을 때에는 사탕상자에서 가장 맛있는 사탕을 꺼내주고, 말을 조금 잘 들었을 때에는 사탕상자에서 여섯 번째로 맛있는 사탕을 꺼내주는 식이다.
수정이가 보관하고 있는 사탕은 매우 많기 때문에 매번 사탕상자를 뒤져서 꺼낼 사탕을 골라내는 일은 매우 어렵다. 수정이를 도와주는 프로그램을 작성하시오.
<입력값>
첫째 줄에 수정이가 사탕상자에 손을 댄 횟수 n(1≤n≤100,000)이 주어진다. 다음 n개의 줄에는 두 정수 A, B, 혹은 세 정수 A, B, C가 주어진다. A가 1인 경우는 사탕상자에서 사탕을 꺼내는 경우이다. 이때에는 한 정수만 주어지며, B는 꺼낼 사탕의 순위를 의미한다. 이 경우 사탕상자에서 한 개의 사탕이 꺼내지게 된다. 또, A가 2인 경우는 사탕을 넣는 경우이다. 이때에는 두 정수가 주어지는데, B는 넣을 사탕의 맛을 나타내는 정수이고 C는 그러한 사탕의 개수이다. C가 양수일 경우에는 사탕을 넣는 경우이고, 음수일 경우에는 빼는 경우이다. 맨 처음에는 빈 사탕상자에서 시작한다고 가정하며, 사탕의 총 개수는 2,000,000,000을 넘지 않는다. 또한 없는 사탕을 꺼내는 경우와 같은 잘못된 입력은 주어지지 않는다.
<출력값>
A가 1인 모든 입력에 대해서, 꺼낼 사탕의 맛의 번호를 출력한다. 물론, A=2 이면서 C<0 일 때는 출력하지 않는다.

<문제 2244>
다각형은 그 경계 위에 놓인 모든 점과 그 안의 모든 영역으로 구성되어 있다. 이러한 다각형 중에서 앞으로 이 문제에서 다룰 다각형은 다음과 같은 특성을 만족하는 것으로 한다.

다각형 안의 임의의 두 점을 잇는 선분이 완전히 그 다각형 안에 속해 있다.
세 개 이상의 꼭짓점으로 이루어져 있다.
세 꼭짓점이 한 직선 위에 있는 경우는 없다.

이러한 특성을 만족하는 두 다각형 A, B가 있을 때, 이들의 민코프스키(Minkowski) 합은, A에 속하는 모든 영역의 좌표 (x1, y1)와 B에 속하는 모든 영역의 좌표 (x2, y2)에 대해, 있을 수 있는 모든 (x1+x2, y1+y2) 조합이 나타내는 영역의 도형이다. 다음은 두 삼각형과 이들의 민코프스키 합을 그림으로 나타낸 것이다.

두 다각형이 주어졌을 때, 두 다각형의 민코프스키 합을 구하는 프로그램을 작성하시오. 만약 민코프스키 합이 여러 개의 다각형으로 이루어진다면 다음의 우선순위에 따라 하나의 다각형만을 구하도록 한다. 번호가 작은 것이 우선순위가 높은 것이다.

꼭짓점의 개수가 가장 작은 것
면적이 가장 작은 것
다각형을 이루는 모든 좌표들 중 최소 x좌표가 가장 작은 것
다각형을 이루는 모든 좌표들 중 최소 y좌표가 가장 작은 것
<입력값>
첫째 줄에 두 다각형 A와 B의 꼭짓점 개수 N과 M이 주어진다. (3<=N, M<=1,000) 다음 N개의 줄에는 다각형 A를 이루는 꼭짓점의 좌표가, 그 다음 M개의 줄에는 다각형 B를 이루는 꼭짓점의 좌표가 주어진다. 좌표는 x좌표와 y좌표가 빈칸을 사이에 두고 순서대로 주어지며, 반시계 방향으로 입력된다. 모든 좌표는 100,000,000을 넘지 않는 음이 아닌 정수이다.
<출력값>
첫째 줄에 우리가 구하고자 하는 다각형의 꼭짓점의 개수를 출력한다. 다음 줄부터는 다각형을 이루는 꼭짓점의 x좌표와 y좌표를 한 줄에 한 쌍씩 반시계 방향으로 출력한다. 출력되는 첫 번째 꼭짓점은 x좌표가 가장 작은 점으로 하며, x좌표가 가장 작은 점이 여러 개 있을 경우 y좌표가 가장 작은 점으로 한다.

<문제 2245>
1이상 N이하의 자연수로 이루어진 두 배열 A[1..N], B[1..N]이 있다. 당신은 이 배열들을 정리하여 모든 서로 다른 두 자연수 i, j(1 <= i, j <= N)에 대해서 A[i]≠A[j]이고 B[i]≠B[j]이도록 하려 한다. 즉, 각 배열에 같은 수가 중복되어 나타나지 않도록 하려 한다.
우리가 수행할 수 있는 연산은 Swap(i)라는 연산뿐이다. 이 연산은 A[i]값과 B[i]값을 서로 바꾼다. 예를 들어, A[i]=1, B[i]=2일 때 Swap(i)를 수행하면 A[i]=2, B[i]=1이 되는 것이다.
Swap연산을 가능한 한 적게 수행하여 각 배열에 같은 수가 중복되어 나타나지 않도록 하는 프로그램을 작성하시오. 만약 Swap연산을 아무리 사용해도 배열들을 정리할 수 없다면 -1을 출력한다.
<입력값>
첫째 줄에 자연수 N(1 <= N <= 100,000)이 들어온다. 둘째 줄에 A[1], A[2], …, A[N]을 나타내는 N개의 자연수들이 공백으로 구분되어 들어온다. 셋째 줄에 B[1], B[2], …, B[N]을 나타내는 N개의 자연수들이 공백으로 구분되어 들어온다.
<출력값>
첫째 줄에 사용한 Swap연산을 사용한 횟수, 또는 -1을 출력한다.

<문제 2246>
콘도를 선정할 때에는 가급적이면 싸고 바닷가에 가까운 곳으로 하려 한다. 이를 위해 우선 적당한 콘도 몇 곳을 후보로 선정하려 하는데, 다음 두 조건을 만족하는 콘도 X가 후보가 된다.

X보다 바닷가에 더 가까운 콘도들은 모두 X보다 숙박비가 더 비싸다.
X보다 숙박비가 더 싼 콘도들은 모두 X보다 바닷가에서 더 멀다.

각 콘도의 바닷가에서의 거리와 숙박비에 대한 정보가 주어졌을 때, 후보 콘도의 개수를 구해내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 콘도의 개수를 나타내는 자연수 N(1≤N≤10,000)이 주어진다. 다음 N개의 줄에는 각 콘도에 대한 정보를 나타내는 두 정수 D(1≤D≤10,000), C(1≤C≤10,000)가 주어진다. D는 그 콘도의 바닷가로부터의 거리를 나타내고, C는 그 콘도의 숙박비를 나타낸다. D와 C값이 서로 같은 콘도가 주어지지는 않는다.
<출력값>
첫째 줄에 후보가 될 수 있는 콘도의 수를 출력한다.

<문제 2247>
두 자연수 A와 B가 있을 때, A = BC를 만족하는 자연수 C를 A의 약수라고 한다. 모든 자연수 N은 1과 자기 자신(N)을 약수로 갖게 된다.
실질적 약수(actual divisor)라는 것이 있다. 자연수 N의 약수들 중에서 1과 자기 자신(N)을 제외한 약수를 실질적 약수라고 한다. 따라서 6의 실질적 약수는 2, 3이며, 13의 실질적 약수는 없다.
SOD(Sum Of Divisor)라는 함수를 정의하자. SOD(n)은 정수 n의 모든 실질적 약수의 합을 가리킨다. 따라서 SOD(6) = 5이며, SOD(13) = 0이다. 한편, CSOD(Cumulative SOD)라는 함수도 정의해 볼 수 있다. CSOD(n)은 SOD(1)+SOD(2)+…+SOD(n)이라고 하자.
CSOD(n)을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 n이 주어진다. (1<=n<=200,000,000인 정수)
<출력값>
첫째 줄에 CSOD(n)을 1,000,000으로 나눈 나머지를 출력한다.

<문제 2248>
N(1 ≤ N ≤ 31)자리의 이진수가 있다. 이러한 이진수 중에서, L(1 ≤ L ≤ N)개 이하의 비트만 1인 것을 크기 순으로 나열했을 때, I번째로 나오는 이진수를 구해내는 프로그램을 작성하시오. 이진수는 0으로 시작할 수도 있다.
<입력값>
첫째 줄에 세 정수 N, L, I가 주어진다. I는 범위 안에 있도록 주어진다.
<출력값>
첫째 줄에 답을 출력한다.

<문제 2249>
Every year since 1896, the nations of the world have competed in the Olympic Games for glory, medals and (particularly in recent years) media coverage. Every day eager fans will scan the medal table to see where their team is placed, which, particularly for teams from smaller countries, usually means badly. Part of the problem is that the medal table is sorted strictly in the order: number of gold medals, number of silvers, number of bronzes. This means that a team with 6 silvers and 10 bronzes but only 1 gold is placed well behind a team with 2 golds and nothing else. The situation could be alleviated by allocating a value to each medal type, calculating a total score for each team by multiplying the numbers of each medal type they have won by the appropriate value and then ranking the teams on that. This then raises the problem of determining the values, with the obvious proviso that a gold has to be worth more than a silver which, in turn, has to worth more than a bronze. To keep numbers manageable (remember we are dealing with the general population, not Computer Science students), values must be in the range 1 to 99.
For this problem you will be given a medal table, that is, a list of countries together with the numbers of medals they have won, from which your program is to determine, for each country in the table, what allocation of values to medal types will give that country the best possible placing, where the placing of a country is the number of rivals with a larger score, plus 1.
<입력값>
Input will consist of several scenarios (Games). Each will start with the name of the city where the Games were held, followed by an unsorted sequence of lines containing the name of a country followed by 3 integers representing the number of gold, silver, and bronze medals won by that country, and terminated by a line containing a single ‘#’. There will be no more than 100 teams in any one Games and no team will win more than 1000 medals. The sequence of Games will be terminated by a line consisting of only a single ‘#’.
<출력값>
Output (for each scenario) will consist of a header line followed by a line for each team in the input in the order they appeared in the input. The header line will consist of ‘Olympic Games in ’ followed by the name of the relevant city. Each team line will consist of the name of the team followed by 4 integers, separated by single spaces, giving the medal values that results in their highest placing, and that placing. Remember that the values must be such that gold > silver > bronze and that they must be in the range 1 to 99. If there are several allocations of values that produce the same best placing, then choose the one that produces the smallest 6 digit number ggssbb, where gg, ss, and bb are the relevant values (including leading zeroes if necessary). Leave a single blank line between scenarios (Games).

<문제 2250>
이진트리를 다음의 규칙에 따라 행과 열에 번호가 붙어있는 격자 모양의 틀 속에 그리려고 한다. 이때 다음의 규칙에 따라 그리려고 한다.

이진트리에서 같은 레벨(level)에 있는 노드는 같은 행에 위치한다.
한 열에는 한 노드만 존재한다.
임의의 노드의 왼쪽 부트리(left subtree)에 있는 노드들은 해당 노드보다 왼쪽의 열에 위치하고, 오른쪽 부트리(right subtree)에 있는 노드들은 해당 노드보다 오른쪽의 열에 위치한다.
노드가 배치된 가장 왼쪽 열과 오른쪽 열 사이엔 아무 노드도 없이 비어있는 열은 없다.

이와 같은 규칙에 따라 이진트리를 그릴 때 각 레벨의 너비는 그 레벨에 할당된 노드 중 가장 오른쪽에 위치한 노드의 열 번호에서 가장 왼쪽에 위치한 노드의 열 번호를 뺀 값 더하기 1로 정의한다. 트리의 레벨은 가장 위쪽에 있는 루트 노드가 1이고 아래로 1씩 증가한다.
아래 그림은 어떤 이진트리를 위의 규칙에 따라 그려 본 것이다. 첫 번째 레벨의 너비는 1, 두 번째 레벨의 너비는 13, 3번째, 4번째 레벨의 너비는 각각 18이고, 5번째 레벨의 너비는 13이며, 그리고 6번째 레벨의 너비는 12이다.

우리는 주어진 이진트리를 위의 규칙에 따라 그릴 때에 너비가 가장 넓은 레벨과 그 레벨의 너비를 계산하려고 한다. 위의 그림의 예에서 너비가 가장 넓은 레벨은 3번째와 4번째로 그 너비는 18이다. 너비가 가장 넓은 레벨이 두 개 이상 있을 때는 번호가 작은 레벨을 답으로 한다. 그러므로 이 예에 대한 답은 레벨은 3이고, 너비는 18이다.
임의의 이진트리가 입력으로 주어질 때 너비가 가장 넓은 레벨과 그 레벨의 너비를 출력하는 프로그램을 작성하시오
<입력값>
첫째 줄에 노드의 개수를 나타내는 정수 N(1 ≤ N ≤ 10,000)이 주어진다. 다음 N개의 줄에는 각 줄마다 노드 번호와 해당 노드의 왼쪽 자식 노드와 오른쪽 자식 노드의 번호가 순서대로 주어진다. 노드들의 번호는 1부터 N까지이며, 자식이 없는 경우에는 자식 노드의 번호에 -1이 주어진다.
<출력값>
첫째 줄에 너비가 가장 넓은 레벨과 그 레벨의 너비를 순서대로 출력한다. 너비가 가장 넓은 레벨이 두 개 이상 있을 때에는 번호가 작은 레벨을 출력한다.

<문제 2251>
각각 부피가 A, B, C(1≤A, B, C≤200) 리터인 세 개의 물통이 있다. 처음에는 앞의 두 물통은 비어 있고, 세 번째 물통은 가득(C 리터) 차 있다. 이제 어떤 물통에 들어있는 물을 다른 물통으로 쏟아 부을 수 있는데, 이때에는 한 물통이 비거나, 다른 한 물통이 가득 찰 때까지 물을 부을 수 있다. 이 과정에서 손실되는 물은 없다고 가정한다.
이와 같은 과정을 거치다보면 세 번째 물통(용량이 C인)에 담겨있는 물의 양이 변할 수도 있다. 첫 번째 물통(용량이 A인)이 비어 있을 때, 세 번째 물통(용량이 C인)에 담겨있을 수 있는 물의 양을 모두 구해내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 세 정수 A, B, C가 주어진다.
<출력값>
첫째 줄에 공백으로 구분하여 답을 출력한다. 각 용량은 오름차순으로 정렬한다.

<문제 2252>
N명의 학생들을 키 순서대로 줄을 세우려고 한다. 각 학생의 키를 직접 재서 정렬하면 간단하겠지만, 마땅한 방법이 없어서 두 학생의 키를 비교하는 방법을 사용하기로 하였다. 그나마도 모든 학생들을 다 비교해 본 것이 아니고, 일부 학생들의 키만을 비교해 보았다.
일부 학생들의 키를 비교한 결과가 주어졌을 때, 줄을 세우는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N(1≤N≤32,000), M(1≤M≤100,000)이 주어진다. M은 키를 비교한 회수이다. 다음 M개의 줄에는 키를 비교한 두 학생의 번호 A, B가 주어진다. 이는 학생 A가 학생 B의 앞에 서야 한다는 의미이다.
학생들의 번호는 1번부터 N번이다.
<출력값>
첫째 줄부터 앞에서부터 줄을 세운 결과를 출력한다. 답이 여러 가지인 경우에는 아무거나 출력한다.

<문제 2253>
N(2 ≤ N ≤ 10,000)개의 돌들이 같은 간격으로 놓여 있다. 편의상 순서대로 1, 2, …, N번 돌이라고 부르자. 당신은 현재 1번 돌 위에 있는데, 이 돌들 사이에서 점프를 하면서 N번째 돌로 이동을 하려 한다. 이때 다음 조건들이 만족되어야 한다.

이동은 앞으로만 할 수 있다. 즉, 돌 번호가 증가하는 순서대로만 할 수 있다.
제일 처음에 점프를 할 때에는 한 칸밖에 점프하지 못한다. 즉, 1번 돌에서 2번 돌이 있는 곳으로 점프할 수 있다. 그 다음부터는 가속/감속 점프를 할 수 있는데, 이전에 x칸 점프를 했다면, 다음번에는 속도를 줄여 x-1칸 점프하거나, x칸 점프하거나, 속도를 붙여 x+1칸 점프를 할 수 있다. 물론 점프를 할 때에는 한 칸 이상씩 해야 한다.
각 돌들은 각기 그 크기가 다르고, 그 중 몇 개의 돌은 크기가 너무 작기 때문에 당신은 그러한 돌에는 올라갈 수 없다.

위와 같은 조건들을 만족하면서 1번 돌에서 N번 돌까지 점프를 해 갈 때, 필요한 최소의 점프 횟수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 두 정수 N, M(0 ≤ M ≤ N-2)이 주어진다. M은 크기가 맞지 않는, 즉 크기가 작은 돌의 개수이다. 다음 M개의 줄에는 크기가 작은 돌들의 번호가 주어진다. 1번 돌과 N번 돌은 충분히 크기가 크다고 가정한다.
<출력값>
첫째 줄에 필요한 최소의 점프 횟수를 출력한다. 만약 N번 돌까지 점프해갈 수 없는 경우에는 -1을 출력한다.

<문제 2254>
소들의 반란이 있은 뒤, 이 소들은 포로로 잡은 인간들을 감시해야 했다.
소들은 (Px, Py)의 위치에 감옥을 짓고, 감옥 둘레에 가능한 한 여러 겹으로 담을 쌓아 포로들이 도망가기 힘들도록 하려 한다. 감옥은 하나의 점으로 표현된다.
이러한 목적을 달성하기 위해, 소들은 감옥 주변에 N개의 담 기둥을 세웠다. 각각의 담은 감옥을 완전히 감싸야 하고, 담 안에 (부분적으로라도) 포함되는 담이 있다면 이러한 담도 완전히 감싸야 한다. 즉, 담벼락이 교차하거나 한 점에서 만나서는 안 된다. 감옥과 담 기둥 중 어느 세 점도 일직선상에 있지 않다.
이러한 담 기둥들이 주어졌을 때, 겹치지 않는 최대의 중첩된 담의 겹 수를 구하는 프로그램을 작성하시오.
담은 여러 개의 담벼락이 연결된, 닫힌 다각형을 의미하고, 각각의 담벼락의 두 끝 점은 담 기둥 이어야 한다. 이러한 담 사이에는 반드시 약간이라도 공간이 있어야 한다. 즉, 서로 다른 두 담이 하나의 담벼락이나 담 기둥을 공유해서는 안 된다.
<입력값>
첫째 줄에 N(1≤N≤1,000), Px, Py (-100,000≤Px, Py≤100,000)이 주어진다. 다음 N개의 줄에는 차례로 담 기둥의 좌표가 주어진다. 각각의 좌표는 절댓값이 100,000을 넘지 않는 정수이다.
<출력값>
첫째 줄에 최대 겹 수를 출력한다.

<문제 2255>
주어진 그래프의 한 노드를 루트로 갖는 스패닝 트리는 여러 개이다. 한 (루트가 있는) 스패닝 트리에서, 루트가 아닌 모든 정점들에 대해서, 그 정점의 부모 정점의 차수의 총 합을 SFD(Sum of Father's Degree)라 한다. 이때 각 정점들의 차수는 스패닝 트리에서가 아니라 원래 그래프에서의 차수를 의미한다. 그래프에서 어떤 정점의 차수는 그 정점에 연결된 정점들의 개수를 의미한다.

이해를 돕기 위해 위의 그림을 보자. 제일 왼쪽 그림은 하나의 그래프이고, 오른쪽의 두 개의 그림은 그 그래프의 루트가 있는(1번 정점) 스패닝 트리를 두 개 나타낸 것이다. 가운데 그림의 경우에는 루트를 제외한 2, 3, 4, 5번 정점에 대해서, 그 부모 정점이 1번 정점이 된다. 1번 정점의 원래 그래프에서의 차수가 4이므로, 이 경우 SFD는 4+4+4+4=16가 된다. 세 번째 그림에서는 부모 정점들이 각각 1, 2, 3, 4 이므로 이 경우 SFD는 4+3+3+3=13이 된다. 그리고 이러한 경우가 최적인 경우이다.
그래프와 루트가 주어졌을 때, SFD의 최솟값을 구해내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 세 정수 N(2 ≤ N ≤ 1,000), M(1 ≤ M ≤ N×(N-1)/2), R(1 ≤ R ≤ N)이 주어진다. N은 정점의 개수, M은 간선의 개수, R은 루트의 번호이다. 다음 M개의 줄에는 각 간선에 대한 정보를 나타내는 두 정수 A, B(1 ≤ A, B ≤ N)가 주어진다. 이는 그 간선이 연결하고 있는 서로 다른 두 정점의 번호이다. 같은 간선이 여러 번 주어지는 경우는 없다.
<출력값>
첫째 줄에 SFD의 최솟값을 출력한다.

<문제 2256>
사람들은 보통 식사를 할 때 젓가락을 두 개 사용한다. 그러나 모 선생님 댁에서는 조금 다르게 세 개의 젓가락을 사용한다. 우리가 일반적으로 사용하는 한 벌의 젓가락에 큰 젓가락을 한 개 더 포함시켜 큰 음식을 젓가락에 꽂아 먹는 방식을 택한다.
큰 젓가락의 경우에는 별도의 용도로 사용하기 때문에 문제가 없지만, 나머지 두 젓가락의 길이가 많이 차이 나는 경우에는 불편할 수도 있다. 한 사람이 가지게 되는 젓가락의 길이 A, B, C(A ≤ B ≤ C)라고 할 때, (A-B)×(A-B)가 그 벌점이 된다.
오늘은 모 선생님의 생일이라 K(1 ≤ K ≤ 1000)명의 사람들이 함께 식사를 하게 되었다. 이를 위해서 모 선생님은 K벌(3×K개)의 젓가락을 준비해야 한다. 이를 위해서 모 선생님은 이미 가지고 있는 N(3×K ≤ N ≤ 5000)개의 젓가락들 중에서 몇 개의 젓가락을 골라서 K명의 사람들에게 나눠주기로 하였다. 하지만 이렇게 많은 인원이 식사하게 된 경우가 처음이라 일부 젓가락의 길이가 맞지 않게 되었다. 모 선생님은 가급적 모든 사람들이 편하게 젓가락을 이용할 수 있도록, 각 사람에게 나눠준 젓가락의 벌점의 총 합이 최소가 되도록 하려 한다.
젓가락에 대한 정보가 주어졌을 때, 벌점의 총 합의 최솟값을 구해내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 두 정수 K, N이 주어진다. 다음 줄에는 N개의 젓가락의 길이가 주어진다. 각 젓가락의 길이는 1이상 32767이하의 정수이다.
<출력값>
첫째 줄에 벌점의 총 합의 최솟값을 출력한다.

<문제 2257>
우리가 널리 사용하는 H2O(물), CH3COOH(아세트산)과 같은 화학식은 알파벳과 숫자, 그리고 괄호로 구성된다. 먼저 알파벳은 원자를 나타내는 것으로 H는 수소(Hydrogen), C는 탄소(Carbon), O는 산소(Oxygen) 원자를 뜻한다. 또한 원자를 나타내는 알파벳 뒤에 따르는 숫자는 그 원자가 몇 개 포함되어 있는지를 뜻한다. 따라서 COOHHH 분자는 CO2H3로 나타낼 수 있다. 이 문제에서, 숫자는 항상 2 이상 9 이하로만 입력으로 주어진다. 따라서 CO23과 같이 숫자가 두자리인 경우는 없다.
물의 화학식을 보고 물은 두 개의 수소 원자와 한 개의 산소 원자로 이루어졌음을 알 수 있다. 또한 아세트산의 화학식처럼 한 종류의 알파벳이 화학식에 여러 번 나타날 수도 있다. 실제 화학식 또한 이렇게 사용되는데, 이는 분자의 결합 구조를 나타내기 위함이다.
종종 화학식에는 괄호가 사용되기도 하는데 괄호로 묶인 원자들은 하나의 새로운 원자와 같은 작용을 한다. 따라서 CH(CO2H)(CO2H)(CO2H) 분자는 CH(CO2H)3와 같이 나타낼 수 있다. 괄호 안에 아무런 알파벳도 없는 경우도 있을 수 있는데, 이런 경우는 괄호가 없는 경우와 마찬가지라고 생각하면 된다.
이러한 화학식을 보고 우리는 화학식량을 계산할 수 있는데, 화학식량이란 그 화학식에 포함되어 있는 모든 원자들의 질량의 합을 말한다. 수소 원자 하나의 질량은 1, 탄소 원자 하나의 질량은 12, 산소 원자 하나의 질량은 16이다. 물은 두 개의 수소 원자와 한 개의 산소 원자로 이루어져 있으므로 물의 화학식량은 18이다.
화학식이 주어졌을 때, 이 화학식의 화학식량을 계산하는 프로그램을 작성하시오. 화학식은 수소, 탄소, 산소만을 포함하고 있는 것만이 입력으로 주어진다.
<입력값>
첫째 줄에 화학식이 주어진다. 화학식은 H, C, O, (, ), 2, 3, 4, 5, 6, 7, 8, 9만으로 이루어진 문자열이며, 그 길이는 100을 넘지 않는다.
<출력값>
첫째 줄에 화학식량을 출력한다. 분자량이 10,000이 넘는 고분자는 입력으로 주어지지 않는다.

<문제 2258>
은혜는 정육점에서 고기를 사려고 한다. 보통 정육점에서는 자신이 원하는 양을 이야기하면 그 양만큼의 고기를 팔지만, 은혜가 방문한 정육점에서는 세일 행사를 하고 있었기 때문에 N 덩어리의 고기를 이미 잘라놓고 판매하고 있었다.
각각의 덩어리들은 이미 정해져 있는 무게와 가격이 있는데, 어떤 덩어리를 샀을 때에는 그 덩어리보다 싼 고기들은 얼마든지 덤으로 얻을 수 있다(추가 비용의 지불 없이). 또한 각각의 고기들은 부위가 다를 수 있기 때문에 비용과 무게와의 관계가 서로 비례하는 관계가 아닐 수도 있다. 은혜는 이러한 점을 고려하지 않고, 어느 부위든지 자신이 원하는 양만 구매하면 되는 것으로 가정한다. 또한 만약 가격이 더 싸다면 은혜가 필요한 양보다 더 많은 고기를 살 수도 있다.
각 덩어리에 대한 정보가 주어졌을 때, 은혜가 원하는 양의 고기를 구매하기 위해 필요한 최소 비용을 계산하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 두 정수 N(1≤N≤100,000), M(1≤M≤2,147,483,647)이 주어진다. N은 덩어리의 개수를 의미하고, M은 은혜가 필요한 고기의 양이다. 다음 N개의 줄에는 각 고기 덩어리의 무게와 가격을 나타내는 음 아닌 두 정수가 주어진다. 무게의 총 합과 가격의 총 합은 각각 2,147,483,647을 넘지 않는다.
<출력값>
첫째 줄에 답을 출력한다. 불가능한 경우에는 -1을 출력한다.

<문제 2259>
정은이는 두더지 잡기 게임을 즐겨 한다. 어느 날 정은이는 한 야외 행사에서 대형 두더지 잡기 게임을 하게 되었다.
게임은 큰 벌판에서 진행되는데, 게임을 시작한 뒤 T(1≤T≤1,000,000)초가 지났을 때, 벌판의 (x, y) 좌표(0≤|x|, |y|≤1,000)에서 두더지가 나타나게 된다. 두더지는 매우 짧은 시간동안만 나타나므로, 정확히 T초에 그 위치에 있게 되면 그 위치에서 나타나는 두더지를 잡을 수 있다. 게임을 하기 위해서는 벌판의 이곳저곳을 돌아다녀야 하는데, 정확히 T초에 두더지가 나타나는 위치에 도착한 경우에도 두더지를 잡을 수 있는 것으로 간주한다.
이러한 두더지들이 N(1≤N≤6,666)마리가 있는데, 정은이는 이 두더지들을 최대한 많이 잡기 위해서 미리 계획을 세우고 이동해야 함을 알게 되었다. 게다가 정은이는 1초에 S(1≤S≤1,000)만큼의 거리를 움직일 수 있기 때문에, 이러한 점도 고려하여 계획을 세워야 한다. 만약 (0, 0)의 위치에서 (1, 1)의 위치로 이동해야 하고, 1초에 1만큼의 거리를 움직일 수 있다면, 대략 1.41초 정도의 시간이 필요하게 된다.
두더지들에 대한 정보가 주어졌을 때, 정은이가 잡을 수 있는 두더지의 최대 마리수를 계산하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 두 정수 N, S가 주어진다. 다음 N개의 줄에는 각 두더지에 대한 정보를 나타내는 세 정수 x, y, T가 주어진다. 게임이 시작되는 순간(T=0)에 정은이의 위치는 (0, 0)이라고 가정한다.
<출력값>
첫째 줄에 답을 출력한다.

<문제 2260>
평화로운 어느 도시에 핵폭탄이 투하되어 도시 전체가 폐허가 되었다. 오랜 시간이 흘러 이 도시에 다시 사람들이 모이게 되었는데, 핵폭탄이 떨어진 위치에 아직 핵폐기물이 남아있었다. 평화로운 도시에 살던 사람들은 핵폐기물의 위험에 대해 잘 몰랐기 때문에, 단순히 이를 둘러싸는 벽을 만들기로 하였다.
핵폭탄의 주변에는 원래 N(3 ≤ N ≤ 100)개의 벽이 있었는데, 핵폭탄으로 인해 각 벽들이 무너지게 되었다. 도시에서는 이러한 벽들을 수리하기로 하였는데, 각 지역의 높이 차이와 파괴된 정도, 그리고 벽의 재질 등으로 각각의 벽들을 수리하는데 필요한 비용이 다를 수도 있다. 도시에서는 이러한 벽들 중 일부(혹은 전부)를 이용하여 최소의 비용으로 벽을 만들기로 하였다.
핵폐기물을 둘러싸는 벽을 만들 때에는, 그 벽들이 완전히 연결되는 볼록 다각형의 형태가 되어야 한다. 각각의 벽들을 하나의 선분이라고 생각했을 때, 그 선분 위에 핵폐기물이 위치하는 경우는 없다고 가정한다. 하지만 도시에서 이전에 있던 벽들에 대한 정보를 판단할 때 착오가 있을 수도 있기 때문에, 서로 다른 두 벽들이 이루는 선분이 서로 교차하는 경우는 있을 수도 있다.
핵폐기물의 위치와 벽들에 대한 정보가 주어졌을 때, 핵폐기물을 둘러싸는 볼록 다각형 형태의 벽을 만들이 위해 필요한 최소 비용을 계산하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 세 정수 N, X, Y가 주어진다. (X, Y)는 핵폐기물의 위치를 나타낸다. 다음 N개의 줄에는 각각의 벽에 대한 정보를 나타내는 다섯 정수 x1, y1, x2, y2, C(1 ≤ C ≤ 10,000)가 주어진다. 이는 두 점 (x1, y1), (x2, y2)를 연결하는 벽을 재건하기 위해 필요한 비용이 C임을 의미한다. 모든 좌표들은 절댓값이 10,000을 넘지 않는 정수이다.
<출력값>
첫째 줄에 답을 출력한다. 불가능한 경우에는 -1을 출력한다.

<문제 2261>
2차원 평면상에 n개의 점이 주어졌을 때, 이 점들 중 가장 가까운 두 점을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 자연수 n(2 ≤ n ≤ 100,000)이 주어진다. 다음 n개의 줄에는 차례로 각 점의 x, y좌표가 주어진다. 각각의 좌표는 절댓값이 10,000을 넘지 않는 정수이다. 여러 점이 같은 좌표를 가질 수도 있다.
<출력값>
첫째 줄에 가장 가까운 두 점의 거리의 제곱을 출력한다.

<문제 2262>
월드시에서는 매년 n명의 사람들이 모여 월드 크래프트라는 게임의 토너먼트 대회를 치른다. 이 게임은 특성상 실력만이 승패를 좌우하기 때문에, 아무리 실력이 엇비슷한 사람이 시합을 치러도 랭킹이 높은 사람이 반드시 이기게 된다. 따라서 월드시에서는 게임을 흥미진진하게 만들기 위해서, 부전승을 여러 번 만들더라도 각 시합에 임하는 선수들의 랭킹 차이를 비슷하게 만들려고 한다.
토너먼트를 만들 때에는 이미 추첨이 된 순서대로 선수들을 배치하고, 왼쪽에서 오른쪽의 순서가 어긋나지 않도록 시합을 정한다. 물론 부전승을 임의로 만들 수 있지만, 토너먼트가 꼬여서는 안 된다. 또한, 각 시합에 임하는 두 선수의 랭킹의 차이의 합이 최소가 되도록 하려 한다.

예를 들어 추첨 결과가 차례로 랭킹 1, 6, 2, 5, 3, 4위의 선수들이었을 때의 토너먼트 세 개가 위에 있다. <A>의 경우는 각 시합이 (1 6), (2 5), (3 4), (1 2), (1 3)으로 랭킹 차이의 합이 5+3+1+1+2=12가 된다. 반면에 <B>는 11이, <C>는 10이 된다.
토너먼트 추첨 결과가 주어졌을 때, 각 시합에 임하는 두 선수의 랭킹 차이의 총 합의 최솟값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 자연수 n(1≤n≤256)이 주어진다. 다음 줄에는 추첨 결과를 나타내는 n명의 선수들의 랭킹이 주어진다. 각 선수의 랭킹은 1부터 n까지의 자연수로 나타나며, 랭킹이 같은 경우는 없다고 가정하자.
<출력값>
첫째 줄에 답을 출력한다.

<문제 2263>
n개의 정점을 갖는 이진 트리의 정점에 1부터 n까지의 번호가 중복 없이 매겨져 있다. 이와 같은 이진 트리의 인오더와 포스트오더가 주어졌을 때, 프리오더를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 n(1≤n≤100,000)이 주어진다. 다음 줄에는 인오더를 나타내는 n개의 자연수가 주어지고, 그 다음 줄에는 같은 식으로 포스트오더가 주어진다.
<출력값>
첫째 줄에 프리오더를 출력한다.

<문제 2264>
어떤 사람이 종이에 점을 찍어서 그림을 그렸다. 그림을 다 그려놓고 보니, 이 그림이 대칭인지 아닌지 궁금해졌다.
대칭이라는 말의 의미는, 종이를 한 번 접었을 때, 위쪽 종이에 점이 찍힌 적이 있는 위치와 아래쪽 종이에 점이 찍힌 적이 있는 위치가 일치할 때를 의미한다. 종이에는 결이 있기 때문에, 종이를 접을 때에는 x축에 수직하게(y축에 평행하게)만 접을 수 있다. 종이를 접는 위치가 반드시 종이의 정 가운데일 필요는 없다. 접힌 선 위에 있는 점들은 무시해도 된다.
점을 찍은 순서대로 점의 위치가 주어졌을 때, 이 그림이 대칭인지 판별하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 점을 찍은 회수 N(1≤N≤100,000)이 주어진다. 다음 N개의 줄에는 순서대로 점을 찍은 x, y좌표가 주어진다. 각각의 좌표는 절댓값이 1,000,000,000을 넘지 않는 정수이다. 즉, 종이가 (-1,000,000,000, -1,000,000,000)부터 (1,000,000,000, 1,000,000,000)까지 있다고 생각하면 된다.
<출력값>
가능할 경우에는 첫째 줄에 접은 위치의 x좌표를 출력한다. 접은 위치의 x좌표가 실수로 나오는 경우에는 소수점 아래 첫째 자리만 출력한다. 즉, %.1lf 로 출력하라는 의미이다. 불가능한 경우에는 NO를 출력한다.

<문제 2265>
로빈슨 크루소가 탄 배는 폭풍우에 난파되었고, 그는 우여곡절 끝에 혼자서 한 섬에 도착하게 되었다. 그는 지치고 절망하였지만 불행 중 다행으로 어릴 때 들은 도착한 섬에 대한 전설을 아직도 생생히 기억할 수 있었다. 그 전설에 따르면 섬에는 선한 사람으로 구성된 종족과 악한 사람으로 구성된 종족이 살고 있다. 그는 살아남기 위해서 선한 종족과 악한 종족을 구별할 필요가 생겼는데, 그것이 그리 쉽지는 않았다. 사람들의 외모는 너무 비슷하여 그것으로 구별할 수가 없었다.
아직도 희망이 완전히 사라진 것은 아니다. 그는 기억 속에서 다음과 같이 유용한 정보를 끄집어낼 수 있었다. 그 섬에 사는 사람들은 모두 서로 잘 알고 있어서, 각자는 어떤 사람이 선한 종족이고 어떤 사람이 악한 종족인지를 구별할 수 있다. 악한 종족 사람들은 자기 마음에 드는 질문에는 대답을 하지만, 그렇지 않으면 질문한 사람을 저주하여 죽일 수도 있다. 다행히도 어떤 사람에게 다른 사람이 선한 종족인지 아닌지를 묻는 질문은 악한 종족의 비위를 거스르는 것이 아니고 따라서 그 질문은 안전하다. 선한 종족 사람들은 모두 항상 참말만 하는 참말 쟁이고, 악한 종족 사람들은 모두 항상 거짓말만 하는 거짓말쟁이이다. 두 종족 사람의 수가 전설에 나와 있어서 미리 알고 있고, 수세기 동안 그 수는 변하지 않고 있다.
로빈슨 크루소가 당신에게 도움을 청해왔다. 당신이 할 일은 그를 도와서 그의 질문에 대한 사람들의 대답을 보고 어떤 사람이 선한 종족이고 어떤 사람이 악한 종족인가를 알아내는 것이다.
<입력값>
첫 줄에는 세 정수 n, p1, p2가 입력된다. n은 로빈슨 크루소가 물은 질문의 수이고, p1, p2는 각각 선한 종족과 악한 종족 사람의 수이다. 그 후 n개의 줄 각각은 두 정수 xi, yi와 한 단어 ai가 입력된다. xi와 yi는 섬에 사는 사람의 번호이다. 섬에 사는 사람은 1부터 p1+p2까지 미리 번호가 매겨져 있다. ai는 yes이거나 no인데, xi가 말하기를 yi가 선한 종족 사람이라고 했다면, yes이고, 그렇지 않으면, no이다. xi와 yi는 같은 사람 일 수 도 있다. 왜냐하면, "당신은 선한 종족 사람이냐?"라고 물을 수 있기 때문이다. 서로 다른 두 줄에 있는 xi와 yi 그리고 xj와 yj가 서로 같을 수도 있는데, 그것은 로빈슨 쿠르소가 흥분하여 같은 사람에게 같은 질문을 했을 수 있기 때문이다. n은 1000이하이고, p1과 p2는 모두 300 이하이다. 또한, 모순되는 답변은 주어지지 않는다.
<출력값>
섬에 사는 사람을 모두 선한 종족과 악한 종족으로 분류할 만큼 충분한 정보가 주어져 있으면, 첫째 줄에 선한 종족 사람의 번호를 오름차순으로 출력한다. 만약, p1 = 0이라 출력할 번호가 없으면, 아무것도 출력하지 않는다. 충분한 정보가 주어져있지 않은 경우에는 첫 줄에 "NO"라고 출력한다.

<문제 2266>
N층 빌딩이 있다. 이 빌딩의 F층은 금고를 떨어뜨렸을 때에 부서지는 최소 층이다. 다시 말하면, F층을 포함하여 그 위의 층에서 금고를 떨어뜨리면 무조건 부서지며, F층의 아래층에서 금고를 떨어뜨릴 때에는 금고는 절대 부서지지 않는다. N층에서도 부서지지 않을 수도 있으며, 1층에서도 부서질 수도 있다.
새로 개발한 금고의 견고함을 측정해보기 위해서 K개의 금고를 이용하여 이 빌딩의 F층을 구하려고 한다. 이를 위해서 직접 금고를 떨어뜨려 보면서 그 결과를 확인하려 한다. 금고가 부서진 경우에는 그 금고를 다시 사용할 수 없으며, 부서지지 않았다면 다시 사용할 수 있다.
이런 상황에서 K개의 금고를 가지고 F층이 몇 층이던지 간에 F층을 알아낼 수 있는 최소한의 금고 낙하 회수를 E(N, K)라 하자. 예를 들어 K=1이라면 F를 알아내기 전에 금고가 부서지면 안 되기 때문에 1층부터 차례로 올라가면서 금고를 떨어뜨려야 한다. 따라서 E(N, 1)=N이 된다.
두 정수 N, K가 주어졌을 때 E(N, K)를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 두 정수 N(1≤N≤500), K(1≤K≤N)가 주어진다.
<출력값>
첫째 줄에 E(N, K)를 출력한다.

<문제 2267>
A typical bus timetable has a column of stops down the left hand side, followed by a series of columns specifying a particular service and labelled with the number of a bus route. Each entry in the table, i.e. each intersection of the row for a given stop and a column for a given service, will be either blank or contain the time that that service is scheduled to leave that stop.
As you can imagine, producing these timetables by hand is very difficult and error prone, so this is where you come in. Write a program to produce a timetable, given details of the various routes and services.
<입력값>
Input will consist of a number of scenarios. Each scenario will start with the title of the scenario, followed by a number of lines, one for each route in the scenario. The sequence of scenarios will be terminated by a line consisting of a single ‘#’.
The line for a route will start with the time that the first service for that route leaves the depot (hours and minutes) followed by the interval between services (minutes). This will be followed by a series of pairs of integers representing travel times and bus stops. The list of routes will be terminated by a line containing two zeroes (0 0) and will never contain details of more than 10 routes. Note that routes are numbered implicitly, starting from 1, bus stops are also numbered from 1 and are always visited in order (apart from the return to the depot), there will never be more than 99 stops, and that the depot is effectively bus stop 0 (thus the last bus stop number in the list will always be 0). Note that no buses leave before 6:00 am and all services terminate (i.e. are back in the depot) by midnight, thus you should not generate a service that violates these constraints.
<출력값>
Output will consist of one timetable per scenario. Each timetable will start with the name of the scenario on a line by itself, followed by a heading line detailing the services (sorted in order of departure time from the depot, see example) followed by as many lines as there are bus stops mentioned in the input. Each line starts with the number of the stop (two columns) followed by an entry for each service. Each entry is 6 columns wide and starts with a ‘|’ followed either by 5 spaces (if that service does not stop there) or a departure time in the form hh:mm, using a 24 hour clock (i.e., including leading zeroes). The line is terminated by a ‘|’. Note that times increase monotonically downwards, but not necessarily across. Leave a blank line between scenarios.

<문제 2268>
N개의 수 A[1], A[2], …, A[N] 이 주어졌을 때, 함수 Sum(i, j)는 A[i]+A[i+1]+…+A[j]를 구하는 함수이다. (i>j일 경우에는 A[j]+A[j+1]+...+A[i]) A가 주어졌을 때, Sum(i, j)를 구하는 것은 매우 쉬운 문제이다. 이러한 (i, j)가 여러 개 주어졌을 때도 별로 어려운 문제는 아니다.
Sum함수와 더불어 Modify라는 함수를 정의하자. Modify(i, k)를 수행하면 A[i]=k가 되는 함수이다. Sum함수와 Modify 함수의 사용 목록이 주어졌을 때, 이에 해당하는 연산을 하는 프로그램을 작성하시오. 두 함수를 섞어서 사용할 수도 있다.
<입력값>
첫째 줄에는 N(1≤N≤1,000,000), M(1≤M≤1,000,000)이 주어진다. M은 수행한 명령의 개수이며 다음 M개의 줄에는 수행한 순서대로 함수의 목록이 주어진다. 첫 번째 숫자는 어느 함수를 사용했는지를 나타내며, 0일 경우에는 Sum 함수를, 1일 경우에는 Modify 함수를 나타낸다. 다음 두 수는 각 함수의 인자 (i, j)나 (i, k)를 나타낸다. 처음에는 A[1]=A[2]=…A[N]=0이다. Modify인 경우에 1 ≤ k ≤ 100,000 이다.
<출력값>
Sum 함수의 개수만큼 각 줄에 Sum 함수의 리턴값을 출력한다.

<문제 2269>
Strict Binary Tree는 이진 트리의 일종으로, 단말 노드가 아닌 모든 노드들이 두 자식 노드를 가지고 있는 트리이다. Strict Binary Tree의 단말값은 그 노드를 루트로 하는 부분 트리에 있는 단말 노드의 개수이다. 예를 들어 아래와 같은 트리는 Strict Binary Tree이며, 노드의 위치에 있는 각각의 수는 그 노드의 단말값이다.

이와 같은 Strict Binary Tree를 Preorder(전위)로 돌면서, 루트와 어떤 노드의 왼쪽 자식 노드들의 단말값을 나열하면 (7 4 1 2 1 1 1)과 같이 된다. 위의 그림에서는 *표가 된 노드들이 단말값이 나열되는 노드들이다. 이와 같이 단말값을 나열한 것을 그 트리의 표시 코드라고 하자.
어떤 Strict Binary Tree의 표시 코드가 주어졌을 때, 이 트리와 같은 개수의 단말 노드를 가지면서 표시 코드가 사전식 순서로 주어진 표시 코드 이전에 오는 트리를 구하시오.
<입력값>
첫째 줄에 표시 코드의 길이 L(1≤L≤10,000)이 주어진다. 다음 줄에는 표시 코드를 나타내는 L개의 정수들이 공백으로 분리되어 주어진다.
<출력값>
만약 주어진 표시 코드가 사전식 순서로 제일 앞에 오는 표시 코드라면 0을 출력한다. 그 외의 경우는 사전식 순서로 주어진 표시 코드 이전에 오는 표시 코드를 출력한다.

<문제 2270>
하노이 탑 문제를 들어 보았을 것이다. 3개의 막대기 중 하나에 n개의 디스크가 꽂혀 있고, 이 디스크들을 다른 막대기로 옮기는 문제이다. 이 문제를 풀 때의 이동 회수가 2ⁿ-1임은 잘 알려져 있다.
동혁이는 이 문제에 도전했는데, 대략 정신이 멍해진 사이에 그만 실수로 디스크들을 잘못 옮겨버렸다. 그래도 하노이 탑 문제의 기본적인 규칙은 어기지 않아서, n개의 디스크들을 한 막대기로 옮길 수는 있게 되었다.
디스크들이 놓여 있는 상태가 입력으로 주어졌을 때, 이 디스크들을 최소의 이동으로 한 막대기로 모으려고 한다. 어느 막대기로 모아야 하는지, 그리고 최소의 이동은 몇 번인지를 알아내는 프로그램을 작성하시오. 답은 매우 커질 수 있기 때문에, 1,000,000으로 나눈 나머지만을 출력한다.
<입력값>
첫째 줄에 정수 n(1≤n≤100,000)이 주어진다. 둘째 줄에는 세 정수 a, b, c가 주어진다. 이는 차례로 1, 2, 3번 막대기에 꽂혀 있는 디스크의 개수이다. 이는 0이상 n이하이며, a+b+c=n이다. 다음 3개의 줄에는 차례로 1, 2, 3번 막대기에 꽂혀 있는 디스크들의 번호가 밑에서부터 주어진다. 각 디스크들의 번호는 1, 2, …, n이며, 잘못된 입력은 주어지지 않는다.
<출력값>
첫째 줄에 모아야 하는 막대기의 번호(1, 2, 3 중 하나)를 출력한다. 그 다음 줄에는 최소의 이동 회수를 1,000,000으로 나눈 나머지를 출력한다.

<문제 2271>
암호문을 만드는 방법에는 여러 가지가 있는데, 보통 이를 위해서 암호화 하려는 글(혹은 파일 등)을 하나의 수열로 나타내게 된다. 이 문제에서는 A[1], A[2], …, A[n]의 수열을 암호화 하려 한다고 하자.
이 수열을 암호화 하는 대단히 효율적인 알고리즘을 발견하였는데, 이 알고리즘에는 약점이 하나 있다. 바로 수열이 특정 조건을 만족할 경우에는 복호화(암호문을 다시 원래의 글로 바꾸는 것)가 유일하지 않게 된다는 점이다.
수열이 주어졌을 때, 이 수열이 우리가 사용하려는 암호화 알고리즘의 약점인지 아닌지를 판별하는 프로그램을 작성하여라.
수열이 1 ≤ p < q < r < s ≤ n 을 만족하는 p, q, r, s 에 대해서 A[q] < A[s] < A[p] < A[r]이나 A[q] > A[s] > A[p] > A[r]를 만족하는 경우가 있다면 이러한 경우가 약점이 된다. 즉, 1 ≤ p < q < r < s ≤ n 이 되도록 p, q, r, s를 어떻게 잘 선택했는데, 이때 A[q] < A[s] < A[p] < A[r]이 만족되거나, A[q] > A[s] > A[p] > A[r]이 만족되는 경우가 약점이다.
<입력값>
첫째 줄에 데이터의 개수 T(1≤T≤10)가 주어진다. 각각의 데이터의 첫째 줄에는 n(4≤n≤5,000)이 주어진다. 그 다음 줄에는 차례로 A[1], A[2], …, A[n]이 주어진다. 각각의 A[i]는 1이상 10,000 이하이다. 모든 A[i]는 서로 다르다고 가정하자.
<출력값>
T개의 줄에 각각의 데이터에 대한 결과를 출력한다. 약점인 경우에는 Yes를, 아닌 경우에는 No를 출력한다.

<문제 2272>
N개의 램프를 다음과 같은 규칙에 의해 켜고 끄려 한다.
0001 → 0011 → 0101 → 1111 → 0000 → 0000 → …
1은 램프가 켜져 있는 상태를 의미하고. 0은 꺼져 있는 상태를 의미한다. 매 초마다 램프들의 상태를 바꾸는데, 만약 전 시간에 자신의 오른 쪽 램프가 켜져 있었다면 다음 시간에 그 램프의 상태를 바꾸는 것이다. 1번 램프는 N번 램프의 오른쪽이라고 생각하자.
램프들의 모양이 주어졌을 때, M초 후의 램프들의 모양을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N(1 ≤ N ≤ 1,000,000), M(0 ≤ M ≤ 1,000,000,000)이 주어진다. N개의 줄에는 0 또는 1이 주어진다.
<출력값>
N개의 줄에 램프의 상태를 출력한다.

<문제 2273>
N명의 학생들이 키 순서대로 줄을 서려고 한다. 각 학생의 키를 직접 재서 정렬하면 간단하겠지만, 마땅한 방법이 없어서 두 학생의 키를 비교하는 방법을 사용하기로 하였다. 그나마도 모든 학생들을 다 비교해 본 것이 아니고, 일부 학생들의 키만을 비교해 보았다.
일부 학생들의 키를 비교한 결과가 주어졌을 때, 각 학생이 설 수 있는 위치의 범위를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N(1≤N≤256), M(1≤M≤100,000)이 주어진다. M은 키를 비교한 회수이다. 다음 M개의 줄에는 키를 비교한 두 학생의 번호 A, B가 주어진다. 이는 학생 A가 학생 B의 앞에 서야 한다는 의미이다. 같은 학생들을 여러 번 비교했을 수도 있다.
<출력값>
N개의 줄에 각 학생이 설 수 있는 위치의 범위를 출력한다. 불가능한 경우에는 첫째 줄에 -1을 출력한다.

<문제 2274>
In 2417 archaeologists discovered a large collection of 20th century text documents of vital historical importance. Although there were many duplicated documents it was soon evident that, as well as the damage due to time making much of the text illegible, there were also some disagreements between them. However, it was noticed that groups of texts could be made consistent, i.e. consistency between texts could be achieved by leaving out some (small) number of texts. For example, the texts:
ap***
ab*le
app*e
*p**e 
(where * denotes an illegible character) can be made consistent by removing just the second text.
<입력값>
Input will consist of a sequence of sets of texts. Each set will begin with a line specifying the number of texts in the set, and the maximum number of texts which can be removed. This will be followed by the individual texts, one per line. Each text consists of at least one and no more than 250 characters, either lower case letters or asterisks. All the texts in a set will be the same length and there will be no more than 10,000 texts in a set. The sequence of sets is terminated by a line containing two zeros (0 0).
<출력값>
Output for each set consists of a line containing one of the words ‘Yes’ or ‘No’ depending on whether or not the set can be made consistent by removing at most the specified number of texts.

<문제 2275>
n(1≤n≤10,000)개의 정점을 갖는 부모가 있는 트리(Rooted Tree)를 생각해 보자. 각각의 간선에는 음 아닌 정수로 가중치가 있다. 이 트리의 높이는 루트에서 가장 멀리 떨어져 있는 정점까지의 거리를 의미한다.
이 트리의 간선의 가중치를 1씩 줄일 때마다 1만큼의 비용이 든다. 쉽게 생각하면, 가중치가 x인 간선의 가중치를 y(x≥y≥0)로 줄일 때, x-y만큼의 비용이 든다는 의미이다. 문제를 쉽게 하기 위해서 음 아닌 정수에서 음 아닌 정수로 줄이는 경우만 생각하기로 하자.
우리는 몇 개의 간선의 가중치를 적절히 줄여서, 이 트리의 높이를 H(H≥0, H는 정수)로 만들려고 한다. 이때, 최소의 비용을 들여서 높이를 H로 만드는 것이 목적이다.
<입력값>
첫째 줄에 정점의 개수 n과 H가 주어진다. 다음 n개의 줄에는 1번 정점부터 n번 정점까지 차례로, 각 정점의 부모 정점과, 그 정점에서 부모 정점까지의 거리(간선의 가중치)가 주어진다. 루트의 경우에는 부모 정점과 비용 대신에 0 두 개가 주어진다. 각 간선의 가중치의 총 합은 1,000,000,000을 넘지 않는다.
<출력값>
첫째 줄에 최소 비용을 출력한다.

<문제 2276>
N×M 크기의 물통이 있다. 이 물통의 각 칸은 높이가 다를 수도 있다. 이와 같은 물통에 물을 부었을 때, 담을 수 있는 물의 최대량을 계산하는 프로그램을 작성하시오. 물통의 테두리도 높이가 다를 수 있고, 테두리가 물통의 안쪽보다 높이가 낮을 수도 있다.

왼쪽 표는 물통의 높이를 나타낸 것이고, 오른쪽은 각 칸에 담은 물의 양을 나타낸 것이다. 이 경우가 답이 12로 최대인 경우가 된다.
<입력값>
첫째 줄에 M, N(1≤N, M≤300)이 주어진다. 다음 M개의 줄에는 N개의 자연수로 각 칸의 높이가 주어진다. 각각의 높이는 1,000,000,000를 넘지 않는다.
<출력값>
첫째 줄에 답을 출력한다. 답은 int 범위 이내이다. 이 값은 0이 될 수도 있다.

<문제 2277>
저명한 물리학자 리처드 파인만은 원자폭탄 제조의 비밀을 기록한 서류가 금고에 보관되어 있음을 알고, 이것을 훔쳐내고자 마음먹었다. 그는 자신의 금고털이 경험에 근거하여 금고 자물쇠의 동작방식을 알아내는데 성공하였다.

자물쇠는 N개의 회전판으로 이루어져 있으며, 각각의 회전판에는 그 둘레를 따라 0부터 M-1까지 총 M개의 번호가 표시되어 있다. 모든 회전판의 번호가 서로 같아지면 금고가 열린다. 모든 회전판은 한쪽 방향(번호가 커지는 방향)으로만 돌릴 수 있다. M-1인 상태에서 한차례 돌리고 나면 그 회전판의 번호는 0이 된다.
회전판 한 개를 돌려서 번호를 1만큼 증가시키는 데 1초가 걸린다. 그런데 파인만은 손가락이 매우 길어서 같은 번호를 가지는 연속된 회전판들을 한꺼번에 돌릴 수 있다. 예를 들어, 자물쇠의 상태가 (1, 1, 1, 2)일 때, 왼쪽 회전판 3개를 1초 만에 돌려서 모두 2로 만들 수 있다.
자물쇠의 초기 상태가 주어졌을 때, 금고를 열 수 있는 최단 시간을 구하시오.
<입력값>
첫째 줄에 N, M(1 ≤ N ≤ 500, 2 ≤ M ≤10,000)이 주어진다. N은 회전판의 개수, M은 번호의 가짓수이다.
둘째 줄에는 N개의 회전판마다 초기 상태에서의 번호가 주어진다.
<출력값>
금고를 열 수 있는 최단 시간을 출력한다.

<문제 2279>
2차원 평면에 n(1≤n≤1,000)개의 점으로 이루어진 도형과 m(1≤m≤10,000)개의 사각형이 있다. 서로 다른 두 사각형은 면적을 갖는 부분을 공유하지 않는다. 이때, 주어진 사각형들 중 몇 개를 선택하면 도형을 덮을 수 있다. 도형을 덮을 때에는, 도형의 바깥으로 벗어나는 사각형을 사용할 수 없으며, 도형의 내부에 사각형으로 덮이지 않은 부분이 있어서는 안 된다.
<입력값>
첫째 줄에 두 자연수 n, m이 주어진다. 다음 n개의 줄에는 차례로 도형의 점들이 주어진다. 다음 m개의 줄에는 네 정수로 각 사각형의 대각선으로 마주 보는 두 꼭짓점의 x, y좌표가 주어진다.
<출력값>
첫째 줄에 선택한 사각형의 개수 C를 출력한다. 다음 C개의 줄에는 선택한 사각형의 번호를 오름차순으로 출력한다. 만약 덮을 수 없다면 C=0을 출력한다.

<문제 2280>
[0, 1]×[0, 1]의 정사각형과 그 안(정사각형의 테두리 및 꼭짓점 포함)에 N개의 점들 P[1], P[2], …, P[N]이 있다. 이 점들과 정사각형의 네 꼭짓점을 연결하여 임의의 두 점이 직접 혹은 간접적으로 연결되어 있게 하려 한다. 이와 같이 만든 그래프의 간선의 길이를 합한 것을 Len(P) 라고 정의하자.
N개의 점들의 위치를 임의로 바꾸면 Len(P)의 값도 이에 따라 변하게 된다. Len(P)가 최소가 되도록 하는 점들의 집합을 P'라고 하자. 즉, Len을 점들의 집합 P에 대한 함수로 생각했을 때, Len의 최솟값이 Len(P')가 되는 것이다.
N개의 점들을 잘 배치하여 Len이 최소가 되도록 할 때, 각각의 점들을 이동시킨 거리가 최소가 되도록 하는 프로그램을 작성하시오.
즉, Len(P'')=Len(P')를 만족하는 P''들 중에서, |P[1]-P''[1]|+|P[2]-P''[2]|+…+|P[N]-P''[N]|이 최소가 될 때, 그 최솟값을 구하는 것이다.
<입력값>
입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스의 첫째 줄에 N(1≤N≤100)이 주어진다. 다음 N개의 줄에는 각 점의 x, y 좌표가 주어진다. N이 0인 경우에 프로그램을 종료한다.
<출력값>
각 테스트 케이스마다 답을 출력한다. 절대/상대 오차는 10-3까지 허용한다.

<문제 2281>
사악한 라이토는 기발한 방법을 이용하여 L(애칭 섊)을 살해한 뒤 데스노트를 다시 손에 넣었다. 라이토는 이제 이 노트에 n명의 이름을 적어 넣으려고 한다. 이때 다음과 같은 조건을 만족시키면서 이름을 적어 넣으려 한다.
우선, 이름을 적어 넣을 때 이미 정해진 순서대로 n명의 이름을 적어 넣어야 한다. 이름을 적을 때도, 노트를 위에서 아래로, 같은 줄에서는 왼쪽 맨 끝에서 오른쪽으로 차례로 적는다고 하자. 또한 이름을 적을 때 각 사람의 이름 사이에 빈 칸을 하나씩 두려고 한다. 한 줄을 적다가 그 줄의 끝에 한 사람의 이름이 다 들어가지 않고 잘리게 되면 반드시 새로운 줄에 이름을 써야 한다. 그렇지 않으면 이름이 중간에 잘려서 자칫하면 두 명의 사람이 죽게 된다. 이때, 각 줄의 끝에 사용하지 않고 남게 되는 칸의 수의 제곱의 합이 최소가 되도록 하려 한다. 이를 계산할 때 제일 마지막 줄은 앞으로 이름을 적을 기회가 있으므로 계산하지 않는다. 예를 들어 노트의 폭(너비)이 20인 다음의 경우를 보자.

각 사람의 이름의 길이가 차례로 7, 4, 2, 3, 2, 5, 1, 12, 7, 5, 6 인 경우이다. 위와 같이 적으면 차례로 1, 10, 0칸이 남아서 제곱의 합이 101이 된다. 반면에 아래의 경우에는 5, 6, 0칸이 남아서 제곱의 합이 61이 된다.
<입력값>
첫째 줄에 n(1 ≤ n ≤ 1,000), m(1 ≤ m ≤ 1,000)이 주어진다. m은 노트의 가로 칸의 개수(폭, 너비)이다. 다음 n개의 줄에는 각 사람의 이름의 길이가 노트에 적어야 할 순서대로 주어진다. 각 길이는 m을 넘지 않는 자연수이다.
<출력값>
첫째 줄에 남게 되는 칸 수의 제곱의 합의 최솟값을 출력한다.

<문제 2282>
N개의 점들로 이루어진 산맥이 있다. 편의상 각각의 점들의 x좌표는 모두 다르다고 가정하자. 이 점들을 x좌표가 증가하는 순서로 연결하면 산맥의 모양이 나온다.
때로는 산맥의 모양이 복잡하기 때문에 산맥을 그리는 것이 힘들 때가 있다. 이럴 경우에, 산맥의 양쪽 끝점과 그 사이의 K개의 점, 즉 총 K+2개의 점으로 산맥을 근사시켜 그리려고 한다. 이때, 원래의 산맥과 근사시킨 산맥에서 부분적으로 차이가 나는 부분의 넓이의 합을 최소로 하려 한다.

검은색이 원래 산맥이고 빨간색이 근사시킨 산맥일 때, 회색으로 칠해진 부분의 넓이의 합이 부분적으로 차이가 나는 부분의 넓이의 합이다.
<입력값>
첫째 줄에 n(3≤n≤100), K(0≤K≤n-2)가 주어진다. 다음 n개의 줄에는 산맥의 각 점의 x, y좌표가 주어진다. 각 좌표는 x좌표가 증가하는 순서대로 주어진다. 각 점의 좌표는 500을 넘지 않는 자연수이다.
<출력값>
첫째 줄에 부분적으로 차이가 나는 부분의 넓이의 합의 최솟값을 출력한다. 절대/상대 오차는 10-6까지 허용한다.

<문제 2283>
수직선(數直線) 상에 구간 N개가 있다. 임의의 두 정수 A, B(A < B)를 정하여, 각 구간에서 A와 B 사이에 포함되지 않은 부분을 모두 잘라냈을 때 남는 부분들의 길이의 총합이 K가 되도록 하여라.
<입력값>
1번째 줄에 정수 N, K(1 ≤ N ≤ 1,000, 1 ≤ K ≤ 1,000,000,000)가 주어진다.
2~N+1번째 줄에 각 구간의 왼쪽 끝점과 오른쪽 끝점의 위치가 주어진다. 양 끝점의 위치는 0 이상 1,000,000 이하의 정수이다.
<출력값>
두 정수 A, B를 출력한다. 조건을 만족하는 A, B가 존재하지 않으면 “0 0”을 출력한다.
조건을 만족하는 A, B가 여러 개 존재할 때는 A가 가장 작은 경우를 출력한다. 그것도 여러 개 존재할 때는 B가 가장 작은 경우를 출력한다.

<문제 2284>
N개의 우주선이 레이스를 하고 있다. i번째 우주선은 순식간에(0초에) 최대 속도인 V[i]에 도달할 수 있고, 이 속도를 레이스가 끝날 때까지 유지할 수 있다. 또한 각 우주선은 지난 대회의 결과에 따라서 X[i]라는 출발점에서 출발하게 된다. 레이스 장은 무한히 길고 X축에 평행하다. 각각의 우주선은 X축에만 평행하게 움직인다.
이렇게 레이스를 하다 보면 우주선이 다른 우주선을 추월하는 경우도 발생하게 된다. 각각의 우주선은 X[i]좌표와는 별도로 Y, Z 좌표도 가지고 있기 때문에 충돌에 대해서는 생각할 필요가 없다.
경기가 끝날 때까지 발생하는 추월들을 알아내는 프로그램을 작성하시오. 경기는 더 이상 추월이 발생하지 않을 때까지 반복된다. 우선 추월의 회수를 알아내야 하고, 연대순으로 처음 10,000개의 추월이 구체적으로 어떤 추월인지(몇 번이 몇 번을 추월하는지)를 알아내야 한다. 편의상 모든 X[i]가 다르다고 가정하자. 또한, 매 순간에 한 x좌표에는 최대 두 개의 우주선만 있을 수 있다.
<입력값>
첫째 줄에 우주선의 개수 N(1 ≤ N ≤ 250,000)이 주어진다. 다음 N개의 줄에는 차례로 X[1] V[1], X[2] V[2], …, X[N] V[N]이 주어진다. 이때 1 ≤ X[i] ≤ 1,000,000과 1 ≤ V[i] ≤ 99가 만족된다. 편의상 X[1] < X[2] < … < X[N]이 만족된다고 가정하자.
<출력값>
첫째 줄에 추월의 회수를 1,000,000으로 나눈 나머지를 출력한다. 다음 줄들에는 각 추월에 대한 정보를 연대순으로(시간 순으로) 출력한다. 만약 추월 회수가 10,000을 넘어가면 처음의 10,000개만 출력하도록 한다. 각 줄은 두 개의 정수 i, j로 출력하는데, i번 우주선이 j번 우주선을 추월한다는 의미이다. 여러 추월이 동시에 일어나면 추월이 일어나는 위치가 출발점에 가까운(x좌표가 작은) 것을 먼저 출력한다.

<문제 2285>
수직선과 같은 일직선상에 N개의 마을이 위치해 있다. i번째 마을은 X[i]에 위치해 있으며, A[i]명의 사람이 살고 있다.
이 마을들을 위해서 우체국을 하나 세우려고 하는데, 그 위치를 어느 곳으로 할지를 현재 고민 중이다. 고민 끝에 나라에서는 각 사람들까지의 거리의 합이 최소가 되는 위치에 우체국을 세우기로 결정하였다. 우체국을 세울 위치를 구하는 프로그램을 작성하시오.
각 마을까지의 거리의 합이 아니라, 각 사람까지의 거리의 합임에 유의한다.
<입력값>
첫째 줄에 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 N개의 줄에는 X[1] A[1], X[2] A[2], …, X[N] A[N]이 주어진다. 범위는 |X[i]| ≤ 1,000,000,000, 0 ≤ A[i] ≤ 1,000,000,000 이며 모든 입력은 정수이다.
모든 A[i]를 합친 값은 0보다 크다.
<출력값>
첫째 줄에 우체국의 위치를 출력한다. 단, 답이 여러 개일 경우 우체국의 위치가 작은 것을 출력한다.

<문제 2286>
순서가 있는 세 개의 원소 (s1, s2, s3)이 s2-s1=s3-s2 와 s1<s2<s3 을 만족한다면 이것을 선형 수열이라고 부른다. (2, 4 6), (14, 21, 28)과 같은 수열이 그 예이다.
  어떤 자연수 수열의 길이 L (4 <= L <= 13)과 그 수열의 원소가 가질 수 있는 최댓값(상한) M (L < M <= 35)이 주어졌을 때, 선형 수열을 부분 수열(subsequence)로 가지지 않으면서 모든 원소의 범위가 1 이상 M 이하이고 길이가 L인 모든 증가하는 수열을 찾아라.
  당신의 프로그램은 가능한 수열들 중에서 사전순서로 가장 앞에 오는 세 개의 수열을 출력하여야 한다. 가능한 수열의 총 개수가 3보다 작을 때에는 그만큼만 출력한다. 사전순서라는 것은 비교되는 두 수열의 원소를 앞에서부터 차례로 비교해 나가는 것을 뜻한다. ( {1, 2, 4, 5}는 {1, 2, 3, 5}보다 나중에 온다) 마지막 줄에는 가능한 모든 수열의 가짓수를 출력한다.
<입력값>
한 줄에 두 정수 L과 M이 차례로 들어온다.
<출력값>
처음 3개(3개 이하) 줄에 가능한 수열들 중 사전순서로 가장 앞에 오는 3개(3개 이하)의 수열을 출력한다.
  마지막 한 줄에 가능한 모든 수열의 가짓수를 출력한다. 출력되는 수가 32bit integer의 범위 안에 들어오게 하는 입력만 들어온다.

<문제 2287>
몇 개의 숫자 K(K는 1, 2, …, 9중 하나)와 사칙 연산(덧셈, 뺄셈, 곱셈, 나눗셈)만을 사용하여 어떤 자연수 X를 수식으로 표현한 것을 X의 K-표현이라 부른다. 수식에는 괄호가 포함될 수 있으며, 나눗셈은 나눈 몫만을 취한다.
예를 들어 12의 5-표현을 몇 개 써 보면 5+5+(5/5)+(5/5), 55/5+5/5, (55+5)/5 등이 있다. K-표현의 길이를 사용한 K의 개수라 하면, 각각의 길이는 6, 5, 4가 된다.
K가 주어졌을 때, 어떤 자연수의 K-표현 중 가장 짧은 길이를 알아보려 한다.
<입력값>
첫째 줄에 K가 주어진다. 다음 줄에는 표현 식을 찾을 수의 개수 n(1≤n≤1,000)이 주어진다. 다음 줄에는 K-표현 중 가장 짧은 길이를 알아보려 하는 자연수 a(1≤a≤32,000)가 주어진다.
<출력값>
입력되는 순서대로 K-표현의 최소 길이를 n개의 줄에 출력한다. 만약 K-표현의 최소 길이가 8보다 크다면 “NO"를 출력한다.

<문제 2288>
연결된, 무향 그래프 G=(V, E)가 주어졌을 때, V가 정점의 집합을 나타내고, E가 간선의 집합을 나타낸다고 하자. V의 부분집합 S를 G에서 제거했을 때, 그래프가 두 개의 연결 요소로 나눠지면 S를 분리자라고 한다. 그래프에서 정점을 제거하면 제거한 정점에 연결된 간선도 함께 제거된다. 이와 같은 상황을 [S, W, B] 라는 기호로 나타내기로 하자. 이는 그래프가 분리자 S에 의해서 W와 B라는 두 개의 연결 요소로 나뉘어 진다는 의미이다.
우리는 격자 모양의 그래프에서의 분리자를 살펴보려 한다. 이 그래프에서 각각의 격자점이 정점을 이루며, 각각의 정점은 이웃한 8개의 정점들과 연결되어 있다. 아래에 6×6 격자 에 대한 예제 그림이 있다. 흰색은 W, 회색은 S, 검은색은 B를 나타낸다.

문제를 단순화하기 위해, 다음의 조건을 만족하는 분리자만 다루기로 하자.

분리자의 부분집합은 분리자를 이루지 않는다.
분리자는 그래프에서 맨 윗줄의 한 점과 맨 아랫줄의 한 점을 포함한다. 단, 0, 5, 30, 35는 제외한다.
분리자를 따라서 그래프를 위에서 아래로 이동할 때, 내려오다가 다시 올라가는 경우는 없다.

이제 다음의 두 단계를 수행하여 분리자의 크기를 줄이려고 한다.

B에서 몇 개의 정점을 택해서 S에 포함시킨다. 이때 택한 정점들은 반드시 왼쪽 정점으로 S에 포함된 정점을 가지고 있어야 한다.
S에서 몇 개의 정점을 제거하여 W에 포함시킨다. 단, 이전 단계에서 포함시킨 정점들은 제거할 수 없다.

이와 같은 개선 방법을 이용하여 S가 여전히 분리자이도록 하고, 이때 S의 크기를 최소로 하라. 위의 예제는 다음과 같이 하면 S의 크기가 7로 최소가 된다.
<입력값>
입력은 여러 개의 테스트 케이스로 이루어져 있다.
첫째 줄에 격자의 크기를 나타내는 두 정수 N, M(3≤N,M≤200)이 주어진다. 이는 격자의 크기가 N×M이라는 의미이다. 다음 N개의 줄에는 M개의 문자가 주어지는데, 각각은 S, W, B 중의 하나이다. 이는 해당 정점이 S, W, B 중 어느 집합에 속해있는지를 나타낸다. W는 반드시 S의 왼쪽에 존재한다. 잘못된 입력이 주어지지는 않는다고 가정해도 좋다. 모든 문자는 붙어서 입력된다.
입력의 마지막 줄에는 0이 두 개 주어진다.
<출력값>
첫째 줄에 S의 최소 크기를 출력한다.

<문제 2290>
지민이는 새로운 컴퓨터를 샀다. 하지만 새로운 컴퓨터에 사은품으로 온 LC-디스플레이 모니터가 잘 안나오는 것이다. 지민이의 친한 친구인 지환이는 지민이의 새로운 모니터를 위해 테스트 할 수 있는 프로그램을 만들기로 하였다.
<입력값>
첫째 줄에 두 개의 정수 s와 n이 들어온다. (1 ≤ s ≤ 10, 0 ≤ n ≤ 9,999,999,999)이다. n은 LCD 모니터에 나타내야 할 수 이며, s는 크기이다.
<출력값>
길이가 s인 '-'와 '|'를 이용해서 출력해야 한다. 각 숫자는 모두 s+2의 가로와 2s+3의 세로로 이루어 진다. 나머지는 공백으로 채워야 한다. 각 숫자의 사이에는 공백이 한 칸 있어야 한다.

<문제 2291>
N, M, K가 주어질 때, A1 ≤ A2 ≤ ... ≤ AN 이고, A1+A2+...+AN = M을 만족하는 수열 중 사전 순으로 K번째 수열을 출력한다. 모든 Ai는 자연수이다.
예를 들어, N=4, M=9, K=3 이었으면,

1 1 1 6
1 1 2 5
1 1 3 4
1 2 2 4
1 2 3 3
2 2 2 3

총 6개가 가능한데 3번째 수열 1 1 3 4이 정답이다.
<입력값>
첫째 줄에 N, M, K가 주어진다. (1 ≤ N ≤ 10, 1 ≤ M ≤ 220, 1 ≤ K ≤ 2147483647)
<출력값>
합이 M인 길이가 N인 수열 중 K번째 수열을 출력한다. 항상 답이 존재 하는 경우만 입력으로 주어진다.

<문제 2292>
위의 그림과 같이 육각형으로 이루어진 벌집이 있다. 그림에서 보는 바와 같이 중앙의 방 1부터 시작해서 이웃하는 방에 돌아가면서 1씩 증가하는 번호를 주소로 매길 수 있다. 숫자 N이 주어졌을 때, 벌집의 중앙 1에서 N번 방까지 최소 개수의 방을 지나서 갈 때 몇 개의 방을 지나가는지(시작과 끝을 포함하여)를 계산하는 프로그램을 작성하시오. 예를 들면, 13까지는 3개, 58까지는 5개를 지난다.
<입력값>
첫째 줄에 N(1 ≤ N ≤ 1,000,000,000)이 주어진다.
<출력값>
입력으로 주어진 방까지 최소 개수의 방을 지나서 갈 때 몇 개의 방을 지나는지 출력한다.

<문제 2293>
n가지 종류의 동전이 있다. 각각의 동전이 나타내는 가치는 다르다. 이 동전을 적당히 사용해서, 그 가치의 합이 k원이 되도록 하고 싶다. 그 경우의 수를 구하시오. 각각의 동전은 몇 개라도 사용할 수 있다.
사용한 동전의 구성이 같은데, 순서만 다른 것은 같은 경우이다.
<입력값>
첫째 줄에 n, k가 주어진다. (1 ≤ n ≤ 100, 1 ≤ k ≤ 10,000) 다음 n개의 줄에는 각각의 동전의 가치가 주어진다. 동전의 가치는 100,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 경우의 수를 출력한다. 경우의 수는 231보다 작다.

<문제 2294>
n가지 종류의 동전이 있다. 이 동전들을 적당히 사용해서, 그 가치의 합이 k원이 되도록 하고 싶다. 그러면서 동전의 개수가 최소가 되도록 하려고 한다. 각각의 동전은 몇 개라도 사용할 수 있다.
사용한 동전의 구성이 같은데, 순서만 다른 것은 같은 경우이다.
<입력값>
첫째 줄에 n, k가 주어진다. (1 ≤ n ≤ 100, 1 ≤ k ≤ 10,000) 다음 n개의 줄에는 각각의 동전의 가치가 주어진다. 동전의 가치는 100,000보다 작거나 같은 자연수이다. 가치가 같은 동전이 여러 번 주어질 수도 있다.
<출력값>
첫째 줄에 사용한 동전의 최소 개수를 출력한다. 불가능한 경우에는 -1을 출력한다.

<문제 2295>
N(5≤N≤1,000)개의 자연수들로 이루어진 집합 U가 있다. 이 중에서 적당히 세 수를 골랐을 때, 그 세 수의 합 d도 U안에 포함되는 경우가 있을 수 있다. 이러한 경우들 중에서, 가장 큰 d를 찾으라.
예를 들어 {2, 3, 5, 10, 18}와 같은 집합이 있다고 하자. 2+3+5=10이 되고, 이 수는 집합에 포함된다. 하지만 3+5+10=18이 되고, 이 경우가 세 수의 합이 가장 커지는 경우이다.
<입력값>
첫째 줄에 자연수 N이 주어진다. 다음 N개의 줄에 차례로 U의 원소가 하나씩 주어진다. 주어진 U는 집합이 되므로 입력되는 두 수가 같아서는 안 된다. U의 원소는 200,000,000보다 작거나 같은 자연수이다. 답이 항상 존재하는 경우만 입력으로 주어진다.
<출력값>
우리가 x번째 수, y번째 수, z번째 수를 더해서 k번째 수를 만들었다라고 하자. 위의 예제에서 2+3+5=10의 경우는 x, y, z, k가 차례로 1, 2, 3, 4가 되며, 최적해의 경우는 2, 3, 4, 5가 된다. k번째 수가 최대가 되도록 하는 것이 목적이다. x, y, z, k가 서로 같아도 된다. 이때, k번째 수를 출력하면 된다.

<문제 2296>
한 도시에 건물들을 지으려고 한다. 각각의 건물들을 지었을 경우의 이익이 있는데, 최대한 많은 이익을 얻기 위해 건물을 지으려고 한다. 어떤 좌표에 건물을 지었을 때, 이 점을 기준으로 평면을 네 구간으로 나눌 수 있다. 쉽게 생각하면 좌표평면상에서 제 1, 2, 3, 4 사분면을 생각하면 된다. 아래 그림이 각 구간과 구간의 번호이다.

위의 그림에서 가운데에 건물을 지은 경우이고, 각각의 번호가 이 건물을 기준으로 한 구간의 번호를 나타낸다.
도시의 미관을 생각해 보았을 때, 한 건물의 구간 1과 구간 2에 건물이 있는 경우나 1, 4에 있는 경우, 2, 3에 있는 경우, 3, 4에 있는 경우는 아름답지 않다. 즉, 1, 3 구간에 있거나 2, 4 구간에 있어야 한다.
이와 같은 조건을 만족하면서 건물들을 지었을 때, 가능한 최대의 이익을 계산하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 건물의 개수를 나타내는 자연수 N(1 ≤ N ≤ 1,000)이 주어진다. 다음 N개의 줄에는 건물을 지을 x, y(1 ≤ x, y ≤ 1,000,000,000) 좌표와 그 건물을 지었을 때의 이익 c(1 ≤ c ≤ 50,000)가 주어진다. 서로 다른 두 건물이 같은 x좌표나 같은 y좌표를 가지는 경우는 없다.
<출력값>
첫째 줄에 최대 이익을 출력한다.

<문제 2297>
평면상에 n개의 직각이등변삼각형들이 있을 때, 이 삼각형들이 덮는 면적을 구하는 프로그램을 작성하시오.
직각이등변삼각형은 세 정수 x, y, m(m>0)으로 표현된다. 이는 삼각형의 세 꼭짓점이 (x, y), (x+m, y), (x, y+m)임을 의미한다.
<입력값>
첫째 줄에 정수 n(1≤n≤2,000)이 주어진다. 다음 n개의 줄에는 각 삼각형을 나타내는 x, y, m이 주어진다. x, y는 절댓값이 10,000,000을 넘지 않으며, m은 1,000이하이다.
<출력값>
첫째 줄에 면적을 출력한다. 면적을 출력할 때는 소숫점 아래 한 자리를 반드시 출력한다.

<문제 2299>
수식을 표현할 때 연산자의 위치에 따라 전위, 중위, 후위로 나뉜다. 전위는 +12, 중위는 1+2, 후위는 12+ 와 같은 수식을 말한다.
한 수식이 주어졌을 때, 이 수식을 전위, 중위, 후위를 마음대로 섞어서 계산했을 때 총 몇 가지 종류의 값이 나올 수 있는지를 계산하는 프로그램을 작성하시오. 예를 들어 +54+-82와 같은 수식은 다음의 두 가지 방법으로 계산할 수 있다.
+54+-82 = 9+-82 = 9+6 = 15
  +54+-82 = +9-82 = +12 = 3
9-4+3과 같은 수식을 계산한 값이 8과 2가 모두 될 수 있음에 유의한다.
<입력값>
첫째 줄에 수식이 공백 없이 주어진다. 공백이 없다는 말은 수식에 사용되는 수가 0부터 9까지의 한 자리 숫자임을 의미한다. 입력되는 수식은 항상 올바른 입력이라고 가정해도 좋다. 입력되는 수식은 80자를 넘지 않는다.
<출력값>
첫째 줄에 경우의 수를 출력한다.

<문제 2300>
KOI 무선통신사는 직선의 통신라인 상에 기지국들을 설치하여 주변의 주요 건물들을 모두 통신범위에 포함 시키고자 한다. 각 기지국의 통신범위는 기지국을 중심으로 하고 밑변이 통신라인과 평행한 정사각형이고, 이 정사각형의 한 변의 길이를 통신폭이라 한다. 기지국들의 총 설치비용은 각 기지국의 통신폭의 합이고, 기지국의 수와는 무관하다. 
평면상에 주요건물들의 위치가 주어졌을 때, 기지국들을 설치하여 모든 주요 건물을 통신범위에 포함하는 최소의 총 설치비용을 구하는 프로그램을 작성하시오. 통신라인은 x-축과 일치하고 건물들의 위치좌표는 정수이다. 통신라인 상에는 건물이 위치하지 않으며, 모든 건물들의 위치는 서로 다르다.
다음 그림의 예를 보면, 첫 번째 기지국의 위치는 (-2, 0) 이고, 통신폭이 4인 정사각형의 통신범위로 세 개의 건물을 포함한다. 두 번째 기지국의 위치는 (2, 0)이고, 통신폭이 2인 정사각형의 통신범위로 두 개의 건물을 포함한다. 세 번째 기지국의 위치는 (6.5, 0) 이고, 통신폭이 3인 정사각형의 통신범위로 두 개의 건물을 포함한다.
<입력값>
첫째 줄에는 건물의 개수 N이 주어지고 (1 ≤ N ≤ 10,000), 그 다음 N개의 줄에는 한 줄에 한 건물의 x-좌표와 y-좌표가 빈 칸을 사이에 두고 차례로 주어진다. x-좌표와 y-좌표는 절댓값이 1,000,000 이하인 정수이다.
<출력값>
최소의 총 설치비용(기지국의 통신범위를 나타내는 통신폭의 총합)을 첫째 줄에 출력한다.

<문제 2301>
해리포터는 마법의 성의 방들에 있는 보물들을 최대한 많이 가져올 계획을 세우고 있다. 마법의 성에는 일렬로 되어있는 N = 2m개의 방이 있으며, 모든 방에는 보물이 하나씩 존재한다. 이 방들에는 문이 없고 출입하기 위해서는 마법 구슬을 이용하는 길밖에 없다.
해리포터에게는 N+1개의 마법 구슬이 있는데, IN으로 표시되는 마법 구슬과 A1, A2, ..., AN-1으로 표시되는 N-1개의 마법 구슬과 OUT으로 표시되는 마법 구슬이 있다. 각 마법 구슬들은 다음과 같은 특징을 가진다.

마법 구슬 IN은 항상 제일 먼저 사용해야 하는 구슬이며, 해리포터를 N개의 방들 중 임의의 어느 한 방에 처음으로 들어가게 한다. (단, 어느 방에 들어가게 될지는 미리 알 수 없지만, 들어간 다음에는 그 방의 번호를 알 수 있다.)
마법 구슬 Ak(1 ≤ k ≤ N-1)는 임의의 방에 있는 해리포터를 왼쪽 또는 오른쪽으로 k 만큼 떨어진 방안으로 이동하게 한다. 왼쪽으로 이동할지 오른쪽으로 이동할지는 해리포터가 지정할 수 있다.
마법 구슬 OUT은 제일 마지막에 사용해야 하는 구슬이며, 해리포터를 마법의 성에 있는 방으로부터 탈출하게 한다.
모든 마법 구슬 IN, Ak(1 ≤ k ≤ N-1), 및 OUT은 한 개씩만 주어져 있고, 한번 사용하고 나면 없어져서 다시 사용할 수 없다.

예를 들어, N=4인 경우에 IN, A1, A2, A3, 및 OUT의 총 5개의 마법 구슬들이 해리포터에게 주어져 있고, IN을 사용했더니 3번방에 들어가게 되었다고 하자.

이때, 그는 다음과 같은 방법으로 마법 구슬을 이용하여 방들에 있는 4개의 보물을 찾아 가져올 수 있다.

A1을 사용하여 2번 방으로 간다.
A2를 사용하여 4번 방으로 간다.
A3를 사용하여 1번 방으로 간다.
OUT을 사용하여 탈출한다. 

또 다른 예로, N=4인 경우에 IN을 이용했더니 1번방에 들어가게 되었다고 하자.

이때는 다음의 방법으로 방들에 있는 4개의 보물을 찾아 가져올 수 있다.

A3를 사용하여 4번 방으로 간다.
A2를 사용하여 2번 방으로 간다.
A1을 사용하여 3번 방으로 간다.
OUT을 사용하여 탈출한다. 

마법의 성에 있는 방들의 개수 N과 해리포터가 IN을 사용하여 들어간 방의 위치가 주어졌을 때, 그가 마법 구슬 A1, ⋯,AN-1및 OUT을 이용해서 방들에 있는 보물을 최대한 많이 찾아 가져오기 위하여 들어간 방의 순서를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 방의 개수를 나타내는 정수 N (단, 21 ≤ N ≤ 213=8192)이 주어진다. N은 2의 거듭제곱인 정수이다. 둘째 줄에는 해리 포터가 IN을 사용해 들어간 방의 번호를 나타내는 정수 M이 주어진다. (단, 1 ≤ M ≤ N)
<출력값>
해리 포터가 처음 들어간 방에서 시작하여, 방들에 있는 보물을 최대한 많이 찾아오기 위하여 들어간 방 번호들을 순서대로 한 줄에 출력한다. 각 방 번호사이에는 빈칸을 한개 둔다. 답이 여러 개인 경우에는 그 중 하나만 출력한다.

<문제 2302>
어떤 극장의 좌석은 한 줄로 되어 있으며 왼쪽부터 차례대로 1번부터 N번까지 번호가 매겨져 있다. 공연을 보러 온 사람들은 자기의 입장권에 표시되어 있는 좌석에 앉아야 한다. 예를 들어서, 입장권에 5번이 쓰여 있으면 5번 좌석에 앉아야 한다. 단, 자기의 바로 왼쪽 좌석 또는 바로 오른쪽 좌석으로는 자리를 옮길 수 있다. 예를 들어서, 7번 입장권을 가진 사람은 7번 좌석은 물론이고, 6번 좌석이나 8번 좌석에도 앉을 수 있다. 그러나 5번 좌석이나 9번 좌석에는 앉을 수 없다.
그런데 이 극장에는 “VIP 회원”들이 있다. 이 사람들은 반드시 자기 좌석에만 앉아야 하며 옆 좌석으로 자리를 옮길 수 없다.
오늘 공연은 입장권이 매진되어 1번 좌석부터 N번 좌석까지 모든 좌석이 다 팔렸다. VIP 회원들의 좌석 번호들이 주어졌을 때, 사람들이 좌석에 앉는 서로 다른 방법의 가짓수를 구하는 프로그램을 작성하시오.
예를 들어서, 그림과 같이 좌석이 9개이고, 4번 좌석과 7번 좌석이 VIP석인 경우에 <123456789>는 물론 가능한 배치이다. 또한 <213465789> 와 <132465798> 도 가능한 배치이다. 그러나 <312456789> 와 <123546789> 는 허용되지 않는 배치 방법이다.
<입력값>
첫째 줄에는 좌석의 개수 N이 입력된다. N은 1 이상 40 이하이다. 둘째 줄에는 고정석의 개수 M이 입력된다. M은 0 이상 N 이하이다. 다음 M 개의 줄에는 고정석의 번호가 작은 수부터 큰 수의 순서로 한 줄에 하나씩 입력된다.
<출력값>
주어진 조건을 만족하면서 사람들이 좌석에 앉을 수 있는 방법의 가짓수를 출력한다. 방법의 가짓수는 2,000,000,000을 넘지 않는다. (2,000,000,000 < 231-1)

<문제 2303>
N명이 모여 숫자 게임을 하고자 한다. 각 사람에게는 1부터 10사이의 수가 적혀진 다섯 장의 카드가 주어진다. 그 중 세 장의 카드를 골라 합을 구한 후 일의 자리 수가 가장 큰 사람이 게임을 이기게 된다. 세 장의 카드가 (7, 8, 10)인 경우에는 합은 7+8+10 = 25가 되고 일의 자리 수는 5가 된다. 어떤 사람이 받은 카드가 (7, 5, 5, 4, 9)인 경우 (7, 4, 9)를 선택하면 합이 20이 되어 일의 자리 수는 0이 되고, (5, 5, 9)를 선택하면 합이 19가 되어 일의 자리 수는 9가 된다. 게임을 이기기 위해서는 세 장의 카드를 선택할 때 그 합의 일의 자리 수가 가장 크게 되도록 선택하여야 한다.
예를 들어, N=3일 때

1번 사람이 (7, 5, 5, 4, 9),
2번 사람이 (1, 1, 1, 1, 1),
3번 사람이 (2, 3, 3, 2, 10)의 

카드들을 받았을 경우, 세 수의 합에서 일의 자리 수가 가장 크게 되도록 세 수를 선택하면

1번 사람은 (5, 5, 9)에서 9,
2번 사람은 (1, 1, 1)에서 3,
3번 사람은 (2, 3, 3)에서 8의

결과를 각각 얻을 수 있으므로 첫 번째 사람이 이 게임을 이기게 된다.
N명에게 각각 다섯 장의 카드가 주어졌을 때, 세 장의 카드를 골라 합을 구한 후 일의 자리 수가 가장 큰 사람을 찾는 프로그램을 작성하시오. 가장 큰 수를 갖는 사람이 두 명 이상일 경우에는 번호가 가장 큰 사람의 번호를 출력한다.
<입력값>
첫 줄에는 사람의 수를 나타내는 정수 N이 주어진다. N은 2이상 1,000이하이다. 그 다음 N 줄에는 1번부터 N번까지 각 사람이 가진 카드가 주어지는 데, 각 줄에는 1부터 10사이의 정수가 다섯 개씩 주어진다. 각 정수 사이에는 한 개의 빈칸이 있다.
<출력값>
게임에서 이긴 사람의 번호를 첫 번째 줄에 출력한다. 이긴 사람이 두 명 이상일 경우에는 번호가 가장 큰 사람의 번호를 출력한다.

<문제 2304>
N 개의 막대 기둥이 일렬로 세워져 있다. 기둥들의 폭은 모두 1 m이며 높이는 다를 수 있다. 이 기둥들을 이용하여 양철로 된 창고를 제작하려고 한다. 창고에는 모든 기둥이 들어간다. 이 창고의 지붕을 다음과 같이 만든다.

지붕은 수평 부분과 수직 부분으로 구성되며, 모두 연결되어야 한다.
지붕의 수평 부분은 반드시 어떤 기둥의 윗면과 닿아야 한다.
지붕의 수직 부분은 반드시 어떤 기둥의 옆면과 닿아야 한다.
지붕의 가장자리는 땅에 닿아야 한다.
비가 올 때 물이 고이지 않도록 지붕의 어떤 부분도 오목하게 들어간 부분이 없어야 한다.

그림 1은 창고를 옆에서 본 모습을 그린 것이다. 이 그림에서 굵은 선으로 표시된 부분이 지붕에 해당되고, 지붕과 땅으로 둘러싸인 다각형이 창고를 옆에서 본 모습이다. 이 다각형을 창고 다각형이라고 하자.

그림1 . 기둥과 지붕(굵은 선)의 예
창고 주인은 창고 다각형의 면적이 가장 작은 창고를 만들기를 원한다. 그림 1에서 창고 다각형의 면적은 98 ㎡이고, 이 경우가 가장 작은 창고 다각형이다.
기둥들의 위치와 높이가 주어질 때, 가장 작은 창고 다각형의 면적을 구하는 프로그램을 작성하시오.
<입력값>
첫 줄에는 기둥의 개수를 나타내는 정수 N이 주어진다. N은 1 이상 1,000 이하이다. 그 다음 N 개의 줄에는 각 줄에 각 기둥의 왼쪽 면의 위치를 나타내는 정수 L과 높이를 나타내는 정수 H가 한 개의 빈 칸을 사이에 두고 주어진다. L과 H는 둘 다 1 이상 1,000 이하이다.
<출력값>
첫 줄에 창고 다각형의 면적을 나타내는 정수를 출력한다.

<문제 2305>
어떤 극장의 자리는 한 줄로 배치되어 있고 자리번호는 왼쪽부터 1에서 N까지 차례대로 매겨져 있다. 이 N개의 자리 중에서 N-1개의 자리는 지정석으로 모두 판매하고, 어떤 한 자리만 자유석으로 비워둔다. 지정석 표를 산 사람들은 아래 규칙에 따라서만 앉을 수 있다.
규칙) 사람들은 구입한 지정석 표에 적힌 번호의 자리에 앉든지, 그 자리의 바로 왼쪽이나 오른쪽의 인접한 자리에 앉든지,  또는 자유석에 앉을 수 있다.
예를 들어 설명해보자. 4개의 자리가 있는 극장의 경우, 아래 그림1과 같이 1, 2, 4번 자리는 지정석으로 판매되었고, 3번 자리는 자유석(회색으로 표시)으로 지정되었다.

아래 그림에서 ⓘ는 지정석 표의 번호가 i인 사람을 나타낸다. 그림2의 (a), (b), (c), (d)는 위의 규칙을 만족하는 자리배치의 예이다.

다음 4가지 경우는 위의 규칙을 만족하지 않는 자리배치의 예이다.

그림3(a)는 4번 좌석표를 받은 사람이 자리에 앉지 않았기 때문에 규칙에 어긋난 자리배치이다. 그림3 (b), (c), (d)의 경우에는 1번 혹은 4번 좌석표를 받은 사람이 원래 자리에서 2칸 이상 떨어진 자리에 앉아서 규칙에 어긋난 경우이다.
문제는 전체 자리의 수 N이 주어지고, 자유석 번호 K가 주어져 있을 때, 앞서 말한 규칙을 만족하며 배치할 수 있는 모든 경우의 수를 출력하는 것이다.
<입력값>
첫 줄에는 자리의 수 N (3 ≤ N ≤ 40)이, 그 다음 줄에는 자유석의 번호 (1 ≤ K ≤ N)가 주어진다.
<출력값>
앞서 설명한 규칙을 만족시키며 자리 배치를 할 수 있는 모든 경우의 수를 첫 줄에 출력한다. 이 값은 231-1 이하의 정수이다.

<문제 2306>
DNA 서열은 4개의 문자 {a,c,g,t} 로 이루어진 문자열이다. DNA 서열에는 생명의 신비를 풀 수 있는 많은 정보가 들어 있다. 특히 KOI 유전자의 길이는 사람의 키와 깊은 상관 관계가 있다는 것이 알려져 있다. 이러한 KOI 유전자는 다음의 조건을 만족한다.

at 와 gc 는 가장 짧은 길이의 KOI 유전자이다.
어떤 X가 KOI 유전자라면, aXt와 gXc도 KOI 유전자이다. 예를 들어, agct 와 gaattc는 KOI 유전자이나, tgca 와 cgattc는 KOI 유전자가 아니다.
어떤 X와 Y가 KOI 유전자라면, 이 둘을 연결한 XY도 KOI 유전자이다. 예를 들면, aattgc 또는 atat는 KOI 유전자이나 atcg 또는 tata는 KOI 유전자가 아니다.

KOI 유전자는 DNA 서열 중에서 부분 서열로 구성되어 있다. 부분 서열이란 주어진 서열에서 임의의 위치에 있는 0개 이상의 문자들을 삭제해서 얻어지는 서열이다. 예를 들면, DNA 서열 acattgatcg에서 두 번째 문자 c와 마지막 문자 g를 삭제하여 생긴 부분 서열 aattgatc는 길이가 8인 KOI 유전자이다. 그러나 마지막 문자 g를 삭제하여 만들어진 부분 서열 acattgatc는 KOI 유전자가 아니다.
문제는 주어진 DNA 서열의 부분 서열들 중에서 길이가 최대가 되는 KOI 유전자를 찾아 그 길이를 출력하는 것이다.
<입력값>
첫째 줄에는 분석하고자 하는 DNA 서열이 주어진다. DNA 서열의 길이는 최대 500이다.
<출력값>
입력 DNA 서열로부터 계산된 가장 긴 KOI 유전자의 길이를 첫 번째 줄에 출력한다. 단, KOI 유전자가 없는 경우에는 0을 출력한다.

<문제 2307>
그림 1은 어떤 도시의 주요 지점과 그 지점들 간의 이동시간을 나타낸 그래프이다. 그래프의 노드는 주요 지점을 나타내고  두 지점을 연결한 도로(에지)에 표시된 수는 그 도로로 이동할 때 걸리는 분 단위의 시간을 나타낸다. 두 지점 a와 b를 연결하는 도로는 도로(a,b)로 표시한다.

예를 들어 도로(1,2)와 도로(2,3)를 통하여 지점1에서 지점3으로 갈 때 걸리는 시간은 3분이다. 도로는 모두 양방향이라고 가정하므로 도로(a,b)와 도로(b,a)를 지날 때 걸리는 시간은 항상 같다고 한다.
오세준은 입력 데이터에 표시된 도시로 진입하여 이 도시를 가장 빠른 시간 내에 빠져나가고자 한다. 그런데 이 사실을 알고 있는 류원룡이 어떤 하나의 도로(에지)를 선택하여 이 도로에서 검문을 하려고 한다. 따라서 오세준은 이 도로를 피해서 가장 빠르게 도시를 탈출하고자 한다. 이 경우 류원룡이 검문을 위하여 선택하는 도로에 따라서 오세준의 가장 빠른 탈출시간은 검문이 없을 때에 비하여 더 늘어날 수 있다.
문제는 도로검문을 통하여 얻을 수 있는 탈출의 최대 지연시간을 계산하는 것이다. 추가설명은 다음과 같다.

두 개의 지점을 직접 연결하는 도로가 있는 경우, 그 도로는 유일하다. 
도시의 지점(노드)은 1에서 N번까지  N개의 연속된 정수로 표시된다.
오세준이 도시에 진입하는 지점은  항상 1번이고 도시를 빠져 나가기 위하여 최종적으로 도달해야하는 지점은 항상 N번 지점이다.
오세준은 검문을 피해서 가장  빨리 도시를 빠져나가고자 하고, 류원룡은 적절한 도로를 선택하여 이 오세준들의 탈출시간을 최대한 지연시키고자 한다.
각 도시 지점 간을 이동하는 시간은 항상 양의 정수이다.

입력 도시의 도로망에 따라서 류원룡이 어떤 도로를 막으면 오세준은 도시를 탈출하지 못할 수도 있다. 이 경우 검문으로 인하여 지연시킬 수 있는 탈출시간은 무한대이다. 이 경우에는 -1을 출력해야 한다.
그림 1에서 볼 때 검문이 없을 경우 오세준이 도시를 탈출하는데 걸리는 시간은 4분이다. 만일 류원룡이 도로(4,3)을 막으면 그 탈출시간을 지연시킬 수 없으므로 지연시간은 0이다. 만일 도로(2,3)을 막으면, 오세준들이 가장 빠르게 탈출할 수 있는 시간은 5분이므로 탈출지연시간은 1분이고, 도로(3,6)을 막으면 탈출지연시간은 2분이다.
여러분은 입력 데이터에 표시된 도로망을 읽고, 류원룡이 한 도로를 막고 검문함으로써 지연시킬 수 있는 최대시간을 정수로 출력하여야한다. 만일 지연효과가 없으면 0을 출력해야하고, 도시를 빠져나가지 못하게 만들 수 있으면(지연시간이 무한대) -1을 출력해야 한다.
<입력값>
첫 줄에는 지점의 수를 나타내는 정수  N(6 ≤ N ≤ 1000)과 도로의 수 M(6 ≤ M ≤ 5000)이 주어진다. 그 다음 이어 나오는 M개의 각 줄에는 도로(a, b)와 그 통과시간 t가 a b t 로 표시된다. 단 이 경우 a < b 이고 1 ≤ t ≤ 10000이다.
<출력값>
경찰이 하나의 도로를 막음으로써 지연시킬 수 있는 최대 시간을 정수로 출력한다. (단, 그 지연시간이 무한대이면 -1을 출력해야 한다.)

<문제 2309>
왕비를 피해 일곱 난쟁이들과 함께 평화롭게 생활하고 있던 백설공주에게 위기가 찾아왔다. 일과를 마치고 돌아온 난쟁이가 일곱 명이 아닌 아홉 명이었던 것이다.
아홉 명의 난쟁이는 모두 자신이 "백설 공주와 일곱 난쟁이"의 주인공이라고 주장했다. 뛰어난 수학적 직관력을 가지고 있던 백설공주는, 다행스럽게도 일곱 난쟁이의 키의 합이 100이 됨을 기억해 냈다.
아홉 난쟁이의 키가 주어졌을 때, 백설공주를 도와 일곱 난쟁이를 찾는 프로그램을 작성하시오.
<입력값>
아홉 개의 줄에 걸쳐 난쟁이들의 키가 주어진다. 주어지는 키는 100을 넘지 않는 자연수이며, 아홉 난쟁이의 키는 모두 다르며, 가능한 정답이 여러 가지인 경우에는 아무거나 출력한다.
<출력값>
일곱 난쟁이의 키를 오름차순으로 출력한다. 일곱 난쟁이를 찾을 수 없는 경우는 없다.

<문제 2310>
어드벤처 게임을 하던 중, 1부터 n까지의 번호가 붙은 방을 지나가야 하는 마법의 미로를 마주쳤다. 각 방 안에는 번호가 붙은 문이 있을 수 있고, 각 문은 해당하는 번호의 방으로 통한다. 방 안에는 레프리콘이나 트롤이 있을 수도 있다.
레프리콘이 있는 방에 들어가면 레프리콘은 모험가의 소지금이 일정 양 이하로 떨어지지 않게 채워준다. 레프리콘은 모험가의 소지금이 일정량 미만일 때에는 그만한 양이 되도록 금화를 채워주고, 소지금이 일정량 이상일 때에는 그대로 둔다. 트롤이 있는 방에 들어가려면 일정량의 통행료를 지불해야 한다. 이는 맨 처음에 모험가가 1번 방에서 시작하려 할 때에도 마찬가지이다.
모험가는 소지금이 0인 상태에서 출발한다. 과연 모험가는 1번 방에서 출발해서 n번 방에 도착할 수 있을까?
<입력값>
입력은 여러 개의 미로로 주어진다. 각 미로의 첫 줄에는 미로의 방 수를 나타내는 정수 n(1 ≤ n ≤ 1000)이 주어진다. 다음 n 줄에는 각 방의 정보가 주어진다. 각 방의 정보는 방의 내용물을 나타내는 알파벳 하나(E: 빈 방, L: 레프리콘, T: 트롤)와 그 방의 레프리콘이나 트롤이 정해놓은 금액(빈 방일 경우 0이고, 금액은 500보다 작거나 같은 자연수), 그리고 그 방에서 다른 방으로 갈 수 있는 문의 번호들로 이루어진다. 각 줄은 0으로 끝난다. 미로의 방 수가 0개인 입력이 들어오면 입력을 종료한다.
<출력값>
출력은 각 미로마다 한 줄씩으로 이루어진다. 각 줄에는 1번 방에서 n번 방까지 갈 수 있는지를 "Yes" 또는 "No"로 출력한다.

<문제 2311>
N개의 나라가 있고, 이들 중 몇 개의 나라들은 서로 도로로 연결되어 있다. 편의상 N개의 나라들은 각각 1, 2, ..., N의 번호가 붙어 있다고 하자. i번 나라와 j번 나라가 도로로 연결되어 있으면 i번 나라에서 j번 나라로 이동할 수 있고, j번 나라에서 i번 나라로도 이동할 수 있다. 당신은 1번 나라에 살고 있다.
여름을 맞이하여 당신은 N번 나라로 왕복 여행을 다녀오려고 한다. 즉 1번 나라에서 N번 나라로 갔다가 다시 1번 나라로 돌아오고자 한다. 아쉽게도 각 도로의 이용권이 한 장씩밖에 주어져 있지 않아서, 한 번 지난 도로는 다시 지날 수 없다고 한다. 이때, 여행에 소요되는 최소 시간을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 나라의 개수 N과 도로의 개수 M이 주어진다. (3 ≤ N ≤ 1,000, 2 ≤ M ≤ 10,000) 둘째 줄부터 M개의 줄에 걸쳐 각 도로를 나타내는 세 자연수 A, B, C가 주어진다. 이는 A번 나라와 B번 나라가 도로로 연결되어 있으며, 이 도로를 지날 때 걸리는 시간이 C임을 의미한다. (1 ≤ A ≤ N, 1 ≤ B ≤ N, 1 ≤ C ≤ 50,000) 두 나라 사이에 두 개 이상의 도로가 있는 경우는 없다고 가정한다. 항상 왕복할 수 있는 경우만 입력으로 주어진다.
<출력값>
첫째 줄에 여행에 소요되는 최소 시간을 출력한다.

<문제 2312>
양의 정수 N이 주어졌을 때, 이 수를 소인수분해 한 결과를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 테스트 케이스의 수가 주어진다. 각 테스트 케이스마다 양의 정수 N (2 ≤ N ≤ 100,000)이 주어진다.
<출력값>
각 테스트 케이스마다 각 인수와 그 인수가 곱해진 횟수를 한 줄씩 출력한다. 출력 순서는 인수가 증가하는 순으로 한다.

<문제 2313>
보석 가게에 여러 가지의 보석이 진열되어 있다. 각각의 보석은 정수로 표현되는 가치가 있다. 때로는 저주받은 보석이 있기 때문에 가치가 음수가 될 수도 있다.
보석들은 총 n개의 줄에 나열되어 있다. 이제 당신은 각각의 줄에서 몇 개의 보석을 구매하려 한다. 이때, 각 줄에서 보석을 구매할 때 연속적인 보석들을 구매해야 한다. 즉, 어느 한 줄에서 1, 2번 보석을 구매할 수도 있고, 2, 3번 보석을 구매할 수도 있지만, 1, 3번 보석을 구매할 수는 없다.
구매하는 보석의 가치의 총 합이 최대가 되도록 보석을 구매하는 방법을 찾아내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 정수 n(1 ≤ n ≤ 1,000)이 주어진다. 다음 2×n개의 줄에는 n개의 줄에 나열된 보석들에 대한 정보가 주어진다. 먼저 각 줄에 나열된 보석의 개수 L(1 ≤ L ≤ 1,000)이 주어지고, 그 다음 줄에 L개의 정수들이 주어진다. 각 정수는 각 보석의 가치를 나타낸다. 보석의 가치는 절댓값이 10,000보다 작거나 같은 정수이다.
<출력값>
첫째 줄에 보석의 가치의 총 합의 최댓값을 출력한다. 다음 n개의 줄에는, 줄에서 몇 번째 보석부터 몇 번째 보석까지를 구매했는지를 출력한다.
만약 최대가 되는 경우가 여럿이면, 구매한 보석들의 총 개수가 최소가 되는 방법을 출력한다. 이와 같은 경우도 여럿이라면, 출력한 n×2개의 수들을 하나의 수열로 생각하여, 사전식으로 가장 앞에 오는 경우를 출력한다.

<문제 2314>
트럭 운전사 택희는 오랜 기간 동안의 공로를 인정받아 이세계로 소환되었다. 택희가 소환된 이세계에는 천사 종족 Portableangel과 악마 종족 Legnaelbatrop이 살고 있었다. 택희는 뛰어난 알고리즘 지식을 발휘해 얼마 지나지 않아 두 종족을 모두 지배하는 이세계의 왕이 되었다.
폭군 택희는 지루해지면 이세계의 주민들을 이용해 게임을 한다. 먼저 종족과 무관하게 16명의 개체를 모아서 4×4 격자 형태로 세워 놓는다. 그 다음 각 자리에 어떤 종족이 서야 하는지를 지정해 주고, 그에 맞게 다시 서도록 명령한다. 그러면 이들은 서로 자리를 바꿔서 택희가 원하는 배치를 만들어야 한다. 자리를 바꿀 때는 상하좌우로 인접한 두 개체끼리만 바꿀 수 있으며, 한 개체가 여러 번 자리를 바꿀 수도 있다.
현재 주민들의 배치와 택희가 원하는 배치가 주어질 때, 최소 몇 번의 자리 바꿈이 필요한지 구하여라.
<입력값>
'P' 또는 'L'을 값으로 갖는 4×4 행렬이 공백 없이 주어진다. 이는 현재 주민들의 배치를 나타내며, 'P'는 Portableangel, 'L'은 Legnaelbatrop 종족을 뜻한다.
그 다음 빈 줄이 0개 이상 주어진 뒤 택희가 원하는 배치가 같은 방식으로 주어진다. 택희에게는 최소한의 양심이 있기에 불가능한 배치는 주어지지 않는다.
<출력값>
택희가 원하는 배치를 만들기 위해 필요한 최소 자리 바꿈 횟수를 출력한다.

<문제 2315>
연구소에서 “초 울트라 캡쑝 으라차 마징가 Z”(이하 마징가)를 완성했다. 하지만 지구는 이미 태권 V로 인해 평화로운 상태를 유지하고 있기 때문에 마징가는 동네에서 가로등을 끄는 일을 시키기로 했다.
마을의 중심에는 매우 긴 도로가 있는데, 이 도로 변에는 가로등이 세워져 있다. 마징가는 이 가로등을 매일 새벽 5시에 끄기 시작해야 한다. 새벽 5시 정각에 마징가는 정확히 여러 가로등 중에서 어느 한 가로등 바로 밑에 위치하고 있다가 일을 시작한다. 그런데, 가로등에는 일정량의 전력을 소비하는 전구가 달려있고, 우리의 날쌘돌이 마징가는 절약정신이 매우 투철하기 때문에 쓸데없이 전력을 낭비하길 원치 않는다.
그래서 소비전력을 최소화할 수 있도록 가로등을 끄는 순서를 알아내고 싶어 한다. 마징가는 일정하게 1m/sec 의 속도로 움직이며, 가로등을 끈 동안의 시간은 무시해도 된다. 왜냐하면 마징가는 너무 날쌔기 때문에 지나가면서 순식간에 가로등을 끌 수 있기 때문이다.
그렇다면, 절약정신으로 똘똘 뭉쳐진 우리의 날쌘돌이 마징가를 도와줄 수 있는 프로그램을 작성하시오.
가로등의 위치와 그 가로등이 소비하는 전력의 양이 주어져 있을 때, 5시 정각이후에 낭비될 수 있는 전력의 최솟값을 구하면 된다.
<입력값>
첫째 줄에는 2개의 정수 N(1 ≤ N ≤ 1,000), M 이 있다. 첫 번째 정수 N은 가로등의 개수를 나타내는 정수이고, 두 번째 정수 M은 마징가 처음에 위치하는 가로등 번호이다. 다음 N 개의 줄에는 각 가로등에 관한 두 개의 정수가 입력된다. 첫 번째 정수 D(0 ≤ D ≤ 1,000)는 가로등의 위치를 나타내고, 두 번째 정수는 이 가로등의 전력소비량 W(1 ≤ W ≤ 100,000,000)을 나타낸다. 가로등의 위치는 마을이 시작되는 부분부터의 거리를 나타내며, 전력소비량은 1초당 소비되는 전력량을 나타낸다. 그러므로, 어떤 가로등의 전력소비량이 w 이고, 이 가로등이 s 초 동안 켜져 있는 동안에 소비된 전력량은 ws 가 된다. 가로등은 위치를 나타내는 정수 D 의 오름차순으로 입력된다. 같은 줄에 나타나는 정수들 사이에는 하나의 space 가 있다. 가로등 번호는 입력되는 순서대로 1번, 2번, ..., N 번을 부여한다.
단, 낭비되는 전력의 최솟값이 1,000,000,000 보다는 항상 작은 데이터가 입력된다.
<출력값>
첫 줄에 낭비되는 전력의 최솟값을 나타내는 정수를 출력한다.

<문제 2316>
N개의 도시가 P개의 양방향 길로 연결되어 있다. 이석원은 1번 도시와 2번 도시 사이를 오가며 워해머를 한다. 성실한 이석원은 두 도시 사이를 최대한 많이 왔다 갔다 하려 하는데, 이때 한 번 방문했던 도시(1, 2번 도시 제외)를 두 번 이상 방문하지 않으려 한다. 한 번 1번 도시와 2번 도시 사이를 오갈 때, 반드시 한 개 이상의 도시를 중간에 거쳐야 한다. 입력에는 1번 도시와 2번 도시를 연결하는 길은 없다. 도시의 번호는 1번부터 N번까지이다.
<입력값>
첫째 줄에 두 정수 N(3 ≤ N ≤ 400), P(1 ≤ P ≤ 10,000)이 주어진다. 다음 P개의 줄에는 각 길이 연결하는 서로 다른 두 도시의 번호가 주어진다.
<출력값>
첫째 줄에 왔다 갔다 할 수 있는 최대 횟수를 출력한다.

<문제 2317>
오늘은 기쁜 날이다. 개미와 코끼리의 결혼식 날이기 때문이다. 결혼 축하 의식으로 기차놀이를 하기로 했다. 기차놀이란 뒷사람이 앞사람의 어깨에 손을 얹고 한 줄로 마을을 돌아다니는 것이다. 그런데 앞사람과 뒷사람의 키 차이가 많이 나면 기차가 아름다워 보이지 않는다. 아름다움을 중요시 여기는 “앙두레 강”은 기차가 아름답게 보이도록 기차에서 사람들의 순서를 잘 조정하기로 했다.
인접한 앞뒤사람의 키 차이를 모두 더한 것이 최소가 될 때 기차는 가장 아름답게 보인다.
하지만 한 가지 문제가 있다. 결혼식에 사자가족도 참석했는데 사자가족은 서열이 엄격해서 서열이 낮은 사자가 서열이 높은 사자보다 기차에서 앞쪽에 위치하면 안 된다. 이 조건만 만족한다면 결혼식에 참석한 사람들의 순서를 마음대로 바꾸어도 된다.

“앙두레 강”을 도와 결혼 축하 기차를 아름답게 만들어 보도록 하자.
<입력값>
첫 줄에 N(N <= 10000)과 K(K <= N, K <= 1000)가 입력된다. N은 결혼식에 참가한 사람의 수이고 K는 결혼식에 참가한 사자가족의 수이다. 바로 이어서 (우선순위가 높은 사자부터) 사자가족의 키가 K줄에 걸쳐 입력된다. 그리고 그 다음 줄부터 (N-K)줄에 다른 사람들의 키가 입력된다. 모든 입력은 int 범위이다.
<출력값>
기차에서 인접한 앞뒤사람의 키 차이를 모두 더한 값을 출력하시오. 답은 항상 int 범위이다.

<문제 2318>
주식회사 월드에서는 오랫동안 열심히 일을 하면 그에 따라 승진할 수도 있고, 그만큼 많은 급료를 받을 수도 있다.
즉, 어떤 사원의 상사는 적어도 그 사원만큼은 회사에서 근무한 것이고, 그 사원보다 많은 급료를 받는다. 또, 어느 사원의 직속 상사는, 적어도 그 사원만큼 회사에서 근무했고, 그 사원보다 많은 급료를 받는 사람들 중에서 가장 적은 급료를 받는 사람이다.
어느 사원의 직속 상사에게 있어서, 그 사원은 부하가 된다. 어떤 사원의 부하의 부하들도 모두 그 사원의 부하라 하자. 만약에 어느 사원이 누구의 상사도 아니면 그 사원은 부하가 없다.
주식회사 월드의 상사-부하 관계가 위와 같이 정의될 때, 몇몇 사원의 직속 상사와 부하의 수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 두 정수 n(≤30,000), m(≤200)이 주어진다. n은 사원의 수고, m은 우리가 직속 상사와 부하의 수를 알아보려는 사원의 수이다. 다음 n개의 줄에는 각 사원의 정보를 나타내는 세 정수 a, b, c가 주어진다. a(int 범위)는 사원의 ID, b(0≤b≤10,000,000)는 급료, c(1,000,000≤c≤2,500,000)는 근무한 시간(분 단위)을 나타낸다. 다음 m개의 줄에는 직속 상사와 부하의 수를 알아보려는 사원의 ID가 주어진다.
<출력값>
m개의 줄에 입력된 순서대로 해당 사원의 직속 상사의 ID와 부하의 수를 출력한다. 만약 입력으로 주어진 ID가 사장일 경우, 즉 가장 오래 근무하였고 가장 많은 급료를 받는 사원의 ID일 경우에는 직속 상사의 ID 대신에 0을 출력한다(직속 상사가 없으므로).

<문제 2319>
어떤 문자열 S의 길이가 k인 부분문자열의 집합을 T(S, k)라 표현하자. 예를 들어 S="ABABA", k=2일 때, T(S, k)={"AB", "BA"}가 된다. {"AB", "BA", "AB", "BA"}가 아닌 이유는 집합은 같은 원소(중복된 원소)를 허용하지 않기 때문이다.
N 종류의 문자로 이루어진 길이가 k인 문자열들의 집합 X가 주어졌을 때, T(S, k)가 X의 부분집합이 되도록 하는 S의 개수를 구하는 프로그램을 작성하시오. 단 S의 길이는 L이어야 한다.
예를 들어 X={"ABB", "BCA", "BCD", "CAB", "CDD", "DDA"}인 경우에는 "BCABB", "BCDDA"의 두 가지 경우가 있다.
<입력값>
첫째 줄에 N(1≤N≤26), L(1≤L≤100), M(1≤M≤600)이 주어진다. M은 집합 X의 크기이다. 다음 줄에는 X를 이루는 문자열들이 주어진다. 각 문자열들의 길이는 같으며, 10 이하이다. 입력으로는 대문자만 주어진다.
<출력값>
첫째 줄에 S의 개수를 출력한다. 이 값은 32-bit signed integer(VC에서 int)의 범위를 넘지 않는다.

<문제 2320>
백승환와 이석원은 한 팀이 되어 English 끝말대회에 출전했다. 앞단어의 마지막 글자가 뒷단어의 처음 글자와 같도록 단어를 차례대로 늘어놓는 게임 말이다. 단어는 주어지는 사전에 나와 있는 단어만 사용해야 하며 (영혼이 맑아질 만한 사실을 한 가지 가르쳐 주자면) 사전의 단어들은 모두 모음(A, E, I, O, U)으로만 이루어져있다는 것이다. 단어의 시작은 어떤 단어이든지 상관이 없고 같은 단어가 두 번 이상 사용되면 안 되며 게임에 사용된 단어의 길이의 합이 그 팀의 점수가 된다.
점수가 최대가 되도록 끝말잇기 규칙에 맞게 단어를 늘어놓는 프로그램을 만들어 승환이와 석원이를 도와주도록 하자.
<입력값>
첫 줄에 사전에 포함된 단어 개수 N이 입력된다. (N ≤ 16)
두 번째 줄부터 N+1번째 줄까지 사전에 포함된 단어들이 한 줄에 하나씩 입력된다. 단어는 대문자 A, E, I, O, U로만 이루어져 있고 하나의 단어는 그 길이가 100을 넘지 않는다. 같은 단어가 두 번 주어지지 않는다.
<출력값>
한 줄에 단어를 잘 늘어 놨을 때 얻을 수 있는 최대 점수를 출력한다.

<문제 2322>
한 헬스장에 n개의 무게가 서로 다른 아령들이 있다.
헬스장을 사용하는 사람들의 편의를 위해, 아령은 무게가 작은 것부터 무거운 것까지 헬스장에 걸려 있다. 하지만 매일 사람들이 이 아령을 사용한 뒤에 아무 위치에나 걸어놓기 때문에, 하루가 끝나고 나면 아령의 순서들은 뒤섞이기도 한다.
당신은 이제 이 아령들을 원래 순서대로 걸어 놓으려고 한다. 이를 위해서는 이미 걸려있는 아령을 들고, 다른 손으로 다른 아령을 하나 들고, 두 아령의 위치를 바꾸는 작업을 해야 한다. 그리고 이와 같은 작업을 여러 번 반복해야 한다. 아령들이 너무 무겁기 때문에 이와 같은 작업을 한 번 마친 뒤에는 반드시 잠시 휴식을 취해야 한다고 가정하자. 즉, 두 아령의 위치를 바꾸는 작업만을 할 수 있는 것이다. 이와 같은 작업을 할 때 각 아령의 무게만큼의 힘이 든다고 하자.
당신은 가급적이면 적은 힘을 들여서 아령을 원래 순서대로 걸어 놓으려고 한다. 아령이 걸려 있는 순서가 주어졌을 때, 필요한 최소의 힘을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 n(1 ≤ n ≤ 100,000)이 주어진다. 다음 줄에는 걸려 있는 순서대로 아령의 무게가 주어진다. 각 아령의 무게는 230보다 작거나 같은 자연수이며 답이 231-1보다 작거나 같게 되도록 주어진다.
<출력값>
첫째 줄에 필요한 최소의 힘을 출력한다.

<문제 2325>
“앙두레 강”이 개미와 코끼리 결혼식에서 기차를 아름답게 만드는 것을 실패했기 때문에 식장이 아수라장이 되고 결혼이 물거품이 되어버렸다. 급기야는 왕국 간에 분쟁으로 이어져 개미왕국은 코끼리왕국을 공격하기로 결정하였다. 동물나라 지도에서 개미왕국은 1번 정점에 위치해 있고 코끼리왕국은 N번 정점에 위치해 있다. 따라서 개미왕국이 1번 정점에서 N번 정점으로 공격을 하러 가는 상황이다. (개미왕국은 최단거리로 이동을 하게 되고, 코끼리왕국은 움직이지 않는다)
“개미”와 “코끼리”의 앞 글자를 따서 이 전쟁은 “개코전쟁”으로 역사에 기억된다.
“앙두레 강”은 자신 때문에 발생한 이 전쟁을 어떻게든 막으려고 한다. 협상을 할 시간을 벌기 위해 개미왕국이 코끼리왕국에 도착하는 시간을 최대한 늦추려고 한다. 그래서 “앙두레 강”은 사자왕국의 도움을 빌어 도로 중 딱 하나를 파괴하려고 하는데 어느 도로를 파괴해야 개미왕국이 최단거리로 가더라도 그 거리를 최대로 할 수 있을까?
“앙두레 강”를 도와 1번 정점에서 N번 정점으로의 최단거리가 최대가 되도록 도로 하나를 파괴하도록 하자. (어떤 하나의 도로를 파괴하더라도 1번 정점에서 N번 정점으로 도달 가능하다)
<입력값>
첫 줄에 N과 M이 입력된다. N은 정점의 개수이고 M은 도로의 수이다. (1 ≤ N ≤ 1000, 1 ≤ M ≤ N×(N-1)/2)
다음 줄부터 M개의 줄에 도로의 정보가 입력된다.
i+1번째 줄에는 i번째 도로의 정보 xi yi zi가 입력되고 이 도로는 정점 xi와 정점 yi를 잇는 도로이며 지나는데 zi만큼의 시간이 걸린다는 것을 의미한다. 두 정점사이에는 두 개 이상의 길이 존재하지 않고 모든 도로는 양방향이며 한 도로를 파괴하는 것은 양방향의 길 모두를 파괴하는 것이다. (1 ≤ xi, yi ≤ N, 1 ≤ zi ≤ 1000)
<출력값>
적당한 도로하나를 파괴했을 때 1번 정점에서 N번 정점으로의 최단거리의 최댓값을 출력한다.

<문제 2326>
최소 편집 문제는 두 개의 문자열이 주어졌을 때 “삽입(insert)”, “삭제(delete)”, “대체(replace)”의 연산으로 하나의 문자열을 다른 하나의 문자열과 같게 만드는데 사용되는 최소 편집 회수를 구하는 문제이다.
하지만 이렇게 익히 알려진 문제를 또 다시 낼 리가 있겠는가?
그래서 문제에 새로운 편집기술이 하나가 추가되었는데 기존의 편집기술도 포함해서 다시 문제를 정리 해보도록 하자.
예를 들면 X=aabcc, Y=abcca와 같이 두 개의 문자열 X, Y가 주어진다.
이때 문자열 X에 다음의 편집기술을 최소로 사용해서 문자열 X가 문자열 Y와 같아지도록 만들어야 한다.
1. 삽입 : 문자열 X의 어느 위치에라도 원하는 글자 하나를 삽입 할 수 있다.
2. 삭제 : 문자열 X의 어느 글자라도 원하는 한 글자를 삭제 할 수 있다.
3. 대체 : 문자열 X의 어느 글자라도 원하는 한 글자로 대체 할 수 있다.
4. 교환 : 문자열 X의 어느 두 인접한 글자라도 그 위치를 서로 바꿀 수 있다.
문자열 X, Y가 주어지면 위의 네 가지 편집기술을 사용하여 두 개의 문자열을 같게 만드는 최소 편집 회수를 구하시오.
<입력값>
첫 번째 줄에 문자열 X가 주어지고 두 번째 줄에 문자열 Y가 주어진다. 각 문자열의 길이는 1,000 이하이다.
<출력값>
최소 편집 회수를 출력한다.

<문제 2327>
오늘은 즐거운 체육 대회이다. 학생들은 그룹 달리기에 출전할 팀을 선발하려고 한다. 그룹달리기는 말아톤과 같은 형식이다. 모든 팀의 구성원들이 출발지점에서 골인지점을 향해 동시에 출발을 한다. 팀의 성적은 그 팀의 구성원 중 가장 늦게 도착한 사람의 도착시간으로 하기 때문에 구성원 중 달리기 속도가 가장 느린 사람이 가장 빠르게 되도록 팀을 선발해야 한다. 이번 대회에서는 팀을 선발할 때 특별한 제약조건이 하나 있는데 그것은 출전 팀 구성원들의 키를 모두 더했을 때 정확히 H가 되어야 한다는 것이다. 키의 합이 H만 된다면 구성원이 몇 명이 되든 상관이 없다.
학생 중에서 그룹달리기에 출전할 팀을 선발하는 프로그램을 작성하시오.
<입력값>
첫 번째 줄엔 H와 학생 수인 N이 주어진다.(7 ≤ H ≤ 100,000 , 1 ≤ N ≤ 350)
  두 번째 줄부터 학생들의 정보 hi, si가 주어지는데 hi는 i번째 학생의 키이며 si는 i번째 학생의 달리기 속도이다.
<출력값>
출전 팀 구성원 중 가장 느린 사람의 달리기 속도를 출력하시오.

<문제 2328>
해시(hash)란 주어진 데이터를 하나의 수로 표현하는 것을 말한다. 예를 들어서 "1024"와 같은 문자열을 1024 라는 수로 생각하는 방법은 해시의 한 예이다. 또, 영단어에서 'a'부터 'z'까지를 1에서 26까지의 수로 생각하여 그 수들을 합한 것도 해시의 한 예이다. 이런 해시를 적용하면 "ab"와 같은 영단어는 3이라는 수가 되고, "ace"와 같은 영단어는 9라는 수가 된다.
당신은 그래프에 대해서 해시 함수를 하나 설계하였다. 당신이 설계한 해시 값은 그래프의 1번 정점에서 2번 정점까지 가는 모든 경로들의 경로 값의 최소공배수로 정의한다. 경로 값은 경로 상에 있는 모든 간선의 가중치들의 최대공약수로 정의한다. 물론 경로에서는 같은 정점이 두 번 이상 나와서는 안 된다.

예를 들어 위와 같은 그래프를 보자. 위의 그래프에서 1번 정점에서 2번 정점까지 가는 경로는 1-4-2, 1-3-2의 두 개가 있다. 각 경로의 경로 값은 2(16, 6의 최대공약수), 3(3, 9의 최대공약수)이 되고, 따라서 해시 값은 6(2, 3의 최소공배수)이 된다.
하나의 그래프가 주어졌을 때, 그 그래프의 해시 값(위에서 설계한 해시 함수를 이용하여 계산한)을 구해내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 그래프의 정점의 개수 N(2 ≤ N ≤ 30)이 주어진다. 다음 N개의 줄에는 N개의 음 아닌 정수로 대칭적인 인접 행렬이 주어진다. 0인 경우는 간선이 없을 때를 나타내며, 그 외의 간선의 가중치는 1이상 5,000이하의 자연수이다.
<출력값>
첫째 줄에 해시 값을 출력한다. 이 값은 10진수로 1000자리를 넘지 않는다.

<문제 2329>
동규 체육관에서 장애물 경기장을 설계하고 있다. 경기장에는 높이가 서로 다른 m개의 장애물이 일렬로 서 있다. 각각의 장애물에는 두 개의 받침대가 있다. 경기장을 설계할 때에는 장애물 옆에 다른 장애물을 놓을 수 있다. 또, 장애물의 두 받침대 사이를 가른 다음, 그 사이에 다른 장애물들을 끼워 넣을 수 있다. 이때 끼워 넣는 장애물들은 반드시 사이를 가른 원래 장애물보다 높이가 높아야 한다.

그림의 왼쪽은 장애물의 한 예이고, 오른쪽은 이런 장애물들을 이용하여 만든 경기장의 한 예이다. 이와 같이 경기장을 설계한 뒤, 왼쪽 땅에서부터 시작하여 오른쪽 땅에 도달할 때까지 경기를 하게 된다. 경기를 하는 도중 높이가 낮은 장애물(혹은 땅)에서 높이가 높은 장애물로 이동할 때마다 경기장의 난이도가 1씩 증가한다. 오른쪽 경기장의 경우에는, 맨 처음 땅에서 첫 번째 장애물로 이동할 때, 첫 번째 장애물에서 두 번째 장애물로 이동할 때, 두 번째 장애물에서 세 번째 장애물로 이동할 때, 그리고 마지막 장애물로 이동할 때를 계산하여, 난이도가 4가 된다. 그 외의 경우에는 높이가 높은 곳에서 낮은 곳으로 이동하는 경우이므로 난이도에 계산되지 않는다.
우리가 만들 장애물 경기장의 난이도 k가 주어졌을 때, m개의 장애물로 만들 수 있는 경기장의 개수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 m(0≤m≤50), k(0≤k≤128)가 주어진다.
<출력값>
첫째 줄에 경기장의 개수를 출력한다. 이 값은 10진수 100자리를 넘지 않는다.

<문제 2330>
초라기 연구소에서는 N종류의 미생물을 이용한 실험을 하고 있다. 주된 실험 내용은 같은 미생물을 여러 다른 온도에서 길러 보면서 각각 어떤 모습으로 자라는지 관찰하는 것이다.
i번째 미생물(편의상 미생물에 1부터 N까지의 번호를 붙이자)은 A[i]이상 B[i]이하의 온도에서만 기를 수 있다. 또, 원활한 실험을 위해서는 최소한 C[i]개의 서로 다른 온도의 실험실에서 i번째 미생물을 길러봐야 한다. 이와 같은 조건이 주어졌을 때, 필요한 실험실의 최소 개수를 구하는 프로그램을 작성하시오.
각각의 실험실은 어떤 특정한, 그리고 서로 다른 온도로 관리된다. 어떤 실험실의 온도가 T도일 때, A[i]≤T≤B[i]를 만족하는 미생물은 몇 개라도, 몇 종류라도 그 실험실에서 기를 수 있다고 하자. 또한 월드 연구소에서는 특별한 단위의 온도를 사용하는데, A[i], B[i], T등 모든 온도가 0이상 50,000 이하의 정수로 표현되는 단위를 사용한다.
<입력값>
첫째 줄에 N(1≤N≤50,000)이 주어진다. 다음 N개의 줄에는 A[i], B[i](0≤A[i]≤B[i]≤50,000), C[i](1≤C[i]≤B[i]-A[i]+1)가 i=1, i=2, …, i=N의 순서로 주어진다.
<출력값>
첫째 줄에 필요한 최소 개수의 실험실을 출력한다.

<문제 2331>
다음과 같이 정의된 수열이 있다.

D[1] = A
D[n] = D[n-1]의 각 자리의 숫자를 P번 곱한 수들의 합

예를 들어 A=57, P=2일 때, 수열 D는 {57, 74(=5^2+7^2=25+49), 65, 61, 37, 58, 89, 145, 42, 20, 4, 16, 37, …}이 된다. 그 뒤에는 앞서 나온 수들(57부터가 아니라 58부터)이 반복된다.
이와 같은 수열을 계속 구하다 보면 언젠가 이와 같은 반복수열이 된다. 이때, 반복되는 부분을 제외했을 때, 수열에 남게 되는 수들의 개수를 구하는 프로그램을 작성하시오. 위의 예에서는 {57, 74, 65, 61}의 네 개의 수가 남게 된다.
<입력값>
첫째 줄에 A(1 ≤ A ≤ 9999), P(1 ≤ P ≤ 5)가 주어진다.
<출력값>
첫째 줄에 반복되는 부분을 제외했을 때, 수열에 남게 되는 수들의 개수를 출력한다.

<문제 2332>
핸드폰의 문자메시지 기능 외에도, 일반 전화기의 각 숫자에 영어 알파벳이 할당되어 있는 경우가 종종 있다. 예를 들어 아래와 같이 각 숫자에 문자가 할당된 경우를 보자.

	1 ij	2 abc	3 def
	4 gh	5 kl	6 mn
	7 prs	8 tuv	9 wxy
		0 oqz

이와 같은 알파벳을 이용하면 전화번호를 쉽게 외울 수 있다. 예를 들면, 번호가 941837296인 당신의 체스 친구의 번호를 WHITEPAWN과 같이 외울 수 있고, 번호가 2855304인 당신의 담임선생님의 번호를 BULLDOG과 같이 외울 수 있다.
어떤 번호가 주어졌을 때, 당신은 그 번호를 쉽게 외우기 위해 적당한 영어 단어들을 찾으려고 한다. 이때 가능하면 단어의 개수를 줄여서 쉽게 외울 수 있도록 하려 한다. 또한, 당신이 평소에 자주 사용하는 영어 단어들만을 사용하려고 한다.
여러 개의 영어 단어로 번호를 기억할 때에는, 각 단어를 숫자로 바꾼 것이 연결되었을 때 번호가 되면 된다. 예를 들어 let it be로 번호를 외웠을 때, 이는 5381823가 된다.
<입력값>
첫째 줄에 전화번호가 공백 없이 주어진다. 이 길이는 100자를 넘지 않는다. 다음 줄에는 당신이 자주 사용하는 영어 단어의 개수 n(1≤n≤50,000)이 주어진다. 다음 n개의 줄에는 각 단어들이 공백 없이 알파벳 소문자로 주어진다. 각 단어의 길이는 50자를 넘지 않는다. 입력 파일의 총 크기는 300KB를 넘지 않는다.
<출력값>
첫째 줄에 사용한 영어 단어의 개수 K를 출력한다. 다음 K개의 줄에는 차례로 영어 단어를 출력한다. 정답이 없는 경우에는 "No solution." 을 출력한다.

<문제 2333>
어이쿠 발이 미끄러져 당신은 깊이 D의 함정에 빠졌다. 이 함정 안으로는 상자에 포장된 음식이 던져진다. 당신은 이 상자를 바닥에 쌓아서 탈출할 발판을 만들거나, 내용물을 먹어서 HP를 늘릴 수 있다. 상자 안이 비게 되면 발판을 만들어도 찌그러진다. 즉, 내용물을 먹는 것과 바닥에 쌓는 것을 동시에 할 수는 없다.
당신은 음식물을 먹으며 생존하면서 D이상의 높이로 상자를 쌓아서 탈출하려 한다. 함정 안으로 던져지는 상자들에 대한 정보가 주어졌을 때, 밖으로 탈출할 수 있게 되는 최소의 시간을 구하는 프로그램을 작성하시오. 현재 시각=0, HP=10에서 시작한다. HP는 시간이 지날 때마다 1씩 감소한다. HP가 0이 되는 순간에 급히 음식을 먹으면 계속 생존할 수 있다.
<입력값>
두 자연수 D, G(1≤G≤100)가 주어진다. D는 함정의 깊이, G는 던져지는 상자들의 개수이다. 다음 G개의 줄에는 상자에 대한 정보가 세 자연수 T(1≤T≤1000), F(1≤F≤30), H(1≤H≤25)로 주어진다. T는 이 상자가 던져지는 시각이다. F는 내용물을 먹었을 때 HP가 늘어나는 양이다. H는 이 상자를 쌓았을 때의 높이이다. 입력은 정렬되어 있지 않을 수 있다.
<출력값>
첫째 줄에 탈출할 수 있게 되는 최소의 시간을 출력한다. 만약 탈출할 수 없다면 생존할 수 있는 최대의 시간을 출력한다.

<문제 2334>
어떤 사람의 동생이 종이에 점을 찍어서 그림을 그렸다. 그림을 다 그려놓고 보니, 이 그림이 대칭인지 아닌지 궁금해졌다.
대칭이라는 말의 의미는, 종이를 한 번 접었을 때, 한 쪽 종이에 점이 찍힌 적이 있는 위치와 반대쪽 종이에 점이 찍힌 적이 있는 위치가 일치할 때를 의미한다. 종이에는 결이 없기 때문에, 종이를 접을 때에는 x축 또는 y축에 수직하게 접지 않아도 된다. 종이를 접는 위치가 반드시 종이의 정 가운데일 필요는 없다. 단, 접힌 선 위에는 어떤 점도 있어서는 안 된다.
점을 찍은 순서대로 점의 위치가 주어졌을 때, 이 그림이 대칭인지 판별하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 데이터 세트의 개수 T(1 ≤ T ≤ 4)가 주어진다. 둘째 줄에 점을 찍은 회수 N(1 ≤ N ≤ 700)이 주어진다. 다음 N개의 줄에는 순서대로 점을 찍은 x, y좌표가 주어진다. 각각의 좌표는 절댓값이 10,000을 넘지 않는 실수이다. 소수점은 최대 둘째자리까지 주어진다. 종이는 상하좌우 모든 방향으로 무한히 뻗어있다고 본다.
<출력값>
각각의 데이터 세트에 대해서 대칭이면 YES, 대칭이 아니면 NO를 출력한다.

<문제 2335>
여러 개의 정원과 여러 개의 이랑(일렬로 나무나 곡식을 심는 길쭉한 길)을 소유한 한 농부가 있다. 정원의 경계는 사이프러스 나무로 둘러싸여 있으며, 각 이랑에도 사이프러스 나무가 심어져 있다. 또한 정원과 이랑 모두, 두 사이프러스 나무 사이에는 올리브 나무가 한 그루 심어져 있다. 이런 식으로 농부의 모든 사이프러스 나무는 정원을 둘러싸거나 이랑을 따라 심어져 있으며, 사이프러스 나무 두 그루 사이에는 반드시 올리브 나무가 한 그루 끼여 있다.
그러던 어느 날, 농부는 심한 병에 걸려 임종을 앞두게 되었다. 숨을 거두기 며칠 전, 그는 맏아들에게 이렇게 말했다. "내 정원과 이랑에 심어진 사이프러스 나무들을 아무 거나 Q 그루 골라라. 그러면 그 나무들과, 두 나무 사이에 심겨져 있는 올리브 나무까지 모두 네게 주겠다."
아버지의 유언에 따라 아들은 정원 경계나 이랑에서 연속하는 구간을 하나 이상 선택하여 사이프러스 나무를 최대 Q 그루까지 얻을 수 있고, 그 사이에 있는 올리브 나무들도 얻을 수 있다. 아들은 올리브를 매우 좋아하기 때문에 올리브 나무를 가장 많이 얻을 수 있는 구간을 선택하고 싶어 한다.

농부에게 정원과 이랑이 세 개씩 있고, 사이프러스 나무가 각 곳에 위의 그림과 같이 있다고 가정하자. (사이프러스 나무 사이에 있는 올리브 나무는 편의상 표기하지 않았다) 그리고 Q=17그루의 사이프러스 나무를 물려받을 수 있다고 하자. 그렇다면 아들은 정원 1과 2에 있는 사이프러스 나무만을 모두 선택하면 된다. 정원은 이랑과는 달리 고리를 이루고 있기 때문에, 그 안에 있는 17그루의 올리브 나무를 모두 물려받을 수 있기 때문이다.
밭과 이랑에 있는 나무 수와 물려받을 수 있는 나무의 수를 입력으로 받아, 아들이 물려받을 수 있는 올리브 나무의 최대 수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 아들이 물려받을 수 있는 나무의 그루 수 Q와, 정원의 수 M, 그리고 이랑의 수 K가 들어있다. 둘째 줄에는 각 정원에 있는 사이프러스 나무의 수를 나타내는 정수가 M개 있으며, 다음 줄에는 각 이랑에 있는 사이프러스 나무의 수를 나타내는 정수가 K개 있다.
0≤ Q ≤15만, 0≤ M, K ≤2000이고, 한 정원이나 이랑에 있는 나무의 수는 2 이상 150 이하이다. 모든 정원과 이랑에 있는 나무들의 총합은 반드시 Q보다 같거나 크다.
<출력값>
아들이 덤으로 받을 수 있는 올리브 나무의 최대 그루 수를 출력한다.

<문제 2336>
N명의 학생이 참여하여 세 번의 시험을 치렀다. N명의 학생들은 세 번의 시험에 모두 응시하였다. 조교는 각각의 시험에서 같은 등수의 학생이 한 명도 없도록 성적을 매겼다.
A라는 학생이 B라는 학생보다 세 번의 시험에서 모두 성적이 좋다면, A가 B보다 '대단하다'고 한다. 또, C라는 학생보다 '대단한' 학생이 한 명도 없으면, C를 '굉장하다'고 한다.
세 번의 시험에서 각 학생의 성적이 주어졌을 때, '굉장한' 학생의 수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N(1 ≤ N ≤ 500,000)이 주어진다. 다음 세 개의 줄에는 각 시험에서 1등인 학생부터 N등인 학생이 순서대로 주어진다. 학생의 번호는 1부터 N까지 매겨져 있다.
<출력값>
첫째 줄에 '굉장한' 학생의 수를 출력한다.

<문제 2337>
트리는 사이클이 없는 연결된 그래프이다. 그렇기 때문에, 트리에서 임의의 한 간선을 자르면 두 개의 트리로 나뉘게 된다.
크기(트리의 정점의 개수)가 n인 트리의 간선을 자르는 과정을 반복하여, 크기가 m인 트리를 얻어내려 한다. 이때 잘라야 하는 간선의 최소 개수를 구해 내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 n(1≤n≤150), m(1≤m≤n)이 주어진다. 다음 n-1개의 줄에는 트리의 각 간선에 대한 정보를 나타내는 두 정수 A, B가 주어진다. 이는 A번 정점과 B번 정점이 연결되어 있다는 의미이다.
<출력값>
첫째 줄에 잘라야 하는 간선의 최소 개수를 출력한다. 불가능한 경우에는 -1을 출력한다.

<문제 2338>
두 수 A, B를 입력받아, A+B, A-B, A×B를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 A가, 둘째 줄에 B가 주어진다. 각각의 수는 10진수로 1,000자리를 넘지 않으며 양수와 음수가 모두 주어질 수 있다.
<출력값>
첫째 줄에 A+B, 둘째 줄에 A-B, 셋째 줄에 A×B를 출력한다. 각각을 출력할 때, 답이 0인 경우를 제외하고는 0으로 시작하게 해서는 안 된다(1을 01로 출력하면 안 된다는 의미).

<문제 2339>
하나 이상의 불순물과 보석 결정체로 이루어진 석판을 여러 조각으로 나누어 가공해서, 보다 높은 가치를 얻을 수 있도록 만들려고 한다. 이때, 높은 가치의 석판을 만들기 위해서는 석판을 여러 조각으로 나누되, 각 조각에는 불순물이 없도록 해야하며, 보석 결정체도 단 하나씩만 포함하고 있어야 한다.
또한, 석판에서 불순물을 빼내기 위해서는 불순물을 포함하고 있는 지점을 중심으로 잘라야 되는데, 석판의 결 때문에 가로 또는 세로 방향으로만 석판을 자를 수 있다. 석판을 자를 때에는 이전에 자른 방향과 같은 방향으로는 자를 수 없다. (단, 처음에 자를 때는 가로방향이나, 세로방향 모두 가능하다.)
석판에 있는 불순물과 보석 결정체의 정보가 주어질 때, 이 석판에서 불순물들을 없애면서 석판을 나누되, 각 조각에 반드시 하나의 보석 결정체만이 들어 있도록 석판을 나누는 방법이 모두 몇 가지 존재하는지 계산하시오.

위의 그림은 초기 석판의 상태에서 불순물을 제거하면서 석판을 잘랐을 때, 최종적으로 나뉘어진 석판의 모습이다. 회색 선은 불순물을 중심으로 가로 또는 세로 방향으로 자른 경계선이고, 노란 색은 보석을 하나씩만 포함하고 있는 석판이다. 석판을 자를 때 ②번이나 ③번은 이전에 잘려진 방향, 즉 ①번의 방향과 같은 방향으로 자를 수 없으며, ④ 번도 마찬가지로 ②번과는 같은 방향으로 자를 수 없다. 단순하게 자르는 순서를 의미하는 것이 아니므로, ④번 방향이 ③번 방향과 같을 수도 있다.
잘라진 석판은 반드시 두 개의 석판이 나뉘어진 것이어야 한다. 또한 결정체가 있는 곳은 자를 수 없으며, 최종적으로 나뉘어진 석판에 두 개 이상의 결정체가 오면 안 된다.
<입력값>
첫 번째 줄에는 석판의 크기 N(1 ≤ N ≤ 20)이 들어온다. 다음 줄부터 N줄에 걸쳐서 석판의 상태가 입력으로 들어온다. 여기서 1은 불순물을 의미하며, 2는 보석 결정체, 0은 불순물과 보석결정체가 존재하지 않는 곳을 의미한다. 이때, 보석 결정체의 수는 15개를 넘지 않으며, 각 줄에 주어지는 석판의 정보는 공백 하나로 구분한다.
<출력값>
각각의 석판 안에 불순물이 없으면서 단 하나의 보석 결정체만이 있도록 주어진 석판을 나눌 때, 모두 몇 가지의 경우가 존재하는지를 출력하시오. 이때 가능한 경우가 존재하지 않으면 -1을 출력한다.

<문제 2340>
길이 N의 이진 수열을 생각해보자. 이와 같은 이진 수열을 회전하면 총 N종류의 이진 수열을 만들 수 있다. 예를 들어 00011과 같은 이진 수열을 회전하면, 00011, 10001, 11000, 01100, 00110의 다섯 종류의 이진 수열을 만들 수 있다. 경우에 따라서는 같은 이진 수열이 여러 번 나올 수도 있다.
이와 같이 만들어진 이진 수열들을 알파벳 순서로(또는 이진수 값으로) 정렬하여 차례로 놓으면 하나의 행렬을 만들 수 있다. 위의 예로는 다음과 같은 행렬을 만들 수 있다.

00011
00110
01100
10001
11000
이와 같이 행렬을 만든 뒤, 이 행렬의 제일 마지막 열의 숫자들을 순서대로 나열하면 길이 N의 이진 수열을 만들 수 있다. 위의 예에서는 10010이 된다. 이와 같이 얻은 이진 수열이 주어졌을 때, 앞서 만든 행렬에서 첫 번째 행(줄)의 이진 수열을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 자연수 N(1≤N≤50,000)이 주어진다. 다음 줄에는 길이 N의 이진 수열이 공백 없이 주어진다.
<출력값>
첫째 줄에 구한 이진 수열을 공백 없이 출력한다. 원래 행렬을 만들 수 없을 때는 -1을 출력한다.

<문제 2341>
상근이는 팩스 이미지를 압축하는 계획을 만들려고 한다. 스캐너를 통해서 이미지를 입력받으면, 1과 256사이의 숫자로 이루어진 수열로 변환된다. 예를 들어, 아래와 같은 수열로 이미지를 변환할 수 있다.
1, 1, 1, 1, 1, 46, 1, 1, 1,1, 1, 1, 2, 1, 2, 1, 1, 25, 26, 25, 25, 255, 256, 256, 256, 255,...
이미지를 반드시 정확하게 변환할 필요는 없다. 따라서, 상근이는 수열의 각 숫자를 레벨 4개(1, 86, 172, 256)으로 나타내려고 한다. 그리고, 이 레벨은 다음과 같이 2-bit 코드로 나타낼 수 있다.



Level
1
86
172
256


Code
00
01
10
11



그림 안에는 같은 색으로 이루어진 영역(예를 들면 공백)이 있다. 이 영역을 변환하면 유사한 숫자들이 연속해서 나타난다. 이를 처리하기 위해서 다음과 같은 압축 방법을 사용하려고 한다.

수열의 첫 번째 숫자는 위의 표에 나온 2bit 코드로 변환한다.
그 다음에 나오는 다른 모든 숫자에 대해서는
	
만약 수열의 바로 앞에 있는 숫자가 같은 숫자라면 0으로 변환한다.
앞에 있는 숫자와 다른 숫자라면 1을 앞에 붙인 뒤 위 표의 2bit 코드로 변환한다.



상근이는 작은 양의 에러를 크게 신경쓰지 않기 때문에, 작은 양의 에러는 무시한다. 예를 들어, 입력된 수열이 2, 2, 2, 2, 2, 46, 2, 2 라고 했을 때, 이를 1, 1, 1, 1, 1, 86, 1, 1로 나타낸 다음 변환하면 0000001011000가 되고 전체 에러는 1+1+1+1+1+40+1+1=47 이 된다. 하지만 1, 1, 1, 1, 1, 1, 1, 1 로 나타낸 후 변환하면 전체 에러는 1+1+1+1+1+45+1+1=52가 되어 커지지만 코드가 000000000가 되어 더 짧아진다.
상근이는 변환 비용을 최소로 하는 방법을 찾으려고 한다. 변환 비용은 전체 에러 + W*(변환 코드의 길이)로 계산할 수 있다.

W는 에러와 코드의 길이 중 어느 것을 중요시 하느냐에 따라 입력으로 주어진다.
이때 전체 에러는 입력 수열 x1, x2, , xN , 변환 수열 y1, y2, , yN에 대해서 다음과 같다. Σ|xi-yi|

수열이 2, 2, 2, 2, 2, 46, 2, 2 이고, W가 100인 경우에 y1,..., y8 = 1, 1, 1, 1, 1, 86, 1, 1 로 변환하면 코드는 0000001011000이 되고, 변환 비용은 47 + 100 * 13 = 1347이다. 하지만 y1,..., y8 = 1, 1, 1, 1, 1, 1, 1, 1로 변환하면 코드는 000000000이고 변환 비용은 52 + 100 * 9 = 952이다.
<입력값>
첫째 줄에 수열의 길이 N(1 ≤ N ≤ 50), 가중치 W(1 ≤ W ≤ 100)가 주어진다. 다음 N개의 줄에는 수열을 이루는 숫자(≤256)들이 차례로 주어진다.
<출력값>
첫줄에는 최소 변환 비용을 출력한다. 그리고 두 번째 줄에는 변환코드를 출력한다.

<문제 2342>
승환이는 요즘 "Dance Dance Revolution"이라는 게임에 빠져 살고 있다. 하지만 그의 춤 솜씨를 보면 알 수 있듯이, 그는 DDR을 잘 하지 못한다. 그럼에도 불구하고 그는 살을 뺄 수 있다는 일념으로 DDR을 즐긴다.
DDR은 아래의 그림과 같은 모양의 발판이 있고, 주어진 스텝에 맞춰 나가는 게임이다. 발판은 하나의 중점을 기준으로 위, 아래, 왼쪽, 오른쪽으로 연결되어 있다. 편의상 중점을 0, 위를 1, 왼쪽을 2, 아래를 3, 오른쪽을 4라고 정하자.

처음에 게이머는 두 발을 중앙에 모으고 있다.(그림에서 0의 위치) 그리고 게임이 시작하면, 지시에 따라 왼쪽 또는 오른쪽 발을 움직인다. 하지만 그의 두 발이 동시에 움직이지는 않는다.
이 게임에는 이상한 규칙이 더 있다. 두 발이 같은 지점에 있는 것이 허락되지 않는 것이다. (물론 게임 시작시에는 예외이다) 만약, 한 발이 1의 위치에 있고, 다른 한 발이 3의 위치에 있을 때, 3을 연속으로 눌러야 한다면, 3의 위치에 있는 발로 반복해야 눌러야 한다는 것이다.
오랫동안 DDR을 해 온 백승환은 발이 움직이는 위치에 따라서 드는 힘이 다르다는 것을 알게 되었다. 만약, 중앙에 있던 발이 다른 지점으로 움직일 때, 2의 힘을 사용하게 된다. 그리고 다른 지점에서 인접한 지점으로 움직일 때는 3의 힘을 사용하게 된다. (예를 들면 왼쪽에서 위나 아래로 이동할 때의 이야기이다.) 그리고 반대편으로 움직일때는 4의 힘을 사용하게 된다. (위쪽에서 아래쪽으로, 또는 오른쪽에서 왼쪽으로). 만약 같은 지점을 한번 더 누른다면, 그때는 1의 힘을 사용하게 된다.
만약 1 → 2 → 2 → 4를 눌러야 한다고 가정해 보자. 당신의 두 발은 처음에 (point 0, point 0)에 위치하여 있을 것이다. 그리고 (0, 0) → (0, 1) → (2, 1) → (2, 1) → (2, 4)로 이동하면, 당신은 8의 힘을 사용하게 된다. 다른 방법으로 발을 움직이려고 해도, 당신은 8의 힘보다 더 적게 힘을 사용해서 1 → 2 → 2 → 4를 누를 수는 없을 것이다.
<입력값>
입력은 지시 사항으로 이루어진다. 각각의 지시 사항은 하나의 수열로 이루어진다. 각각의 수열은 1, 2, 3, 4의 숫자들로 이루어지고, 이 숫자들은 각각의 방향을 나타낸다. 그리고 0은 수열의 마지막을 의미한다. 즉, 입력 파일의 마지막에는 0이 입력된다. 입력되는 수열의 길이는 100,000을 넘지 않는다.
<출력값>
한 줄에 모든 지시 사항을 만족하는 데 사용되는 최소의 힘을 출력한다.

<문제 2343>
강토는 자신의 기타 레슨 동영상을 블루레이로 만들어 판매하려고 한다. 블루레이에는 총 N개의 레슨이 들어가는데, 블루레이를 녹화할 때, 레슨의 순서가 바뀌면 안 된다. 순서가 뒤바뀌는 경우에는 레슨의 흐름이 끊겨, 학생들이 대혼란에 빠질 수 있기 때문이다. 즉, i번 레슨과 j번 레슨을 같은 블루레이에 녹화하려면 i와 j 사이의 모든 레슨도 같은 블루레이에 녹화해야 한다.
강토는 이 블루레이가 얼마나 팔릴지 아직 알 수 없기 때문에, 블루레이의 개수를 가급적 줄이려고 한다. 오랜 고민 끝에 강토는 M개의 블루레이에 모든 기타 레슨 동영상을 녹화하기로 했다. 이때, 블루레이의 크기(녹화 가능한 길이)를 최소로 하려고 한다. 단, M개의 블루레이는 모두 같은 크기이어야 한다.
강토의 각 레슨의 길이가 분 단위(자연수)로 주어진다. 이때, 가능한 블루레이의 크기 중 최소를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 레슨의 수 N (1 ≤ N ≤ 100,000)과 M (1 ≤ M ≤ N)이 주어진다. 다음 줄에는 강토의 기타 레슨의 길이가 레슨 순서대로 분 단위로(자연수)로 주어진다. 각 레슨의 길이는 10,000분을 넘지 않는다.
<출력값>
첫째 줄에 가능한 블루레이 크기중 최소를 출력한다.

<문제 2344>
세로 N, 가로 M 크기의 상자가 있다. 이 상자 안에는 몇 개의 거울이 들어 있다. 상자를 위에서 봤을 때, 거울은 한 칸 안에 대각선 모양으로 들어있다고 한다. 또, 상자의 테두리를 따라서 칸마다 구멍이 뚫려 있다. 편의상 구멍은 왼쪽 위에 뚫려있는 것부터 시계 반대 방향으로 1, 2, …, 2N+2M 의 번호가 붙어 있다. 예를 들어 다음과 같은 경우를 보자.

이제 이 상자에 뚫려있는 구멍으로 빛을 쏜다고 생각해보자. 1번 구멍으로 쏠 경우에는 (1, 2)의 위치에 있는 거울에 반사되어 9번 구멍으로 빛이 가게 된다. 또, 2번 구멍으로 빛을 쏠 경우에는 (2, 2)의 위치에 있는 거울과 (1, 2)에 있는 거울에 차례로 반사되어 7번 구멍으로 빛이 나가게 된다.
이와 같이 상자의 모양이 주어졌을 때, 각 구멍으로 쏜 빛이 나가게 되는 구멍을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N, M (1 ≤ N, M ≤ 1,000)이 주어진다. 다음 N개의 줄에는 M개의 수로 상자의 모양이 주어진다. 거울이 있는 위치는 1로, 거울이 없는 위치는 0으로 주어진다. 거울은 / 모양으로만 놓일 수 있다고 하자.
<출력값>
첫째 줄부터 차례로 1번 구멍으로 쏜 빛이 나가는 구멍의 번호, 2번 구멍으로 쏜 빛이 나가는 구멍의 번호, …, 2N+2M번 구멍으로 쏜 빛이 나가는 구멍의 번호를 출력한다.

<문제 2345>
한 도시에 지뢰가 묻혀 있다는 제보가 들어왔다. 당신은 도시를 테러의 위협에서 지키기 위해 지뢰를 제거하기로 하였다.
지뢰를 제거할 때에는 도시에 지뢰 제거용 폭탄을 매설하여 이를 터뜨리는 방법을 사용하기로 하였다. 도시에는 몇 개의 건물들도 있는데, 폭탄이 터질 때에 이 건물들을 건드려서는 안 된다. 반면에 도시에는 폭탄에 부서지지 않는 벽도 있어서 폭탄이 터지는 것을 막아 주기도 한다.
폭탄은 터지는 길이가 있는데, 그 길이만큼 위, 아래로 터지게 된다. 이때 중간에 부서지지 않는 벽이 있으면 더 이상 터지지 않고 그 위치에서 멈추게 된다.

위의 예는 *의 위치에서 길이 2 짜리의 폭탄을 터뜨린 모양이다. 2는 폭탄에 부서지지 않는 벽이고, 검게 되어있는 부분은 폭탄이 터지는 부분이다. 물론 *의 위치에서도 폭탄이 터진다.
도시의 모양이 주어졌을 때, 지뢰가 묻혀 있을 가능성이 있는 위치들을 모두 한 번 이상 폭파시키기 위해 필요한 폭탄의 개수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 두 자연수 N(1≤N≤100), M(1≤M≤100)이 주어진다. 이는 도시의 크기가 세로 N칸, 가로 M칸이라는 의미이다. 다음 줄에는 도시의 모양을 나타내는 정수가 주어진다. 0은 지뢰 및 폭탄이 설치될 수 있는 위치이고, 1은 건물(지뢰 및 폭탄 설치 불가능), 2는 폭탄에도 부서지지 않는 벽(지뢰 및 폭탄 설치 불가능)이다. 0, 1, 2 외의 정수는 입력으로 주어지지 않는다고 가정하자. 다음 줄에는 폭탄의 길이를 나타내는 자연수 K(1≤K≤100)가 주어진다.
<출력값>
첫째 줄에 터뜨리는 폭탄의 개수 X를 출력한다. 다음 X개의 줄에는 폭탄을 터뜨린 위치를 출력한다. 위치를 출력할 때는 행 번호, 열 번호로 출력한다.

<문제 2346>
N개의 풍선이 있다. 각 풍선 안에는 -N부터 N까지의 수가 적혀있는 종이가 들어 있다. 이 풍선들을 다음과 같은 규칙으로 터뜨린다.
우선, 제일 처음에는 1번 풍선을 터뜨린다. 다음에는 풍선 안에 있는 종이를 꺼내어 그 종이에 적혀있는 값만큼 이동하여 다음 풍선을 터뜨린다. 양수가 적혀 있을 경우에는 오른쪽으로, 음수가 적혀 있을 때는 왼쪽으로 이동한다. 풍선은 원형으로 놓여 있다고 생각한다. 즉, 1번 풍선의 왼쪽에 N번 풍선이 있고, N번 풍선의 오른쪽에 1번 풍선이 있는 것이다. 이동할 때에는 이미 터진 풍선은 빼고 생각한다.
예를 들어 다섯 개의 풍선 안에 차례로 3, 2, 1, -3, -1이 적혀 있었다고 하자. 이 경우 3이 적혀 있는 1번 풍선, -3이 적혀 있는 4번 풍선, -1이 적혀 있는 5번 풍선, 1이 적혀 있는 3번 풍선, 2가 적혀 있는 2번 풍선의 순서대로 터지게 된다.
<입력값>
첫째 줄에 자연수 N(1≤N≤1,000)이 주어진다. 다음 줄에는 차례로 각 풍선 안의 종이에 적혀 있는 수가 주어진다. 편의상 0은 적혀있지 않다고 가정하자.
<출력값>
첫째 줄에 터진 풍선의 번호를 차례로 나열한다.

<문제 2347>
2344번 거울의 출력이 입력으로 주어졌을 때, 원래의 입력을 구하는 프로그램을 작성하시오. 즉, 거울의 각 구멍에서 쏜 빛이 나가는 구멍의 번호들이 주어졌을 때, 상자의 모양을 구해 내는 문제이다. 항상 답이 존재하는 경우만 주어진다.
<입력값>
첫째 줄에 N, M (1≤N, M≤100)이 주어진다. 다음 줄에는 2N+2M개의 수들이 주어진다.
<출력값>
N개의 줄에 M개의 수로 상자의 모양을 출력한다. 답이 여러 가지 존재할 경우 아무 것이나 출력하면 된다.

<문제 2349>
한 도시에 N개의 무선 통신 기지국이 있다. 각각의 기지국의 위치는 x, y 좌표로 표현되며 각 기지국의 좌표는 서로 다르다.
  기지국에서는 특정 주파수의 전파를 이용하여 통신을 한다. 만약 두 기지국의 거리가 20을 넘지 않으면 두 기지국은 인접해 있다고 한다. 인접해 있는 두 기지국은 전파의 방해를 막기 위해 서로 다른 주파수를 사용해야 한다. 또한 주파수가 비슷할 경우 통신 장애가 발생할 수 있기 때문에, 2 이상 차이나야 한다고 하자. 편의상 주파수는 자연수만 고려하자.
  무선 통신 기기를 만들 때에는 가능한 모든 주파수를 다 처리해 주어야 하기 때문에, 사용되는 주파수의 종류수가 적은 편이 유리하다.
  무선 통신 기지국의 위치가 주어졌을 때, 사용되는 주파수의 최소 종류수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N(1≤N≤12)이 주어진다. 다음 N개의 줄에는 각 기지국의 좌표가 실수로 주어진다. 입력으로 주어지는 기지국의 위치는 비교적 넓게 퍼져 있어서, 한 기지국에는 최대 4개(물론 자기 자신을 제외하고)의 기지국만 인접해 있다고 가정하자.
<출력값>
첫째 줄에 주파수의 최소 종류수를 출력한다.

<문제 2350>
4대강 사업의 성공에 힘입은 정부는 대한민국의 도시들을 모두 운하로 연결하여 뱃길로 KTX를 대체하려는 계획을 세웠다.
대한민국에는 N개의 도시가 있고, 이들을 연결하는 M개의 운하를 건설하려고 한다. 하지만 지형의 문제로 운하의 폭을 제한할 수 밖에 없었기 때문에, 문제가 생겼다. 배의 폭이 운하의 폭보다 작거나 같아야 운하를 무사히 통과할 수 있기 때문이다.
정부는 K개의 노선을 준비했다. 각 노선의 도시 i와 j간을 운행하는 배는 도시 i와 j 간의 경로에 포함되는 운하를 통과할 수 있어야 한다. (이 경로는 여러 개가 존재할 수 있다.) 배가 클수록 많은 사람을 실을 수 있으므로, 정부는 배의 폭을 최대화하기를 원한다.
N개의 도시는 운하로 서로 연결되어 있음이 보장되며, 운하는 양방향으로 통행이 가능하다.
<입력값>
입력의 첫 번째 줄에는 도시의 수 N, 운하의 수 M, 노선의 수 K가 주어진다. (N <= 1000, M <= 100000, K <= 10000)
다음 M개의 줄에는 세 정수 i, j, w가 주어지며, 이는 도시 i와 j 사이에 폭이 w인 운하를 건설할 것임을 의미한다. (1 <= i, j <= N, w <= 200)
다음 K개의 줄에는 각 노선이 연결하는 도시 i, j가 주어진다. (1 <= i, j <= N)
<출력값>
K개의 줄에 각 노선을 운행할 수 있는 최대 배의 폭을 출력한다.

<문제 2351>
정N각형의 각 꼭짓점에 1부터 N까지의 정수가 중복 없이, 그리고 임의의 순서로 붙어있다. 또 이 N각형의 내부에 M개의 대각선이 그려져 있다. 각각의 대각선은 교차하지 않는다고 하자(두 대각선의 한 끝점이 같은 경우는 교차하지 않는 것으로 간주한다).
이 다각형을 살펴보면서, N+M개의 선분들이 연결하는 두 꼭짓점에 붙어 있는 정수들의 목록을 나열하였다. 당신은 이 목록을 살펴보던 중, 다각형(과 대각선)이 있을 때 이와 같은 목록을 만드는 것도 쉬운 일이지만, 이와 같은 목록을 가지고 다각형(과 대각선)을 만드는 것도 그렇게 어렵지만은 않은 일임을 발견하였다.
예를 들어 이와 같은 목록이 (1, 3), (4, 2), (1, 2), (4, 1), (2, 3) 이었다고 했을 때, 다각형의 꼭짓점에 순서대로 1, 3, 2, 4의 정수를 붙이면 대각선도 교차하지 않고, 다각형의 모든 선분들이 목록에 있음을 알 수 있다.

선분들의 목록이 주어졌을 때, 이를 이용하여 다각형에 붙어 있는 정수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 정수 N(3≤N≤10,000), M(0≤M≤N-3)이 주어진다. 다음 N+M 줄에는 각 선분의 두 끝점에 붙어 있는 정수가 주어진다.
<출력값>
첫째 줄에 다각형에 붙어 있는 N개의 정수들을 출력한다. 1을 제일 먼저 출력하며, 두 번째 수가 더 작은 경우를 출력한다. (1 4 2 3 대신 1 3 2 4 를 출력)

<문제 2352>
반도체를 설계할 때 n개의 포트를 다른 n개의 포트와 연결해야 할 때가 있다.

예를 들어 왼쪽 그림이 n개의 포트와 다른 n개의 포트를 어떻게 연결해야 하는지를 나타낸다. 하지만 이와 같이 연결을 할 경우에는 연결선이 서로 꼬이기 때문에 이와 같이 연결할 수 없다. n개의 포트가 다른 n개의 포트와 어떻게 연결되어야 하는지가 주어졌을 때, 연결선이 서로 꼬이지(겹치지, 교차하지) 않도록 하면서 최대 몇 개까지 연결할 수 있는지를 알아내는 프로그램을 작성하시오
<입력값>
첫째 줄에 정수 n(1 ≤ n ≤ 40,000)이 주어진다. 다음 줄에는 차례로 1번 포트와 연결되어야 하는 포트 번호, 2번 포트와 연결되어야 하는 포트 번호, …, n번 포트와 연결되어야 하는 포트 번호가 주어진다. 이 수들은 1 이상 n 이하이며 서로 같은 수는 없다고 가정하자.
<출력값>
첫째 줄에 최대 연결 개수를 출력한다.

<문제 2353>
컴퓨터를 이용하여 타자를 치다 보면 오타가 날 수 있다. 타자를 친 문장이 들어왔을 때, 이 문장에 오타가 있는지를 검사하고, 처음 오타가 난 부분을 알아내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 입력한 타자가 주어진다. 이는 2벌식 한글 키보드 자판에서 각 키에 해당하는 영문자로 주어진다.
<출력값>
첫째 줄에 처음 오타가 난 위치를 출력한다. 오타가 없을 경우에는 0을 출력한다.

<문제 2354>
n개의 수 A[1], A[2], …, A[n]이 있을 때, 1≤a<b≤n인 두 정수 a, b에 대해서 비교교환(Compare-Exchange) 함수는 다음과 같이 정의된다.

CE(a, b)
    if(A[a] > A[b])
        Swap(A[a], A[b]);
즉, 두 값을 비교하여 더 작은 값이 앞으로 오도록 하는 함수이다. 이와 같은 CE함수를 나열해 놓은 것을 CE프로그램이라 한다. 어떤 CE프로그램을 수행한 후, 어떤 A[1], A[2], …, A[n]에 대해서도 A[1]에 최솟값(A[1], A[2], …, A[n] 중에서)이 저장될 경우, 그 CE프로그램을 최소-탐색-CE프로그램 이라고 한다. 특히 이와 같은 최소-탐색-CE프로그램들 중에서 프로그램 내의 CE함수 호출을 임의로 하나 제거해도 최소-탐색-CE프로그램인 것을 안정적인-최소-탐색-CE프로그램 이라고 한다.
어떤 CE프로그램이 주어졌을 때, 여기에 프로그램의 마지막 부분에 CE함수 호출을 최소로 추가하여 안정적인-최소-탐색-CE프로그램이 되도록 하려 한다.
<입력값>
첫째 줄에 두 정수 n(2≤n≤10,000), m(0≤m≤25,000)이 주어진다. m은 주어진 CE프로그램의 CE함수 호출 횟수이다. 다음 m개의 줄에는 순서대로 CE함수 호출에서의 두 인자 a, b가 주어진다.
<출력값>
첫째 줄에 추가할 CE함수 호출 횟수의 최솟값을 출력한다.

<문제 2355>
두 정수 A와 B가 주어졌을 때, 두 정수 사이에 있는 수의 합을 구하는 프로그램을 작성하시오. 사이에 있는 수들은 A와 B도 포함한다.
<입력값>
첫째 줄에 두 정수 A, B가 주어진다. (-2,147,483,648 ≤ A, B ≤ 2,147,483,647)
<출력값>
첫째 줄에 답을 출력한다. (-2,147,483,648 ≤ 답 ≤ 2,147,483,647)

<문제 2357>
N(1 ≤ N ≤ 100,000)개의 정수들이 있을 때, a번째 정수부터 b번째 정수까지 중에서 제일 작은 정수, 또는 제일 큰 정수를 찾는 것은 어려운 일이 아니다. 하지만 이와 같은 a, b의 쌍이 M(1 ≤ M ≤ 100,000)개 주어졌을 때는 어려운 문제가 된다. 이 문제를 해결해 보자.
여기서 a번째라는 것은 입력되는 순서로 a번째라는 이야기이다. 예를 들어 a=1, b=3이라면 입력된 순서대로 1번, 2번, 3번 정수 중에서 최소, 최댓값을 찾아야 한다. 각각의 정수들은 1이상 1,000,000,000이하의 값을 갖는다.
<입력값>
첫째 줄에 N, M이 주어진다. 다음 N개의 줄에는 N개의 정수가 주어진다. 다음 M개의 줄에는 a, b의 쌍이 주어진다.
<출력값>
M개의 줄에 입력받은 순서대로 각 a, b에 대한 답을 최솟값, 최댓값 순서로 출력한다.

<문제 2358>
평면상에 n개의 점이 있다. 이 점들 중에 서로 다른 두 점을 선택하면 하나의 직선이 만들어진다. 이와 같이 직선을 만들었을 때, x축 또는 y축에 평행한 직선이 몇 개나 되는지 알아내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 n(1≤n≤100,000)이 주어진다. 다음 n개의 줄에는 각 점의 좌표가 int 범위에서 주어진다. 만약 입력에 서로 같은 두 점이 주어지면, 그 두 점을 이용하여 직선을 만들 수 있다.
<출력값>
첫째 줄에 답을 출력한다.

<문제 2359>
n(3≤n≤500)개의 도시로 이루어진 나라가 있다. 이들 중 몇 개의 도시들은 서로 도로로 연결되어 있다. 당신은 당신의 취미 생활인 자동차 드라이브를 즐기려고 한다. 각각의 도시는 1, 2, 3, …, N의 번호가 붙어 있고, 현재 당신은 S번 도시에 위치하고 있다. 당신은 T번 도시로 가려고 한다.
각각의 도로를 지날 때에는 특정한 비용을 지불하여야 한다. 드라이브를 시작하면 처음으로 도로를 지날 때에는, 0원을 지불한다. 그 외의 경우에는 다음과 같은 방법을 이용하여 지불 비용을 계산한다. 우선, 현재까지 지난 도로들 중에서 최소인 비용을 m, 최대인 비용을 M이고, 현재 지나려는 도로의 비용이 x라고 하자. 만약 x가 m보다 작다면 m-x만큼의 비용을 추가로 지불하여야 한다. 만약 x가 M보다 크다면, x-M의 비용을 추가로 지불하여야 한다.
예를 들어, 비용이 3, 1, 5, 4, 2, 7인 도로들을 차례로 지났다고 하자. 그러면 각각을 지날 때 지불하는 비용은 0, 2, 2, 0, 0, 2가 되어, 총 6의 비용을 지불하게 된다.
도로에 대한 정보가 주어졌을 때, 지불하게 되는 총 비용을 최소로 하는 드라이브 경로를 찾는 것이 목적이다.
<입력값>
첫째 줄에 네 정수 n, m(1≤m≤2,000), S, T가 주어진다. m은 도로의 개수를 나타낸다. 다음 m개의 줄에는 도로에 대한 정보를 나타내는 세 정수 a, b, c가 주어진다. 이는 a번 도시와 b번 도시를 연결하는 도로의 비용이 c(1≤c≤1,000,000,000)임을 나타낸다. a와 b는 항상 다르고, 두 도시는 오직 한 개의 도로(경로가 아님)로만 연결되어 있다.
<출력값>
첫째 줄에 지불하는 비용을 출력한다. 다음 줄에는 방문하는 도시들을 차례로 출력한다. 답이 없는 경우는 입력으로 주어지지 않는다고 가정하자.

<문제 2360>
The software company, where the young programmer Stancho was hired, is famous with its distributed software for management of small planetary systems, the number of planets of which is a power of two. Recently, the company issued the current version of the software and the young professionals of the company have to visit the clients and to install the updates. Stancho also has to visit the planets of one system-customer. Traveling from one planet to another planet of the system is not easy. Imagine that the planets are ordered in line by their distances to the star of the system and labeled with the numbers 0, 1, …, 2n –1 following this order (astronomically this is rare, but not impossible). Stancho has 2n –1 teleports, labeled with 1, 2,…,2n –1. The teleport labeled with t could transmit only once one human from a planet labeled with m to the planets with label m+t or label m–t, if such a planet exists (i.e. if 0 ≤ m–t and m+t ≤ 2n –1). Using a space-stop Stancho could go to the planet labeled with k. Write a program teleport, which for given n and k has to find the best way Stancho can use the teleports in order to visit as many as possible planets of the system.
<입력값>
On the single line of the standard input the positive integers, n and k are given, 1 ≤ n ≤ 20, 0 ≤ k ≤ 2n –1.
<출력값>
On the first line of the standard output the program has to print the maximal number p of planets that Stancho could visit – excluding the planet k. On the next row, the program has to print a sequence of the numbers of p teleports that Stancho has to use, in the order of using. The numbers of teleports that transmit him from a planet with larger number to a planet with smaller number has to be multiplied by –1. If there are several different ways to do the teleporting the program has to print any one of them.

<문제 2361>
어떤 정원에 n(10≤n≤1,000)개의 식물이 심어져 있다. 각각의 식물들은 x, y좌표를 가지고 있다. 우리는 이 정원에서 전체 식물들의 절반 이상을 포함하는 정사각형 모양의 땅을 찾으려고 한다. 정사각형의 테두리에 심어져 있는 식물들도 포함한다고 하자. 이와 같은 정사각형 모양의 땅 중에서, 그 크기가 제일 작은 것을 찾는 것이 목적이다.
또한, 이 정사각형의 각 변은 x, y축에 평행해야 한다.
<입력값>
첫째 줄에 n이 주어진다. 다음 n개의 줄에는 각 좌표가 주어진다.
<출력값>
첫째 줄에 정사각형의 한 변의 길이를 출력한다. 다음 줄에는 정사각형의 왼쪽 아래 좌표를 출력한다. 모든 길이, 좌표와 정답과의 오차가 6자리 이내일 경우만 정답이다.

<문제 2362>
2005년 1월 14일 밤 파라다이스 감옥에서 죄수들이 탈출을 감행하려 한다. 어찌어찌하다 이 사실을 알게 된 간수장. 간수장은 길목마다 간수들을 배치해 탈출을 막아보기로 했다. 하지만 이를 위해서는 간수들에게 추가 수당을 지급해야만 하는데... 왠지 돈이 아깝다. 때문에 적은 수의 간수를 감옥내에 배치하려고 하는데... (단, 간수들은 깜깜한 어둠속에서는 자기 옆으로 죄수가 지나가도 알아챌수 없다. 그리고 죄수들은 대각선으론 움직일 수 없다.)
<입력값>
첫 번째 줄에는 정방형 감옥의 크기(N <= 100) 와 일할수 있는 간수들의 수(0 <= K 인 양수)가 주어진다. 두 번째 줄부터는 감옥의 구조가 주어진다. +는 벽 X는 감옥을 탈출하려는 죄수들의 위치이다. O는 바깥으로 나갈수 있는 문들의 위치이다. 감옥의 문은 하나이상 일수 있다.
<출력값>
K명의 간수들로 모든 죄수들의 탈출을 막을수 있다면 첫줄에 Yes 그렇지 않다면 No를 출력한다. 만약 막을수 있다면 두 번째 줄에 필요한 간수들의 최소 수를 출력하여라.

<문제 2363>
한 수열의 부분수열은 주어진 수열에서 몇 개의(1개 이상) 숫자를 제거하여 얻어진 수열을 말한다. 이때 제거하는 수들이 꼭 연속적일 필요는 없다. 예를 들어 1234의 부분수열로는 1, 2, 12, 13, 24 등이 있지만, 1234는 제거한 숫자가 없으므로 부분수열이 아니다.
약수부분수열이란, 부분수열이 나타내는 수가 동시에 약수인 것을 의미한다. 예를 들어 8013824의 약수부분수열로는 8, 13, 14 등이 있다.
입력으로 한 자연수 N이 주어졌을 때, N에서 약수부분수열을 하나 제거해 다음 수 N[2]를 만든다. 이 N[2]에서 약수부분수열을 또 하나 제거하면 N[3]를 만들 수 있고, N[3]에서 약수부분수열을 또 하나 제거하면 N[4]를 만들 수 있다. 이와 같은 과정을 더 이상 다음 수를 만들 수 없을 때까지 반복하면 N, N[2], …, N[k]와 같은 수열을 얻을 수 있다. 이때 k를 최대로 하려고 한다.
8013824와 같은 경우에는 약수부분수열 80을 제거하여 N[2]=13824을 얻고, N[3]=1324,  N[4]=132, N[5]=12, N[6]=1을 얻는다. 이때 k=6이 되고, 이 경우가 k가 제일 커지는 경우이다.
<입력값>
첫째 줄에는 자연수 N(1≤N≤1,000,000,000)이 주어진다.
<출력값>
첫째 줄에 차례로 N, N[1], N[2], …, N[k]를 출력한다.

<문제 2364>
어떤 나라에는 커다란 담장이 여러 개 건설되어, 한 담장의 양 끝은 정확히 두 마을과 연결이 돼 있다. 이 문제에서 마을은 점으로, 담장은 마을을 연결하는 선으로 표현된다. 담끼리 교차하는 경우는 없다. 그래서 이 나라는 담장 때문에 국토가 여러 "구역"으로 나눠지게 되는데, 한 구역에서 다른 구역으로 가려면 마을을 통과하거나 담을 넘어야 한다. 각 담장들은 모두 서로 이어져 있기 때문에 임의의 마을 A와 B에 대해서 한쪽 끝이 A이거나 B인 담장이 반드시 존재하며, 고립돼 있는 마을이 없다. 또한 담장만 따라 걸어가면 A에서 B까지 갈 수 있다.
이들 마을에 사는 사람들을 대상으로 하는 모임이 하나 있다. 각 마을마다 최대 한 명이 모임에 가입해 있으며, 모임에 가입한 사람이 한 명도 없는 마을도 있다. 그런데, 모임에 든 사람들이 마을 바깥에 있는 한 구역에서 만나고 싶어한다. 여기 회원들은 자전거를 타고 그 약속장소로 가는데, 교통 문제 때문에 마을을 통과하지 않으려 한다. 그리고 가는 과정에서 담장은 가능한 한 적게 넘고 싶다. 이들은, 도착하기 위해 각 회원들이 담장을 넘어야 하는 횟수의 합이 가장 적게 되는 곳을 찾아 거기서 모이기를 원한다.

마을은 1부터 N까지 번호가 매겨져 있다. (N은 마을의 총 개수) 그림 1을 보면, 정점은 마을을 나타내고, 정점들을 잇는 선은 담장을 나타낸다. 그리고 모임에 든 사람은 3번, 6번, 9번 마을에 한 사람씩 있다고 가정하자. 이때, 이 사람들이 전체적으로 담장을 가장 적게 거쳐서 모일 수 있는 적합한 곳은 그림 2에 나타나 있는 구역이다. 각 마을 사람이 화살표 친 대로 이동하면 되는 것이다. 담장을 넘은 총횟수는 2이다. 6번 사람이 4번과 7번 마을 사이에 있는 담을 넘어야 하고, 9번 사람이 2번과 4번 마을 사이에 있는 담을 넘었기 때문이다.
마을과 담장, 그리고 모임에 속한 사람들에 대한 자료를 입력받아, 모이기에 가장 적합한 구역을 고르고 담장을 넘는 총횟수의 최솟값을 구하는 프로그램을 작성하라.
<입력값>
첫째 줄에는 구역의 개수 M이있다(2<=M<= 200). (그림 1을 살펴보면 생겨난 다각형 개수가 경계 바깥을 포함해서 10개임을 알 수 있다. 그 개수를 일컫는다.) 둘째 줄에는 마을(그림에서 꼭짓점)의 개수 N이있다(2<=N<= 250). 셋째 줄에는 모임에 든 회원의 수 L이 들어있다(1<=L<=30, L<=N). 그리고 넷째 줄에는 각 회원이 사는 마을의 번호를 나타내는 L개의 정수가 오름차순으로 들어있다.
그리고 다음에는 2M개의 줄이 있으며, 한 구역에 대한 정보가 두 줄에 걸쳐 들어있다. 거기서 첫줄에는 이 구역이 감싸는 마을의 개수 I가 들어있으며, 다음줄에는 이 구역의 경계를 이루는 마을 I개의 번호가 시계 방향 순서로 들어있다. 다만, 한 가지 예외가 있는데, 가장 마지막에 있는 구역은(M째 구역) 마을 전체의 바깥을 이루는 구역에 대한 정보이다. 이 구역을 다룰 때만은 가장 바깥을 감싸고 있는 마을들의 번호가 반시계 방향 순서로 제시된다. 이렇듯 입력 파일에는 담과 마을로 인해 생겨난 모든 구역에 대한 정보가 바깥쪽 구역까지 포함해서 모두 들어있다.
구역은 입력 파일에 수록돼 있는 순서가 곧 그 구역을 지정하는 번호가 된다. 가장 먼저 나오는 구역이 1번 구역, 그 다음에 있는 구역이 2번이다. 즉, 모이기에 가장 적합한 구역을 가리킬 때는 입력 파일에서 몇째로 나온 구역인지를 출력하면 된다.
<출력값>
첫째 줄에는 답안 프로그램이 구한 총횟수의 최솟값을 출력한다. 둘째 줄에는 담장을 가장 적게 넘고 만날 수 있는 구역의 번호를 출력한다. 그런 구역이 여러 개 있을 수 있더라도 한 곳만 출력하면 된다.

<문제 2365>
가로의 크기와 세로의 크기가 각각 N인 숫자판이 있다. 숫자판의 각 칸에는 음 아닌 정수들만 들어갈 수 있고 각 행과 각 열의 합이 미리 주어진다고 하자. N=2 인 경우의 예가 다음에 있다.



?
?
12


?
?
4


6
10
 



위 그림에서 숫자판 옆의 수는 해당하는 행에 들어가는 숫자의 합을 나타내며, 숫자판 아래의 수는 해당하는 열에 들어가는 숫자의 합을 나타낸다. 이제, 숫자판에 주어진 합과 일치하도록 수를 넣으려고 한다. 합이 일치되도록 숫자를 넣는 방법은 여러 가지 있을 수 있으며 위의 예에 대해 서로 다른 형태를 3가지만 보이면 다음과 같다.



5
7


1
3






6
6


0
4






4
8


2
2



이 문제에서는 가능한 여러 가지 형태중 숫자판에 들어가는 최대 숫자의 값을 최소로 하는 형태를 찾고자 한다. 그러므로, 위의 예에서는 최대 숫자가 6 인 형태가 원하는 답이다. 이 문제를 해결하는 프로그램을 작성하시오.
<입력값>
입력의 첫째 줄에는 행(열)의 크기 N이 주어진다(1≤N≤50). 둘째 줄에는 N개의 정수가 주어진다. 주어지는 정수는 1행부터 N행까지의 합을 차례대로 나타낸다. 셋째 줄에는 N개의 정수가 주어진다. 주어지는 정수는 1열부터 N열까지의 합을 차례대로 나타낸다. 합을 나타내는 각 정수는 0 이상 10000 이하이다. 숫자판을 구성할 수 없는 입력은 주어지지 않는다고 가정한다.
<출력값>
첫 줄에는 배정된 수들중 최댓값을 출력한다. 둘째 줄부터 (N+1)째줄까지 각 행에 배정된 수들을 한 줄에 한 행씩 출력한다. 배정되는 각각의 정수는 0 이상이어야 한다.

<문제 2366>
그래프를 주어진 제약조건을 만족하도록 평면상에 그리는 것은 VLSI에서 회로를 배선하거나 정보 시스템의 구조를 다이어그램으로 나타내어 분석하는데 이용된다. 이 문제에서는 주어진 이진트리(binary tree)를 다음 조건을 만족하도록 이차원 격자구조에 그리는 문제를 고려한다. 

루트는 격자상의 최상단 가장 왼쪽 모서리에 위치한다.
각 정점에 대해 하나의 자식 정점은 수평방향 오른쪽, 다른 자식 정점은 수직방향 아래쪽의 격자점에 위치한다 (자식정점이 하나인 경우는 둘중 하나의 조건을 만족).
각 정점에 대해 두 자식 정점을 루트로 하는 서브트리를 둘러싼 두 직사각형은 서로 겹치지 않는다.

예를 들어, 다음은 주어진 이진트리를 위의 제약 조건을 만족하도록 그린 것이다.

왼쪽부터 이진트리, 그리기-1, 그리기-2, 그리기-3이다.
또, 위와 같이 이진 트리를 그릴 때는 그리기에 필요한 면적이 중요한 평가 요소가 된다. 어떤 그리기의 면적은 그리기에 필요한 이차원 격자의 가로크기와 세로크기를 곱한 값이다. 그러므로, 위의 그림에서 <그리기-1>의 면적은 16이며 <그리기-2>와 <그리기-3>의 면적은 15이다.
이진 트리가 주어질 때 위의 제약 조건을 만족하는 그리기 중 면적을 최소로 하는 그리기의 면적을 출력하는 프로그램을 작성하시오.
<입력값>
입력의 첫째 줄에는 이진트리의 정점수를 나타내는 n이 주어진다(1≤n≤100). 둘째 줄에는 n개의 정수로 구성된 수열이 주어진다. 주어지는 정수 수열은 이진트리를 전위(preorder) 순회한 순서가 1, 2, 3, . . . ,n 이라고 가정했을 때, 그 이진트리를 중위순회한 순서를 나타낸다. 정수 사이에는 빈칸이 하나 있다. 올바른 입력만 주어진다고 가정한다.
<출력값>
첫 줄에 최소 면적을 출력한다.

<문제 2367>
N(3 ≤ N ≤ 200)명의 사람이 파티를 하려고 한다. 각각의 사람은 몇 종류의 음식을 요리할 줄 안다. 각각의 음식의 종류는 1부터 D(5 ≤ D ≤ 100)까지의 정수로 표현된다 하자. 파티를 위해서 각각의 사람이 요리를 해서 가져오기로 했는데, 가급적이면 많은 양(접시의 수로 계산)의 음식을 파티에 준비하려 한다.
그렇다면 각각의 음식을 최대한 많이 준비해 오면 되겠지만, 우선 각각의 사람이 가져올 수 있는 음식의 양에 제한이 있다. 각각의 사람은 최대 K(1 ≤ K ≤ 5)개의 접시밖에 가져올 수 없다고 하자. 이때 같은 종류의 음식은 한 접시밖에 가져갈 수 없다고 하자. 즉, 한 사람이 세 접시의 스테이크를 가져올 수 없지만, 한 접시의 스테이크, 한 접시의 샐러드, 한 접시의 파스타를 가져올 수 있다.
또한 각 음식의 종류마다도 가져올 수 있는 양에 제한이 있다. 사전에 파티 참석자들에게 음식 선호도 조사를 하여 낭비되는 음식이 없도록 양을 정했다.
이와 같은 제한들이 주어졌을 때, 파티에 준비될 수 있는 접시(물론 음식이 담겨있는)의 개수의 최댓값을 알아내는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 N, K, D가 주어진다. 다음 줄에는 D개의 정수가 주어지는데, 이는 각 음식의 종류마다 가져올 수 있는 양의 제한을 의미한다. 다음 N개의 줄에는 각 사람이 요리할 줄 아는 음식의 종류 개수 Z(1 ≤ Z ≤ D)와, Z개의 정수로 요리할 줄 아는 음식의 번호가 주어진다.
<출력값>
첫째 줄에 파티에 준비될 수 있는 접시 개수의 최댓값을 출력한다.

<문제 2369>
N×M(1≤N, M≤256)의 행렬이 하나 있다. 이 행렬의 부분행렬들 중 그 성분(원)들의 합이 K(1≤K≤1,000,000)로 나누어떨어지는 경우가 몇 가지나 되는지 알아보려 한다.

	  부분행렬은 말 그대로 어떤 행렬에서 부분적으로 뽑아내는 행렬을 의미한다. 다음의 예를 보면 이해가 갈 것이다.



	  위와 같은 3×3행렬이 있을 때, 2×2인 부분행렬들은 다음과 같다.



	  1×1인 부분행렬을 총 9개가 있고, 3×3인 부분행렬은 자기 자신 한 개만 있다.
<입력값>
첫째 줄에 세 개의 자연수 N, M, K가 주어진다. 다음 N개의 줄에는 각 줄에 M개씩 정수들이 주어진다. 각각은 행렬의 성분들이다. 각 성분은 1보다 크거나 같고, 50보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 부분행렬의 개수를 출력한다.

<문제 2370>
마을에서 시장 선거를 하려 한다. 그래서 특정한 곳에 포스터를 붙이려 하는데, 선거 관리 위원회에서 몇 가지 규칙을 정해 주었다.

모든 후보자는 오직 한 개의 포스터만을 벽에 붙일 수 있다.
모든 포스터는 벽의 높이와 같게 하고, 포스터 너비는 자유다.
벽은 조각으로 나누어져 있으며, 하나의 조각의 단위는 byte다.
각각의 포스터는 정해진 벽 부분에 빈틈없이 붙어야 한다.

그리고 그들은 너비가 100,000,000byte의 벽을 마련해 주었다. 시장 후보 홍보가 시작됐을 때 각 후보자들은 벽에다가 그들의 포스터를 붙일 수 있다. 게다가 이미 붙이려는 부분에 포스터가 있어도 그 위에다 붙일 수 있다. 월드 마을사람들은 선거 전날 벽에 몇 명의 시장 포스터가 붙어 있는지 궁금하다. 당신의 할 일은 주어진 정보대로 포스터를 붙인 후에 선거 전날에 보이는 총 포스터의 수를 출력하는 프로그램을 작성하여라.
<입력값>
첫줄에는 포스터의 개수 n(1≤n≤10,000)이 주어지고, 그 다음 n줄에는 각 포스터의 왼쪽 끝의 위치와 오른쪽 끝의 위치 l, r이 주어진다. (1 ≤ l < r ≤ 100,000,000)
<출력값>
입력된 순서대로 포스터를 붙인 후에 보이는 포스터의 총 수를 출력하여라.

<문제 2371>
메모리에 N개의 파일이 저장되어 있다. 이 문제에서는 편의상 각각의 파일을 수열과 같이 생각하자. 이와 같은 파일들을 구별하기 위해서는 두 개의 파일을 맨 끝까지 읽어보는 작업을 수행해야 한다. 이와 같은 작업을 좀 더 효율적으로 수행하기 위해서, 파일의 앞에서부터 차례로 K번째 수 까지만 읽어보는 방법이 있다. 만약 파일의 크기가 K보다 작다면 파일의 뒤에 0이 여러 개 붙어서 총 길이를 K로 만드는 것으로 생각하면 된다.
예를 들어 {1, 2, 3}, {1, 2, 3, 4}, {1, 2, 4, 5}과 같은 세 개의 파일이 있다고 해 보자. K=3일 경우 각 파일의 앞에서부터 K번째 수 까지 읽으면 {1, 2, 3}, {1, 2, 3}, {1, 2, 4}이 된다. 이 경우에는 서로 같은 경우가 있으므로 파일들을 완전히 구별할 수 없다. 하지만 K=4일 경우 {1, 2, 3, 0}, {1, 2, 3, 4}, {1, 2, 4, 5}가 되어 모든 파일들을 완전히 구별할 수 있게 된다.
N개의 파일에 대한 정보가 주어졌을 때, 모든 파일들을 구별할 수 있게 해 주는 최소의 K값을 찾는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N(1≤N≤100)이 주어진다. 다음 N개의 줄에는 각각의 파일의 정보를 나타내는 자연수(int 범위)가 주어진다. 각 줄의 맨 마지막에는 -1이 주어진다. 두 파일의 길이와 내용이 모두 동일한 경우는 없다고 가정하자.
<출력값>
첫째 줄에 K의 최솟값을 출력한다.

<문제 2373>
당신은 N(2≤N≤1,000,000)개의 구슬을 가지고 다음과 같은 게임을 하려고 한다. 게임은 두 사람이 번갈아 가면서 진행하며, 1번 사람이 몇 개의 구슬을 가져가는 것으로 게임이 시작된다. 1번 사람이 처음에 구슬을 가져갈 때는 몇 개라도 가져갈 수 있지만 N개의 구슬을 다 가져가서는 안 된다. 그 후에 구슬을 가져갈 때는, 상대편이 바로 전에 가져간 개수의 2배 이하를 가져갈 수 있다. 즉, 상대편이 1개를 가져갔다면, 당신은 1개, 또는 2개를 가져갈 수 있는 것이다. 이런 식으로 게임을 진행하여, 마지막으로 구슬을 가져간 사람이 이기게 된다.
예를 들어, N=3인 경우를 보자. 1번 사람이 몇 개를 가져가도 2번 사람이 남아있는 구슬을 다 가져갈 수 있다. 반면에 N=4인 경우에는, 1번 사람이 1개를 가져가면 이기게 된다.
1번 사람의 입장이 되어, 처음에 몇 개의 구슬을 가져갈 것인지를 결정하는 프로그램을 작성하시오. 만약 가능한 경우가 여러 가지 존재한다면, 더 적은 수의 구슬을 가져가는 것으로 한다. 만약 몇 개를 가져가도 지게 된다면, -1을 출력한다.
<입력값>
첫째 줄에 정수 N이 주어진다.
<출력값>
가져갈 구슬의 개수, 또는 -1을 출력한다.

<문제 2374>
n(1 ≤ n ≤ 1,000)개의 자연수 A[1], A[2], A[3], …, A[n]이 있다. 이 자연수에 Add(i)라는 연산을 하면, A[i]가 1만큼 증가한다. 이때, A[i]만 증가하는 것이 아니고, A[i]의 좌우로 인접한 같은 수의 그룹이 한번에 1씩 증가한다. A[1]과 A[n]은 인접해 있지 않다.
예를 들어 수가 {1, 1, 1, 1, 3, 3, 1} 이었다고 해 보자. Add(2)를 하면 A[2]의 좌우로 인접한 같은 수가 1씩 증가하니까 {2, 2, 2, 2, 3, 3, 1}이 된다. 여기서 Add(4)를 하면 {3, 3, 3, 3, 3, 3, 1}이 되고, 여기서 Add(1)을 하면 {4, 4, 4, 4, 4, 4, 1}이 된다.
이와 같이 Add라는 연산을 사용하여 A[1]=A[2]=A[3]=…=A[n]이 되도록 하려 한다. 이때, 최소 회수로 Add연산을 사용하는 방법을 찾는 것이 문제이다.
<입력값>
첫째 줄에 정수 n이 주어진다. 다음 n개의 줄에는 차례로 A[1], A[2], …, A[n]이 주어진다. 모든 입력은 1,000,000,000을 넘지 않는다.
<출력값>
첫째 줄에 최소의 Add연산 사용 회수를 출력한다. 이 값은 1025을 넘지 않는다.

<문제 2375>
흔히 알고 있는 2차원 평면과 같은 격자 나라가 있다.

이 나라에는 위와 같이 원점에서 거리가 정수가 되는 지점에 x축과 또는 y축과 평행하게 길이 나있고 세로로 나있는 길과 가로로 나있는 길이 교차하는 모든 곳에만 마을이 있어서 사람이 살고 있다.
이중에 n개의 마을 사람들만 농구를 좋아하고 이 사람들을 위해 나라에서 농구 골대 딱 하나를 세워주고자 한다.
농구를 좋아하는 어느 마을도 큰 불이익이 없게 하기 위해 각각 농구를 좋아하는 마을에 대해서 ( 각 마을에서 농구골대까지의 거리 × 그 마을의 사람 수 )의 합이 최소화되는 마을에 농구골대를 세우고자 한다. 농구골대는 (길이 아닌)마을에 세워져야 하며 그 마을은 꼭 농구를 좋아하는 마을일 필요는 없다.
한 마을에서 다른 마을까지의 거리는 길을 따라 이동한 최단거리로 간주한다.  이렇게 측정하는 거리를 맨하탄 거리(manhattan distance)라고 한다. 예를들면 (x1, y1)에서 (x2, y2)까지의 거리는 ABS(x2-x1)+ABS(y2-y1)이다.
<입력값>
첫 줄에 농구를 좋아하는 마을의 개수인 n이 주어지고 다음 줄부터 xi yi pi와 같이 한 줄에 농구를 좋아하는 하나의 마을에 대한 정보가 주어진다. ( 1 ≤ n ≤ 100,000,  -1,000,000 ≤ xi, yi ≤ 1,000,000,  1 ≤ pi ≤ 100 )
<출력값>
한 줄에 농구골대를 세워야 하는 마을의 위치를 출력한다. 만약 답이 되는 여러 개의 마을이 존재한다면 우선 x좌표가 가장 작은 마을을, 그리고 y좌표가 가장 작은 마을을 출력한다.

<문제 2376>
n개의 단말 정점을 갖는 루트가 있는 이진 트리(Rooted binary tree)가 있다. 단말 정점은 자식 정점이 없는 정점을 말한다. 주어진 트리를 인오더로 탐색하였을 때 단말 정점들이 나오는 순서대로 단말 정점들에 1, 2, …, n의 번호가 붙어 있다. 주어진 트리에서 만약 어떤 정점에 자식 정점이 있다면, 그 정점은 반드시 두 개의 자식 정점을 갖는다고 하자.
n보다 작은 자연수 k에 대해서, 우리는 k번 단말 정점과 k+1번 단말 정점의 거리를 알고 있다. 이러한 정보를 알고 있으면, 이를 이용하여 임의의 두 단말 정점 사이의 거리를 알 수 있다. 이를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 단말 정점의 개수 n(2≤n≤1,000)이 주어진다. 다음 n-1개의 줄에는 차례로 1, 2번 단말 정점 사이의 거리, 2, 3번 단말 정점 사이의 거리, …, n-1, n번 단말 정점 사이의 거리가 주어진다. 다음 줄에는 거리를 알고자 하는 서로 다른 두 단말 정점의 번호가 주어진다.
<출력값>
첫째 줄에 거리를 출력한다.

<문제 2378>
현재 사용되고 있는 폰노이만 컴퓨터에서는 난수(random number)를 만들어낼 수 없다. 따라서 난수를 얻고자 할 때는 수들을 규칙적으로, 하지만 뒤섞인 순서로 나열하는 방법을 사용한다. 실수 범위의 난수는 다루기가 복잡하므로, 이 문제에서는 음 아닌 정수만을 고려하자.
당신은 좀 더 난수에 가까운 수를 얻고자 다음과 같은 방법을 고안했다. 당신은 0이상 M이하의 난수를 얻고 싶은데, 이를 위해 0이상 M이하의 난수 N개 R[1], R[2], …, R[N]을 만든다. 다음으로 이 수열에서 인접한 두 수들의 합으로 된 합수열을 만든다. 위의 수열의 합수열은 R[1]+R[2], R[2]+R[3], …, R[N-1]+R[N]이 된다. 이와 같은 합수열을 만들면 수열의 길이가 N-1이 되는데, 합수열의 합수열을 구하는 과정을 반복하여 합수열의 길이가 1이 될 때까지, 즉 한 개의 수가 남을 때까지 반복한다. 이때 남은 수를 M으로 나눈 나머지를 구하면 우리가 만들고자 하는 난수가 된다.
하지만 이와 같은 방법에서, 어떤 N과 M에 대해서는 불필요한 수가 생기기도 한다. R[i] (1≤i≤N)가 어떤 값이더라도 최종적으로 얻은 난수가 같다면 i번째 수는 불필요한 수가 된다. 예를 들어 N=3, M=2일 때는 R[2]의 값에 상관없는 난수가 만들어진다.
N과 M이 주어졌을 때 불필요한 수의 개수를 세고, 구체적으로 어떤 수들이 불필요한 수인지 알아내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 두 정수 N(1≤N≤100,000), M(2≤M≤1,000,000,000)이 주어진다.
<출력값>
첫째 줄에 불필요한 수의 개수 K를 출력한다. 다음 줄에는 불필요한 K개의 수들의 index(위에서의 i)를 출력한다. index는 순서대로 출력한다.

<문제 2379>
n개의 정점으로 이루어진 트리가 있다. 이와 같은 트리를 DFS와 비슷한 방식으로 탐색하려 한다. 탐색을 시작할 때에는 트리의 한 정점에서 시작하여, 한 번도 지나지 않은 간선을 따라서 다음 정점으로 이동한다. 이때 한 번도 지나지 않은 간선이 여러 개 존재한다면 그 중 하나를 임의로 선택한다. 만약 한 번도 지나지 않은 간선이 존재하지 않는다면, 전 단계로 돌아간다. 이와 같은 과정을 반복하면 모든 간선을 두 번씩 지나게 된다.
이와 같은 탐색을 할 때, 시작 정점에서 멀어질 때 0을, 시작 정점에 가까워 질 때 1을 적으면 경로를 얻을 수 있다. 하지만 이와 같은 경로 저장 방식을 사용하면, 같은 트리라 하더라도 여러 개의 경로로 저장될 수 있다.

예를 들어 위와 같은 트리를 살펴보면, 0010011101001011, 0100011011001011, 0100101100100111 등의 경로로 탐색될 수 있다. 탐색 시작 정점은 그림에서 크게 표시된 정점이다.
트리를 탐색한 경로가 두 개 주어졌을 때, 이 경로들이 같은 트리를 탐색한 것인지 알아내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 데이터의 개수 T(1≤T≤10)이 주어진다. 다음 2×T개의 줄에는 트리를 탐색한 경로가 주어진다. 경로의 길이는 3,000을 넘지 않는다.
<출력값>
입력 데이터 순서대로 T개의 줄에 출력을 하는데, 만약 같은 트리라면 1을, 다른 트리라면 0을 출력한다.

<문제 2381>
N(1 ≤ N ≤ 50,000)개의 점들이 있을 때, 최대 L1-metric 거리를 찾으시오.
두 점의 좌표가 (a, b), (c, d)일 때, 두 점의 L1-metric 거리는 |a-c|+|b-d|이다.
<입력값>
첫째 줄에 N이 주어진다. 다음 N개의 줄에는 각 점의 x, y좌표가 주어진다. 각 좌표의 범위는 -1,000,000이상 1,000,000이하이다.
<출력값>
첫째 줄에 최대 거리를 출력한다.

<문제 2382>
인터넷을 사용해 본 사람이라면 사용자가 원하는 조건에 맞춰 페이지를 찾아주는 검색 엔진에 익숙하다. 많은 수의  이런 엔진들은 좀 더 빠르고 정확한 응답을 위해 개량된 알고리즘과 병렬 검색 기법 등 복잡한 알고리즘을 이용한다.
이번 문제는 다소 간단하다. 한 그룹의 웹 페이지들은 각각의 페이지마다 몇 개의 키워드로 분류되었다. 한 웹 페이지에서의 키워드들은 연관성 순서에 따라 내림차순으로 정렬되어 있다. 예를 들어 Smalltalk에서의 programming를 다룬 페이지는 Smalltalk, programming, computer의 세 개의 키워드를 순서대로 가지고 있다. 이때 가장 연관있는 단어는 Smalltalk이다.
질의 역시 연관성의 내림차순 순서로 정렬된 몇 개의 키워드로 구성되어 있다. 만약 질의에서 Smalltalk가 먼저 나오고 computer가 뒤따라 나왔다면 Smalltalk는 computer보다 더 중요한 키워드이다.
이 문제에서 당신은 각각의 질의에 대해 질의와 일치하는 상위 5개(또는 그 이하)의 페이지를 결정해야 한다. 질의와 페이지의 연관 지수를 계산하기 위해 각각의 페이지와 질의의 각 키워드에 대해 정수의 가중치가 부여되었다고 가정하자. 가장 처음에 나온 키워드의 가중치는 N이고(또한 N은 페이지와 질의에 쓰일 수 있는 최대 키워드 개수이기도 하다), 다음 단어부터는 가중치가 1씩 줄어든다. 연관 지수는 각 키워드의 가중치의 곱(페이지의 키워드 가중치×질의의 키워드 가중치)들의 합이다. 예를 들어 다음과 같은 페이지와 키워드가 있다고 하자.

Page 1: Smalltalk, programming, computers
Page 2: computers, programming
Page 3: computers, Smalltalk

N은 8이라고 할 때 Smalltalk와 programming으로 되어 있는 질의에 대해 각 페이지의 연관 지수는 페이지 1 → 113(=8×8+7×7), 페이지 2 → 49(=7×7), 페이지 3 → 56(=8×7)이다. 한편, Smalltalk와 computers로 되어있는 질의에 대해서는 페이지 1 → 106(=8×8+7×6), 페이지 2 → 56(=7×8), 페이지 3 → 112(=8×7+7×8)의 연관 지수를 가진다.
<입력값>
입력 데이터는 각각의 웹 페이지와 질의에 대해 한 줄씩으로 구성되어 있다. 각 줄은 식별문자와 키워드 목록으로 되어있다. 식별문자 P, Q, E는 각각 페이지, 질의, 파일 끝을 나타낸다. 식별문자와 키워드 사이에는 하나 이상의 공백문자가 있다. P와 Q는 임의의 순서대로 나타날 수 있다. 페이지는 입력 파일의 순서대로 번호가 부여된다. 각각의 페이지는 최소 하나 이상의 키워드가 있되 8개를 넘어가지 않는다. 각각의 키워드는 20문자를 넘어가지 않는다. 대소문자 구분은 중요하지 않다. 입력에는 최대 25개의 페이지가 올 수 있다.
각각의 질의 또한 1개부터 8개 사이의 키워드로 되어 있다. 역시 각각의 키워드는 20문자를 넘어가지 않고, 대소문자 구별은 하지 않는다. 질의는 입력 파일의 순서대로 번호가 부여된다.
<출력값>
각각의 질의에 대해 연관성이 큰 5개(또는 그 이하)의 페이지를 연관성의 내림차순 순으로 출력한다. 각 줄에는 질의 식별자, 콜론(:), 연관성이 큰 페이지 식별자 5개의 순서대로 출력한다. 페이지 식별자는 “P#”(단, #은 페이지 번호), 질의 식별자는 “Q#”(단, #은 질의 번호)의 형태로 출력한다. 만약 여러 페이지가 같은 연관 지수를 가지고 있다면 페이지 번호 순서대로 출력한다. 관계없는 페이지(즉, 연관 지수가 0인 페이지)는 절대로 출력하지 않는다.

<문제 2383>
노르웨이에는 땅과 피오르드(강이라고 생각하면 된다)가 반복되며 나타난다. 따라서 이동을 하기 위해서는 땅에서는 운전을 하고, 피오르드에서는 이미 갖춰진 배들을 이용하여 건너야 한다.
가장 빠른 시간에 이동하는 방법은, 땅에서는 최고 속도인 80km/h로 운전을 하고, 피오르드에 도착해 배를 기다리고, 배를 타고 다음 위치로 가서 반복하는 것이다. 하지만 이와 같이 이동하는 것은 비싸기도 하고, 환경 친화적이지도 않다. 따라서 당신은 우선 가장 빠른 시간에 이동하는 방법을 찾고, 그와 동시에 운전 속도도 최소화해야 한다.
<입력값>
입력 파일에는 여러 개의 데이터가 들어 있다. 첫째 줄에는 s(s>0)가 주어진다. 이는 이동할 때의 구역의 개수이다. 다음 s개의 줄에는 각 구역에 대한 정보가 이동해야 하는 순서대로 주어져 있다. 각 구역에 대한 정보는 시작 위치와 끝 위치의 이름으로 시작된다. 그 다음에는 땅이라면 road, 피오르드라면 ferry가 주어진다.
Dryna Solholmen road 32
road의 경우에는 그 다음에 양의 정수로 땅의 길이가 km단위로 주어진다. 위의 예는 Dryna에서 Solholmen까지는 땅으로 되어 있으며 그 길이는 32km라는 것이다.
Manhiller Fodnes ferry 20 2 15 35
ferry의 경우에는 우선 배를 타고 건너는 시간이 양의 정수로 주어진다. 이 시간의 단위는 분으로, 위의 예에서는 20분이 된다. 다음 수 f(f>0)는 각 시간에 운행되는 배의 개수이다. 다음 f개의 정수들은 각 배가 출발하는 시간이 분으로 주어진다. 위의 예에서는 배들이 0:15, 0:35, 1:15, 1:35, 2:15, … 와 같이 운행된다는 의미이다. 이 f개의 정수들은 증가하는 순서로 입력된다.
각각의 데이터는 총 이동 시간이 10시간을 넘지 않도록 설계되어 있다. 또한 이동은 항상 정각(x시 0분)에 시작된다고 가정하자. 만약 s=0이 주어지면 입력이 끝난 것이다.
<출력값>
각 줄에 데이터 번호, 최소 이동 시간, 이동 시간이 최소일 때의 최소 운전 속도를 출력한다. 속도는 소수점 아래 셋째 자리에서 반올림해서 출력한다.

<문제 2384>
On the table in front of you lie a bunch of pieces of coloured thread. All the threads are different colours and the ends have been arranged in a single line, for example red, blue, green, green, blue, red. Note that each colour appears exactly twice, once for each end of that thread. You've been asked to tie the threads into a single large loop by successively tying together ends of some pair of adjacent threads. In the above example you could start by tying end 1 to end 2 or end 2 to end 3 but not end 3 to end 4 since that would make a green loop. Likewise, if your first tie was red to blue, then your second tie could not join the remaining red and blue.
Finding the job a little boring, you decide instead to count the number of ways in which you could perform the task, i.e. the number of sequences of ties that you could do. For instance, suppose that the initial pattern was rrbb, then there is only one allowed sequence of ties (join the middle two, then join the two remaining). On the other hand if it were rbrb, then there are three allowed sequences (join any consecutive pair to begin with, then join the remaining two).
Likewise you can see that if the initial pattern were rgrbgb, then four of your initial ties lead to a subsequent pattern of the general form abab, while one leads to abba. Thus there are 4x3 + 1x2 = 14 ways to complete the ties in this case.
<입력값>
Input will consist of a sequence of colour patterns represented by words of length at most 22 consisting of lower case letters and will be terminated by a line containing the single character '#'.
<출력값>
Output will be a sequence of lines, one for each line in the input, each containing a the number of ways to tie off the pattern in the corresponding input line. If an input line is invalid (because it does not contain exactly two occurrences of each of its characters) the output for that line should be 0.

<문제 2385>
일반적으로, 대부분의  암호알고리즘은 단 하나만의 암호 키를 사용해서 암호화 파일을 해독한다. 만약 공격자가 해킹으로 암호 키를 취득하게 되면, 정보가 샐 위험이 있게 된다. 이를 막기 위해 고안된 것이 “Secret sharing”이란 기술이다.
“Secret Sharing“은 암호 키를 그룹에 있는 여러 사람에게 키를 나눠서 저장하는 방법이다.”Secret sharing“ 에서는 암호 키를 N개의 조각으로 분리하고 각각의 조각들은 share라고 부른다.
N개의 모든 조각을 얻지 못하면 암호 키를 복원할 수 없다.  예를 들면 'password'란 암호 키를 4개의 share들(pa, ss, wo, rd)로 나눌 때, 모든 share들이 있어야만 ‘password’란 암호 키를 복원해 낼 수 있다. 그리고, 암호를 복원할 때에는 모든 share뿐 아니라 share의 순서를 알아야만 한다. 만약 순서를 모른다면 ‘wosspard' 나 ’pawordss' 같은 잘못된 암호 키를 복원 해낼 수도 있기 때문이다.
최근, 새로운 암호 알고리즘에서는 매우 긴 10진수를 암호 키로 쓴다. 암호 키는 0이 아닌 숫자로 시작 되며, 그 암호 키는 여러 개의 share들로 분할된다. 이 share들의 순서는 매우 간단한 방법으로 되어있다. 모든 share를 써서 만들 수 있는 모든 키중 가장 작은 값이 암호 키가 되는 것이다. 예를 들면 2, 4, 11, 33, 00 이라는 5개의 share가 있다면 암호 키는 11002334 가 된다. (00112334 는 0으로 시작하기 때문에 암호 키가 될 수 없다).
N개의 share들로부터 암호 키를 복원해내는 프로그램을 작성하여 보자.
<입력값>
첫 번째 줄에는 share들의 개수 N(1≤N≤100)이 주어지고, 다음 줄에는 5자리 이하인 N개의 조각들이 입력으로 주어진다.
<출력값>
암호 키를 한 줄에 출력한다. 단, 위의 조건을 만족하는 암호 키가 존재하지 않는다면 “INVALID”를 출력한다.﻿

<문제 2386>
꿍은 도비의 자유를 위해 영어를 가르치기로 결심했다. 하지만 도비는 바보라 ABC부터 배워야 한다.
그래서 꿍은 영어 문장과 알파벳 하나가 주어지면 그 알파벳이 문장에서 몇 번 나타나는지를 세는 문제들을 내주었다. 하지만 도비는 마법사고 컴공도 마법사다.
여러분은 도비를 위해 문제의 답을 알려주는 프로그램을 만들수 있을것이다!
<입력값>
입력은 몇 개의 줄들로 이루어진다.
각 줄에는 하나의 소문자와 영어 문장이 공백으로 구분되어 주어진다.
각 문장은 길이가 1에서 250이며 입력의 마지막은 #이다.
<출력값>
출력의 각 줄은 입력으로 주어진 소문자와 그 소문자 알파벳이 나타난 횟수로 이루어진다. 이때 문장에서 해당 알파벳이 소문자로 나타나던 대문자로 나타나던 모두 세야 한다.

<문제 2388>
영수는 가로 N, 세로 M 크기의 판 위에, 각 변의 길이가 1인 정육면체 블록을 쌓는 놀이를 하고 있었다. 그러다가 중간에 잠시 중지할 일이 생겼는데, 나중에 계속 블록을 쌓기 위해 쌓아놓은 블록들을 앞면과 옆면에서 본 모습을 그려 두었다. 예를 들어 다음과 같은 예를 보자.

왼쪽은 앞에서 본 모습이고, 오른쪽은 옆에서 본 모습이다. 영수는 나중에 블록을 원래의 모습으로 복원하려고 했는데, 복원을 하다 보니 예전에 그려둔 그림만으로는 원래의 모습이 유일하게 결정되지 않음을 알게 되었다. 그래서 영수는 두 가지 경우를 생각해 보기로 했는데, 하나는 블록의 개수가 최대가 되는 경우이고, 다른 하나는 블록의 개수가 최소가 되는 경우이다.

왼쪽은 위의 그림을 바탕으로 블록의 개수가 최대가 되도록 쌓은 경우고, 가운데는 최소가 되도록 쌓은 모습이다. 오른쪽 그림은 최소가 될 때의 모습을 뒤에서 본 것이다. 최대는 21개의 블록이 필요하고, 최소는 10개의 블록이 필요하다.
<입력값>
첫째 줄에 두 정수 N, M(1 ≤ N, M ≤ 100,000)이 주어진다. 다음에는 N개의 정수로, 쌓아 놓은 블록을 앞에서 보았을 때의 모습이 한 줄에 하나씩 주어진다. 이는 왼쪽부터 차례로 높이를 나타낸다. 같은 방식으로 M개의 정수로 각각의 높이가 한 줄에 하나씩 주어진다. 각각의 높이는 231-1을 넘지 않는다.
<출력값>
첫째 줄에 최소 블록, 최대 블록을 출력한다. 답은 231-1을 넘지 않으며, 만약 불가능한 경우가 주어지면 -1을 출력한다.

<문제 2389>
위대한 뮤지션 김동혁은 그의 팬들을 위한 공연을 하기로 하였다. 그는 관객과 함께하는 공연을 기획하기 위해 원형 모양의 콘서트홀을 만들기로 하였다.
N명의 팬들은 (x, y)좌표를 갖는 곳에 있다. 김동혁은 N명의 사람들을 모두 포함하는 원(원의 경계에 있는경우도 포함하는 경우로 치자)의 가운데에서 공연을 하려 한다. 이때 원의 반지름을 최소 얼마로 하면 되겠는가?
김동혁이 세상의 중심에서 락을 외칠 수 있도록 도와 주는 프로그램을 작성해 보자.
<입력값>
첫째 줄에 N(1≤N≤100)이 주어진다. 다음 N개의 줄에는 x, y 좌표가 주어진다. 각각의 좌표는 소수점 여섯째자리까지 주어지며, -600,000 ≤ x, y ≤ 600,000을 만족한다.
<출력값>
첫째 줄에 김동혁의 x좌표, y좌표, 원의 반지름을 출력한다. 절대/상대 오차는 10-3까지 허용한다.

<문제 2391>
Chinese people are known for their difficulty with pronouncing the "R". Often the "R" is replaced by the "L", like in "radio", which becomes "ladio". Especially when a secondary language is involved, the examples become very colourful. For example, in Spanish the "V" is pronounced like a soft "B". In South-America it is most disturbing to hear a Dutch young couple shout " Famos, Famos!". To give another well-known example, the English pronunciation of "th" is in The Netherlands often replaced by a loud "S", which results, for example, in announcing the program "NorS and SouS".
At a young age, children often have diffculties with certain letters as well (although luckily, they usually get over it quite soon). Sascha, a 3 year old girl, also doesn’t succeed in pronouncing a number of letters. She just replaces them with another letter which she finds easier to pronounce. It became a problem when she started to replace many letters by the same letter. This forced her parents to use a lot of creativity and imagination when trying to figure out what the original word was that she meant. Additional skills were required when they noticed that her "replacement"-rules weren't consistent. For example, Sascha can clearly pronounce an "R" at the beginning of a word, while substituting the "R" in the middle of a word. This can even happen within the same word!
Your job is to write a translation program to figure out the original word Sascha wanted to say. You have to find the most likely word, given a dictionary of proper words. The most likely word is the word in the dictionary that can be found with the least number of substitutions. A substitution consists of replacing a single letter by another letter. The different letters which cause speech difficulties are not given. Neither is the replacement letter.
<입력값>
The first line of input consists of the integer number n (0 < n ≤ 10000), the number of test cases;
Then, for each test case:
	
One line with the word as Sascha pronounced it;
One line with an integer w (0 < w ≤ 10000), the number of words in the dictionary;
Then w lines with one word each: the dictionary.



All words consist of lower case letters and never exceed 128 characters in length. All words in the dictionary have the same length as the word that Sascha pronounced.
<출력값>
For each test case, the output contains one line with one word: the word that Sascha most likely meant to say. When multiple words would be possible, a word that appears earlier in the dictionary is more likely.

<문제 2392>
정 N각형의 꼭짓점에서 다른 꼭짓점을 잇는 선분을 그으면 주어진 다각형을 삼각형이나 사각형으로 나눌 수 있다. 이와 같은 선분들은 교차해서는 안 된다. N이 주어졌을 때, 가능한 삼각분할의 경우의 수와 사각분할의 경우의 수를 구하는 프로그램을 작성하시오. 회전, 또는 대칭을 이용한 경우에는 같은 것으로 세지 않고 다른 것으로 센다.
<입력값>
첫째 줄에 N(1≤N≤1,000)이 주어진다. 답이 커질 수 있으므로 1,000,000,000으로 나눈 나머지를 출력한다.
<출력값>
첫째 줄에 삼각 분할의 경우의 수를, 둘째 줄에 사각 분할의 경우의 수를 출력한다.

<문제 2394>
N(3≤N≤256)개의 도시로 이루어진 나라가 있다. 이들 중 몇 개의 도시들은 서로 도로로 연결되어 있다. 당신은 당신의 취미 생활인 자동차 드라이브를 즐기려고 한다. 각각의 도시는 1, 2, 3, …, N의 번호가 붙어 있고, 현재 당신은 1번 도시에 위치하고 있다. 당신은 N번 도시까지 갔다가 다시 돌아오고자 한다.
1번 도시에서 N번 도시로 갈 때에는 도시의 번호가 증가하는 순서로 가려고 하며, N번 도시에서 1번 도시로 돌아올 때에는 도시의 번호가 감소하는 순서로 가려고 한다. 또한, 갈 때 방문했던 도시를 올 때에 다시 방문할 수는 없다.
도로에 대한 정보가 주어졌을 때, 최대한 많은 도시를 방문하는 드라이브 경로를 찾으라.
<입력값>
첫째 줄에 N이 주어진다. 다음 줄부터는 도로에 대한 정보를 나타내는 두 자연수 P, Q가 주어진다. 이는 P번 도시와 Q번 도시 사이에 도로가 있음을 의미한다. P=Q=0이 입력으로 주어지면 입력의 끝을 나타낸다.
<출력값>
첫째 줄에 방문한 도시의 개수를 출력한다. 다음 줄에는 드라이브 경로를 출력한다. 1번 도시에서 N번에 갔다가 다시 돌아올 수 없는 경우에는 0을 출력한다.

<문제 2395>
A = (a1, a2, …, an)을 n개의 원소를 가진 집합 X = {1,2,3,…,n}의 순열이라고 하자. 즉, i ≠ j이면, ai ≠ aj이고 (1 ≤ i, j ≤ n), 모든 i (1 ≤ i ≤ n)에 대해서 ai∈X이다. 순열 A에 대해서 수열 P(A) = (p1, p2, …, Pn-1)을 다음과 같이 정의한다.
만약 ai > ai+1이면, pi = 0이고, 그렇지 않으면 pi = 1이다. (1 ≤ i ≤ n-1). 문제는 n과 순열 A가 주어질 때, P(A) = P(B)를 만족하는 순열의 수를 구하여 출력하는 것이다.
예를 들어 A=(1,3,2,4)이라면, P(A) = (1,0,1)이다. 아래와 같은 순열 B에 대해서 P(A)=P(B)가 성립한다.
(1,3,2,4),(1,4,2,3),(2,3,1,4),(2,4,1,3),(3,4,1,2)
<입력값>
첫째 줄에 집합 X의 크기 n이 주어진다. n은 5,000이하인 양의 정수이다. 둘째 줄에 X의 순열 하나가 주어진다. 순열은 n개의 정수로 나타내고, 이들 사이에 공백이 있다.
<출력값>
첫째 줄에 주어진 순열 A에 대하여 P(A)=P(B)를 만족하는 순열의 수를 출력한다. 이때  A 자신도 순열의 수를 헤아릴 때 포함시킨다. 답이 매우 클 수 있으니 1,000,000,000으로 나눈 나머지만 출력한다.

<문제 2396>
승연이는 길이가 정수인 동일한 막대기를 여러 개 가지고 있는데, 이 막대기들을 각각 정수의 길이를 갖는 여러 개의 토막으로 아무렇게나 잘랐다. 단, 어떤 막대기는 자르지 않을 수도 있다. 승연이는 이렇게 잘려진 토막들을 다시 붙여서 원래 상태의 막대기로 만들려고 하는데 원래 자기가 가지고 있던 막대기의 수와 막대기의 길이를 잊어버렸다. 그래서 승연이는 길이가 모두 같은 가장 짧은 막대기들로 복원하기로 하였다.
문제는 잘려진 모든 토막으로부터 구성될 수 있는 같은 길이의 막대기 중에서 가장 짧은 길이를 계산하는 프로그램을 작성하는 것이다.
아래 <그림>의 예에서 보듯이 같은 막대기 몇 개를 잘라서 길이가 {5,2,1,1,2,5,2,5,1}인 토막으로 만들었다. 문제는 이 토막들로부터 구할 수 있는 같은 길이의 막대기 중에서 가장 짧은 것을 구하는 것이다. 아래 그림의 예에서 길이가 12인 긴 막대기 2개를 만들 수도 있으나 가장 짧은 동일한 막대기들의 길이는 6이 된다.
<입력값>
입력은 두 줄로 구성된다. 입력 파일의 첫째 줄에는 잘려진 토막들의 총 수를 나타낸다. 두 번째 줄에는 작게 잘라진 토막들의 각 길이를 나타내는 정수가 나열된다. 각 토막의 길이를 나타내는 숫자 사이에는 하나씩의 공백이 있다. 각 토막의 길이 i 은 2≤i≤50 인 정수이다.
<출력값>
첫째 줄에 복구된 막대기들의 길이를 나타내는 정수를 출력한다.

<문제 2397>
평면상에 N개의 직교 정사각형이 있다. 직교라는 말의 의미는 정사각형의 각 변이 모두 축(x축, y축)에 평행하다는 의미이다. 정사각형의 각 꼭짓점은 정수이며, 정사각형들끼리 닿아 있거나 겹치는 경우는 없다.
이러한 사각형들이 주어졌을 때, 원점 O(0, 0)에서 보이는 정사각형의 개수를 세는 프로그램을 작성하시오.
정사각형의 테두리에 있는 서로 다른 두 점 A, B에 대해서 삼각형 OAB의 내부(삼각형의 경계를 제외하고)에 다른 사각형이 지나지 않을 경우, 그 사각형이 원점에서 보인다고 정의하자.
<입력값>
첫째 줄에 N(1≤N≤1,000)이 주어진다. 다음 N개의 줄에는 각 직교 정사각형을 나타내는 세 정수 X, Y, L(1≤X, Y, L≤10,000)이 주어진다. 이는 사각형의 왼쪽 아래 좌표가 (X, Y)이고 변의 길이가 L이라는 의미이다.
<출력값>
첫째 줄에 보이는 정사각형의 개수를 출력한다.

<문제 2398>
코리아 통신회사에서는 3인통화 서비스를 제공한다. 이 서비스에서는 두 사람이 아니라 세 사람이 통화할 수 있도록 해준다. 전화망은 스위치들을 연결하여 구성되어 있으며, 각 통화자들은 스위치에 연결하여 전화망에 접속한다. 두 스위치들은 양방향으로 신호를 보낼 수 있는 링크에 의하여 연결되어 있다. 모든 스위치들은 전화망에 의하여 연결되어 있어서 스위치에 접속한 사람들은 다른 스위치에 연결한 사람과 항상 통화할 수 있다. 전화망에서 두 개의 스위치를 연결하는 링크를 사용하는 비용은 주어져 있다.
통신회사에서는 이들 세 사람을 전화망을 통하여 연결해주는데, 가장 비용이 적게 되도록 연결하고자한다. 세 사람이 연결한 스위치가 주어졌을 때, 이 스위치들을 비용이 가장 적게 되도록 연결하는 프로그램을 작성하시오.
<입력값>
첫 번째 줄에는 두 개의 정수가 있다. 첫 번째 정수 n(1<=n<=1000) 는 전화망에 있는 스위치의 개수를 나타내며, 두 번째 정수 m은 스위치와 스위치를 연결하는 링크의 개수를 나타낸다. 단, 같은 스위치들을 연결하는 링크는 1 개 이상 존재하지 않는다. 각 스위치들은 1번부터 차례로 n 번 까지 번호가 부여된다. 다음 m개의 줄에는, 각 줄에 세 개의 정수가 주어진다. 처음의 두 개의 정수는 하나의 링크에 의하여 연결되는 두 스위치의 번호를 나타내며, 세 번째 정수는 그 링크를 사용하는 비용을 나타내는 양의 정수이다. 이 정수는 100 보다 작다. 입력의 마지막 줄에는 세 개의 정수가 주어 진다. 이 정수는 세 명의 통화자가 연결되어 있는 스위치 번호이며, 세 정수는 모두 다르다.
<출력값>
첫 줄에는 3자 통화를 하는데 있어서 가장 적은 비용으로 통화할 때 드는 비용을 나타내는 정수와 세명의 통화자를 연결하는 네트워크 상에서의 링크의 수를 출력한다. 그 다음 줄부터 각 줄에는 하나의 링크에 연결되는 두 개의 스위치 번호를 출력한다. 비용이 최소가 되도록 연결하는 방법이 여러 가지인 경우에는 아무거나 출력한다.

<문제 2399>
수직선에 n개의 점이 찍혀 있다. 각각의 점의 x좌표가 주어졌을 때, n2개의 모든 쌍에 대해서 거리를 더한 값을 구하는 프로그램을 작성하시오.
즉, 모든 i, j에 대해서 |x[i] - x[j]|의 합을 구하는 것이다.
<입력값>
첫째 줄에 n(1 ≤ n ≤ 10,000)이 주어진다. 다음 줄에는 x[1], x[2], x[3], …, x[n]이 주어진다. 각각은 0 이상 1,000,000,000 이하의 정수이다.
<출력값>
첫째 줄에 답을 출력한다.

<문제 2401>
어떤 긴 문자열이 주어지고 여러 개의 짧은 문자열들이 주어질때 이때 짧은 문자열을 긴 문자열에 붙여 넣을때 가장 길게 붙여 넣는 경우를 찾아라. 단 이때 짧은 문자열들끼리는 교차 할 수 없다. (‘aabbc'  에  'aab' 와 'bbc' 둘 다 붙여 넣는 것은 불가능하다.) 또, 짧은 문자열은 여러 번 사용할 수 있다.
<입력값>
첫 번째 줄에는 가장 긴 문자열이 주어지고 두 번째 줄에는 짧은 문자열의 숫자 N(1 ≤ N ≤ 500)이 입력으로 주어진다. 세 번째 줄부터 N개의 줄에는 짧은 문자열이 주어진다.
가장 긴 문자열의 길이 L은 (1 ≤ L ≤ 100,000) 짧은 문자열의 길이 l은 (1 ≤ l ≤ 10,000)이다.
<출력값>
붙여 넣은 짧은 문자열들의 길이의 총합을 출력한다.

<문제 2402>
어느 두 사람이 질문자와 답변자가 되어 게임을 하고 있다. 게임을 위해 답변자에게 길이 N(1 ≤ N ≤ 1,000,000,000)의 이진 수열(0과 1로만 이루어진 수열)이 주어진다.
질문자는 M(1 ≤ M ≤ 5,000)번에 걸쳐 답변자에게 수열의 i번째 항부터 j번째 항까지 1이 짝수 번 나타나는지 홀수 번 나타나는지를 물어본다. 이는 i번째 항과 j번째 항을 포함시켜서 생각하는 것으로 한다. 1이 짝수 번 나타나는 경우에는 0이라고, 홀수 번 나타나는 경우에는 1이라고 답변자가 답한다.
이 게임의 목적은, 이런 식으로 질문과 답변을 진행하다가, 답변자가 몇 번째 질문에서 거짓말을 하였는지를 알아내는 것이다. 질문자와 답변자의 질문과 답이 주어졌을 때, 답변자가 몇 번째 질문에 대해 거짓말을 했는지를 알아내는 프로그램을 작성하시오.
답변자가 어느 질문에 대해 거짓말을 했다는 것은, 그 전 질문까지의 답변과 그 질문의 답변을 동시에 만족하는 이진 수열이 존재하지 않음을 의미한다.
<입력값>
첫째 줄에는 두 정수 N과 M이 주어진다. 다음 M개의 줄에는 질문과 답을 나타내는 3개의 정수가 주어진다. 첫 번째 정수는 i이며, 두 번째 정수는 j이다. 세 번째 정수는 그 질문에 대한 답변자의 답을 나타낸다.
<출력값>
첫째 줄에 몇 번째 질문에 대해 답변자가 거짓말을 했는지를 출력한다. 만약 답변자가 모든 질문에 대해 거짓말을 하지 않았다면 M+1을 출력한다.

<문제 2403>
교실 게시판에 압정을 사용하여 만들어진 구멍들을 안보이게 하기 위해서 두 개의 같은 크기의 정사각형 모양의 종이로 가리려고 한다. 두 종이는 서로 떨어져도 되고 서로 겹치는 부분이 있어도 상관없지만 모든 구멍들을 포함해야 한다. 단, 각 구멍은 크기가 매우 작아,  x, y 좌표로 표현되는 점으로 표현되고, 구멍이 종이의 경계나 모서리에 놓이는 것도 종이에 포함되는 것으로 한다.  게시판에 각 구멍의 위치가 주어지고, 두 종이가  모두 게시판의 틀에 대해서 수평과 수직으로 놓인다고 할 때,  모든 구멍을 가리는 가장 작은 정사각형 모양의 종이의 크기를 구하시오.
구멍의 위치를 표시하기 위해서 게시판의 왼쪽 아래 모서리를 기준으로 오른쪽으로 갈수록 x좌표가 커지고 위로 갈수록 y 좌표가 커지는 좌표계를 이용한다.
<입력값>
첫째 줄에는 구멍의 개수인 n이 주어지고 (1≤n≤1000), 다음 n개의 줄에는 구멍의 위치로 x 좌표와 y 좌표가 주어진다.
<출력값>
첫째 줄에는 종이의 변의 길이를 출력하고 둘째 줄에는 한 종이의 왼쪽 아래 모서리의 위치를, 셋째 줄에는 다른 종이의 왼쪽 아래 모서리의 위치를 x좌표와 y좌표로 출력한다.

<문제 2404>
분수 중에서 분자가 1이고 분모가 양수인 것을 단위분수라고 한다. 분수 p/q를 유한개의 단위분수의 합으로 나타내었을 때 p/q를 단위분수로 분할했다고 말한다. 예를 들면 2/3는 1/2+1/6으로 분할 할 수 있다. 분할에서 더하기의 순서만 바뀐 것은 고려하지 않는다. 예를 들면 1/6+1/2와 1/2+1/6은 같은 분할로 본다.
네 개의 양의정수 p, q, a, n이 주어졌을 때 다음 두 조건을 만족하는 p/q의 분할의 개수를 구하여라.

n개 이하의 단위분수의 합으로 나타내야 한다.
분할을 이루는 단위분수의 분모의 크기의 곱은 a보다 작거나 같아야 한다.

예를 들어 만약 (p, q, a, n)이 (2, 3, 120, 3)일 때 답은 4가 되어야 한다.
2/3 = 1/3+1/3 = 1/2+1/6 = 1/4+1/4+1/6 = 1/3+1/6+1/6
<입력값>
첫째 줄에 양의 정수 p, q, a, n이 입력된다. (p, q <= 800, a <= 12000, n <= 7)
<출력값>
첫째 줄에 문제의 조건을 만족하는 분할의 개수를 출력한다.

<문제 2405>
n개의 정수 A[1], A[2], …, A[n]이 있다. 서로 다른 세 정수 i, j, k에 대해서 a = A[i], b = A[j], c = A[k]라 하자. 세 수의 중위(Median)값은 정렬했을 때 가운데에 오는 수가 된다. 세 수의 평균(Mean)값은 (a+b+c)÷3이 된다.
만약 세 수가 5, 2, 5라면 중위값은 5, 평균값은 4가 된다. 세 수가 2, 3, 1이라면 중위값은 2, 평균값도 2가 된다.
n개의 수들이 주어졌을 때, 위와 같이 세 수를 선택하여(i, j, k가 서로 다르도록) 중위값과 평균값의 차이가 최대가 되도록 해 보시오.
<입력값>
첫째 줄에 정수 n(3≤n≤100,000)이 주어진다. 다음 n개의 줄에는 n개의 정수들이 주어진다. 각 수들의 절댓값은 100,000,000을 넘지 않는다.
<출력값>
첫째 줄에 중위값과 평균값의 차이를 세 배 한 값을 출력한다.

<문제 2406>
한 회사는 본사와 지사의 컴퓨터들을 연결하는 네트워크 시설을 보유하고 있다. 각 지사에는 네트워크용 컴퓨터가 한 대씩 있으며, 이들은 본사의 메인 컴퓨터와 직접 연결되어 있다. 몇몇 지사들끼리 연결되어 있는 경우도 있다.
네트워크 시설에서는 두 컴퓨터가 직접 연결되어 있지 않더라도 다른 컴퓨터들을 경유하여 연결될 수 있다. 예를 들어 1, 2번 컴퓨터가 직접 연결되어 있고, 1, 3번 컴퓨터가 직접 연결되어 있다면, 이것은 2, 3번 컴퓨터가 연결되어 있는 효과도 발휘한다는 것이다.
회사 측에서는 네트워크에 고장이 발생하더라도 컴퓨터들이 연결되어 있도록 안정적인 네트워크를 구축하고자 한다. 네트워크에 고장이 발생하는 경우는 두 가지가 있다. 첫 번째는 직접 연결되어 있는 두 컴퓨터의 연결이 끊어지는 경우이다. 회사 측은 이런 경우에도 이 두 컴퓨터가 다른 컴퓨터들을 경유하여 연결되어 있기를 원한다. 두 번째는 컴퓨터가 고장 나는 경우이다. 회사 측은 이런 경우에는 고장 나지 않은 컴퓨터들끼리 연결되어 있기를 원한다.
예제로 주어진 입력에서 1, 2번 컴퓨터의 연결이 끊어지더라도, 이 두 컴퓨터는 3번 컴퓨터를 통해서 연결되게 된다. 하지만 1번 컴퓨터가 고장 나는 경우에는 5번 컴퓨터가 다른 컴퓨터들과 연결되어 있지 못하게 된다. 따라서 5번 컴퓨터를 다른 컴퓨터와 직접 연결해 주어야 한다.
두 컴퓨터를 연결하는 데 소요되는 비용은 일정하지 않다. 당신은 네트워크의 연결 상태를 입력받아 이 네트워크가 안정적인 네트워크인지 판별하고, 만약 아닐 경우에는 최소 비용으로 회사의 네트워크가 안정적이 되도록 하여야 한다.
<입력값>
첫째 줄에 두 정수 n(1≤n≤1,000), m이 주어진다. n은 컴퓨터의 개수이며, m은 연결되어 있는 지사 컴퓨터들의 쌍의 개수이다. 다음 m개의 줄에는 두 정수 x, y가 주어진다. 이는 서로 다른 두 컴퓨터, x번 컴퓨터와 y번 컴퓨터가 직접 연결되어 있음을 의미한다. 다음 n개의 줄에는 인접 행렬의 형태로 두 컴퓨터를 연결할 때 드는 비용이 주어진다. 이 값은 1 이상 30,000이하의 정수이며, i번 컴퓨터와 j번 컴퓨터를 연결할 때 드는 비용은 j번 컴퓨터와 i번 컴퓨터를 연결할 때 드는 비용과 같다. 본사의 컴퓨터는 항상 1번 컴퓨터이다.
<출력값>
첫째 줄에 최소 비용 X와 연결할 컴퓨터들의 쌍의 개수 K를 출력한다. 다음 K개의 줄에는 두 정수로 연결할 컴퓨터들의 번호를 출력한다. 만약 주어진 입력이 안정적인 네트워크라면 X=0이고 K=0이 된다.

<문제 2407>
nCm을 출력한다.
<입력값>
n과 m이 주어진다. (5 ≤ n ≤ 100, 5 ≤ m ≤ 100, m ≤ n)
<출력값>
nCm을 출력한다.

<문제 2408>
어떤 임의의 수식이 입력으로 들어올때 수식을 계산하는 프로그램을 짜시오. 단 수 하나하나의 크기는 -10100 이상 10100이하 이다. 단, 수식에 괄호는 없다고 가정한다.
소수점이 나올 경우, 소수점은 내린다. 참고로, -5/2 = -3이고, 5/-2도 -3이다. -5/-2는 2이다.
<입력값>
수의 개수 N(1 ≤ N ≤ 10) 이 주어지고 다음 2＊N - 1 줄에는 수와 연산자(+, -, *, /) 가 번갈아서 들어온다.
<출력값>
한 줄에 계산이 끝난 후 수를 출력한다.

<문제 2409>
동혁건설에서는 이번에 새로운 건물을 짓게 되었다. 건물을 만들기 위해서는 짧은 길이의 강철 파이프가 N개 필요하다. 마침 공사 때 사용하고 남은 긴 길이의 파이프가 M개 있어서 이를 먼저 사용한 뒤 필요한 파이프를 추가 주문하기로 하였다. 동혁건설에서는 가급적이면 적은 개수의 파이프를 추가 주문하려 한다. 즉, 주어진 강철 파이프를 잘라서 최대한 많은 개수의 필요한 파이프를 만들어 내려 한다.
작은 길이의 파이프를 만들기 위해서는 긴 길이의 파이프를 자르면 된다. 자르는 과정에서 파이프의 길이에 손실이 있을 수도 있지만, 문제에서는 이를 무시해도 좋다. 또한, 파이프를 자를 때에는 여러 번 자를 수도 있다.
<입력값>
첫째 줄에 M(1≤M≤50)이 주어진다. 다음 줄에는 M개의 긴 강철 파이프의 길이가 주어진다. 각각의 길이는 100,000을 넘지 않는 정수이다. 다음 줄에는 N(1≤N≤1023)이 주어진다. 다음 줄에는 만들고자 하는 파이프의 길이를 나타내는 정수가 N개 주어진다. 이 길이는 128 이하의 자연수이다.
<출력값>
첫째 줄에 만들 수 있는 필요한 파이프의 최대 개수를 출력한다.

<문제 2410>
어떤 자연수 N을 2의 멱수의 합으로 나타내는 경우의 수를 구하는 프로그램을 작성하시오. 2의 멱수라는 것은, 2^k으로 표현되는 자연수를 의미한다.
예를 들어 7을 2의 멱수의 합으로 나타내는 경우의 수는 다음의 여섯 가지가 있다.

1+1+1+1+1+1+1
1+1+1+1+1+2
1+1+1+2+2
1+1+1+4
1+2+2+2
1+2+4
<입력값>
첫째 줄에 N(1≤N≤1,000,000)이 주어진다.
<출력값>
첫째 줄에 경우의 수를 출력한다. 답이 커질 수 있으므로 1,000,000,000으로 나눈 나머지를 출력한다.

<문제 2411>
N×M 모양의 맵에 아이템과 장애물이 있다. 이때 맵의 왼쪽 아래에서 출발하여 오른쪽 위로 가려고 하는데, 중간에 모든 아이템을 먹으려고 한다. 이동할 때에는 오른쪽이나 위쪽으로만 이동할 수 있다. 또, 장애물이 있는 곳으로는 지날 수 없다.

이때, 이동하는 경로의 개수가 총 몇 개인지 알아내는 프로그램을 작성하시오. 위의 예에서 ◎은 장애물, ☆는 아이템이다. 이때 경우의 수는 4 가지가 된다.
<입력값>
첫째 줄에 N, M(1≤N, M≤100), A(1≤A), B(0≤B)가 주어진다. A는 아이템의 개수이고, B는 장애물의 개수이다. 다음 A개의 줄에는 아이템의 위치, B개의 줄에는 장애물의 위치가 주어진다. 위치를 나타낼 때에는 왼쪽 아래가 (1, 1)이 되고 오른쪽 위가 (N, M)이 된다.
<출력값>
첫째 줄에 경우의 수를 출력한다. 이 값은 int 범위이다.

<문제 2412>
어떤 암벽에 n(1≤n≤50,000)개의 홈이 파져 있다. 각각의 홈의 좌표는 (x, y)와 같이 표현되는데, |a-x|≤2이고 |b-y|≤2이면 (x, y)에서 (a, b)로 이동할 수 있다. 이와 같이 홈들을 이용하여 이동하면서 y=T(1≤T≤200,000)일 때까지, 즉 암벽의 정상까지 오르려고 한다.
현재 당신이 있는 위치는 (0, 0)이다. 이 위치에서 시작하여 이동 회수를 최소로 하면서 정상에 오르려고 한다. 정상에 오를 때의 x좌표는 아무 것이나 되어도 상관이 없다.
<입력값>
첫째 줄에 n, T가 주어진다. 다음 n개의 줄에는 각 점의 x, y좌표가 주어진다. 두 좌표는 모두 0이상이며, x좌표는 1,000,000이하, y좌표는 T이하이다. 입력에 현재 위치인 (0, 0)은 주어지지 않는다.
<출력값>
첫째 줄에 최소 이동 회수를 출력한다. 만약, 정상에 오를 수 없으면 -1을 출력한다.

<문제 2413>
1부터 n까지의 수들을 중복 없이 나열한 것을 순열이라 한다. 순열이 하나 주어졌을 때, 그 순열과 비슷한 순열들 중에서 제일 작은 것을 구하는 프로그램을 작성하시오.
순열이 비슷하다는 것은, 순열의 각 위치의 수들의 차이가 1 이하인 경우를 말한다. 순열의 크기를 비교할 때는 순열의 제일 앞의 수부터 차례로 비교한다.
예를 들어 1 2 3과 2 1 3은 비슷한 순열이고, 1 2 3과 3 1 2는 1과 3의 차이가 2이므로 비슷한 순열이 아니다. n=3일 때의 순열들을 작은 순서대로 나열하면 1 2 3, 1 3 2, 2 1 3, 2 3 1, 3 1 2, 3 2 1이 된다.
<입력값>
첫째 줄에 n(3≤n≤50,000)이 주어진다. 다음 줄에는 순열의 각 수를 나타내는 자연수가 n개 주어진다.
<출력값>
첫째 줄에 답을 출력한다.

<문제 2414>
N×M 모양의 게시판에 구멍이 뚫려 있다. 이를 폭이 1인 테이프를 이용하여 막으려 한다. 테이프의 길이는 무한하다고 생각해도 좋지만, 테이프를 끊어내는 횟수를 최소로 하려 한다. 테이프를 붙일 때에는 구멍이 뚫려 있지 않은 부분을 막아서는 안 된다. 하지만 테이프가 한 번 붙은 곳에 테이프를 또 붙여도 된다. 또한, 테이프를 붙일 때에는 가로나 세로로 붙이는 경우만 허용한다.
<입력값>
첫째 줄에 N, M(1 ≤ N, M ≤ 50)이 주어진다. 다음 N개의 줄에는 M개의 문자로 게시판의 모양이 주어진다. 각각의 문자는 붙어 있으며, 구멍이 없는 부분은 '.', 구멍이 있는 부분은 '*'으로 주어진다.
<출력값>
첫째 줄에 테이프를 끊어 내는 횟수의 최솟값을 출력한다.

<문제 2415>
좌표 평면에 N (4<=N<=1,500) 개의 점이 주어진다.서로 다른 점 4개를 선택하면 사각형을 만들 수 있다. 이러한 사각형 중에 직사각형인 것 중 넓이가 가장 큰 것을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 점의 개수 N이 주어진다. 둘째 줄부터 N개의 줄에 점의 좌표 x y가 주어진다. 점의 좌표는 -10^8보다 크거나 같고, 10^8보다 작거나 같은 정수이다. 점의 좌표는 중복되지 않는다.
<출력값>
가장 큰 직사각형의 넓이를 출력한다.

<문제 2416>
수십년간 소프트웨어 엔지니어로 일해온 백승환은 이제 전혀 다른 일을 시작하기로 했다. 승환이는 여러 가지 일자리를 살펴보고 있었고, 승환이의 눈을 사로잡은 직업이 하나 있었으니… 그것은 양식업이었다.
오늘은 승환이가 출근한 첫 날이다.
승환이의 상사 규현이는 이미 승환이가 할 일을 정해놓았다. 승환이는 저수지 하나를 다른 것들로 부터 격리시켜야 한다.다음은 승환이가 생각한 방법이다.
두 저수지는 여러개의 수로로 서로 연결되어 있다. 각 수로에는 두 개의 문이 있다. 두 문이 모두 열려있으면, 수로는 열려있는 것이고, 그렇지 않으면 닫혀있는 것이다. 문은 스위치로 작동한다 하나의 스위치는 여러개의 문을 작동시킬 수 있지만, 각각의 문은 오직 단 하나의 스위치로만 작동시킬 수 있다. 하나의 스위치로 어떤 수로의 두 문을 작동 시키는 것이나, 스위치가 작동시킬 수 있는 문이 없는 것도 가능하다

위의 그림은 3개의 수로와 2개의 스위치가 있는 예이다.
스위치는 다음 두 가지 방법 중의 한 방법으로 문을 작동 시킨다.

스위치가 켜져있으면, 문이 열려있고, 스위치가 꺼져있으면, 문이 닫혀있다.
스위치가 켜져있으면, 문이 닫혀있고, 스위치가 꺼져있으면, 문이 열려있다.

승환이는 스위치를 가지고 조금 놀다가, 지금까지 수십년간 일해온 프로그래밍 스킬을 여기에 적용시킬 수 있다는 사실을 알았다. 문과 스위치간의 연결 설정이 주어졌을 때, 모든 수로를 닫는 것이 가능한지 구하는 프로그램을 작성하시오. 만약, 가능하다면, 각 스위치가 켜져야하는지, 꺼져야하는지, 상태를 출력한다.
<입력값>
첫째 줄에 수로의 개수 N (1 ≤ N ≤ 250,000)과 스위치의 개수 M (1 ≤ M ≤ 500,000)이 주어진다. 둘째 줄부터 N개의 줄에 각 수로의 정보가 주어진다. 수로의 정보는 4개의 숫자로 이루어져 있고, a, sa, b, sb라고 한다. a와 b (1 ≤ a, b ≤ m)은 연결되어 문을 작동시키는 스위치이다. sa와 sb는 0과 1 중의 하나이다. si가 0이면, 스위치 i가 꺼져야 문이 닫히는 것이고, si가 1이면, 스위치 i가 켜져야 문이 닫히는 것이다.
<출력값>
모든 수로를 닫는 것이 가능하면, m개의 줄에, 각 스위치가 꺼져야 하면 0을, 켜져야 하면 1을 출력한다. 여러 가지가 있으면, 아무거나 출력해도 된다.
모든 수로를 닫는 것이 불가능하다면, IMPOSSIBLE을 출력한다.

<문제 2417>
정수가 주어지면, 그 수의 정수 제곱근을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 정수 n이 주어진다. (0 ≤ n < 263)
<출력값>
첫째 줄에 q2 ≥ n인 가장 작은 음이 아닌 정수 q를 출력한다.

<문제 2418>
다음과 같은 단어 격자가 있다.

여기서 TARTU란 단어를 읽는 방법은 총 7가지가 있다.

단어 격자와, 단어가 주어졌을 때, 주어진 단어를 읽을 수 있는 방법의 경우의 수를 구하는 프로그램을 작성하시오. 단어의 첫 글자는 격자의 어느 곳이 되어도 되고, 두 번째 글자부터는 그 전 글자가 있던 칸과 인접한 칸이어야 한다. (상하좌우, 대각선, 총 8방향). 각 칸은 중복되게 사용해도 된다.
<입력값>
첫째 줄에 3개의 수 H, W, L이 주어진다. H는 격자의 높이, W는 격자의 격자의 너비, L은 단어의 길이이다. (1<=H,W<=200, 1<=L<=100) 다음 줄 부터 H개의 줄에는 격자에 있는 글자가 W개씩 주어지고, 마지막 줄에는 길이가 L인 단어가 주어진다. 모든 글자는 알파벳 대문자이다.
<출력값>
단어를 읽을 수 있는 방법의 경우의 수를 출력한다. 이 값은 1018을 넘지 않는다.

<문제 2419>
수아는 x축 위에 앉아있다. "나는 x축이 너무 좋아!!" 라고 수아가 말했다. 수평선에는 n개의 사탕바구니가 있고, 각 사탕 바구니에는 m개의 사탕이 있다. 각 사탕 바구니는 x1, x2, ..., xn 에 있고, 수아는 0에 있다.
오늘은 날씨가 덥다. 따라서, 시간이 1만큼 지날 때 마다, 모든 사탕바구니에서 사탕은 1만큼 줄어든다. 수아는 매우 배가고프기 때문에, 사탕바구니에 있는 사탕을 0만에 모두 먹을 수 있다. 수아가 1만큼 움직일 때, 시간은 1만큼 지나간다.
수아가 먹을 수 있는 사탕의 최대 개수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 n과 m이 주어진다. 둘째 줄부터 n개의 줄에 사탕 바구니의 위치 xi가 주어진다. (0 ≤ n ≤ 300, 1 ≤ m ≤ 1,000,000, -10,000 ≤ xi ≤ 10,000) 사탕 바구니의 위치는 중복되지 않는다.
<출력값>
수아가 먹을 수 있는 사탕의 최대 개수를 출력한다.

<문제 2420>
사파리월드는 인터넷으로만 존재하는 미스테리한 나라이다. 사파리월드에는 2개의 서브도메인이 seunghwan.royal.gov.sw와 kyuhyun.royal.gov.sw 이 있는데, 이것이 couple.royal.gov.sw으로 합쳐질 것이다. 그러나 도메인 관리 센터 SWNIC(센터장: 김동규)에는 엄격한 룰이 있다. 두 서브도메인을 합칠 때, 유명도의 차이가 너무 차이나지 않을 경우에만 두 서브도메인을 결혼시키는 것이다. 서브도메인의 유명도는 정수이다. 두 서브도메인의 유명도가 주어졌을 때, 그 차이를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 두 도메인의 유명도 N과 M이 주어진다. (-2,000,000,000 ≤ N, M ≤ 2,000,000,000)
<출력값>
첫째 줄에 두 유명도의 차이 (|N-M|)을 출력한다.

<문제 2421>
홍태석은 저금통 2개를 가지고 있다. 홍태석은 매일매일 하나의 저금통에 1원을 넣는다. 두 저금통에 모두 N원이 모이면 태석이는 새로운 장난감을 살 수 있기 때문에, 저금을 멈춘다.
홍태석은 소수를 좋아하는 것으로 서강대에서 유명하기 때문에, 첫째 저금통에 들어있는 돈의 양과 둘째 저금통의 돈의 양을 이어붙였을 때, 그것이 소수가 되는 것을 너무나도 좋아한다.
예를 들어, 첫째 저금통에 12원이 있고, 둘째 저금통에 7원이 있다고 하자. 그럼 그 두 수를 이은 127은 소수가 된다.
이제, 최대한 소수가 많이 나오도록, 홍태석이 돈을 넣는 최적의 순서를 찾아내면 된다. 가장 처음에 두 저금통에는 1원씩 들어있다.
예를 들어,  N=4일 때를 보자.
1,1 → 2,1 → 2,2 → 3,2 → 3,3 → 4,3 → 4,4
위와같이 돈을 넣으면 소수는 오직 1번 등장한다. (43)
하지만, 다음과 같이 돈을 넣으면 소수는 3번 (31,41,43) 등장하게 된다.
1,1 → 2,1 → 3,1 → 4,1 → 4,2 → 4,3 → 4,4
위의 예가 N=4일 때 의 답이다. 가장 처음에 11은 세지 않는다.
<입력값>
첫째 줄에 N이 주어진다. (1<=N<=999)
<출력값>
첫째 줄에 소수가 가장 많이 나오는 저금 방법에서 소수가 나오는 횟수를 출력한다.

<문제 2422>
한윤정과 친구들은 이탈리아로 방학 여행을 갔다. 이탈리아는 덥다. 윤정이와 친구들은 아이스크림을 사먹기로 했다. 아이스크림 가게에는 N종류의 아이스크림이 있다. 모든 아이스크림은 1부터 N까지 번호가 매겨져있다. 어떤 종류의 아이스크림을 함께먹으면, 맛이 아주 형편없어진다. 따라서 윤정이는 이러한 경우를 피하면서 아이스크림을 3가지 선택하려고 한다. 이때, 선택하는 방법이 몇 가지인지 구하려고 한다.
<입력값>
첫째 줄에 정수 N과 M이 주어진다. N은 아이스크림 종류의 수이고, M은 섞어먹으면 안 되는 조합의 개수이다. 아래 M개의 줄에는 섞어먹으면 안 되는 조합의 번호가 주어진다. 같은 조합은 두 번 이상 나오지 않는다. (1 ≤ N ≤ 200, 0 ≤ M ≤ 10,000)
<출력값>
첫째 줄에, 가능한 방법이 총 몇 개 있는지 출력한다.

<문제 2423>
선영이는 N*M 직사각형 크기의 전자 회로를 디자인 하고 있다. 회로에는 N*M개의 정사각형 타일이 있고, 모두 직사각형의 변과 평행하다. 모든 타일은 두 개의 마주보는 꼭짓점이 전선으로 연결되어 있다. (그림 참조)
전원은 왼쪽 위 모서리에 연결되어 있고, 전구는 오른쪽 아래 모서리에 연결되어 있다. 전구는  전원에서 전구로 가는 경로가 있을 때만 불이 켜진다. 전구에 불을 켜기 위해서, 선영이는 몇개의 타일을 90도 회전 시킬 수 있다.

위의 그림에서 전구는 꺼져있다. 만약 오른쪽에서 2번째 열 중 아무 칸이나 90도 회전시킨다면, 전원과 전구는 연결되어 전구가 켜지게 된다. 전구에 불을 켜기 위해 돌려야 하는 칸의 개수의 최솟값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N과 M이 주어진다. 둘째 줄부터 N개의 줄에는 전자 회로의 상태가 주어진다. 상태는 / 또는 \이다. (1<=N,M<=500)
<출력값>
첫째 줄에 문제의 정답을 출력한다. 전구에 불을 켜는 것이 가능하면, 몇 개의 칸을 돌려야 하는지를 출력하고, 불가능할때는 "NO SOLUTION"을 따옴표 없이 출력한다.

<문제 2424>
수아는 보물 지도를 얻었다. 보물 지도는 N*M 크기이고 1*1크기의 정사각형으로 나누어져 있다. 보물 지도의 각 칸은 바다이거나 섬의 일부이다. 그리고, 지도에는 보물과 부산의 해적선의 위치도 있다. 마지막으로 수아는 자신의 위치를 지도에 표시했다.
자 이제, 수아는 보물을 가지기 위한 경로를 정해야 한다. 경로는 현재 수아의 위치에서 시작해야 하고, 보물의 위치에서 끝나야 한다. 매번 수아가 이동할 때, 수아는 위, 아래, 오른쪽, 왼쪽 중의 한 방향으로 이동해야 하고, 섬으로 들어가면 안 된다. 하지만, 부산의 해적도 수아와 같은 방식으로 이동할 것이므로, 부산의 해적을 조심해야 한다. 매번 수아가 이동한 후에, 해적은 수아의 이동에 대해서 이동할지 멈춰있을지 결정할 수 있다. 수아의 움직임과 해적의 반응을 턴이라고 부르면, 매 턴이 지난 후에 다음과 같이 2가지 방법으로확인할 수 있다.

만약 수아가 해적과 바라보고 있다면 (해적과 수직선, 수평선상에 수아가 있고, 오직 그 사이에 바다만 있을 때) 수아는 죽는다.
만약, 수아가 아직 죽지 않았고, 보물 위치에 있다면, 수아는 보물은 얻은 것이다.

부산의 해적이 어떻게 움직이건 관계없이 수아가 죽지않고 보물을 얻을 수 있는 경로를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N과 M이 주어진다. 둘째 줄부터 N개의 줄에 보물 지도가 주어진다. 각 줄은 M개의 문자로 구성되어 있는데, .은 바다이고, I는 섬이고, V는 해적의 위치이고, Y는 현재 수아의 위치이고, T는 보물의 위치이다. V, Y, T는 모두 한 번씩 등장한다. (1 ≤ N, M ≤ 700)
<출력값>
첫째 줄에 수아가 보물을 얻을 수 있으면 YES를 출력하고, 그렇지 않으면 NO를 출력한다.

<문제 2425>
백승환은 레고를 좋아한다. 레고를 쌓은 모습이 2가지 각도에서 주어졌을 때, 그렇게 만드는 경우의 수는 총 몇 가지가 있는지 구하는 프로그램을 작성하시오.
이 문제에서 승환이는 오직 2*2크기의 블록만 사용한다. 하지만, 이 블록은 흰색 (W), 회색 (G), 검정색 (B) 과 같이 총 3가지 색상이 있다. 승환이는 이 세가지 색상의 블록을 무수히 많이 가지고 있다. 승환이는 6*6크기의 보드에 레고를 꼽을 것이다. 모든 블록은 보드의 모서리에 평행해야 하고, 보드의 바깥으로 나가면 안 된다. 그리고 블록은 떠있을 수 없다.

가장 왼쪽은 가능한 경우다. 한 블록이 다른 블록 위에 있기 때문이다. 하지만, 가운데는 블록이 떠있기 때문에 불가능한 경우다. 오른쪽은 6*6 보드를 넘어가므로 불가능한 경우다.
<입력값>
입력의 첫째 줄에 H가 주어진다. H는 승환이가 만들려고 하는 것의 높이이다. 다음 H개의 줄에는 6개의 문자가 주어진다. 이것은 승환이가 만든 것을 한 쪽에서 봤을 때 (밑의 Hint 그림에서 A) 이다. 모든 문자는 W, G, B 또는 .이다. W, G, B는 블록의 색상이고, .은 빈 공간이다. 이 문제에서 각 블록의 깊이를 예측할 수 없는 것을 예상하고 문제를 풀어야 한다. 따라서 ,같은 색상이 인접해 있다고 해도, 같은 높이에 있는 블록이 아닐 수 있다. 그 다음 H줄에는 그림 상에서 B에 해당하는 곳에서 본 블록의 모양이 주어진다.
<출력값>
첫째 줄에 문제의 정답을 출력한다. 이때, 어떤 두 가지 모양이 있다고 할 때, 하나를 A, 하나를 B라고 하자. 이때 B를 거울 대칭이나 회전을 해서 A를 만들 수 있다고 하면, 두 가지 모두 다른 경우로 세야 한다. 정답은 64비트 인트형에 항상 포함된다.

<문제 2426>
세계적인 석유 재벌 "규현 조 압둘 티크리티 안드레스 후세인 리오넬 솔레르 살라 마리우 두스 산투스 펠리스 빈 자이드 술탄 친나왓 뱅거 7세"는 집 앞에 정원이 있다. 정원의 관리인은 그냥 홍태석이다. 이 석유 재벌은 앱등이 출신으로, 애플제품이면 모두 사모은다. 그의 집에는 아이팟 터치, 아이팟 나노, 아이폰, 맥북, 애플 티비, 아이패드 등등 전세계의 모든 애플 제품이 있다. 애플을 너무 좋아하기 때문에 정원에는 N개의 사과 나무가 있다.
홍태석은 나무에 비료를 주는 일과, 나무에 대한 통계를 내는 일 2가지만 한다. 다른 일은 해봤자 망치기 때문에, 전혀 하지 않는다.
나무에 비료를 주기 위해서 세계적인 비료 회사 "Telcontar"에서 만든 "BbuRiJaMaJaJaRam"을 사용한다. 이 비료를 나무에 뿌리면, 그 나무는 즉시 1cm 자란다. 이 비료는 병에 담겨져서 나오는데, 모든 병은 제한된 용량 Ci가 있다. 이 Ci는 몇 개의 나무에 비료를 뿌릴지에 쓰인다. 게다가 모든 병에는 나무의 최소 높이 Hi가 있다. 규현 조 압둘 티크리티 안드레스 후세인 리오넬 솔레르 살라 마리우 두스 산투스 펠리스 빈 자이드 술탄 친나왓 뱅거 79세는 가능하면 모든 트리를 크게 만들라고 그냥 홍태석에게 시켰다. 홍태석은 나무 중에 적어도 높이가 Hi 센치미터인 서로 다른 Ci개의 가장 작은 나무를 골라서 비료를 뿌린다.
통계를 낼 때는, 주어진 구간에 속하는 높이의 나무의 개수를 구하는 것이다. 세계적인 석유 재벌 규현 조 압둘 티크리티 안드레스 후세인 리오넬 솔레르 살라 마리우 두스 산투스 펠리스 빈 자이드 술탄 친나왓 뱅거 7세는 홍태석에게 일처리좀 빨리 하라고 강요했기 때문에, 홍태석은 결국 이 일을 대신하는 프로그램을 작성하기로 했다. 홍태석이 해야 하는 일의 목록이 주어졌을 때, 홍태석을 위해 통계를 구해주는 프로그램을 작성하시오.
<입력값>
입력의 첫째 줄에는 N과 M이 있다. N은 나무의 개수이고, M은 홍태석이 해야 하는 일의 개수이다. 둘째 줄에는 각 나무의 처음 높이가 주어진다. 이 높이는 모두 1보다 크거나 같고, N보다 작거나 같은 정수이다. 다음 M개의 줄에는 홍태석이 해야 하는 일이 시간 순서대로 주어진다. 각각의 입력은 문자 Ti (홍태석이 해야 하는 일의 타입)로 시작된다. (Ti = F 또는 Ti = c)
만약, Ti = F라면, 두 개의 정수 Ci와 Hi가 주어진다. 이 줄이 의미하는 것은 홍태석이 높이가 적어도 Hi센치미터인 가장 작은 나무 Ci개를 골라서 "BbuRiJaMaJaJaRam" 비료를 뿌리는 것이다. 만약, 높이가 적어도 Hi센치미터인 나무의 개수가 Ci개 보다 작으면, 남은 비료는 버린다. (한 번 비료를 뿌릴 때면, 하나의 나무에 두번 뿌릴 수 없다.)
만약, Ti = C이면, mini와 maxi가 입력으로 주어진다. 이것은 홍태석이 통계를 내야 하는 개수이다. 나무의 높이 H가 mini와 maxi 사이에 있는 나무의 개수를 구하면 된다. (mini <= H <= maxi) (1<=N,M<=100,000, 1<=Ci<=N, 0<=Hi<=1,000,000,000, 1<=mini<=maxi<=1,000,000,000)
<출력값>
홍태석이 해야 하는 일의 타입이 C일때 마다, 해당하는 나무의 개수를 출력하면 된다.

<문제 2427>
2012년 지구는 멸망한다. 이러한 멸망하는 지구를 지키기 위해서, 초강대국 사파리 월드에는 긴급 의회를 소집했다. 이 의회에는 N명의 의원이 있다. 
의회에는 회의를 통해서 하나의 의견을 결론으로 낸다. 회의에서, 결론에 도달하기 위해서는, 회의 참석자들이 다음과 같은 과정을 지켜야 한다.

모든 사람은 의견이 있고, P분동안 다른 사람들에게 설명할 수 있다.
모든 참석자들이 발표를 한 후에, 가장 좋은 의견에 대해 투표를 한다. 이 투표는 V분 걸린다.

예를 들어, P=1이고, V=1이라고 하면, 100명의 참가자가 참석한 회의라면 최종 결론이 나오기 까지 101분이 걸린다.
지금 지구가 멸망하고 있는데, 사파리 월드 의원들은 의외로 책임감이 넘쳐서, 이러한 의사 결정 절차를 빠르게 하기로 했다. 그러기 위해서 몇 개의 그룹으로 의원들을 나누고, 동시에 회의를 진행하기로 했다. 각 그룹은 각 그룹의 참석자들 사이에서 가장 좋은 의견을 뽑고, 각 그룹에서 가장 좋은 의견을 내놓은 사람들끼리 다시 회의를 한다.
예를 들어, P=1, V=1이고, 100명의 의원을 40, 60명의 그룹으로 나누면 다음과 같은 과정을 거친다.

60명의 그룹의 회의는 61분이 걸린다.
40명의 그룹의 회의는 41분이 걸리고, 60명의 그룹의 회의가 끝날 때 까지 기다린다.
두 그룹의 가장 좋은 의견을 낸 사람들이 최종 회의에 참가하고, 발표하는데 2분, 투표하는데 1분이 걸린다.

따라서 총 61+2+1 = 64분이 걸린다.
그룹을 만들었을 때, 거기서 또다른 소그룹을 만드는 것은 때때로 의사 결정 속도를 엄청나게 빠르게 하기도 한다. 특별한 예외 경우로 회의의 참석자가 1명인 결정하는데 시간이 걸리지 않고, 다른 사람에게 자신의 의견을 발표할 필요도 없다.
N과 P와 V가 주어졌을 때, 회의와 그룹을 최적의 상태로 나누었을 때, 마지막 의견 하나가 나오는데 걸리는 시간을 출력하시오.
<입력값>
첫째 줄에 N과 P와 V가 주어진다. 1<=N<=10^15, 1<=P,V<=1,000
<출력값>
첫째 줄에 의회가 최종 의견을 내는 시간 M을 출력한다.

<문제 2428>
세계적인 석유 재벌 "규현 조 압둘 티크리티 안드레스 후세인 리오넬 솔레르 살라 마리우 두스 산투스 펠리스 빈 자이드 술탄 친나왓 뱅거 7세"는 1등 상품으로 페라리를 걸고 프로그래밍 대회를 개최했다. 이 대회의 참석자는 총 N명이고 각각 솔루션 파일 1개를 제출했다. 이 솔루션 파일을 F1, F2, ..., Fn이라고 한다.
채점 결과를 발표하기 전에, 남의 것을 배낀 사람이 있는지 찾아내려고 한다. 이 대회의 주최측은 두 파일을 비교해서 너무 비슷한지 아닌지 판별하는 프로그램이 있다.
하지만, 제출한 파일의 개수가 너무 많아서, 모든 쌍을 검사한다면, 2012년 지구가 멸망할 때 까지도 검사를 해야할 판이다. 따라서, 파일 크기가 너무 다른 경우에는 그러한 쌍을 검사하지 않고 넘어가기로 했다.
좀더 정확하게 하기 위해서, 대회의 심판들은 두 파일이 있을 때, 작은 파일의 크기가 큰 파일 크기의 90%보다도 작을 때는, 이러한 쌍은 검사하지 않고 넘어가기로 했다. 따라서, (Fi, Fj) 쌍을 검사해야 하는데, 이때, i≠j이고, size(Fi) ≤ size(Fj)이면서, size(Fi) ≥ 0.9 × size(Fj)인 쌍만 검사하려고 한다.
몇 개의 쌍을 검사해야 하는 지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 제출한 솔루션의 개수 N이 주어진다. 둘째 줄에는 각 솔루션 파일의 크기 size(F1), size(F2), ..., size(FN)이 주어진다. (1 ≤ N ≤ 100,000, 1 ≤ size(Fi) ≤ 100,000,000) 솔루션 파일의 크기는 정수이다.
<출력값>
첫째 줄에 검사해야 하는 파일의 개수를 출력한다.

<문제 2429>
N개의 꼭짓점을 가진 단순 다각형 (Simple Polygon)이 무한한 사각 격자판에 그려져 있다. 단순 다각형은, 두 개의 인접한 변이 오직 하나의 공통된 꼭짓점을 지나고, 이러한 변이 아니라면 교차하거나, 접하지 않는다. 모든 꼭짓점은 정수 좌표를 가진다.
이러한 다각형이 주어지면, 다각형 내부에 격자 선분의 길이를 구하면 된다. (그림 참고)
<입력값>
첫째 줄에 꼭짓점의 개수 N이 주어진다. 둘째 줄부터 N개의 줄에는 두 정수 x와 y가 주어진다. 이 좌표는 하나의 꼭짓점이다. 꼭짓점은 시계방향 또는 반시계 방향으로 주어지며, 모든 꼭짓점은 서로 다르다. (3<=N<=100,000, -500,000,000<=x,y<=500,000,000)
<출력값>
첫째 줄에, 다각형 내부의 격자 선분의 길이를 출력하면 된다.
정답과의 절대/상대 오차는 10-3까지 허용된다.

<문제 2430>
T는 루트가 있는 트리이다. S는 T의 완벽한 복사본이다. 자 이제 T와 S를 합친다. 루트를 제외한 모든 단말 노드 (leaf node)를 합치면 된다. 이 그래프는 거울대칭트리 그래프이다.
임의의 무방향 연결 그래프가 주어졌을 때, 이 그래프가 거울대칭트리 그래프인지 아닌지 판별하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N과 M이 주어진다. N은 정점의 개수 M은 간선의 개수이다. 그래프의 정점은 1부터 N까지 번호가 매겨져 있다. 다음 M개의 줄에는 x와 y가 주어진다. (x ≠ y, 1 ≤ x, y ≤ N) x와 y는 하나의 간선이고, x와 y가 이어져 있는 것이다. 두 정점 사이에는 많아야 하나의 간선만 있을 수 있다. (3 ≤ N, M ≤ 100,000)
<출력값>
첫째 줄에 그래프가 거울대칭트리 그래프이면 YES를 아니면 NO를 출력한다.

<문제 2431>
스톡홀롬 지하철은 여러 개의 노선으로 이루어져 있다. 이 문제는 노선이 하나 있고, 자주 발생하는 문제인 신호 장애에 대해서 다룬다.
지하철 노선은 양 끝점을 연결하는 평행한 두 레일로 생각할 수 있다. 위쪽 레일에서 열차는 오른쪽에서 왼쪽으로 이동하며, 아래쪽 레일에서는 왼쪽에서 오른쪽으로 이동한다. 열차가 끝 점에 도착했을 때는, 반대편 레일로 이동한 다음, 방향을 바꿔서 다시 진행한다. 이렇게 방향을 바꾸고 반대편 레일로 이동하는데 걸리는 시간은 없다.
평소에 교통 흐름은 연속적이고, 열차는 항상 일정한 속도로 이동한다. (1분에 1칸) 열차는 균등하게 분포되어 있다. 따라서, 레일의 한 점을 지나가는 열차는 주기적이다. 열차가 역에 정차하고, 승객을 태우는데 걸리는 시간은 무시한다.
신호 장애가 발생했을 때, 열차는 레일 위에 랜덤하게 분포된다. 이 경우에 지하철 관제 센터에서는 열차를 재빠르게 균등하게 분포해야 한다. 각 열차의 현재 위치가 주어졌을 때, 얼마나 빠르게 균등하게 분포할 수 있는 지 구하는 프로그램을 작성하시오. 관제 센터에서는 열차를 잠시 멈추게 할 수도 있고, 방향을 반대로 바꿀 수도 있다. 방향을 바꾸는 경우에 열차는 반대편 라인으로 이동하게 된다.

위의 그림은 길이가 100인 레일을 나타낸다. 위쪽 그림에 열차는 5(오른쪽), 35(왼쪽), 46(왼쪽), 75(왼쪽), 85(오른쪽)에 있다. 열차를 균등하게 배치하는 한 가지 방법은 46에 있는 열차를 한 칸 움직이게 하고, 방향을 반대로 바꾸는 것이다. 하지만, 이 방법은 가장 빠른 방법은 아니다.
<입력값>
첫째 줄에 레일의 길이 m, 열차의 수 n이 주어진다. 다음 n개 줄에는 열차의 현재 위치가 주어진다. 열차의 위치 xi와 함께 방향이 주어지며, L인 경우는 왼쪽, R인 경우는 오른쪽으로 열차가 향하는 것이다. (100 ≤ m ≤ 100,000,000, 1 ≤ n ≤ 100,000 0 ≤ xi ≤ m)
<출력값>
열차를 균등하게 배치하는데 필요한 가장 빠른 시간을 출력한다. 소수점 오차는 10-6까지 허용한다.

<문제 2432>
상근이는 몇 달전에 대박의 꿈을 안고 아이폰 앱의 세계에 발을 들였다. 상근이는 게임을 하나 만들었는데, 이 게임에는 전체 사용자의 순위를 보여주는 기능이 있다. 상근이는 점수를 내림차순으로 정렬해 사용자의 순위를 보여주려고 한다.
사용자의 점수를 저장하는데 사용한 자료구조는 오직 연산 하나만 수행할 수 있다. 이 연산은 i번째 사용자를 j번째로 옮기는데, 다른 사용자의 상대적인 순서를 바꾸지 않는다.
예를 들어, i>j인 경우에 j와 i-1번 사이의 사용자의 순위는 1씩 증가한다. 반대로 i<j인 경우에는 i+1과 j 사이의 사용자의 순위가 1씩 감소한다.
연산을 한 번 사용할 때, 이동시킬 사용자를 찾는데 i단계, 이동할 위치를 찾는데 j단계가 필요하기 때문에, i번째 사용자를 j번째로 옮기는데 드는 비용은 i+j이다. 순위는 1부터 시작한다.
현재 자료구조에 저장된 점수가 주어졌을 때, 사용자를 내림차순으로 정렬하기 위해 필요한 비용의 최솟값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 저장된 점수의 수 n (2 ≤ n ≤ 1000) 이 주어진다. 다음 줄에는 점수 si가 현재 자료구조에 저장되어 있는 순서대로 주어진다. (0 ≤ si ≤ 1,000,000) 두 점수가 같은 경우는 없다.
<출력값>
첫째 줄에 점수를 내림차순으로 정렬하기 위해 필요한 이동 횟수를 출력한다. 다음 줄에는 각 이동을 순서대로 출력한다. i번째 점수를 j번째로 옮긴 경우에는 i j를 출력한다.

<문제 2433>
디지털 음악에서 소리는 대기압의 변화를 나타내는 숫자로 표현한다. 대기압의 변화는 일정한 시간 구간을 정해놓고, 연속되는 구간동안 얼마나 빠르게 변했는지를 측정한다. 이렇게 측정한 값을 샘플이라고 한다.
음성 처리에서 가장 중요한 단계는 녹음된 소리를 사일런스 기준으로 사일런스가 아닌 구간으로 나누는 작업이다. 너무 많은 조각이 나는 것을 방지 하기 위해서 사일런스는 최저값과 최고값의 차이가 c를 넘지않는 샘플 m개의 연속이라고 정의한다.
샘플 n개 이루어진 레코딩과 m과 c가 주어졌을 때, 사일런스를 찾는 프로그램을 작성하시오.
<입력값>
첫째 줄에 샘플의 수 n (1 <= n <= 1,000,000), m (1 <= m <= 10,000), c (0 <= c <= 10,000)가 주어진다.
둘째 줄에는 각 샘플의 값 ai가 주어진다. (0 <= ai <= 1,000,000 for 1 <= i <= n)
<출력값>
max(a[i . . . i+m−1])−min(a[i . . . i+m−1]) <= c를 만족하는 모든 i를 오름차순으로 한 줄에 하나씩 출력한다.
만약, 주어진 입력에 사일런스가 없다면, NONE을 출력한다.

<문제 2434>
3 × N개의 점이 찍혀있는 직사각형 그리드가 있다. 그리드 상의 모든 점은 최대 8개의 이웃한 점을 가지고 있다.

그리드 상의 점을 연결해서 만들 수 있는 다각형의 개수를 구하려고 한다. 다각형은 아래와 같은 조건을 만족해야 한다.
꼭짓점은 3 × N개 모두로 이루어져 있어야 한다.
다각형에서 인접한 꼭짓점은 그리드상에서 이웃한 점이어야 한다.
단순 다각형이어야 한다. 즉, 변이 교차하며 안 된다.
아래 그림은 N=6인 경우에 가능한 두 가지 다각형이다.

N이 주어졌을 때, 만들 수 있는 다각형의 개수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 양의 정수 N이 주어진다. (N <= 1,000,000,000).
<출력값>
다각형의 만드는 방법의 수를  1,000,000,000로 나눈 나머지를 출력한다.

<문제 2435>
2012년 여름은 너무나 더웠다. 현수는 이런 더위 속에서 컴퓨터 공학과 회장을 게속하는 것은 불가능하다고 생각했다. 결국 그는 2학기 개강을 앞두고 기상청 인턴으로 지원했다.
요즘 꿈의 직장은 기상청이다. 현수는 어떻게든 인턴으로 취직해서 한국 날씨에 큰 별이 되고자 날씨에 관한 모든 것을 공부하기 시작했다.
그는 9시 뉴스를 보며 기상 캐스터 처럼 연습을 하기도 했고, 그 어렵다는 수능 지구과학을 공부하면서 다시 한 번 기상에 대한 기초 지식을 쌓았고, 로욜라 도서관에서 날씨에 대한 책을 모두 읽었다.
드디어 그날이 왔다. 면접 날이다.
기상청 면접관의 질문은 딱 하나였다. 
"자네 FA있나?"
현수는 당당하게 말했다. "저는 컴공과 11학번 중, 유일하게 FA가 없습니다!!"
면접관은 흐믓하게 그를 쳐다본 후에 바로 채용하기로 결정했다.
현수는 집에 돌아가는 길에 계속해서 이런 생각이 났다. "왜 FA가 있나 없나를 물어봤을까..? 성실함만 있으면 정말 다 되는 사회인가? 왜 내가 준비한 걸 펼칠 수 있는 기회를 주지 않았을까??"
결국 그는 침대에 누워서 천장을 바라보면서 이런 생각을 계속 했지만, 계속 머리에 맴도는 것은 "컴실2에 늦을까봐 홍태석 어깨를 잡고 뛰어가는 것과, 기상청 면접관의 어이없는 질문 뿐이었다."
드디어 오늘은 현수가 기상청에 출근하는 첫 날이다. 출근 시간은 8시였다. 지금 시간은 7시 58분이다.
기상청 1층이다. 뛰어야겠다. 긴 다리를 이용해 사무실까지 날아가보자.
7시 59분 50초. 아슬아슬하게 도착했다.
"잘했네. 이번 인턴 기간동안 자네가 할 일은 하나네. 매일 아침 9시까지 와서 온도를 측정하고 집에 가면 된다네."
10일동안 이 일을 한 뒤에, 현수는 큰 고민에 빠졌다. 
내가 이 일을 왜 하는 것일까?? 안되겠다. 이 데이터를 이용해서 의미 있는 값을 찾아야겠어! 왜 그가 나한테 이 일만을 시켰는지를!!
현수가 10일동안 잰 온도는 다음과 같다.
3 -2 -4 -9 0 3 7 13 8 -3
대체 이게 무슨 의미가 있을까?? 그럼 한 번 연속된 이틀동안 온도의 합을 구해보자.
1 -6 -13 -9 3 10 20 21 5
이제 여기서 가장 큰 값을 찾아보았다. 21
온도의 합이 가장 큰 값은 21이었다. 그래 바로 이거였어!
자 그럼 이제 연속된 5일동안 온도의 합을 구해보자!
-12 -12 -3 14 31 28
그래 이거야 31!!!
현수는 바로 이게 자신이 매일 온도를 재던 이유라는 것을 알았다. (현수는 소수점을 싫어하기 때문에, 온도는 항상 정수이다.)
측정한 온도가 어떤 정수의 수열로 주어졌을 때, 연속적인 며칠 동안의 온도의 합이 가장 큰 값! 이것을 구하면 된다.
현수가 N일동안 측정한 온도가 순서대로 주어졌을 때, 연속적인 K일 동안의 온도의 합이 가장 큰 값을 구해보세요.
<입력값>
첫째 줄에 두 개의 정수 N과 K가 한 개의 공백을 사이에 두고 주어진다. N은 온도를 측정한 전체 날짜의 수이다. N은 2이상, 100이하이다. K는 합을 구하기 위한 연속적인 날짜의 수이다. K는 1과 N 사이의 정수이다. 
둘째 줄에는 매일 측정한 온도를 나타내는 N개의 정수가 빈칸을 사이에 두고 주어진다. 이 수는 모두 -100이상, 100이하이다.
<출력값>
첫째 줄에, 온도의 수열에서 연속적인 K일의 온도의 합이 최대가 되는 값을 출력한다.

<문제 2436>
어떤 두 자연수에 공통인 약수들 중에서 가장 큰 수를 최대공약수라고 하고, 두 자연수의 공통인 배수들 중에서 가장 작은 수를 최소공배수라고 한다. 
예를 들어, 두 자연수 12와 90의 최대공약수는 6이며, 최소공배수는 180이다.
이와 반대로 두 개의 자연수 A, B가 주어졌을 때, A를 최대공약수로, B를 최소공배수로 하는 두 개의 자연수를 구할 수 있다. 그러나, 이러한 두 개의 자연수 쌍은 여러 개 있을 수 있으며, 또한 없을 수도 있다. 
예를 들어, 최대공약수가 6이며 최소공배수가 180인 두 정수는 위의 예에서와 같이 12와 90일 수도 있으며, 30과 36, 18과 60, 혹은 6과 180일 수도 있다. 그러나, 최대공약수가 6이며 최소공배수가 20인 두 자연수는 있을 수 없다.
두 개의 자연수가 주어졌을 때, 이 두 수를 최대공약수와 최소공배수로 하는 두 개의 자연수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 두 개의 자연수가 빈칸을 사이에 두고 주어진다. 첫 번째 수는 어떤 두 개의 자연수의 최대공약수이고, 두 번째 수는 그 자연수들의 최소공배수이다. 입력되는 두 자연수는 2 이상 100,000,000 이하이다.
<출력값>
첫째 줄에는 입력되는 두 자연수를 최대공약수와 최소공배수로 하는 두 개의 자연수를 크기가 작은 수부터 하나의 공백을 사이에 두고 출력한다. 입력되는 두 자연수를 최대공약수와 최소공배수로 하는 두 개의 자연수 쌍이 여러 개 있는 경우에는 두 자연수의 합이 최소가 되는 두 수를 출력한다.

<문제 2437>
하나의 양팔 저울을 이용하여 물건의 무게를 측정하려고 한다. 이 저울의 양 팔의 끝에는 물건이나 추를 올려놓는 접시가 달려 있고, 양팔의 길이는 같다. 또한, 저울의 한쪽에는 저울추들만 놓을 수 있고, 다른 쪽에는 무게를 측정하려는 물건만 올려놓을 수 있다.


무게가 양의 정수인 N개의 저울추가 주어질 때, 이 추들을 사용하여 측정할 수 없는 양의 정수 무게 중 최솟값을 구하는 프로그램을 작성하시오.
예를 들어, 무게가 각각 3, 1, 6, 2, 7, 30, 1인 7개의 저울추가 주어졌을 때, 이 추들로 측정할 수 없는 양의 정수 무게 중 최솟값은 21이다.
<입력값>
첫 째 줄에는 저울추의 개수를 나타내는 양의 정수 N이 주어진다. N은 1 이상 1,000 이하이다. 둘째 줄에는 저울추의 무게를 나타내는 N개의 양의 정수가 빈칸을 사이에 두고 주어진다. 각 추의 무게는 1이상 1,000,000 이하이다.
<출력값>
첫째 줄에 주어진 추들로 측정할 수 없는 양의 정수 무게 중 최솟값을 출력한다.

<문제 2438>
첫째 줄에는 별 1개, 둘째 줄에는 별 2개, N번째 줄에는 별 N개를 찍는 문제
<입력값>
첫째 줄에 N(1 ≤ N ≤ 100)이 주어진다.
<출력값>
첫째 줄부터 N번째 줄까지 차례대로 별을 출력한다.

<문제 2439>
첫째 줄에는 별 1개, 둘째 줄에는 별 2개, N번째 줄에는 별 N개를 찍는 문제
하지만, 오른쪽을 기준으로 정렬한 별(예제 참고)을 출력하시오.
<입력값>
첫째 줄에 N(1 ≤ N ≤ 100)이 주어진다.
<출력값>
첫째 줄부터 N번째 줄까지 차례대로 별을 출력한다.

<문제 2440>
첫째 줄에는 별 N개, 둘째 줄에는 별 N-1개, ..., N번째 줄에는 별 1개를 찍는 문제
<입력값>
첫째 줄에 N(1 ≤ N ≤ 100)이 주어진다.
<출력값>
첫째 줄부터 N번째 줄까지 차례대로 별을 출력한다.

<문제 2441>
첫째 줄에는 별 N개, 둘째 줄에는 별 N-1개, ..., N번째 줄에는 별 1개를 찍는 문제
하지만, 오른쪽을 기준으로 정렬한 별(예제 참고)을 출력하시오.
<입력값>
첫째 줄에 N(1 ≤ N ≤ 100)이 주어진다.
<출력값>
첫째 줄부터 N번째 줄까지 차례대로 별을 출력한다.

<문제 2442>
첫째 줄에는 별 1개, 둘째 줄에는 별 3개, ..., N번째 줄에는 별 2×N-1개를 찍는 문제
별은 가운데를 기준으로 대칭이어야 한다.
<입력값>
첫째 줄에 N(1 ≤ N ≤ 100)이 주어진다.
<출력값>
첫째 줄부터 N번째 줄까지 차례대로 별을 출력한다.

<문제 2443>
첫째 줄에는 별 2×N-1개, 둘째 줄에는 별 2×N-3개, ..., N번째 줄에는 별 1개를 찍는 문제
별은 가운데를 기준으로 대칭이어야 한다.
<입력값>
첫째 줄에 N(1 ≤ N ≤ 100)이 주어진다.
<출력값>
첫째 줄부터 N번째 줄까지 차례대로 별을 출력한다.

<문제 2444>
예제를 보고 규칙을 유추한 뒤에 별을 찍어 보세요.
<입력값>
첫째 줄에 N(1 ≤ N ≤ 100)이 주어진다.
<출력값>
첫째 줄부터 2×N-1번째 줄까지 차례대로 별을 출력한다.

<문제 2445>
예제를 보고 규칙을 유추한 뒤에 별을 찍어 보세요.
<입력값>
첫째 줄에 N(1 ≤ N ≤ 100)이 주어진다.
<출력값>
첫째 줄부터 2×N-1번째 줄까지 차례대로 별을 출력한다.

<문제 2446>
예제를 보고 규칙을 유추한 뒤에 별을 찍어 보세요.
<입력값>
첫째 줄에 N(1 ≤ N ≤ 100)이 주어진다.
<출력값>
첫째 줄부터 2×N-1번째 줄까지 차례대로 별을 출력한다.

<문제 2447>
재귀적인 패턴으로 별을 찍어 보자. N이 3의 거듭제곱(3, 9, 27, ...)이라고 할 때, 크기 N의 패턴은 N×N 정사각형 모양이다.
크기 3의 패턴은 가운데에 공백이 있고, 가운데를 제외한 모든 칸에 별이 하나씩 있는 패턴이다.

***
* *
***
N이 3보다 클 경우, 크기 N의 패턴은 공백으로 채워진 가운데의 (N/3)×(N/3) 정사각형을 크기 N/3의 패턴으로 둘러싼 형태이다. 예를 들어 크기 27의 패턴은 예제 출력 1과 같다.
<입력값>
첫째 줄에 N이 주어진다. N은 3의 거듭제곱이다. 즉 어떤 정수 k에 대해 N=3k이며, 이때 1 ≤ k < 8이다.
<출력값>
첫째 줄부터 N번째 줄까지 별을 출력한다.

<문제 2448>
예제를 보고 규칙을 유추한 뒤에 별을 찍어 보세요.
<입력값>
첫째 줄에 N이 주어진다. N은 항상 3×2k 수이다. (3, 6, 12, 24, 48, ...) (0 ≤ k ≤ 10, k는 정수)
<출력값>
첫째 줄부터 N번째 줄까지 별을 출력한다.

<문제 2449>
최대 K가지의 서로 다른 색을 표현할 수 있는 전구들이 있다. 이 전구 N개를 다음의 그림과 같이 한 줄로 배치하여 서로 연결한다. (동그라미 안의 숫자는 전구의 색을 의미한다)

각 전구는 스위치가 있어서 전구의 색을 임의의 색으로 바꿀 수 있다. 하나의 전구 색을 바꾸는 경우에는, 색이 바뀌는 전구에 인접한 전구가 같은 색이면, 이 전구의 색도 같이 바뀌게 되며 인접한 전구가 다른 색이 나올 때까지 계속 바뀌게 된다. 예를 들어, 위의 그림에서 4번 전구의 색을 2번 색으로 바꾸면, 5번 전구가 4번 전구와 같은 색이었으므로 2번 색으로 바뀌고, 6번 전구도 5번 전구와 같은 색이었으므로 2번 색으로 바뀌게 된다. 즉, 4번 전구의 색을 2번 색으로 바꾸면, 연결된 같은 색의 모든 전구인 4, 5, 6번의 전구가 2번 색으로 바뀌게 되어 아래의 그림과 같이 된다.

전구의 수 N과 N개의 전등에 대한 초기 색이 주어질 때, 모든 전구의 색이 하나로 같아질 때까지 최소 몇 번 전구의 색을 바꾸어야 하는지를 구하는 프로그램을 작성하시오. 단, 전구의 각 색은 1부터 K까지의 정수로 나타낸다.
<입력값>
입력의 첫 번째 줄에는 전구의 수를 나타내는 양의 정수 N과 전구가 표현할 수 있는 색의 수 K가 주어진다. 단, N은 1이상 200이하의 정수이며, K는 1이상 20이하의 정수이다. 두 번째 줄에는 N개 전구의 색이 전구번호의 순서대로 하나의 정수로 하나의 빈칸을 사이에 두고 주어진다.
<출력값>
첫째 줄에 모든 전구의 색이 하나로 같아질 때까지 전구의 색을 바꾸는 횟수의 최솟값을 하나의 정수로 출력한다.

<문제 2450>
여러 개의 세모, 네모, 동그라미 모양들이 일렬로 나열되어 있다. 임의의 위치에 있는 두 개의 모양을 서로 맞바꾸는 작업을 반복하여 같은 모양끼리 연속하도록 정돈하려고 한다. 단, 정돈된 모양의 순서는 상관없다.
예를 들어, 모양들이 다음과 같이 나열되어 있다고 하자. 

첫 번째 위치에 있는 세모와 일곱 번째 위치에 있는 동그라미를 맞바꾸면 다음과 같이 된다.

이어서, 다섯 번째 위치에 있는 세모와 마지막에 있는 네모를 맞바꾸면 다음과 같이 된다.

위와 같이 맞바꾸기를 두 번하면 같은 모양들끼리 연속하도록 정돈할 수 있지만, 한 번의 맞바꾸기만으로 같은 모양들끼리 연속하도록 하는 방법은 없으므로 이 경우 모양을 정돈하기위해 필요한 맞바꾸기의 최소 횟수는 2이다. 
일렬로 나열된 모양들의 순서가 입력으로 주어질 때, 같은 모양들끼리 연속하도록 정돈하기 위해 필요한 맞바꾸기 의 최소 횟수를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 모양의 전체 개수 N이 주어진다. N은 3이상 100,000이하이다. 둘째 줄에는 나열된 모양들을 나타내는 N개의 정수가 빈 칸을 사이에 두고 주어지는데, 정수 1은 세모를, 정수 2는 네모를, 정수 3은 동그라미를 나타낸다. 각 모양은 최소 한번 이상 나타난다.
<출력값>
첫째 줄에 같은 모양들끼리 연속하도록 정돈하기 위해 필요한 맞바꾸기의 최소 횟수를 출력한다.

<문제 2451>
KOI대학교 영재교육원에서 정보올림피아드에 관심 있는 학생들을 위한 캠프가 열린다. 캠프에 모인 학생들 중에는 원래부터 서로 아는 사이인 경우가 있다.

	교육원에서는 다음과 같은 방식으로 학생들을 몇 개의 모둠으로 분할하려고 한다. 먼저 학생들의 명단을 생년월일 순서대로 나열한 다음, 나열된 순서에서 연속된 구간에 속한 학생들을 하나의 모둠으로 구성할 것이다. 이때, 분할을 위한 원칙은 다음과 같다. 각 모둠에 속한 학생들은 서로 아는 사이여야 하고, 다른 모둠에 속한 학생들과는 서로 모르는 사이여야 한다. 그러나 위의 원칙으로 분할하는 것이 불가능한 경우가 많다. 그래서 가능한 위의 원칙을 따르는 방향으로 분할을 수행하기 위해, 분할 점수라는 값을 도입하여 구성된 분할이 얼마나 좋은지를 평가한다. 분할 점수는 다음과 같이 구해진다.

	같은 모둠에 속한 학생들 중에서 서로 모르는 학생 쌍에 대해 각각 1점씩 점수를 부여하고, 다른 모둠에 속한 학생들 중에서 서로 아는 사이인 학생 쌍에 대해 각각 1점씩 점수를 부여한다. 

	다음 그림은 모둠의 수가 3이고 분할 점수가 5인 분할의 예를 보여준다. 그림에서 검은색 점은 학생을, 점 사이를 연결하는 선은 학생들이 서로 아는 사이임을 나타낸다. 점선으로 표시된 원은 모둠을 나타낸다. 학생들은 생년월일의 순서대로 1번부터 8번까지 번호로 표시되었고, 각 모둠은 A, B, C로 표시되어 있다. 이 예에서는 모둠 A와 모둠 B 사이의 점들을 연결하는 3개의 선이 존재하고, 모둠 B와 모둠 C 사이의 점들을 연결하는 1개의 선이 존재한다. 모둠 A와 모둠 B의 경우, 모둠 내의 모든 점들 쌍에 선이 존재하지만, 모둠 C에는 점 7과 점 8 사이에 선이 존재하지 않는다. 따라서 분할 점수는 3+1+1=5 이다.



	아래 그림과 같이 두 개의 모둠으로 분할된 경우에도 분할 점수는 5이다. 



	아래 그림과 같이 4개의 모둠으로 분할된 경우에는 분할 점수가 8이다. 



	학생들에 대한 정보가 주어질 때, 분할 점수가 최소가 되는 분할을 구하는 프로그램을 작성하시오. 단, 모둠이 한 개만 있는 분할도 존재할 수 있다.
<입력값>
첫째 줄에는 학생들의 수 N이 주어진다. N은 2 이상 3,000 이하이다. 학생들은 1부터 N까지 번호로 구분되고, 번호가 작은 학생은 번호가 큰 학생보다 생년월일이 빠르다. 둘째 줄부터 시작하여 N개의 줄에는 서로 알고 지내는 학생들에 대한 정보가 주어진다. 이들 중 K번째 줄에는 학생 K가 알고 있는 학생들의 번호와 끝을 나타내는 0이 빈칸을 사이에 두고 주어진다(K=1,2,...,N). 학생 번호들은 오름차순으로 주어진다. 학생 I가 학생 J를 알고 있으면, 항상 학생 J도 학생 I를 알고 있다.
<출력값>
첫째 줄에 최적으로 분할한 경우의 분할 점수를 출력하고, 둘째 줄에는 모둠의 개수와 각 모둠의 크기를 빈칸을 사이에 두고 출력한다. 모둠은 생년월일이 빠른 학생들의 모둠부터 출력한다. 만일 분할 점수가 같은 분할이 여러 개 있으면 그 중 하나만 출력한다.

<문제 2452>
태양이는 아래와 같이 M×N 그리드 위에 놓여있는 MN개의 흰색과 검은색 돌들을 가지고 게임을 시작한다. 



	임의의 돌 X에 대해서, X에 상, 하, 좌, 우로 인접한 4개의 돌들을 X의 이웃이라고 한다. 태양이는 위의 돌들 중에서 하나를 선택해서 돌의 색깔을 바꿀 수 있다. 그러면 이 돌의 이웃이고 같은 색을 가지는 돌들도 또한 새로운 색으로 바뀐다. 계속해서 반복적으로 색이 바뀌는 돌의 이웃들 또한 같은 색을 가지는 경우에 색이 바뀐다. 

	예를 들어, 위 그림에서 돌 A의 색을 흰색으로 바꾸면 ‘ㄷ’자 모양의 검은색 돌들이 흰색으로 바뀌어서 다음과 같이 된다.



	다음으로 돌 C를 흰색으로 바꾸면 다음 그림과 같이 바뀐다. 



	그리고 돌 F를 흰색으로 바꾸고, 마지막으로 돌 E를 흰색으로 바꾸면 모든 돌들이 흰색이 된다. 따라서 모두 네 번의 색 바꾸기로 모든 돌들을 흰색으로 바꾸었다. 

	하지만 두 번만의 색 바꾸기로 모든 돌들을 같은 색으로 바꿀 수 있다. 먼저 돌 B를 검은색으로 바꾸면 다음 그림과 같이 된다.



	그러면 돌 A를 흰색으로 바꾸어서 모든 돌들을 흰색으로 바꾸거나, 돌 D를 검은색으로 바꾸어서 모든 돌들을 검은색으로 바꿀 수 있다. 따라서 두 번만의 색 바꾸기로 모든 돌들을 같은 색으로 바꾸었다.

	흰색과 검은색 돌들이 M×N 그리드 위에 놓여 있을 때, 모든 돌들이 같은 색이 되도록 하는 색 바꾸기의 최소 횟수를 찾는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 M×N 그리드를 나타내는 두 양의 정수 M과 N이 빈칸을 사이에 두고 주어진다. M과 N은 2 이상 100 이하이다. 둘째 줄부터 M개의 각 줄에는 그리드의 가로줄 한 줄에 놓여진 흰색 돌을 나타내는 0과 검은색 돌을 나타내는 1이 빈칸을 사이에 두고 연속해서 N개 주어진다.
<출력값>
첫째 줄에 모든 돌들이 같은 색이 되도록 하는 색 바꾸기의 최소 횟수를 출력한다.

<문제 2453>
게임업체인 KOI (Kernel Operation International)는 2011년 신입사원을 두 개의 개발부서 A, B에 적절히 나누어서 배치하려고 한다. 그런데 사원들 중에는 같이 일을 하고 싶어 하는 “친구관계”인 사람들과 같은 부서에서 일하기를 싫어하는 “경쟁관계”인 사람들이 있다.
x와 y가 친구 관계이면 +(x,y)로 표시하고, 경쟁관계이면 -(x,y)로 표시한다. 단 두 사람 x와 y가 +(x,y)와 -(x,y)를 동시에 만족할 수는 없다. 그리고 친구관계와 경쟁관계에는 대칭성이 있어서 +(x,y)이면 +(y,x)도 성립하고, -(x,y)이면 -(y,x)도 항상 성립된다.  
신입사원 전체를 A, B 두 부서에 배치하는 KOI식 배정 원칙은 다음과 같다.

모든 신입사원은 두 부서 중  한 부서에는 반드시 배치되어야 한다.
+(x,y) 관계인 x와 y는  반드시 같은 부서에 배치되어야 한다. 
-(x,y) 관계인 x와 y는 반드시 서로 다른 부서에 배치되어야 한다.
두 부서 A와 B에 배정된 인원수의 차이는 최소가 되어야 한다.

3명의 신입사원 {1,2,3}이 있고 이들의 관계가 다음 표의 R1과 같다면 이들은 KOI식 배치가 가능하다. 왜냐하면 {1,2,3} 모두를 A나 B 한쪽 부서로 전부 배치하면 되기 때문이다. 

R2의 경우라면 A={1,2} B = {3}로 배치할 수 있다. 그런데 R3의 경우라면 경쟁관계인 어떤 두 사람은 같은 부서에 배치될 수밖에 없으므로 KOI식 배치가 불가능하다. R4의 경우도 KOI식 배치가 불가능한데,  A={1,2}, B={3}로 배치하면 친구관계인 2와 3이 다른 부서에 배치되고, A={2,3}, B={1}로 나누면 친구관계인 1과 2가 서로 다른 부서로 분리 배치되기 때문이다. 
신입사원이 4명인 경우를 생각해보자. 이 경우 아래 R5나 R6의 경우에는 모두 KOI식 배치는 가능하다. R5의 경우  KOI식 배치를 하면 양쪽 부서원의 차이는 2명이며, R6의 경우 그 두 부서원의 차이는 0, 즉 두 부서의 인원은 같다. 

여러분은 주어진 친구, 경쟁관계 데이터를 이용해서 KOI식 배치가 가능한지를 판단하는 프로그램을 작성해야 한다.
<입력값>
이 파일에는 항상 5개의 검사용 데이터가 주어진다. 
각 검사용 데이터의 첫 줄에는 신입사원의 수 N, 그리고 친구 또는 경쟁 관계를 나타내는 자료의 수 M이 하나의 공백을 두고 나타난다. 
이 문제에서 N명의 신입사원은 정수 1, 2,3,..., N으로 표시된다. 그리고 이어지는 M개의 줄에는 +(x,y)와 -(x,y)의 관계가 각각 '1 x y' 과 '-1 x y' 의 형식으로  주어진다.  N과 M은 3 이상 10,000 이하의 정수이다.
<출력값>
입력 파일에 제시된 5개의 검사용 데이터에 대하여 KOI식 부서배치가 가능한지를 계산하여 그 결과를 5개의 줄에 각각 출력한다. 만일 KOI식 배치가 가능하면 두 부서 인원의 차이를 나타내는 음이 아닌 정수 값을 출력하고, 만일 KOI식 배치가 불가능하면 음수 ‘-1’을 출력한다.

<문제 2454>
N개의 도시들과 이들 도시들을 연결하는 트리 형태의 도로망이 있다. 즉, 이 도로망은 임의의 두 도시 사이의 경로가 항상 하나만 있다. 다음은 11개의 도시들로 이루어진 트리 형태의 도로망의 예이다.


두 도시 u, v사이의 경로는 u로부터 인접한 도로들을 따라 v에 도달하는 길로서, 중간에 거치는 도시가 중복되어서는 안 된다. 이 경로는 u부터 시작하여 지나는 도시들을 순서대로 나열하여 나타낸다. 예를 들어, 9부터 10까지의 경로는 (9, 8, 2, 10)으로 나타낸다.
양의 정수 K에 대하여, 이 트리 형태의 도로망의 K-경로 분할은 다음 조건을 만족하는 경로들의 집합이다. 

	(1) 이들 경로들 중 임의의 두 경로가 같은 도시를 지나서는 안 된다,

	(2) 도로망의 각 도시는 반드시 이들 경로 중 하나에 포함되어야 한다. 

	(3) 각 경로는 길이가 K 이하이어야 한다. 경로의 길이란, 이 경로 상에 있는 도로(간선)의 개수이다.
예를 들어, 위 그림에 있는 도로망의 2-경로 분할 중 하나는 다음과 같다.

	{(1, 2, 10), (8, 9), (3, 4), (6, 5, 7), (11)}

	이 2-경로 분할에 있는 경로들은 아래 그림에서 점선 부분으로 표시되어 있으며,  경로들의 개수가 5이다. 이는 경로들의 수가 최소인 2-경로 분할 중 하나이다. 



	또 다른 예로, 다음은 3-경로 분할 중 하나이다.

	{(1, 2, 3, 4), (8, 9), (10), (6, 5, 11), (7)}

	이 분할에서 경로 개수는 5로서 3-경로 분할 중 경로 수가 가장 작다. 

	또 다른 예로, 다음은 1-경로 분할 중 하나이다.

	{(1, 2), (10), (8, 9), (3, 4), (5, 6), (11), (7)}

	이 분할에서 경로 개수는 7로서 1-경로 분할 중 경로 수가 가장 작다. 
트리 형태의 도로망과 K가 주어질 때, 경로 개수가 가장 작은 K-경로 분할의 경로 수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 도시의 수 N과 K-경로 분할을 위한 수 K가 빈칸을 사이에 두고 입력된다. N은 2 이상 300,000이하이다. K는  1이상 N-1이하인 정수이다. 다음 N-1개의 각 줄에 도로의 양 끝 도시를 나타내는 두 정수가 빈칸을 사이에 두고 주어진다.
<출력값>
경로 개수가 가장 작은 K-경로 분할의 경로 수를 출력한다.

<문제 2455>
최근에 개발된 지능형 기차가 1번역(출발역)부터 4번역(종착역)까지 4개의 정차역이 있는 노선에서 운행되고 있다. 이 기차에는 타거나 내리는 사람 수를 자동으로 인식할 수 있는 장치가 있다. 이 장치를 이용하여 출발역에서 종착역까지 가는 도중 기차 안에 사람이 가장 많을 때의 사람 수를 계산하려고 한다. 단, 이 기차를 이용하는 사람들은 질서 의식이 투철하여, 역에서 기차에 탈 때, 내릴 사람이 모두 내린 후에 기차에 탄다고 가정한다.




 
내린 사람 수
탄 사람 수




1번역(출발역)
0
32


2번역
3
13


3번역
28
25


4번역(종착역)
39
0



예를 들어, 위와 같은 경우를 살펴보자. 이 경우, 기차 안에 사람이 가장 많은 때는 2번역에서 3명의 사람이 기차에서 내리고, 13명의 사람이 기차에 탔을 때로, 총 42명의 사람이 기차 안에 있다.
이 기차는 다음 조건을 만족하면서 운행된다고 가정한다.

기차는 역 번호 순서대로 운행한다.
출발역에서 내린 사람 수와 종착역에서 탄 사람 수는 0이다.
각 역에서 현재 기차에 있는 사람보다 더 많은 사람이 내리는 경우는 없다.
기차의 정원은 최대 10,000명이고, 정원을 초과하여 타는 경우는 없다.

4개의 역에 대해 기차에서 내린 사람 수와 탄 사람 수가 주어졌을 때, 기차에 사람이 가장 많을 때의 사람 수를 계산하는 프로그램을 작성하시오.
<입력값>
각 역에서 내린 사람 수와 탄 사람 수가 빈칸을 사이에 두고 첫째 줄부터 넷째 줄까지 역 순서대로 한 줄에 하나씩 주어진다.
<출력값>
첫째 줄에 최대 사람 수를 출력한다.

<문제 2456>
N명의 학생들이 모인 초등학교 반에서 학급회장 선거를 하려고 한다. 그 중 3명이 회장후보로 나왔고, 이들에 대한 선호도를 N명의 학생들 각각에게 적어내도록 하였다. 세 명의 후보는 후보 1번, 후보 2번, 후보 3번이라 한다.
모든 학생은 3명의 후보 중에서 가장 선호하는 후보에게는 3점, 두 번째로 선호하는 후보에게는 2점, 가장 선호하지 않는 후보에게는 1점을 주어야 한다. 3명의 후보에 대한 한 학생의 선호 점수는 모두 다르며, 1점, 2점, 3점이 정확히 한 번씩 나타나야 한다. 
후보의 최종 점수는 학생들로부터 받은 자신의 선호도 점수를 모두 더한 값이 된다. 그러면 3명의 후보 중 가장 큰 점수를 받은 후보가 회장으로 결정된다. 단, 점수가 가장 큰 후보가 여러 명인 경우에는 3점을 더 많이 받은 후보를 회장으로 결정하고, 3점을 받은 횟수가 같은 경우에는 2점을 더 많이 받은 후보를 회장으로 결정한다. 그러나 3점과 2점을 받은 횟수가 모두 동일하면, 1점을 받은 횟수도 같을 수밖에 없어 회장을 결정하지 못하게 된다.
여러분은 선호도 투표를 통해 얻은 세 후보의 점수를 계산한 후, 유일하게 회장이 결정되는 경우에는 회장으로 결정된 후보의 번호(1, 2, 3 중 한 번호)와 최고 점수를 출력하고, 회장을 결정하지 못하는 경우에는 번호 0과 최고 점수를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 반의 학생들의 수 N (3 ≤ N ≤ 1,000)이 주어진다. 다음 N개의 각 줄에는 각 학생이 제출한 회장후보 3명에 대한 선호 점수가 주어지는 데, 첫 번째 점수는 후보 1번에 대한 점수이고 두 번째 점수는 후보 2번에 대한 점수이고 세 번째 점수는 후보 3번에 대한 점수이다. 이 세 점수는 서로 다르며, 1, 2, 3이 정확히 한 번씩 나타난다.
<출력값>
학생들의 선호도 투표 결과로부터, 회장이 유일하게 결정되는 경우에는 회장으로 결정된 후보의 번호와 최고 점수를 출력하고, 유일하게 결정할 수 없는 경우에는 0과 최고 점수를 출력한다.

<문제 2457>
오늘은 공주님이 태어난 경사스러운 날이다. 왕은 이 날을 기념하기 위해 늘 꽃이 피어있는 작은 정원을 만들기로 결정했다.
총 N개의 꽃이 있는 데, 꽃은 모두 같은 해에 피어서 같은 해에 진다. 하나의 꽃은 피는 날과 지는 날이 정해져 있다. 예를 들어, 5월 8일 피어서 6월 13일 지는 꽃은 5월 8일부터 6월 12일까지는 꽃이 피어 있고, 6월 13일을 포함하여 이후로는 꽃을 볼 수 없다는 의미이다. (올해는 4, 6, 9, 11월은 30일까지 있고, 1, 3, 5, 7, 8, 10, 12월은 31일까지 있으며, 2월은 28일까지만 있다.)
이러한 N개의 꽃들 중에서 다음의 두 조건을 만족하는 꽃들을 선택하고 싶다.

공주가 가장 좋아하는 계절인 3월 1일부터 11월 30일까지 매일 꽃이 한 가지 이상 피어 있도록 한다.
정원이 넓지 않으므로 정원에 심는 꽃들의 수를 가능한 적게 한다. 

N개의 꽃들 중에서 위의 두 조건을 만족하는, 즉 3월 1일부터 11월 30일까지 매일 꽃이 한 가지 이상 피어 있도록 꽃들을 선택할 때, 선택한 꽃들의 최소 개수를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 꽃들의 총 개수 N (1<=N<=100,000)이 주어진다. 다음 N개의 줄에는 각 꽃이 피는 날짜와 지는 날짜가 주어진다. 하나의 날짜는 월과 일을 나타내는 두 숫자로 표현된다. 예를 들어서, 3 8 7 31은 꽃이 3월 8일에 피어서 7월 31일에 진다는 것을 나타낸다.
<출력값>
첫째 줄에 선택한 꽃들의 최소 개수를 출력한다. 만약 두 조건을 만족하는 꽃들을 선택할 수 없다면 0을 출력한다.

<문제 2458>
1번부터 N번까지 번호가 붙여져 있는 학생들에 대하여 두 학생끼리 키를 비교한 결과의 일부가 주어져 있다. 단, N명의 학생들의 키는 모두 다르다고 가정한다. 예를 들어, 6명의 학생들에 대하여 6번만 키를 비교하였고, 그 결과가 다음과 같다고 하자. 

1번 학생의 키 < 5번 학생의 키
3번 학생의 키 < 4번 학생의 키
5번 학생의 키 < 4번 학생의 키
4번 학생의 키 < 2번 학생의 키
4번 학생의 키 < 6번 학생의 키
5번 학생의 키 < 2번 학생의 키

이 비교 결과로부터 모든 학생 중에서 키가 가장 작은 학생부터 자신이 몇 번째인지 알 수 있는 학생들도 있고 그렇지 못한 학생들도 있다는 사실을 아래처럼 그림을 그려 쉽게 확인할 수 있다. a번 학생의 키가 b번 학생의 키보다 작다면, a에서 b로 화살표를 그려서 표현하였다. 

1번은 5번보다 키가 작고, 5번은 4번보다 작기 때문에, 1번은 4번보다 작게 된다. 그러면 1번, 3번, 5번은 모두 4번보다 작게 된다. 또한 4번은 2번과 6번보다 작기 때문에, 4번 학생은 자기보다 작은 학생이 3명이 있고, 자기보다 큰 학생이 2명이 있게 되어 자신의 키가 몇 번째인지 정확히 알 수 있다. 그러나 4번을 제외한 학생들은 자신의 키가 몇 번째인지 알 수 없다. 
학생들의 키를 비교한 결과가 주어질 때, 자신의 키가 몇 번째인지 알 수 있는 학생들이 모두 몇 명인지 계산하여 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 학생들의 수 N (2<=N<=500)과 두 학생 키를 비교한 횟수 M (0<=M<=N(N-1)/2)이 주어진다. 다음 M개의 각 줄에는 두 학생의 키를 비교한 결과를 나타내는 두 양의 정수 a와 b가 주어진다. 이는 번호가 a인 학생이 번호가 b인 학생보다 키가 작은 것을 의미한다.
<출력값>
자신이 키가 몇 번째인지 알 수 있는 학생이 모두 몇 명인지를 출력한다.

<문제 2459>
가로 줄과 세로 줄의 개수가 각각 N인 바둑판 모양이 있다. 여기에서 인접한 두 가로줄 또는 두 세로줄 사이의 거리는 1이다. 또한, 가로줄과 세로줄이 만나서 생기는 교차점은 왼쪽에서 x번째 세로줄과 아래쪽에서 y번째 가로줄의 교차점일 때, (x,y)로 나타낸다. 그러면, 제일 왼쪽, 제일 아래쪽 교차점을 S라 하고, (1,1)로 나타낸다. 

예를 들어, N=5인 경우에 바둑판 모양은 위와 같고, 교차점 A와 B는 각각 (2,3)와 (4,2)로 나타낸다.  
이제 하나의 철사를 다음 규칙에 따라서 바둑판 모양에 놓는다. 

철사는 바둑판 모양의 가로줄과 세로줄 위에만 놓인다.
철사는 바둑판 모양의 가로줄과 세로줄의 교차점에서만 직각으로 꺾일 수 있다.
철사는 겹쳐서 놓일 수 있다. 
철사의 시작점과 끝점은 모두 S이고 이들은 (용접하여) 붙여져 있다.

예를 들어, N=5인 위 그림 모양의 바둑판에서 철사를 S=(1,1)에서 시작해서 순서대로 교차점 (3,1), (3,4), (2,4), (2,3), (4,3), (4,5), (1,5) 에서 꺾어서 S=(1,1)에 연결 할 수 있다. 
철사가 놓여 지면 세로줄과 평행한 직선으로 바둑판 모양을 자른다. 그러면 철사는 이 직선에 의해 여러 조각들로 나누어질 수 있다. 이 직선은 인접한 두 세로줄 사이를 정확히 가운데로 지나고, 철사를 반드시 2개 이상의 조각으로 나눈다고 가정한다.
위 규칙들을 만족하게 놓여 진 철사와 자르는 직선이 주어지면, 이 직선에 의해 나누어진 철사 조각들 중에서 가장 긴 조각의 길이를 찾는 프로그램을 작성하시오.
예를 들어, 아래 그림과 같이 위의 예에서 놓여진 철사에 대해서 2번째 세로줄과 3번째 세로줄 사이를 지나는 직선으로 나누어진 철사 조각들 중에서 가장 긴 부분의 길이는 7이다.
<입력값>
첫 번째 줄에 가로줄과 세로줄의 개수인 N (2 ≤ N ≤ 1,000,000)이 주어진다. 다음 줄에는 철사가 꺾여진 점들의 개수 K (1 ≤ K ≤ 100,000)가 주어진다. 다음 K줄 각각에 철사가 꺾여진 교차점을 나타내는 (x,y)의 x와 y가 공백으로 구별해서 주어진다. 그리고, 다음 줄에는 철사를 자르는 직선이 지나는 I번째 세로줄과 번째 세로줄 I+1사이를 나타내는 수 I(1 ≤ I ≤ N-1)가 주어진다.
<출력값>
첫째 줄에 잘려진 철사의 조각들 중 가장 긴 조각의 길이를 출력한다.

<문제 2460>
최근에 개발된 지능형 기차가 1번역(출발역)부터 10번역(종착역)까지 10개의 정차역이 있는 노선에서 운행되고 있다. 이 기차에는 타거나 내리는 사람 수를 자동으로 인식할 수 있는 장치가 있다. 이 장치를 이용하여 출발역에서 종착역까지 가는 도중 기차 안에 사람이 가장 많을 때의 사람 수를 계산하려고 한다. 단, 이 기차를 이용하는 사람들은 질서 의식이 투철하여, 역에서 기차에 탈 때, 내릴 사람이 모두 내린 후에 기차에 탄다고 가정한다.



 
내린 사람 수
탄 사람 수


1번역(출발역)
0
32


2번역
3
13


3번역
28
25


4번역
17
5


5번역
21
20


6번역
11
0


7번역
12
12


8번역
4
2


9번역
0
8


10번역(종착역)
21
0



예를 들어, 위와 같은 경우를 살펴보자. 이 경우, 기차 안에 사람이 가장 많은 때는 2번역에서 3명의 사람이 기차에서 내리고, 13명의 사람이 기차에 탔을 때로, 총 42명의 사람이 기차 안에 있다.
이 기차는 다음 조건을 만족하면서 운행된다고 가정한다.

기차는 역 번호 순서대로 운행한다.
출발역에서 내린 사람 수와 종착역에서 탄 사람 수는 0이다.
각 역에서 현재 기차에 있는 사람보다 더 많은 사람이 내리는 경우는 없다.
기차의 정원은 최대 10,000명이고, 정원을 초과하여 타는 경우는 없다.

10개의 역에 대해 기차에서 내린 사람 수와 탄 사람 수가 주어졌을 때, 기차에 사람이 가장 많을 때의 사람 수를 계산하는 프로그램을 작성하시오.
<입력값>
각 역에서 내린 사람 수와 탄 사람 수가 빈칸을 사이에 두고 첫째 줄부터 열 번째 줄까지 역 순서대로 한 줄에 하나씩 주어진다.
<출력값>
첫째 줄에 최대 사람 수를 출력한다.

<문제 2461>
KOI 중학교에는 N개의 학급이 있으며, 각 학급의 학생 수는 모두 M명으로 구성된다. 이 중학교에서는 체육대회에 새로운 종목의 경기를 추가하였다. 이 경기에 대해 모든 학생들은 저마다의 능력을 나타내는 능력치를 가지고 있으며, 이 능력치는 모든 학생이 서로 다르다.

	이 경기는 한반에서 한 명의 대표선수를 선발하여 치른다. 경기의 형평성을 위하여, 각각의 반에서 대표로 선발된 모든 학생들의 능력치 중 최댓값과 최솟값의 차이가 최소가 되도록 선수를 선발하려고 한다. 예를 들어, N=3, M=4인 경우 학생들의 능력치가 1반=[12, 16, 67, 43],  2반=[7, 17, 68, 48], 3반=[14, 15, 77, 54]로 주어질 때, 각 학급으로부터 능력치 16, 17, 15를 가진 학생을 각각 선택하면, 최댓값과 최솟값의 차이가 17-15=2로 최소가 된다. 

	대표로 선발된 모든 학생들 능력치의 최댓값과 최솟값 차이가 최소가 되는 경우의 값을 출력하는 프로그램을 작성하시오.
<입력값>
입력의 첫 번째 줄에는 학급의 수를 나타내는 N과 각 학급의 학생의 수를 나타내는 M이 하나의 빈칸을 사이에 두고 주어진다. 단, 1<=N,M<=1,000이다. 두 번째 줄부터 N개의 줄에는 각 줄마다 한 학급 학생들의 능력치를 나타내는 M개의 양의 정수가 하나의 빈칸을 사이에 두고 주어진다. 능력치는 0이상 10^9이하이다.
<출력값>
대표로 선발된 모든 학생들 능력치의 최댓값과 최솟값 차이가 최소가 되는 경우의 값을 하나의 정수로 출력한다.

<문제 2462>
연아와 연재는 아래 그림과 같은 모양으로 보도블록이 깔린 지역에서 자주 놀곤 한다. M개의 행과 N개의 열로 이루어진 M*N크기의 보도블록은 2MN개의 타일들로 구성되는데, 이 타일들은 짧은 변과 긴 변의 길이 비가 1:2인 직사각형 모양으로 크기가 동일하고, 색은 흰색과 회색 두 종류가 있다. 



	M*N 크기의 보도블록에서 각 행은 위에서 아래로 1부터 M까지 번호가 매겨져 있고, 각 열은 왼쪽에서 오른쪽으로 1부터 N까지 번호가 매겨져 있다고 하자. i행 j열에는 색이 다른 두 타일이 정사각형 모양으로 맞붙어 배치되어 있는데, 배치된 모양은 i+j의 값에 따라 다음 두 가지 중 하나이다.

	(A) i+j의 값이 짝수이면, 그림 1(a)의 1행 1열처럼 두 타일이 가로로 배치되어 있으며 위의 것이 흰색이다.

	(B) i+j의 값이 홀수이면, 그림 1(a)의 1행 2열처럼 두 타일이 세로로 배치되어 있으며 왼쪽의 것이 흰색이다.

	i행 j열의 흰색 타일은 (i,j,0)으로 나타내고 회색 타일은 (i,j,1)로 나타낸다.

	연아와 연재는 이 보도블록에서 자주 게임을 하는데, 이 게임의 규칙은 간단하다. 먼저 보도블록의 크기를 정한다. 그런 다음 이 보도블록에 속한 타일 하나에서 출발하여 아래의 조건을 만족하면서 가능한 많은 개수의 타일을 밟고 지나서 다시 출발한 타일로 되돌아오는 게임이다.

	(1) 출발하는 타일은 임의로 정할 수 있다.

	(2) 하나의 타일은 정확히 한번만 밟고 지날 수 있다. 단, 출발한 타일은 출발할 때와 도착할 때 한 번씩 두 번 밟게 된다.

	(3) 한 타일에서 다음 타일로 이동할 때 반드시 변을 맞대고 있는 타일로 이동해야 한다. 따라서 한 타일에서 이동 가능한 타일은 최대 5개이다. 예를 들면, 그림 1(a)의 1행 2열에 있는 흰색 타일에서는 바로 오른쪽 회색 타일, 바로 아래 흰색 타일, 바로 왼쪽의 흰색 또는 회색 타일로만 이동 가능하다.

	예를 들어 그림 1(a)와 같이  크기의 보도블록에서는 다음과 같은 방법으로 12개의 타일을 모두 지날 수 있다.
  

	(1,1,1) -> (1,1,0) -> (1,2,0) ->

	(1,2,1) -> (1,3,0) -> (1,3,1) ->

	(2,3,1) -> (2,3,0) -> (2,2,0) ->

	(2,2,1) -> (2,1,1) -> (2,1,0) -> (1,1,1)

	보도블록의 크기 M*N이 주어질 때 최대 몇 개의 타일을 지날 수 있는지, 그리고 어떤 순서로 타일을 지나야 최대 개수의 타일을 지나게 되는지를 알아내는 프로그램을 작성 하시오.
<입력값>
첫 째 줄에 보도블록의 행의 개수 M과 열의 개수 N을 나타내는 두 개의 정수가 빈칸을 사이에 두고 주어진다. (2<=M,N<=100)
<출력값>
첫째 줄에 밟고 지날 수 있는 타일의 최대 개수 K를 출력한다. 다음 K개의 줄에, 밟고 지나는 순서대로 출발점부터 시작하여 개의 타일들을 한 줄에 하나씩 출력한다. (마지막에 돌아온 출발점은 다시 출력하지 않는다.) 하나의 줄에는 하나의 타일을 나타내는 3개의 정수 i, j, c를 빈칸을 사이에 두고 출력한다. 여기서, i는 타일의 행 번호, j는 타일의 열 번호,  c (0 또는 1)는 타일의 색을 나타낸다.

<문제 2463>
간선(혹은 에지)에 가중치가 주어진 그래프가 있다. 정점들의 수가 N일 때, 모든 정점은 1부터 N까지 번호가 붙여져 있고, 모든 간선들의 가중치는 서로 다르다. 이때 서로 다른 두 정점 u,v에 대하여, Cost(u,v)는 다음에서 제거되는 간선들의 가중치 합이다: u와 v사이의 경로가 있으면 이 그래프의 최소 가중치 간선을 그래프에서 제거한다. 이 과정을 u와 v사이의 경로가 없을 때까지 반복한다.
예를 들어, 6개의 정점으로 이루어진 다음 그래프를 고려해 보자.

 
두 정점 2, 6에 대하여, Cost(2,6)을 구하는 과정에서 제거되는 간선들을 차례대로 나열하면 다음과 같다: (2, 3), (4, 5), (3, 5), (3, 4), (2, 6).
이들 간선들 중 (2, 6)이 제거될 때, 두 정점 2와 6사이의 경로가 없으므로 간선 제거가 끝나게 된다. 따라서  Cost(2,6) = 2 + 3 + 4 + 5 + 6 = 20이다.
간선에 가중치가 있는 그래프가 주어질 때, u<v인 모든 두 정점 u,v에 대한 Cost(u,v)들의 총 합을 구하는 프로그램을 작성하시오. 총 합이 10^9보다 크거나 같으면 이를 10^9으로 나눈 나머지를 출력한다.
<입력값>
첫 번째 줄에 정점의 수 N (1<=N<=100,000)과 간선의 수 M (1<=M<=100,000)이 빈칸을 사이에 두고 주어진다. 다음 M개의 각 줄에 간선 하나에 대한 정보를 나타내는 세 개의 양의 정수 x,y,w가 빈칸을 사이에 두고 주어진다. 이는 간선 (x,y)의 가중치가w 임을 의미한다. 1<=w<=100,000이다.
<출력값>
u<v인 모든 두 정점 에 대한 Cost(u,v)들의 총 합을 첫째 줄에 출력한다. 단, 총 합이 10^9보다 크거나 같으면 이를 10^9으로 나눈 나머지를 출력한다.

<문제 2464>
KOI 보안회사에서는 자동으로 비밀번호를 만드는 시스템을 연구하고 있다. 주어진 하나의 양의 정수에 대하여 다음의 원칙에 따라 두 수를 만들어 비밀번호를 정하려고 한다.

	하나의 주어진 양의 정수 A에 대하여 비밀번호를 위한 두 수를 만드는 방법은 다음과 같다.

	1. A의 이진수 표현에서 나오는 1의 개수 x를 찾는다. 

	2. A보다 작은 수 중에서 그 수의 이진수 표현에서 1의 개수가 x와 같고 A에 가장 가까운 수를 하나 찾는다. 

	3. A보다 큰 수 중에서 그 수의 이진수 표현에서 1의 개수가 x와 같고 A에 가장 가까운 수를 하나 찾는다. 

	예를 들어, 주어진 수 가 43이면, 이 수의 이진수 표현은 101011이다. 이 이진수는 1의 개수가 4이다. 그러므로 43보다 작고 43에 가장 가까우며 이진수 표현에서 1의 개수가 4인 수는 39=100111이다. 또한  43보다 크고 43에 가장 가까우며 이진수 표현에서 1의 개수가 4인 수는 45=101101이다.

	이 두 수를 찾아 출력하는 프로그램을 작성하시오.
<입력값>
입력의 첫 번째 줄에는 하나의 양의 정수 A가 주어진다. 단, 1<=A<=10^18이다.
<출력값>
주어진 수 보다 작은 수 중에서 이진수의 1의 개수가 같으며 가장 가까운 수와, 주어진 수 보다 큰 수 중에서 이진수의 1의 개수가 같으며 가장 가까운 수를 한 줄에 빈칸을 사이에 두고 출력한다. 만약 그러한 수가 존재하지 않으면 그 수에 대해서는 0을 출력한다.

<문제 2465>
N명의 사람들이 어떤 공연장에 입장하기 위해서 한 줄로 서 있다. 줄 서 있는 각 사람은 자기 앞에 서 있는 사람들 중에서 자기보다 키가 작거나 같은 사람들의 수를 알고 있다. 그러면, 이 수들을 표시하는 수열을 S라고 한다.

	N명의 키 집합과 수열 S가 주어질 때, 원래 줄 서 있는 키 순서를 정확히 찾아내는 프로그램을 작성하시오. 

	예를 들어서, 사람들의 키 집합이 다음과 같이 주어진다 (여기서, 같은 키의 사람들이 여러 명 존재할 수 있어서 중복이 포함된다). 

	{120, 167, 163, 172, 145, 134, 182, 155, 167, 120, 119, 156}

	또한 각 사람이 자기 앞에 있는 사람들 중에서 자기보다 키가 작거나 같은 사람들의 수를 표시하는 수열 S는 다음과 같이 주어진다. 

	S :   0 1 0 0 3 2 6 7 4 6 9 4

	그러면, 실제 줄 서 있는 사람들의 키 순서는 다음과 같다. 

	134 167 120 119 156 120 167 182 155 163  172 145
<입력값>
첫째 줄에는 전체 사람의 수 N (1<=N<=100,000)이 주어진다. 다음 N개의 줄에 사람들의 키를 나타내는 양의 정수가 하나씩 주어진다. 여기서 모든 키들은 2*10^9이하이다. 그리고 마지막 줄에 수열 S가 한 줄로 주어진다. 단 그 수열의 수는 하나의 공백을 두고 나타난다.
<출력값>
출력은 N개의 줄로 구성된다. N개의 줄 각각에 원래 줄 서 있는 사람들의 키를 순서대로 하나씩 출력한다.

<문제 2466>
찬수는 1번에서 N번까지 번호가 매겨진 N권의 책을 가지고 있다. 찬수는 이 책을 꽂을 수 있는 책장을 설계하려고 한다. 찬수가 가지고 있는 i번 책의 두께는 ti이고, 높이는 hi이다. 단, 1 ≤ i ≤ N이다. 이 책들을 번호 순서대로 책장에 꽂아야하고 번호의 순서를 임의로 바꾸어 꽂을 수 없다.
이 책들을 책장의 가장 아래 칸부터 위 칸의 순서로, 같은 칸에서는 왼쪽부터 오른쪽으로 책의 번호 순서로 꽂는다. 한번 위 칸으로 옮겨와서 책을 꽂으면 다시 아래 칸으로 내려가서 책을 꽂을 수 없다. 책장의 칸의 높이는 그 칸에 꽂는 책들 중 가장 높이가 높은 책에 의해 결정되며 책이 꽂혀있는 칸들의 높이의 합이 책장의 높이가 된다. 책장의 폭은 꽂혀있는 책의 두께의 합이 가장 큰 칸에 의해 결정된다. 단, 책장을 구성하는 나무의 두께는 고려하지 않는다. 
책을 모두 꽂은 후의 책장 전체의 높이를 H, 책장의 폭을 L이라고 할 때, 찬수는 H와 L중 최댓값을 최소로 하는 책장을 설계하려고 한다.
이 책장의 H와 L중 최댓값을 최소로 하는 책장을 구하는 프로그램을 작성하시오.
<입력값>
입력의 첫 번째 줄에 책의 수를 나타내는 하나의 정수 N이 주어진다. 두 번째 줄부터 N개의 줄에, 책들의 번호 순서대로 한 줄에 한권씩, 각 책에 대한 두께 ti와 높이 hi를 나타내는 두 정수가 하나의 빈칸을 사이에 두고 주어진다.
<출력값>
첫째 줄에 책을 모두 꽂은 후의 책장 전체의 높이와 책장의 폭 중에서 최댓값을 최소로 하는 값을 하나의 정수로 출력한다.

<문제 2467>
KOI 부설 과학연구소에서는 많은 종류의 산성 용액과 알칼리성 용액을 보유하고 있다. 각 용액에는 그 용액의 특성을 나타내는 하나의 정수가 주어져있다. 산성 용액의 특성값은 1부터 1,000,000,000까지의 양의 정수로 나타내고, 알칼리성 용액의 특성값은 -1부터 -1,000,000,000까지의 음의 정수로 나타낸다.
같은 양의 두 용액을 혼합한 용액의 특성값은 혼합에 사용된 각 용액의 특성값의 합으로 정의한다. 이 연구소에서는 같은 양의 두 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들려고 한다. 
예를 들어, 주어진 용액들의 특성값이 [-99, -2, -1, 4, 98]인 경우에는 특성값이 -99인 용액과 특성값이 98인 용액을 혼합하면 특성값이 -1인 용액을 만들 수 있고, 이 용액의 특성값이 0에 가장 가까운 용액이다. 참고로, 두 종류의 알칼리성 용액만으로나 혹은 두 종류의 산성 용액만으로 특성값이 0에 가장 가까운 혼합 용액을 만드는 경우도 존재할 수 있다.
산성 용액과 알칼리성 용액의 특성값이 정렬된 순서로 주어졌을 때, 이 중 두 개의 서로 다른 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들어내는 두 용액을 찾는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 전체 용액의 수 N이 입력된다. N은 2 이상 100,000 이하의 정수이다. 둘째 줄에는 용액의 특성값을 나타내는 N개의 정수가 빈칸을 사이에 두고 오름차순으로 입력되며, 이 수들은 모두 -1,000,000,000 이상 1,000,000,000 이하이다. N개의 용액들의 특성값은 모두 서로 다르고, 산성 용액만으로나 알칼리성 용액만으로 입력이 주어지는 경우도 있을 수 있다.
<출력값>
첫째 줄에 특성값이 0에 가장 가까운 용액을 만들어내는 두 용액의 특성값을 출력한다. 출력해야 하는 두 용액은 특성값의 오름차순으로 출력한다. 특성값이 0에 가장 가까운 용액을 만들어내는 경우가 두 개 이상일 경우에는 그 중 아무것이나 하나를 출력한다.

<문제 2468>
재난방재청에서는 많은 비가 내리는 장마철에 대비해서 다음과 같은 일을 계획하고 있다. 먼저 어떤 지역의 높이 정보를 파악한다. 그 다음에 그 지역에 많은 비가 내렸을 때 물에 잠기지 않는 안전한 영역이 최대로 몇 개가 만들어 지는 지를 조사하려고 한다. 이때, 문제를 간단하게 하기 위하여, 장마철에 내리는 비의 양에 따라 일정한 높이 이하의 모든 지점은 물에 잠긴다고 가정한다.
어떤 지역의 높이 정보는 행과 열의 크기가 각각 N인 2차원 배열 형태로 주어지며 배열의 각 원소는 해당 지점의 높이를 표시하는 자연수이다. 예를 들어, 다음은 N=5인 지역의 높이 정보이다.

이제 위와 같은 지역에 많은 비가 내려서 높이가 4 이하인 모든 지점이 물에 잠겼다고 하자. 이 경우에 물에 잠기는 지점을 회색으로 표시하면 다음과 같다. 

물에 잠기지 않는 안전한 영역이라 함은 물에 잠기지 않는 지점들이 위, 아래, 오른쪽 혹은 왼쪽으로 인접해 있으며 그 크기가 최대인 영역을 말한다. 위의 경우에서 물에 잠기지 않는 안전한 영역은 5개가 된다(꼭짓점으로만 붙어 있는 두 지점은 인접하지 않는다고 취급한다). 
또한 위와 같은 지역에서 높이가 6이하인 지점을 모두 잠기게 만드는 많은 비가 내리면 물에 잠기지 않는 안전한 영역은 아래 그림에서와 같이 네 개가 됨을 확인할 수 있다. 

이와 같이 장마철에 내리는 비의 양에 따라서 물에 잠기지 않는 안전한 영역의 개수는 다르게 된다. 위의 예와 같은 지역에서 내리는 비의 양에 따른 모든 경우를 다 조사해 보면 물에 잠기지 않는 안전한 영역의 개수 중에서 최대인 경우는 5임을 알 수 있다. 
어떤 지역의 높이 정보가 주어졌을 때, 장마철에 물에 잠기지 않는 안전한 영역의 최대 개수를 계산하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 어떤 지역을 나타내는 2차원 배열의 행과 열의 개수를 나타내는 수 N이 입력된다. N은 2 이상 100 이하의 정수이다. 둘째 줄부터 N개의 각 줄에는 2차원 배열의 첫 번째 행부터 N번째 행까지 순서대로 한 행씩 높이 정보가 입력된다. 각 줄에는 각 행의 첫 번째 열부터 N번째 열까지 N개의 높이 정보를 나타내는 자연수가 빈 칸을 사이에 두고 입력된다. 높이는 1이상 100 이하의 정수이다.
<출력값>
첫째 줄에 장마철에 물에 잠기지 않는 안전한 영역의 최대 개수를 출력한다.

<문제 2469>
k명의 참가자들이 사다리 타기를 통하여 어떤 순서를 결정한다. 참가자들은 알파벳 대문자 첫 k개로 표현되며, 사다리 타기를 시작할 때의 순서는 아래 그림과 같이 항상 알파벳 순서대로이다. 
k=10 인 예를 들어 보자. 10명의 A, B, C, D, E, F, G, H, I, J 참가자들이 사다리 타기를 준비한다. 아래 그림은 10개의 세로 줄과 5개의 가로 줄을 가지고 있는 사다리의 한 예를 보여주고 있다.  


이 사다리에서 점선은 가로 막대가 없음을, 굵은 가로 실선은 옆으로 건너갈 수 있는 가로 막대가 있음을 나타내고 있다.  
따라서 위에 제시된 사다리를 타면 그 최종 도달된 순서는 왼쪽으로부터 A, C, G, B, E, D, J, F, I, H 가 된다. 
사다리 타기는 세로 막대를 타고 내려오는 중에 가로막대를 만나면 그 쪽으로 옮겨 가면서 끝까지 내려가는 과정이다.  따라서 사다리 타기의 규칙 특성상 아래 그림과 같이 두 가로 막대가 직접 연결될 수는 없으므로 이 상황은 이 문제에서 고려할 필요가 없다.


우리는 하나의 가로 줄이 감추어진 사다리를 받아서 그 줄의 각 칸에 가로 막대를 적절히 넣어서 참가자들의 최종 순서가 원하는 순서대로 나오도록 만들려고 한다.  
입력에서 사다리의 전체 모양은 각 줄에 있는 가로 막대의 유무로 표현된다. 각 줄에서 가로 막대가 없는 경우에는 ‘*’(별)문자, 있을 경우에는 ‘-’(빼기) 문자로 표시된다. 그리고 감추어진 특정 가로 줄은 길이 k-1인 ‘?’ (물음표) 문자열로 표시되어 있다.
<입력값>
첫 줄에는 참가한 사람의 수 k가 나온다(3≤k≤26). 그 다음 줄에는 가로 막대가 놓일 전체 가로 줄의 수를 나타내는 n이 나온다(3≤n≤1,000). 그리고 세 번째 줄에는 사다리를 타고 난 후 결정된 참가자들의 최종 순서가 길이 k인 대문자 문자열로 들어온다.  
k와 n, 그리고 도착순서 문자열이 나타난 다음, 이어지는 n개의 줄에는 앞서 설명한 바와 같이 ‘*’와 ‘-’ 문자로 이루어진 길이 k-1인 문자열이 주어진다. 그 중 감추어진 가로 줄은 길이가 k-1인 ‘?’ 문자열로 표시되어 있다.
<출력값>
입력 파일 세 번째 줄에서 지정한 도착순서가 해당 사다리에서 만들어질 수 있도록 감추어진 가로 줄을 구성해야 한다. 
여러분은 감추어진 가로 줄의 상태를 재구성하여 이를 ‘*’(별) 문자와 ‘-’(빼기) 문자로 구성된 길이 k-1인 문자열로 만들어 출력하면 된다.
그런데 어떤 경우에는 그 감추어진 가로 줄을 어떻게 구성해도 원하는 순서를 얻을 수 없는 경우도 있다.  이 경우에는   ‘x’(소문자 엑스)로 구성된 길이 k-1인 문자열을 출력해야 한다.

<문제 2470>
KOI 부설 과학연구소에서는 많은 종류의 산성 용액과 알칼리성 용액을 보유하고 있다. 각 용액에는 그 용액의 특성을 나타내는 하나의 정수가 주어져있다.  산성 용액의 특성값은 1부터 1,000,000,000까지의 양의 정수로 나타내고, 알칼리성 용액의 특성값은 -1부터 -1,000,000,000까지의 음의 정수로 나타낸다.
같은 양의 두 용액을 혼합한 용액의 특성값은 혼합에 사용된 각 용액의 특성값의 합으로 정의한다. 이 연구소에서는 같은 양의 두 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들려고 한다. 
예를 들어, 주어진 용액들의 특성값이 [-2, 4, -99, -1, 98]인 경우에는 특성값이 -99인 용액과 특성값이 98인 용액을 혼합하면 특성값이 -1인 용액을 만들 수 있고, 이 용액이 특성값이 0에 가장 가까운 용액이다. 참고로, 두 종류의 알칼리성 용액만으로나 혹은 두 종류의 산성 용액만으로 특성값이 0에 가장 가까운 혼합 용액을 만드는 경우도 존재할 수 있다.
산성 용액과 알칼리성 용액의 특성값이 주어졌을 때, 이 중 두 개의 서로 다른 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들어내는 두 용액을 찾는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 전체 용액의 수 N이 입력된다. N은 2 이상 100,000 이하이다. 둘째 줄에는 용액의 특성값을 나타내는 N개의 정수가 빈칸을 사이에 두고 주어진다. 이 수들은 모두 -1,000,000,000 이상 1,000,000,000 이하이다. N개의 용액들의 특성값은 모두 다르고, 산성 용액만으로나 알칼리성 용액만으로 입력이 주어지는 경우도 있을 수 있다.
<출력값>
첫째 줄에 특성값이 0에 가장 가까운 용액을 만들어내는 두 용액의 특성값을 출력한다. 출력해야 하는 두 용액은 특성값의 오름차순으로 출력한다. 특성값이 0에 가장 가까운 용액을 만들어내는 경우가 두 개 이상일 경우에는 그 중 아무것이나 하나를 출력한다.

<문제 2471>
여러 개의 0과 1의 숫자들이 달려있는 모빌이 하나 있다. 모빌은 가로 막대와 그 가로 막대에 0과 1, 혹은 다른 가로 막대가 아래에 차례대로 달려있는 모양으로 구성되어 있다. 예를 들어 하나의 모양을 보면 다음과 같다.


모빌의 균형은 언제나 잘 잡혀있다고 가정하자. 모빌에 바람이 불면 각 가로 막대는 회전을 하게 되는데 그렇게 되면 여러 가지 다른 모양의 모빌을 형성하게 된다. 우리는 모빌의 한 상태에서 하나의 이진수를 만들어 낼 수 있는데, 그 수는 모빌의 현재 상태를 아래와 같은 방법으로 괄호와 0, 1을 사용해서 표현한 것에서, 왼쪽부터 0과 1들을 읽어내면서 만들어지는 수이다.
표현 방법 : 모빌의 하나의 가로 막대를 하나의 괄호 쌍 안에 표현한다. 괄호 내부에 0, 1들과 그 아래 가로 막대들의 (괄호를 이용한) 표현을 현재 상태에서 달려 있는 순서에 따라 왼쪽부터 적는다.
모빌의 표현은 반드시 여는 괄호로 시작하여 닫는 괄호로 끝난다는 것에 주의하라. 예를 들어, 왼쪽 그림의 모빌의 상태는 아래와 같이 표현된다.

(10(1011)00(10(01))) 
위와 같이 표현되는 모빌의 상태에서 만들어지는 이진수는, 괄호들을 제거하면  101011001001 임을 알 수 있다. 
만약, 이 상태에서 중간 1011 가로 막대가 회전을 한다면 101101001001이라는 숫자를 얻게 되고, 다시 이 상태에서 가장 상위에 있는 가로 막대가 움직이면 전체의 숫자가 뒤집혀 100100101101이라는 숫자를 얻게 된다. 주어진 모빌로부터 생성이 가능한 이진수를 모빌 이진수라고 말한다. 
모빌의 하나의 상태가 주어졌을 때, 그 상태를 변화시키면 매우 다양한 모빌 이진수를 관찰할 수 있는데, 이 문제의 목표는 관찰 가능한 모든 모빌 이진수들 중에서 K번째로 작은 모빌 이진수를 찾아내는 것이다. 단, 모빌의 서로 다른 형태가 동일한 모빌 이진수를 만들어 내는 경우, 동일한 숫자들은 “하나만” 남기고 나머지는 모두 제거하여야 한다. 예를 들어, 다음과 같은 모빌의 경우, 

(0(1(01))1)

	관찰되는 모빌 이진수는 (크기 순서에 관계없이) 01011, 11010, 10110 등이 있다. 만일 K=3 이라면 모빌 이진수들 중 3번째로 작은 숫자인 01101 을 출력해야 한다. 과정의 일부를 보이면 다음과 같다.

(0((01)1)1)

	-> 00111

	-> 가장 작은 수

(0((10)1)1)

	-> 01011

	-> 2번째로 작은 수

(0(1(01))1)

	-> 01011

	-> 위의 수와 동일

(0(1(10))1)

	-> 01101

	-> 3번째로 작은 수
만일 K가 관찰 가능한 모든 모빌 이진수의 총 개수보다 많은 경우 (예를 들어, 관찰 가능한 모든 모빌 이진수의 총 개수는 10개인데 K=15로 주어짐), 여러분은 대문자로 NO를 출력해야 한다.
<입력값>
첫째 줄에는 0, 1과 괄호들로 구성된 모빌의 상태 표현이 주어진다. 모빌의 상태 표현은 빈칸 없이 이어진 문자열로 주어진다. 주어지는 0, 1과 괄호들의 총 개수는 200개 이하이다. 둘째 줄에는 K가 주어진다. K의 값은 1,000이하 자연수이다. 잘못된 형식의 입력은 없다고 가정해도 좋다.
<출력값>
하나의 줄에 K번째로 작은 모빌 이진수 혹은 대문자로 NO를 출력한다. 숫자가 0으로 시작하는 경우에 앞의 0들도 반드시 출력하여야 한다.

<문제 2472>
홍길동은 요즘 한창 인기가 많은 KOI 치킨 체인점을 차리려고 계획하고 있다. 홍길동이 사는 지역의 도로 지도는 아래 그림과 같다. 그림에서 원으로 표시된 부분은 체인점의 매장 설치 후보지이고, 선은 도로를 나타내며 선 옆에 표시된 값은 도로의 길이이다. 이 지역에는 대규모 아파트 단지가 세 군데 있다. 아파트의 위치는 그림에서 A, B, C로 표시된 원이다. 이 지역의 모든 교차로는 연결된 도로의 개수가 5개 이하이고, 도로를 통해 어떤 장소라도 찾아갈 수 있다.

위 그림에서 매장 후보지 1에 매장을 설치한다고 하자. 후보지 1에서 아파트 단지 A, B, C까지의 최단 경로 길이는 각각 8, 16, 9이다. 이 값들은 매장 후보지 4에서 아파트 단지 A, B, C까지 최단 경로의 길이인 6, 7, 3보다 각각 더 크다. 사람들은 더 가까운 매장을 이용하는 경향이 있기 때문에, 아파트 단지까지의 거리를 비교할 때 후보지 1은 모든 면(각 아파트까지의 거리)에서 후보지 4보다 불리한 위치이다. 후보지 6의 경우는 아파트 단지 A, B, C까지의 거리가 각각 5, 3, 5이므로, 후보지 1과 비교하면 모든 면에서 유리하지만, 후보지 4와 비교하면 아파트 단지 A, B에는 유리하고 C에는 불리하다. 
이런 이유 때문에 홍길동은 매장 위치를 결정하는데 있어 다음의 기준을 정해 놓았다. 

매장 후보지 p에서 아파트 단지 A, B, C까지의 최단 경로 길이를 각각 a, b, c라고 하고 다른 매장 후보지 q가 존재해서 q에서 아파트 단지 A, B, C까지의 최단 경로 길이를 각각 x, y, z라고 할 때, a > x 이고 b > y 이고 c > z이면 p에는 매장을 설치하지 않는다.

홍길동은 자신이 원하는 어떤 장소에 매장을 차릴 수 있는지를 알려고 한다. 질의로서 매장 후보지가 하나 주어질 때 그 곳에 매장을 차릴 수 있는지 여부를 판별하는 프로그램을 작성하시오. 질의는 여러 개가 들어올 수 있다. 아파트 단지가 위치한 장소에도 매장을 설치할 수 있다는 점과 각 교차로는 기껏해야 오거리임에 유의하라.
<입력값>
첫째 줄에는 매장 후보지의 개수를 나타내는 정수 N이 입력된다(1≤N≤100,000). 매장 후보지들은 1부터 N까지의 번호로 구분된다. 둘째 줄에는 아파트 단지의 위치를 나타내는 세 개의 정수 A, B, C가 빈칸을 사이에 두고 주어진다. A, B, C는 모두 다른 값이며 매장 후보지 중의 하나로 주어진다. 세 번째 줄에는 도로의 개수를 나타내는 정수 M이 주어진다. 그 다음 M개의 줄에는 각 줄마다 세 개의 정수 X, Y, Z가 주어진다. 여기서 X, Y는 도로의 양 끝 매장 후보지 번호를 나타내고, Z는 도로의 길이이다(1≤Z≤10,000). 입력에서 같은 도로가 중복해서 들어오는 경우는 없다. 그 다음 줄에는 질의의 개수를 나타내는 정수 T가 주어진다(1≤T≤10,000). 그 다음 T개의 줄에는 각 줄마다 질의를 나타내는 한 개의 정수 Q가 주어진다(1≤Q≤N).
<출력값>
각 질의 Q에 대해 매장 후보지 Q에 매장을 설치할 수 있으면 대문자로 YES, 아니면 NO를 출력한다.

<문제 2473>
KOI 부설 과학연구소에서는 많은 종류의 산성 용액과 알칼리성 용액을 보유하고 있다. 각 용액에는 그 용액의 특성을 나타내는 하나의 정수가 주어져있다.  산성 용액의 특성값은 1부터 1,000,000,000까지의 양의 정수로 나타내고, 알칼리성 용액의 특성값은 -1부터 -1,000,000,000까지의 음의 정수로 나타낸다.
같은 양의 세 가지 용액을 혼합한 용액의 특성값은 혼합에 사용된 각 용액의 특성값의 합으로 정의한다. 이 연구소에서는 같은 양의 세 가지 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들려고 한다. 
예를 들어, 주어진 용액들의 특성값이 [-2, 6, -97, -6, 98]인 경우에는 특성값이 -97와 -2인 용액과 특성값이 98인 용액을 혼합하면 특성값이 -1인 용액을 만들 수 있고, 이 용액이 특성값이 0에 가장 가까운 용액이다. 참고로, 세 종류의 알칼리성 용액만으로나 혹은 세 종류의 산성 용액만으로 특성값이 0에 가장 가까운 혼합 용액을 만드는 경우도 존재할 수 있다.
산성 용액과 알칼리성 용액이 주어졌을 때, 이 중 같은 양의 세 개의 서로 다른 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들어내는 세 용액을 찾는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 전체 용액의 수 N이 입력된다. N은 3 이상 5,000 이하의 정수이다. 둘째 줄에는 용액의 특성값을 나타내는 N개의 정수가 빈칸을 사이에 두고 주어진다. 이 수들은 모두 -1,000,000,000 이상 1,000,000,000 이하이다. N개의 용액들의 특성값은 모두 다르고, 산성 용액만으로나 알칼리성 용액만으로 입력이 주어지는 경우도 있을 수 있다.
<출력값>
첫째 줄에 특성값이 0에 가장 가까운 용액을 만들어내는 세 용액의 특성값을 출력한다. 출력해야하는 세 용액은 특성값의 오름차순으로 출력한다. 특성값이 0에 가장 가까운 용액을 만들어내는 경우가 두 개 이상일 경우에는 그 중 아무것이나 하나를 출력한다.

<문제 2474>
2차원 좌표평면상에 x-축과 평행한 서로 다른 두 직선 L1, L2와 이 두 직선을 연결하는 선분들이 있다. 이 문제에서는 다음 조건을 만족시키는 선분들의 집합을 고려한다.

선분들의 끝점들은 서로 겹치지 않는다. 
선분들은 각 집합 안에 있는 어떤 두 선분도 서로 교차되지 않도록 두 개의 집합 X와 Y로 분할될 수 있다.

아래 그림은 위 조건을 만족시키는 선분 집합의 한 예이다. 두 번째 조건의 경우, 선분들을 X={A, C, E, F, G}(실선 표시)와 Y={B, D, H}(점선 표시)로 분할하면 같은 집합 안의 어떤 두 선분도 교차되지 않음을 알 수 있다.

선분 집합에서 일부 선분들을 뽑아 선분들의 리스트 (s[1], s[2], ..., s[k])를 구성할 수 있는데, 리스트 상에서 모든 인접한 두 선분 s[i]와 s[i+1] (1 ≤ i < k)이 서로 교차하면, 이 리스트를 선분 체인(chain)이라 부른다. 선분 체인의 길이는 체인을 구성하는 선분들의 개수로 정의된다. 예를 들어, 위 그림에서 선분 리스트 (B, C, D, F)는 길이가 4인 선분 체인이지만, (A, C, D)는 선분 체인이 아니다.
위의 조건을 만족하는 선분들의 집합이 주어졌을 때, 이 집합으로부터 만들 수 있는 가장 긴 선분 체인의 길이를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 선분의 개수 N이 입력된다. N은 1이상 100,000 이하이다. 둘째 줄부터 N개의 줄에 한 줄에 하나씩 선분에 대한 정보가 입력된다. 선분에 대한 정보는 L1상에 놓인 끝점의 x-좌표값과 L2상에 놓인 끝점의 x-좌표값이 순서대로 주어진다. 좌표값은 모두 1이상 1,000,000 이하인 정수이다.
<출력값>
첫째 줄에 가장 긴 선분 체인의 길이를 출력한다.

<문제 2475>
컴퓨터를 제조하는 회사인 KOI 전자에서는 제조하는 컴퓨터마다 6자리의 고유번호를 매긴다. 고유번호의 처음 5자리에는 00000부터 99999까지의 수 중 하나가 주어지며 6번째 자리에는 검증수가 들어간다. 검증수는 고유번호의 처음 5자리에 들어가는 5개의 숫자를 각각 제곱한 수의 합을 10으로 나눈 나머지이다.
예를 들어 고유번호의 처음 5자리의 숫자들이 04256이면, 각 숫자를 제곱한 수들의 합 0+16+4+25+36 = 81 을 10으로 나눈 나머지인 1이 검증수이다.
<입력값>
첫째 줄에 고유번호의 처음 5자리의 숫자들이 빈칸을 사이에 두고 하나씩 주어진다.
<출력값>
첫째 줄에 검증수를 출력한다.

<문제 2476>
1에서부터 6까지의 눈을 가진 3개의 주사위를 던져서 다음과 같은 규칙에 따라 상금을 받는 게임이 있다.

같은 눈이 3개가 나오면 10,000원+(같은 눈)*1,000원의 상금을 받게 된다. 
같은 눈이 2개만 나오는 경우에는 1,000원+(같은 눈)*100원의 상금을 받게 된다. 
모두 다른 눈이 나오는 경우에는 (그 중 가장 큰 눈)*100원의 상금을 받게 된다.  

예를 들어, 3개의 눈 3, 3, 6이 주어지면 상금은 1,000+3*100으로 계산되어 1,300원을 받게 된다. 또 3개의 눈이 2, 2, 2로 주어지면 10,000+2*1,000 으로 계산되어 12,000원을 받게 된다. 3개의 눈이 6, 2, 5로 주어지면 그 중 가장 큰 값이 6이므로 6*100으로 계산되어 600원을 상금으로 받게 된다.
N(2 ≤ N ≤ 1,000)명이 주사위 게임에 참여하였을 때, 가장 많은 상금을 받은 사람의 상금을 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 참여하는 사람 수 N이 주어지고 그 다음 줄부터 N개의 줄에 사람들이 주사위를 던진 3개의 눈이 빈칸을 사이에 두고 각각 주어진다.
<출력값>
첫째 줄에 가장 많은 상금을 받은 사람의 상금을 출력한다.

<문제 2477>
시골에 있는 태양이의 삼촌 댁에는 커다란 참외밭이 있다. 문득 태양이는 이 밭에서 자라는 참외가 도대체 몇 개나 되는지 궁금해졌다. 어떻게 알아낼 수 있는지 골똘히 생각하다가 드디어 좋은 아이디어가 떠올랐다. 유레카! 1m^2의 넓이에 자라는 참외 개수를 헤아린 다음, 참외밭의 넓이를 구하면 비례식을 이용하여 참외의 총개수를 구할 수 있다.
1m^2의 넓이에 자라는 참외의 개수는 헤아렸고, 이제 참외밭의 넓이만 구하면 된다. 참외밭은 ㄱ-자 모양이거나 ㄱ-자를 90도, 180도, 270도 회전한 모양(┏, ┗, ┛ 모양)의 육각형이다. 다행히도 밭의 경계(육각형의 변)는 모두 동서 방향이거나 남북 방향이었다. 밭의 한 모퉁이에서 출발하여 밭의 둘레를 돌면서 밭경계 길이를 모두 측정하였다.


예를 들어 참외밭이 위 그림과 같은 모양이라고 하자. 그림에서 오른쪽은 동쪽, 왼쪽은 서쪽, 아래쪽은 남쪽, 위쪽은 북쪽이다. 이 그림의 왼쪽위 꼭짓점에서 출발하여, 반시계방향으로 남쪽으로 30m, 동쪽으로 60m, 남쪽으로 20m, 동쪽으로 100m, 북쪽으로 50m, 서쪽으로 160m 이동하면 다시 출발점으로 되돌아가게 된다.
위 그림의 참외밭  면적은 6800m^2이다. 만약 1m^2의 넓이에 자라는 참외의 개수가 7이라면, 이 밭에서 자라는 참외의 개수는 47600으로 계산된다.
1m^2의 넓이에 자라는 참외의 개수와, 참외밭을 이루는 육각형의 임의의 한 꼭짓점에서 출발하여 반시계방향으로 둘레를 돌면서 지나는 변의 방향과 길이가 순서대로 주어진다. 이 참외밭에서 자라는 참외의 수를 구하는 프로그램을 작성하시오.
<입력값>
첫 번째 줄에 1m^2의 넓이에 자라는 참외의 개수를 나타내는 양의 정수 K (1≤K≤20)가 주어진다. 참외밭을 나타내는 육각형의 임의의 한 꼭짓점에서 출발하여 반시계방향으로 둘레를 돌면서 지나는 변의 방향과 길이 (1 이상 500 이하의 정수) 가 둘째 줄부터 일곱 번째 줄까지 한 줄에 하나씩 순서대로 주어진다. 변의 방향에서 동쪽은 1, 서쪽은 2, 남쪽은 3, 북쪽은 4로 나타낸다.
<출력값>
첫째 줄에 입력으로 주어진 밭에서 자라는 참외의 수를 출력한다.

<문제 2478>
띠 모양의 자물쇠가 있다. 이 자물쇠는 한 줄로 늘어선 N개의 칸으로 이루어져 있고, 각 칸에는 1부터 N까지의 숫자가 하나씩 들어 있다. 맨 처음에는 1번째 칸부터 N번째 칸까지 1부터 N까지 숫자가 순서대로 하나씩 들어 있다. 아래 그림 1은 10개의 칸으로 이루어진 자물쇠의 맨 처음 모양을 보여주고 있다.

이 자물쇠를 잠그기 위해서는 다음과 같은 3회의 동작을 연속적으로 수행해야 한다.

왼쪽으로 밀기
구간 뒤집기
왼쪽으로 밀기

첫 번째 동작은 왼쪽으로 밀기이다. 칸 밖으로 밀려나간 번호는 다시 오른쪽으로 돌아온다. 그림 1의 자물쇠를 왼쪽으로 3칸 밀고 나면 그림 2와 같게 된다. 이렇게 왼쪽으로 k칸 밀기 동작을 k-왼쪽밀기라고 부른다. 이때 1<=k<=N이다.

그 다음 동작은 정해진 구간의 숫자를 뒤집는 것이다. 예를 들어 그림 2의 자물쇠에서 7번째 칸에서부터 9번째 칸까지 숫자 <10,1,2>를 뒤집으면 다음 그림 3과 같게 된다. p번째 칸부터 q번째 칸까지 숫자들을 뒤집는 동작을 (p,q)-구간뒤집기라고 한다. 이때 항상 p<q이다.

이 상황에서 다시 5-왼쪽밀기 동작을 수행하였다면 자물쇠 모양은 아래 그림 4와 같게 된다.

위에서 3-왼쪽밀기, (7,9)-구간뒤집기, 다시 5-왼쪽밀기의 동작을 차례로 수행하여 자물쇠를 잠궜다.
잠긴 자물쇠의 마지막 상태를 입력으로 받아서 그렇게 만든 3회의 동작을 찾아내는 프로그램을 작성하시오. 예를 들어 자물쇠 모양이 그림 4와 같다면 그 답은 3-왼쪽밀기, (7,9)-구간뒤집기, 5-왼쪽밀기이다.
<입력값>
첫째 줄에 자물쇠에 있는 칸의 수를 나타내는 정수 N이 주어진다. N은 10 이상 500 이하이다. 둘째 줄에는 잠겨 있는 자물쇠의 1번째 칸부터 N번째 칸까지 들어 있는 숫자들이 순서대로 빈칸을 사이에 두고 입력된다.
<출력값>
처음 k-왼쪽밀기의 k를 첫째 줄에, (p,q)-구간뒤집기의 p와 q를 빈칸을 사이에 두고 둘째 줄에, 그리고 마지막 k-왼쪽밀기의 k를 셋째 줄에 출력한다. 만일 답이 여럿일 경우에는 그 중 하나만 출력하면 된다.

<문제 2479>
길이가 같은 두 개의 이진수 코드 A와 B가 있다고 하자. 이 두 코드 사이의 해밍 거리는 A와 B의 각 비트를 왼쪽부터 오른쪽으로 차례대로 비교할 때 서로 다른 값을 가진 비트의 수이다. 예를 들어, A=010010, B=011011 이라고 하면, 세 번째 비트와 여섯 번째 비트만 서로 다르므로 이 두 코드 사이의 해밍 거리는 2이다.
우리는 총 N개의 이진 코드를 가지고 있고, 각 코드의 길이는 K로 같다.
예를 들어, 다음과 같이 길이가 3인 5개의 이진 코드들이 있다.

	A=000, B=111, C=010, D=110, E=001

	두 코드 A와 B사이의 해밍 거리를 H(A,B)로 표현한다. 그러면, H(A,B)=3, H(A,C)=1, H(A,D)=2, H(A,E)=1 이다.

	우리는 이진 코드들에 대해 해밍 경로를 찾고자 한다. 해밍 경로는 모든 인접한 두 코드사이의 해밍 거리가 1인 경로이다. 위의 예에서 (A,C,D)는 코드 A와 C의 해밍 거리가 1이고, 코드 C와 D의 해밍 거리가 1이므로 해밍 경로이다. (A,E,B)는 코드 A와 E의 해밍 거리는 1이지만, 코드 E와 B의 해밍 거리가 2이므로 해밍 경로가 아니다.

	이 문제는 주어진 두 코드 사이에 가장 짧은 해밍 경로를 구하는 프로그램을 작성하는 것이다.
<입력값>
첫째 줄에는 두 개의 정수 N과 K가 빈칸을 사이에 두고 주어진다(3≤N≤1,000, 2≤K≤30). 둘째 줄부터 N개의 줄에는 각 줄마다 길이가 K인 이진 코드가 하나씩 주어진다. 하나의 코드는 빈칸이 없이 주어진다. 코드들은 주어진 순서대로 1부터 N까지의 번호로 구분된다. 코드가 같은 경우는 없다. 그 다음 줄에는 해밍 경로를 찾고자 하는 서로 다른 두 개의 코드 A와 B가 각각의 코드번호로 주어진다.
<출력값>
입력으로 주어진 두 코드 사이에 해밍 경로가 존재하면 그 경로 중 가장 짧은 경로를 코드 A부터 코드 B까지 경로상의 코드 번호로 출력한다. 코드 번호를 출력할 경우에는 코드 번호 사이에 하나의 빈칸을 사이에 두고 출력한다. 만약 답이 여러 개 있으면 그 중에 하나만 출력하고, 경로가 존재하지 않으면 -1을 출력한다.

<문제 2480>
1에서부터 6까지의 눈을 가진 3개의 주사위를 던져서 다음과 같은 규칙에 따라 상금을 받는 게임이 있다. 

같은 눈이 3개가 나오면 10,000원+(같은 눈)*1,000원의 상금을 받게 된다. 
같은 눈이 2개만 나오는 경우에는 1,000원+(같은 눈)*100원의 상금을 받게 된다. 
모두 다른 눈이 나오는 경우에는 (그 중 가장 큰 눈)*100원의 상금을 받게 된다.  

예를 들어, 3개의 눈 3, 3, 6이 주어지면 상금은 1,000+3*100으로 계산되어 1,300원을 받게 된다. 또 3개의 눈이 2, 2, 2로 주어지면 10,000+2*1,000 으로 계산되어 12,000원을 받게 된다. 3개의 눈이 6, 2, 5로 주어지면 그중 가장 큰 값이 6이므로 6*100으로 계산되어 600원을 상금으로 받게 된다.
3개 주사위의 나온 눈이 주어질 때, 상금을 계산하는 프로그램을 작성 하시오.
<입력값>
첫째 줄에 3개의 눈이 빈칸을 사이에 두고 각각 주어진다.
<출력값>
첫째 줄에 게임의 상금을 출력 한다.

<문제 2481>
길이가 같은 두 개의 이진수 코드 w1과 w2가 있다고 하자. 이 두 코드 사이의 해밍 거리(Hamming distance)는 w1과 w2의 각 비트를 왼쪽부터 오른쪽으로 차례대로 비교할 때 서로 다른 값을 가진 비트의 수이다. 예를 들어, w1 = 010010, w2 = 011011 이라고 하면, 세 번째 비트와 여섯 번째 비트만 서로 다르므로 해밍 거리는 2이다.
KOI 연구소는 특정 암호문에서 사용되는 총 N개의 이진 코드를 가지고 있다. 각 코드의 길이는 K로 일정하다. 연구소는 이 코드들에 대해 여러 가지 특징을 분석하고 있다. 예를 들어, 다음과 같이 길이가 3인 5개의 이진 코드들이 있다고 하자.
w[1] = 000, w[2] = 111, w[3] = 010, w[4] = 110, w[5] = 001
두 코드 w[i]와 w[j] 사이의 해밍 거리를 hd(w[i],w[j])로 표현한다. 그러면, hd(w1, w2) = 3, hd(w1, w3) = 1, hd(w1, w4) = 2, hd(w1, w5) = 1 이다.
당신은 이진 코드들에 대해 해밍 경로(Hamming path)를 찾고자한다. 해밍 경로는 모든 인접한 두 코드사이의 해밍 거리가 1인 경로이다. 위의 예에서 (w1, w3, w4)는 길이가 3인 해밍 경로이지만, (w1, w5, w2)는 해밍 경로가 아니다. 두 코드 사이에 해밍 경로가 여러 개가 있을 경우 가장 짧은 경로를 찾고자 한다.
이 문제는 1번 코드에서부터 질의로 주어진 여러 개의 코드까지의 해밍 경로를 각각 구하는 프로그램을 작성하는 것이다.
<입력값>
첫째 줄에는 두 개의 정수 N과 K가 빈칸을 사이에 두고 주어진다(3≤N≤100,000, 2≤K≤30). 둘째 줄부터 N개의 줄에는 각 줄마다 길이가 K인 이진 코드가 하나씩 주어진다. 하나의 코드는 빈칸이 없이 주어진다. 코드들은 주어진 순서대로 1부터 N까지의 번호로 구분된다. 코드가 같은 경우는 없다. 그 다음 줄에는 해밍 경로를 찾고자하는 질의의 수인 하나의 정수 M이 주어진다. (2≤M≤50) 그 다음 M개의 줄에는 각 줄마다 한 개의 양의 정수 J가 주어진다. (2≤J≤N) J는 1번 코드와 J번 코드 사이의 해밍 경로를 구하라는 질의에 해당한다. 주어지는 J는 모두 다르다.
<출력값>
출력은 M개의 줄로 구성된다. 각 줄에는 입력으로 주어진 각 질의에 대한 답을 순서대로 출력한다. 만일 두 코드 사이에 해밍 경로가 존재하면 가장 짧은 경로에 있는 코드들의 번호를 1번 코드부터 차례로 하나의 빈칸을 사이에 두고 출력한다. 답이 여러 개 있으면 그 중에 하나만 출력하고, 경로가 존재하지 않으면 -1을 출력한다.

<문제 2482>
색을 표현하는 기본 요소를 이용하여 표시할 수 있는 모든 색 중에서 대표적인 색을 고리 모양으로 연결하여 나타낸 것을 색상환이라고 한다. 미국의 화가 먼셀(Munsell)이 교육용으로 고안한 20색상환이 널리 알려져 있다. 아래 그림은 먼셀의 20색상환을 보여준다.

그림 1. 먼셀의 20색상환
색상환에서 인접한 두 색은 비슷하여 언뜻 보면 구별하기 어렵다. 위 그림의 20색상환에서 다홍은 빨강과 인접하고 또 주황과도 인접하다. 풀색은 연두, 녹색과 인접하다. 시각적 대비 효과를 얻기 위하여 인접한 두 색을 동시에 사용하지 않기로 한다.
주어진 색상환에서 시각적 대비 효과를 얻기 위하여 서로 이웃하지 않은 색들을 선택하는 경우의 수를 생각해 보자.  먼셀의 20색상환에서 시각적 대비 효과를 얻을 수 있게 10개의 색을 선택하는 경우의 수는 2이지만, 시각적 대비 효과를 얻을 수 있게 11개 이상의 색을 선택할 수 없으므로 이 경우의 수는 0이다.
주어진 정수 N과 K에 대하여, N개의 색으로 구성되어 있는 색상환 (N색상환)에서 어떤 인접한 두 색도 동시에 선택하지 않으면서 서로 다른 K개의 색을 선택하는 경우의 수를 구하는 프로그램을 작성하시오.
<입력값>
입력 파일의 첫째 줄에 색상환에 포함된 색의 개수를 나타내는 양의 정수 N(4 ≤ N ≤ 1,000)이 주어지고, 둘째 줄에 N색상환에서 선택할 색의 개수 K(1 ≤ K ≤ N)가 주어진다.
<출력값>
첫째 줄에 N색상환에서 어떤 인접한 두 색도 동시에 선택하지 않고 K개의 색을 고를 수 있는 경우의 수를 1,000,000,003 (10억 3) 으로 나눈 나머지를 출력한다.

<문제 2483>
1부터 N까지 번호가 붙여진 N개의 마을과 이들 마을을 연결하는 도로망이 있다. 이 도로망에서는, 각 마을로부터 다른 모든 마을까지 가는 경로는 하나뿐이다. 각 마을에 사는 사람들의 수와 각 도로를 지나는데 걸리는 시간이 주어진다. 그리고 이들 마을 중 서로 다른 두 마을에만 병원이 있다.
마을 A에서 마을 B까지 가는데 걸리는 시간은 A에서 B까지의 경로 상에 있는 도로들의 통행시간의 합이다.
예를 들어, 다음과 같은 도로망을 고려해 보자. 


그림 1
동그라미는 마을을 나타내고, 동그라미 안에 있는 수는 마을의 번호이고, 바깥에 있는 수는 마을에 있는 사람들의 수이다. 선분은 도로를 나타내고, 선분 상의 수는 도로의 통행시간을 나타낸다. 또한 병원이 세워져 있는 두 마을은 회색으로 칠해져 있다.
예산을 도로개선에 투입하여 도로의 통행시간을 줄일 수 있다. 이때 각 도로는 예산 C를 들이면 통행시간을 C 시간 만큼 줄일 수 있다. 이제 다음의 제약조건을 만족하면서 전체 예산 B를 도로개선에 투입한다.


제약조건:

		(1) 도로에 예산을 아무리 많이 사용하더라도 각 도로의 통행시간을 L 미만으로 할 수는 없다. 

		(2) 도로개선에 사용하는 전체예산은 B 이하이어야 한다.

		* L과 B의 값은 입력으로 주어진다.

		이때, 위의 제약조건을 만족하면서 다음 두 질문의 답을 구하는 프로그램을 작성하시오.

질문 1: 각 사람이 가까운 병원까지 가는데 걸리는 시간의 합이 가장 작도록 할 때, 시간의 합의 최솟값은 얼마인가?  

질문 2: 각 사람이  가까운 병원까지 가는데 걸리는 시간 중 가장 긴 시간이 최소가 되도록 할 때, 그 최소 시간은 얼마인가?

그림 1의 도로망에서 전체예산 B = 7이고, L = 6일 경우, 질문 1의 해는 도로 (1,3)에 예산 3을 사용하여 도로 (1,3)의 통행시간을 6으로 만들고, 도로 (2,3)에 예산 1을 사용하여 통행시간을 7로 만들고, 예산 3을 도로 (5,7)에 사용하여 통행시간을 6으로 만들면 각 사람이 병원을 이용하는데 걸리는 시간의 합은   50*6 + 20*7 + 10*5 + 20*5 +30*6 + 15*7 = 875이다. 
질문 2의 해는 도로 (1,3), (4,5), (5,7)에 각각 비용 2를 사용하고,  도로 (2,3)에 비용 1을 사용하면 각 사람이 가까운 병원까지 가는데 걸리는 가장 긴 시간은 7이 된다. 
어떻게 하더라도 위의 두 답보다 좋게 할 수 없다.
<입력값>
첫 번째 줄에 B(1≤B≤4,000,000)와 L(1≤L≤1,000)을 나타내는 두개의 양의 정수가 빈칸을 사이에 두고 주어진다. 두 번째 줄에 마을의 수 N (2≤N≤4,000)이 주어진다. 세 번째 줄에 마을 1부터 마을 N까지 각 마을에 사는 사람들의 수(1 이상 500 이하)가 빈칸을 사이에 두고 차례로 주어진다. 그 다음 줄부터 N-1개의 각 줄에 도로의 정보 즉, 도로의 양끝 마을 번호와 도로의 통행시간(1 이상 1,000 이하)을 나타내는 세 개의 양의 정수가 빈칸을 사이에 두고 차례로 주어진다. 마지막 줄에 병원이 있는 서로 다른 두 마을의 번호가 빈칸을 사이에 두고 주어진다.
<출력값>
반드시 질문 1의 답은 첫째 줄에, 질문 2의 답은 둘째 줄에 출력한다. 답이 2^32을 넘을 수 있음에 유의하라.

<문제 2484>
1에서부터 6까지의 눈을 가진 4개의 주사위를 던져서 다음과 같은 규칙에 따라 상금을 받는 게임이 있다. 

같은 눈이 4개가 나오면 50,000원+(같은 눈)*5,000원의 상금을 받게 된다. 
같은 눈이 3개만 나오면 10,000원+(3개가 나온 눈)*1,000원의 상금을 받게 된다. 
같은 눈이 2개씩 두 쌍이 나오는 경우에는 2,000원+(2개가 나온 눈)*500원+(또 다른 2개가 나온 눈)*500원의 상금을 받게 된다.
같은 눈이 2개만 나오는 경우에는 1,000원+(같은 눈)*100원의 상금을 받게 된다. 
모두 다른 눈이 나오는 경우에는 (그 중 가장 큰 눈)*100원의 상금을 받게 된다.  

예를 들어, 4개의 눈이 3, 3, 3, 3으로 주어지면 50,000+3*5,000으로 계산되어 65,000원의 상금을 받게 된다. 4개의 눈이 3, 3, 6, 3으로 주어지면 상금은 10,000+3*1,000으로 계산되어 13,000원을 받게 된다. 또 4개의 눈이 2, 2, 6, 6으로 주어지면 2,000+2*500+6*500으로 계산되어 6,000원을 받게 된다. 4개의 눈이 6, 2, 1, 6으로 주어지면 1,000+6*100으로 계산되어 1,600원을 받게 된다. 4개의 눈이 6, 2, 1, 5로 주어지면 그 중 가장 큰 값이 6이므로 6*100으로 계산되어 600원을 상금으로 받게 된다.
N(1≤N≤1,000)명이 주사위 게임에 참여하였을 때, 가장 많은 상금을 받은 사람의 상금을 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 참여하는 사람 수 N이 주어지고 그 다음 줄부터 N개의 줄에 사람들이 주사위를 던진 4개의 눈이 빈칸을 사이에 두고 각각 주어진다.
<출력값>
첫째 줄에 가장 많은 상금을 받은 사람의 상금을 출력한다.

<문제 2485>
직선으로 되어있는 도로의 한 편에 가로수가 임의의 간격으로 심어져있다. KOI 시에서는 가로수들이 모두 같은 간격이 되도록 가로수를 추가로 심는 사업을 추진하고 있다. KOI 시에서는 예산문제로 가능한 한 가장 적은 수의 나무를 심고 싶다.
편의상 가로수의 위치는 기준점으로 부터 떨어져 있는 거리로 표현되며, 가로수의 위치는 모두 양의 정수이다.
예를 들어, 가로수가 (1, 3, 7, 13)의 위치에 있다면 (5, 9, 11)의 위치에 가로수를 더 심으면 모든 가로수들의 간격이 같게 된다. 또한, 가로수가 (2, 6, 12, 18)에 있다면 (4, 8, 10, 14, 16)에 가로수를 더 심어야 한다.
심어져 있는 가로수의 위치가 주어질 때, 모든 가로수가 같은 간격이 되도록 새로 심어야 하는 가로수의 최소수를 구하는 프로그램을 작성하라. 단, 추가되는 나무는 기존의 나무들 사이에만 심을 수 있다.
<입력값>
첫째 줄에는 이미 심어져 있는 가로수의 수를 나타내는 하나의 정수 N이 주어진다(3≤N≤100,000). 둘째 줄부터 N개의 줄에는 각 줄마다 심어져 있는 가로수의 위치가 양의 정수로 주어지며, 가로수의 위치를 나타내는 정수는 100,000,000 이하이다. 가로수의 위치를 나타내는 정수는 모두 다르다.
<출력값>
모든 가로수가 같은 간격이 되도록 새로 심어야 하는 가로수의 최소수를 첫 번째 줄에 출력한다.

<문제 2486>
이진 코드 중에서 모든 인접한 코드가 한 비트만 서로 다르면 그레이(Gray) 코드라고 말한다. 첫째 코드와 마지막 코드도 인접하다고 보고 한 비트만 달라야 한다. 아래에 3-비트 그레이 코드가 있다. 첫 번째 코드와 둘째 코드, 둘째와 셋째, …, 그리고 마지막 코드 100은 첫째 코드 000과 1비트만 다르다.
000 - 001 - 011 - 010 - 110 - 111 - 101 - 100
그레이 코드에서, 111과 한 비트가 다른 110, 101은 코드에서 인접하게 나타나지만, 역시 한 비트가 다른 011은 그렇지 않다. 이 사실을 관찰한 철희군은 111과 011이 인접한 그레이 코드가 존재하는가 하는 문제에 호기심이 발동하였고, 그런 코드가 있다는 것을 손으로 확인하였다. 비트 수가 더 큰 경우에는 손으로 확인하기가 어려워, 컴퓨터 프로그램을 작성하기로 하였다.
한 비트가 다른 쌍들이 하나 혹은 둘 주어질 때, 그 쌍이 인접하다는 조건을 만족하는 그레이 코드가 존재하는가를 확인하고, 존재하면 조건을 만족하는 그레이 코드를 출력하는 프로그램을 작성하라.
<입력값>
첫째 줄에 코드에서 비트의 수를 나타내는 M(3 ≤ M ≤ 15)과 인접해야 하는 코드 쌍의 수 K(1 ≤ K ≤ 2)가 주어진다. 이어서 K개의 줄에 한 줄에 하나씩 인접하기를 원하는 코드 쌍이 빈칸을 사이에 두고 입력된다.
<출력값>
첫째 줄에 조건을 만족하는 그레이 코드가 존재하면, 그레이 코드를 000…0부터 시작하여 차례로 한 줄에 코드 8개씩 2M-3 줄에 걸쳐서 출력한다. 만일 답이 여럿일 경우에는 그 중 하나만 출력하면 된다. 조건을 만족하는 그레이 코드가 존재하지 않으면 -1을 출력한다.

<문제 2487>
A1, A2, …, AN으로 표시된 N 개의 카드를 정해진 방법으로 섞고자 한다. 그 섞는 방법은 1에서 N까지의 숫자로 이루어진 수열로 표시된다. 이 수열을 섞기 수열이라 하자. 섞기는 현재 가지고 있는 카드에서 섞기 수열의 각 숫자가 나타내는 위치에 있는 카드를 순서대로 뽑아서 나열하는 것이다. 예를 들어, N = 6이고 섞기 수열이 [3, 2, 5, 6, 1, 4]라고 하자. 카드의 처음 상태가 [A1, A2, A3, A4, A5, A6]일 때, 섞기를 한 번 실행하면 카드의 순서가 다음과 같이 된다.

	[A3, A2, A5, A6, A1, A4]
이 상태에서 다시 한 번 섞기를 실행하면 카드의 순서가 [A5, A2, A1, A4, A3, A6]이 되고, 다시 한 번 더 섞기를 실행하면 카드의 순서가 [A1, A2, A3, A6, A5, A4]가 된다. 이렇게 섞기를 반복하면 카드의 순서가 처음 상태인 [A1, A2, A3, A4, A5, A6]이 된다. 처음 상태로 돌아 올 때까지 반복한 섞기의 최소 횟수를 주어진 섞기 수열의 궤적이라 한다. 임의의 섞기 수열이 주어졌을 때, 그 섞기 수열의 궤적을 구하는 프로그램을 작성하시오.
<입력값>
첫 번째 줄에 카드의 수 N이 주어진다. N은 1 이상 20,000 이하의 수이다. 두 번째 줄에 섞기 수열을 나타내는 N 개의 자연수가 빈칸을 사이에 두고 주어진다.
<출력값>
첫 번째 줄에 입력으로 주어진 섞기 수열의 궤적을 출력한다. 단, 궤적이 1 이상 2,000,000,000 이하인 입력만 주어진다.

<문제 2488>
A, B 두 마을의 주민들이 모여서 줄다리기 시합을 하려고 한다. 줄다리기에 참여할 사람들은 운동장에 각 동네별로 각각 한 줄씩 늘어서 있다. 우리는 이 줄을 각각 A줄, B줄이라고 부르기로 한다. 우리는 A줄(B줄)을 A1, A2, A3 (B1, B2, B3) 3개로 잘라 각 A1:B1, A2:B2, 그리고 A3:B3로 짝을 지어 모두 3번의 줄다리기 시합을 하려고 한다. 우리는 A1, A2, A3, B1, B2, B3 각각을 단위 줄이라고 부른다. 그리고 단위 줄에 속한 사람들의 몸무게의 합을 단위 줄의 무게라고 부르기로 한다.
이 문제에서 A, B줄은 각 줄에 늘어선 사람들의 몸무게를 나타내는 정수로 표시된다. 예를 들어 10명과 8명의 사람으로 구성된 A, B 줄이 다음과 같다고 하자.
A: 62,34,54,26,65,40,30,29,35,32
B: 44,45,66,76,35,60,34,60
우리는 아래와 같이 2개의 ‘|’를 사용하여 분리된 각 단위 줄을 나타내고자 한다.
A: 62,34,54 | 26,65,40,30 | 29,35,32
B: 44,45,66 | 76,35,60 | 34,60
위의 예에서 단위 줄 A1은 <62,34,54>이며, 그 무게는 150이다. 그리고 단위줄 B3은 <34, 60>이며 그 무게는 94가 된다. 그런데 시합을 좀 더 흥미롭게 만들기 위하여 우리는 반드시 다음의 규칙을 만족시키고자 한다.
[규칙1] A, B줄에 늘어선 사람들의 처음 정해진 순서는 중간에 바꿀 수 없다.
[규칙2] 각 단위 줄은 한 명 이상으로 구성된다.
[규칙3] 시합을 위하여 대응하는 각 단위 줄의 무게의 차이는 모두 50 이하가 되어야 한다.
예를 들어 A1을 <62,34>로, B1을 <44,45,66>로 편성하면 이것은 규칙3을 위반하는 것이므로 그러한 단위 줄 편성은 불가능하다.
대응하는 3개 단위 줄 무게의 차이 중, 가장 큰 값을 줄다리기 값이라고 한다면, 우리는 시합을 흥미롭게 진행하기 위하여 가장 작은 줄다리기 값을 가지는 단위 줄 편성을 찾고자 한다.
만일 대응하는 단위 줄의 무게 차이가 각각 10, 15, 12 라고 한다면 이 상황에서의 줄다리기 값은 15가 된다. 만일 다르게 단위 줄을 편성하여 그 무게 차이가 각각 8, 17, 4 이라고 하면 그 줄다리기 값은 17이 되어 전자가 후자보다 더 나은 편성이 된다.
A, B줄의 몸무게 값을 순서대로 받아서 줄다리기 값을 최소로 하는 단위 줄 편성을 찾아내는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 A, B줄의 사람 수를 나타내는 N과 M이 각각 주어진다. 두 번째, 세 번째 줄에는 A, B줄을 나타내는 N개, M개의 정수들이 빈칸을 사이에 두고 주어진다. 단, N과 M은 3 이상 30,000 이하의 정수이며, 각 사람들의 몸무게는 20 이상, 100 이하의 정수이다.
<출력값>
첫째 줄에는 A에 대하여 최소의 줄다리기 값을 가지는 단위 줄 A1, A2, A3에 속한 사람 수를 차례대로 출력한다. 그 다음 줄에는 같은 방식으로 B에 대하여 3개의 정수를 출력한다. 예를 들어 만일 7명, 5명으로 구성된 두 줄에서 최소의 줄다리기 값을 가지는 편성이 A: 20, 20, 20 | 60 | 40, 30, 20, 그리고 B: 61 | 32, 30 | 71, 22 이라면 답으로는 다음을 출력해야 한다.

3 1 3
1 2 2
만일 각각 3명으로 구성된 A, B 두 줄의 구성이 A: 20, 20, 20 이고 B: 90, 30, 30 일 경우라면 앞서 말한 규칙을 모두 만족하는 단위 줄 편성이 불가능하다. 이렇게 편성이 불가능한 경우에는 -1을 첫 줄에 출력하면 된다. 입력에 따라서 어떤 경우에는 최소의 줄다리기 값을 가지는 단위 줄 편성이 한 개 이상 존재할 수도 있는데, 그러한 경우에는 그 중 한 가지만 출력하면 된다.

<문제 2489>
지하철 망이 있다. 이 지하철 망은 하나의 순환선과 이 순환선상의 역에 연결되는 지선들로 구성되어 있고, 각 지선은 트리 형태이다. 각 역에는 지선들이 없을 수도 있어서, 지하철이 순환선만으로 구성될 수도 있다. 모든 역은 1부터 N까지의 번호로 나타낸다. 아래 그림은 이러한 형태의 지하철 망의 예를 보여준다. 그림에서 정점은 지하철역을 나타내고, 간선은 두 역을 잇는 선로를 나타내며 간선상의 값은 선로를 지나는데 걸리는 시간을 나타낸다. 지하철 망의 역의 개수와 선로의 개수는 항상 같음에 유의하라.



	지하철 사고 발생 시 응급치료를 위하여 2개의 역에 응급센터를 설치하기로 하였다. 각 역의 응급대처시간은 가까운 응급센터까지 가는데 걸리는 최단 시간이다. 모든 역들의 응급대처시간 중 가장 긴 시간이 최소가 되도록 2 개의 응급센터 설치 역을 구하는 프로그램을 작성하시오.

	위의 그림에서 역 8과 역 12에 응급센터를 설치할 경우, 역 1에서부터 역 12까지의 응급대처시간은 각각 11, 13, 8, 6, 13, 11, 5, 0, 12, 7, 10, 0으로서 가장 긴 시간은 13이다. 또한, 두 응급센터를 어디에 설치하더라도, 모든 역들의 응급 대처시간 중 가장 긴 시간은 13보다 작아지지 않는다.
<입력값>
첫째 줄에 역의 개수(선로의 개수)인 N(3≤N≤50,000)이 주어진다. 다음 줄부터 N줄에 걸쳐 각 줄에 하나의 선로를 나타내는 세 개의 양의 정수 u, v, x가 주어진다. 여기서 u, v는 선로를 통해 연결되는 두 역의 번호이고, x는 이 선로를 지나는데 걸리는 시간이다. 단, x는 1 이상 10,000 이하이다.
<출력값>
첫째 줄에 응급센터를 설치하는 두 역의 번호를 빈칸을 사이에 두고 출력한다. 만약 해가 두 가지 이상이면 그 중 한 가지만 출력한다. 다음 줄에 모든 역들의 응급대처시간 중 가장 긴 시간을 출력한다.

<문제 2490>
우리나라 고유의 윷놀이는 네 개의 윷짝을 던져서 배(0)와 등(1)이 나오는 숫자를 세어 도, 개, 걸, 윷, 모를 결정한다. 네 개 윷짝을 던져서 나온 각 윷짝의 배 혹은 등 정보가 주어질 때 도(배 한 개, 등 세 개), 개(배 두 개, 등 두 개), 걸(배 세 개, 등 한 개), 윷(배 네 개), 모(등 네 개) 중 어떤 것인지를 결정하는 프로그램을 작성하라.
<입력값>
첫째 줄부터 셋째 줄까지 각 줄에 각각 한 번 던진 윷짝들의 상태를 나타내는 네 개의 정수(0 또는 1)가  빈칸을 사이에 두고 주어진다.
<출력값>
첫째 줄부터 셋째 줄까지 한 줄에 하나씩 결과를  도는 A, 개는 B, 걸은 C, 윷은 D, 모는 E로 출력한다.

<문제 2491>
0에서부터 9까지의 숫자로 이루어진 N개의 숫자가 나열된 수열이 있다. 그 수열 안에서 연속해서 커지거나(같은 것 포함), 혹은 연속해서 작아지는(같은 것 포함) 수열 중 가장 길이가 긴 것을 찾아내어 그 길이를 출력하는 프로그램을 작성하라. 
예를 들어 수열 1 2 2 4 4 5 7 7 2 의 경우에는  1≤2≤2≤4≤4≤5≤7≤7 이 가장 긴 구간이 되므로 그 길이 8을 출력한다. 수열 4 1 3 3 2 2 9 2 3 의 경우에는 3≥3≥2≥2 가 가장 긴 구간이 되므로 그 길이 4를 출력한다. 또 1 5 3 6 4 7 1 3 2 9 5 의 경우에는 연속해서 커지거나 작아지는 수열의 길이가 3 이상인 경우가 없으므로 2를 출력하여야 한다.
<입력값>
첫째 줄에는 수열의 길이 N이 주어지고, 둘째 줄에는 N개의 숫자가 빈칸을 사이에 두고 주어진다. N은 1 이상 100,000 이하의 정수이다.
<출력값>
첫째 줄에 가장 긴 길이를 출력한다.

<문제 2492>
지질 탐사의 결과 지하 깊숙이 묻힌 금강석 정보를 나타내는 지도가 아래 그림처럼 만들어졌다. 지도에는 같은 간격으로 수직선과 수평선들이 그어져 있다. 금강석은 항상 수직선(경계선 포함)과 수평선(경계선 포함)이 만나는 곳에 위치하며 굵은 점으로 표시된다. 앞으로 지도의 왼쪽 변에서 A 칸 떨어진 수직선과 지도의 아래쪽 변에서 B 칸 떨어진 수평선이 만나는 곳을 (A, B)라고 표시하자. 
이제 땅을 파서 금강석을 캐려고 한다. 굴착할 영역은 항상 각 변이 지도의 경계선과 평행한 정사각형이다. 현재 보유하고 있는 예산과 굴착 기술로는 한 변의 길이가 K인 정사각형 영역에 대해 단 한 번만 팔 수 있다. 그래서 정사각형 영역에 가장 많은 금강석이 포함될 수 있도록 하려고 한다. 단, 굴착할 영역인 정사각형의 모든 꼭짓점들은 지도의 수직선(경계선 포함)과 수평선(경계선 포함)이 만나는 곳에 위치해야 하고, 정사각형 변에 놓인 금강석도 이 정사각형에 포함된 것으로 본다. 
예를 들어, 아래 그림에서 K=3인 경우 가장 많은 금강석을 포함하는 정사각형은 5개의 금강석을 포함한다. 

지질 탐사 지도에 대한 정보를 입력받아 가장 많은 금강석을 포함하는 정사각형을 구하는 프로그램을 작성하라.
<입력값>
첫째 줄에 4개의 정수 N, M, T, K가 빈칸을 사이에 두고 주어진다. N은 지도의 너비를 나타내고, M은 지도의 높이를 나타낸다(1 ≤ N, M ≤ 1,000,000).  T는 금강석의 개수를 나타내고, K는 정사각형의 크기(한 변의 길이)를 나타낸다. T는 1 이상 100 이하이고, K는 1 이상 1,000,000 이하로서 N과 M보다 크지 않다. 둘째 줄부터 T개의 줄에는 각 줄마다 각 금강석의 위치 (A, B)를 나타내는 두 개의 정수 A와 B가 빈칸을 사이에 두고 주어진다. A는 0 이상 N 이하이고, B는 0 이상 M 이하이다. 입력으로 주어진 금강석의 좌표들은 모두 다르다.
<출력값>
첫째 줄에 정사각형의 왼쪽 위 꼭짓점의 위치 (X, Y)를 나타내는 두 개의 정수 X, Y를 빈칸을 사이에 두고 출력한다. 둘째 줄에는 이 정사각형에 포함되는 금강석의 개수를 출력한다. 답이 여러 개 있는 경우에는 그 중 하나만 출력하라. 
정사각형은 지도 밖으로 벗어날 수 없다.

<문제 2493>
KOI 통신연구소는 레이저를 이용한 새로운 비밀 통신 시스템 개발을 위한 실험을 하고 있다. 실험을 위하여 일직선 위에 N개의 높이가 서로 다른 탑을 수평 직선의 왼쪽부터 오른쪽 방향으로 차례로 세우고, 각 탑의 꼭대기에 레이저 송신기를 설치하였다. 모든 탑의 레이저 송신기는 레이저 신호를 지표면과 평행하게 수평 직선의 왼쪽 방향으로 발사하고, 탑의 기둥 모두에는 레이저 신호를 수신하는 장치가 설치되어 있다. 하나의 탑에서 발사된 레이저 신호는 가장 먼저 만나는 단 하나의 탑에서만 수신이 가능하다. 
예를 들어 높이가 6, 9, 5, 7, 4인 다섯 개의 탑이 수평 직선에 일렬로 서 있고, 모든 탑에서는 주어진 탑 순서의 반대 방향(왼쪽 방향)으로 동시에 레이저 신호를 발사한다고 하자. 그러면, 높이가 4인 다섯 번째 탑에서 발사한 레이저 신호는 높이가 7인 네 번째 탑이 수신을 하고, 높이가 7인 네 번째 탑의 신호는 높이가 9인 두 번째 탑이, 높이가 5인 세 번째 탑의 신호도 높이가 9인 두 번째 탑이 수신을 한다. 높이가 9인 두 번째 탑과 높이가 6인 첫 번째 탑이 보낸 레이저 신호는 어떤 탑에서도 수신을 하지 못한다.
탑들의 개수 N과 탑들의 높이가 주어질 때, 각각의 탑에서 발사한 레이저 신호를 어느 탑에서 수신하는지를 알아내는 프로그램을 작성하라.
<입력값>
첫째 줄에 탑의 수를 나타내는 정수 N이 주어진다. N은 1 이상 500,000 이하이다. 둘째 줄에는 N개의 탑들의 높이가 직선상에 놓인 순서대로 하나의 빈칸을 사이에 두고 주어진다. 탑들의 높이는 1 이상 100,000,000 이하의 정수이다.
<출력값>
첫째 줄에 주어진 탑들의 순서대로 각각의 탑들에서 발사한 레이저 신호를 수신한 탑들의 번호를 하나의 빈칸을 사이에 두고 출력한다. 만약 레이저 신호를 수신하는 탑이 존재하지 않으면 0을 출력한다.

<문제 2494>
아래 그림과 같이 N개의 회전이 가능한 숫자 나사가 아래위로 연결되어 있다. 가장 위에 있는 숫자나사는 숫자나사 1이고 가장 아래에 있는 숫자나사는 숫자나사 N이다. 모든 숫자나사는 각각 10개의 면을 가지고 있고, 각 면에는 오른쪽 방향으로 0, 1, 2, 3, …, 9까지의 숫자가 하나씩 순서대로 적혀 있다. 하나의 숫자나사를 왼쪽으로 회전 시키면, 이 나사보다 아래에 위치한 모든 나사는 같이 따라서 돌게 되지만, 나사를 오른쪽으로 회전시키면, 다른 나사는 함께 돌지는 않는다. 정면에서 보아 위에서부터 아래쪽으로 숫자를 읽어 내려간다고 할 때, 현재의 상태에서 가장 적은 칸수의 움직임으로 원하는 숫자를 만들기 위한 방법을 출력하는 프로그램을 작성하라.
예를 들어 세 개의 숫자나사가 주어졌을 때, 정면에서 보는 현재 상태가 326이고 원하는 상태는 446이라면 최소 회전 칸수는 4이다. 먼저 숫자나사 1을 왼쪽으로 한 칸 돌리면 437이 되고, 숫자나사 2를 역시 왼쪽으로 한 칸 돌리면 448이 되며, 마지막으로 숫자나사 3을 오른쪽으로 두 칸 돌리면 446이 된다.
<입력값>
첫째 줄에는 숫자나사의 개수 N이 주어지고, 둘째 줄에는 현재의 상태가, 셋째 줄에는 원하는 상태가 주어진다. N은 3 이상이고 10,000 이하이다.
<출력값>
첫째 줄에는 현재 상태에서 원하는 상태로 도달하는데 필요한 최소 회전 칸수를 출력한다. 다음 줄부터는 회전 순서대로 각 줄에 하나의 숫자나사 번호와 회전 칸수를 빈칸을 사이에 두고 출력한다. 회전 칸수는 왼쪽을 기준으로 하여 출력한다. 만일 왼쪽으로 4칸 회전한다면 4를, 오른쪽으로 3칸 회전한다면 -3을 출력한다. 답이 여러 개이면 그 중에 하나만 출력한다.

<문제 2495>
여덟 자리의 양의 정수가 주어질 때, 그 안에서 연속하여 같은 숫자가 나오는 것이 없으면 1을 출력하고, 있으면 같은 숫자가 연속해서 나오는 구간 중 가장 긴 것의 길이를 출력하는 프로그램을 작성하라. 
예를 들어 세 개의 숫자 12345123, 17772345, 22233331이 주어졌다고 하자. 12345123은 연속하여 같은 숫자가 나오는 것이 없으므로 1을 출력하고, 17772345는 7이 세 개 연속하여 나오므로 3을 출력하며, 22233331의 경우에는 2가 세 개, 3이 네 개 연속해서 나오므로 그 중 큰 값인 4를 출력하여야 한다.
<입력값>
첫째 줄부터 셋째 줄까지 각 줄에 하나씩 세 개의 여덟 자리 양의 정수가 주어진다.
<출력값>
첫째 줄에서 셋째 줄까지 한 줄에 하나씩 각 입력된  수 내에서 같은 숫자가 연속하여 나오는 가장 긴 길이를 입력 순서대로 출력한다.

<문제 2496>
지질 탐사의 결과 지하 깊숙이 묻힌 금강석 정보를 나타내는 지도가 아래 그림처럼 만들어졌다. 그림에서 굵은 점은 금강석이 위치한 곳을 나타낸다. 이제 땅을 파서 금강석을 캐려고 한다. 굴착할 영역은 항상 두 대각선이 좌표축에 평행한 정사각형 모양이다. 앞으로 이 사각형을 D-사각형이라고 부르자. 현재 보유하고 있는 예산과 굴착 기술로는 대각선의 길이가 K인 D-사각형 영역을 단 한 번만 팔 수 있다. 그래서 굴착할 D-사각형 영역에 가장 많은 금강석이 포함될 수 있도록 하려고 한다.
지도에서 가장 왼쪽 아래의 점을 좌표축의 원점 (0, 0)이라고 하자. 각 금강석은 정수 좌표에 위치한다. D-사각형의 각 꼭짓점은 정수 좌표를 가져야 하고, D-사각형의 중심, 즉, 두 대각선이 만나는 점은 반드시 지도(경계선 포함) 위에 놓여야 한다. D-사각형 변에 놓인 금강석도 이 사각형에 포함된 것으로 본다.
예를 들어, 아래 그림에서 K=4인 경우 왼쪽 D-사각형은 5개의 금강석을, 오른쪽 D-사각형은 3개의 금강석을 포함한다. 

지질 탐사 지도에 대한 정보를 입력받아 가장 많은 금강석을 포함하는 D-사각형을 구하는 프로그램을 작성하라.
<입력값>
첫째 줄에 4개의 정수 N, M, T, K가 빈칸을 사이에 두고 주어진다. N은 지도의 너비를 나타내고, M은 지도의 높이를 나타낸다(1 ≤ N, M ≤ 1,000,000). T는 금강석의 개수를 나타내고, K는 D-사각형의 크기(대각선의 길이)를 나타낸다, T는 1 이상 100 이하의 정수이고, K는 2 이상 10,000,000 이하의 짝수이다. 둘째 줄부터 T개의 줄에는 각 줄마다 두 개의 정수 A와 B가 빈칸을 사이에 두고 주어진다. 여기서 (A, B)는 금강석이 위치한 곳의 좌표이다(0 ≤ A ≤ N, 0 ≤ B ≤ M). 입력으로 주어진 금강석의 좌표들은 모두 다르다.
<출력값>
첫째 줄에 D-사각형의 중심의 좌표 (X, Y)를 나타내는 두 개의 정수 X, Y를 빈칸을 사이에 두고 출력한다. 둘째 줄에는 이 D-사각형에 포함되는 금강석의 개수를 출력한다. 답이 여러 개 있는 경우에는 그 중 하나만 출력하라.

<문제 2497>
N개의 꼭짓점을 갖는 볼록다각형 모양의 KOI랜드에는 각 꼭짓점에 도시가 건설되어 있으며 모든 도시는 볼록다각형의 각 변으로 구성된 일주도로로 연결되어 있다. 한 도시에서 다른 도시로 가려면 일주도로를 이용하여야 한다. 특정 두 도시를 연결하는 하나의 직선인 횡단도로를 건설하여 모든 도시들 사이의 최단 경로 가운데 길이가 가장 긴 것을 최소화하려고 한다.
예를 들어, 아래 그림과 같이 5개 도시와 일주 도로가 건설되어 있을 경우, 도시 A와 C 사이의 최단 경로 (A↔B↔C)의 길이가 √5 + √37로 가장 길다. 
도시 B와 E 또는 C와 E 또는 B와 D를 횡단도로로 연결하면 가장 긴 최단경로에 변화가 없다.
도시 A와 C를 횡단도로로 연결하면 도시 B와 D 사이의 최단경로 (B↔A↔E↔D)의 길이가 √5 + √8 + √10로 가장 길게 된다.


또한  도시 A와 D를 횡단도로로 연결하면 도시 A와 C 사이의 최단경로 (A↔D↔C)의 길이가√26 + √8로 가장 길게 된다.
√26 + √8 < √5 + √8 √10 < √5 + √37 이므로, 도시 A와 D를 횡단도로로 연결하면 모든 도시들 사이의 최단 경로 가운데 가장 긴 것이 최소가 된다.
N개 도시의 위치가 주어졌을 때, 모든 도시들 사이의 최단경로 가운데 가장 긴 것의 길이를 최소화하기 위하여 횡단도로로 연결해야 하는 두 도시를 결정하는 프로그램을 작성하라.
<입력값>
첫째 줄에 도시의 개수 N (4 ≤ N ≤ 300)이 주어진다. N개 도시의 위치가 시계방향의 순서로 둘째 줄부터 한 줄에 하나씩 주어진다. 각 도시의 위치는 평면상의 좌표 (X, Y)로 주어진다. X와 Y는 0 이상 200,000 이하인 정수다.
<출력값>
모든 도시들 사이의 최단경로 가운데 가장 긴 것의 길이를 최소화하기 위하여 횡단도로로 연결해야 하는 두 도시의 좌표 (X1, Y1)과 (X2, Y2)를 나타내는 4개의 정수 X1, Y1, X2, Y2를 첫째 줄에 한 개의 빈칸을 사이에 두고 순서대로 출력한다. 답이 두 가지 이상인 경우 하나만 출력한다.

<문제 2498>
문자열에서 교체 연산은 문자열의 한 문자를 다른 문자로 바꾸는 연산이다. 예를 들어, 문자열 “computer”에서 4번째 문자 p를 m으로 교체하면 “commuter”가 된다. 
같은 길이의 두 문자열 P와 Q의 거리 d(P,Q)는 P를 Q로 바꾸기 위한 교체 연산의 최소 개수로 정의된다. 예를 들어 P = “computers”, Q = “consumers”라 하면, P에서 3번째 문자 m을 n으로, 4번째 문자 p를 s로, 6번째 문자 t를 m으로 바꾸면 Q가 된다. 따라서 P와 Q 사이의 거리는 3이다. 
A, B, C를 같은 길이의 문자열이라 하자. 이때 어떤 문자열 W의 반경 r(W)는 문자열 W와 문자열 A, B, C와의 거리 중 최댓값으로 정의된다. 즉, r(W)= max{ d(W,A), d(W,B), d(W,C) } 이다. 예를 들어, A = “computers”, B = “consumers”, C = “consensus”일 때, X = “consunsrs”라 두면, A, B, C와 X 사이의 거리는 d(X,A) = 4, d(X,B) = 2, d(X,C) = 2이므로, X의 반경 r(X)는 4이다.
문자열 A, B, C의 중앙문자열은 A, B, C와의 반경이 최소가 되는 문자열로 정의된다. 예를 들어, 문자열 A, B, C가 위와 같이 주어졌을 때, Y = “consuners”라 두면, Y의 반경은 3이고, 반경이 2인 문자열은 존재하지 않으므로, Y는 A, B, C의 중앙문자열이 된다.
영어 소문자들로만 구성된 문자열 A, B, C가 주어졌을 때, 이들의 중앙문자열을 구하는 프로그램을 작성하라.
<입력값>
첫 째 줄에는 문자열 A가 주어진다. 마찬가지로 문자열 B와 C가 각각 둘째 줄과 셋째 줄에 주어진다. 세 문자열의 길이는 동일하고, 그 길이는 1 이상 100,000 이하이다.
<출력값>
첫 째 줄에 중앙문자열의 반경을 출력하고 둘째 줄에 중앙문자열을 출력한다. 중앙문자열이 여러 개인 경우 하나만 출력한다.

<문제 2499>
어떤 N × N 개의 단위 구역으로 구성된 논이 있다. 각 단위 구역에서는 쌀이 생산되는데 구역에 따라서 쌀의 생산량이 다르다. 아래는 5 × 5 = 25개의 단위 구역으로 나누어진 논을 보여주고 있다. 각 구역에 적혀 있는 숫자는 예상되는 쌀의 수확량(가마)이다.


두 의좋은 형제는 이 N × N의 논을 다음과 같이 두 부분으로 나누어 형은 아래쪽에 있는 땅을 가지고, 동생은 위쪽의 땅을 가지기로 하였다. 전체 구역을 마구잡이로 나누면 기계로 농사를 짓는데 불편하기 때문에 각 형제에게 배분된 구역이 단조 증가하는 계단 모양이 되게 하려고 한다. 즉, 주어진 논을 N × N 행렬로 볼 때 형이 특정 열에서 할당받는 구역의 개수는 바로 왼쪽 열에서 받은 구역의 개수보다 크거나 같아야 한다. 예를 들어 다음 세 그림 중 그림 1과 2는 올바른 배정 방법으로, 회색 지역은 형의 논, 나머지 부분은 동생의 논이다. 그러나 그림 3은 논을 나누는 규칙을 어기는 경우이다.
두 형제는 논을 공평하게 나누기 위해, 위와 같은 방법들 중 각 영역의 예상 수확량의 차이가 되도록 적게 하고자 한다. 예를 들어 그림 1은 형의 예상 수확량이 48, 동생이 49로 최적인 경우이나, 그림 2는 형은 39, 동생은 58로 공평하게 나눠지지 않은 경우이다. 주어진 논을 최대한 공평하게 나누는 방법을 구하는 프로그램을 작성하라.
<입력값>
첫째 줄에 논의 크기를 나타내는 정수 N (2≤N≤20)이 주어진다. 둘째 줄부터 N+1번째 줄에는 각 단위 구역의 예상 수확량이 0에서 100 사이의 정수로 주어진다. 둘째 줄에는 논의 제 1행의 각 구역의 예상 수확량에 해당하는 N개의 정수가 빈칸을 사이에 두고 주어지며, 셋째 줄에는 제 2행의 각 구역의 예상 수확량에 해당하는 N개의 정수가 빈 칸을 사이에 두고 주어진다. 넷째 줄부터 N+1번째 줄도 같은 형식으로 각 줄마다 N개 정수들이 주어진다.
<출력값>
첫째 줄에는 최적의 방법으로 영역을 나누었을 때의 예상 수확량 차이를 나타내는 정수를 출력하고, 둘째 줄에는 이 최적의 방법에서 논의 첫 번째 열부터 N번째 열까지 형이 배분받는 구역의 수를 나타내는 N개의 정수를 빈칸을 사이에 두고 출력한다. 방법이 여러 개인 경우 하나만 출력한다.

<문제 2500>
1박2일 제작진은 다음과 같은 새로운 복불복 게임을 제안하였다. 먼저 게임을 하는 한 사람에게 K개의 조약돌을 주고, 숫자가 적혀있는 회전판을 N번 돌리게 한다. 게임을 하는 사람은 회전판을 돌려서 나오는 숫자만큼의 조약돌을 제작진에게 되돌려 주어야 한다. 회전판을 N번 돌리는 동안 제작진에게 줄 수 있는 조약돌이 있으면 게임을 하는 사람이 이기게 되고, 제작진에게 주어야 하는 조약돌이 모자라게 되면 게임에서 지게 된다. 
회전판에는 T개의 숫자가 그려지고, 그려지는 숫자는 0 이상 T-1 이하의 정수 중 하나이다. 회전판에 사용되는 정수는 중복 사용이 가능하고, 0부터 T-1 사이의 정수 모두가 다 회전판에 나타나야 하는 것은 아니다. 
N과 K, 그리고 T와 회전판에 그려진 모든 숫자가 주어질 때, 게임을 하는 사람이 이길 수 있는 경우의 수를 계산하는 프로그램을 작성하라.

	단, 회전판에 같은 수가 여러 개 있을 때 이들 수는 값은 같지만 서로 다른 경우의 수들로 계산된다.
예를 들어, 6개의 숫자 0, 1, 1, 2, 4, 5가 그려진 회전판에서 가지고 있는 조약돌의 수가 6개이고, 회전판을 2번 돌린다면, 게임을 하는 사람이 이길 수 있는 경우의 수는 30이다. 즉, 처음 나온 정수가 0 혹은 1이면, 그 다음에 어떤 수가 나오더라도 게임을 이길 수 있으며, 2가 처음 나오는 경우에는 정수 5가 나오는 경우를 제외한 5가지 경우가 존재한다. 4가 처음 나오는 경우는 4가지 경우, 5가 처음 나오는 경우에는 3가지 경우가 존재하게 된다.
<입력값>
첫째 줄에 3개의 정수 N, K, T가 빈칸을 사이에 두고 주어진다. N은 회전판을 돌리는 횟수를 나타내고, K는 게임을 하는 사람에게 처음 주어지는 조약돌의 개수를 나타낸다. T는 회전판에 그려져 있는 정수들의 수이다. N은 1 이상 100,000 이하이고, K는 1 이상 1,000 이하, T는 2 이상 20,000 이하이다. 둘째 줄부터 T개의 줄에는 각 줄마다 회전판에 적혀져 있는 정수가 주어진다.
<출력값>
첫째 줄에 게임을 하는 사람이 이길 수 있는 경우의 수를 42,043으로 나눈 나머지 값으로 출력한다.

<문제 2501>
어떤 자연수 p와 q가 있을 때, 만일 p를 q로 나누었을 때 나머지가 0이면 q는 p의 약수이다. 
6을 예로 들면

6 ÷ 1 = 6 … 0
6 ÷ 2 = 3 … 0
6 ÷ 3 = 2 … 0
6 ÷ 4 = 1 … 2
6 ÷ 5 = 1 … 1
6 ÷ 6 = 1 … 0

그래서 6의 약수는 1, 2, 3, 6, 총 네 개이다.
두 개의 자연수 N과 K가 주어졌을 때, N의 약수들 중 K번째로 작은 수를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N과 K가 빈칸을 사이에 두고 주어진다. N은 1 이상 10,000 이하이다. K는 1 이상 N 이하이다.
<출력값>
첫째 줄에 N의 약수들 중 K번째로 작은 수를 출력한다. 만일 N의 약수의 개수가 K개보다 적어서 K번째 약수가 존재하지 않을 경우에는 0을 출력하시오.

<문제 2502>
하루에 한 번 산을 넘어가는 떡 장사 할머니는 호랑이에게 떡을 주어야 산을 넘어갈 수 있는데, 욕심 많은 호랑이는 어제 받은 떡의 개수와 그저께 받은 떡의 개수를 더한 만큼의 떡을 받아야만 할머니를 무사히 보내 준다고 한다. 
예를 들어 첫째 날에 떡을 1개 주었고, 둘째 날에는 떡을 2개 주었다면 셋째 날에는 1+2=3개, 넷째 날에는 2+3=5개, 다섯째 날에는 3+5=8개, 여섯째 날에는 5+8=13개를 주어야만 무사히 산을 넘어갈 수 있다. 
우리는 산을 무사히 넘어온 할머니에게 오늘 호랑이에게 몇 개의 떡을 주었는지, 그리고 오늘이 호랑이를 만나 떡을 준지 며칠이 되었는지를 알아내었다. 할머니가 호랑이를 만나서 무사히 넘어온 D째 날에 준 떡의 개수가 K개임을 알 때, 여러분은 할머니가 호랑이를 처음 만난 날에  준 떡의 개수 A, 그리고 그 다음 날에 호랑이에게 준 떡의 개수 B를 계산하는 프로그램을 작성하시오. 이 문제에서는 항상 1≤A≤B 이다.  
예를 들어 여섯 번째 날에 산을 무사히 넘어온 할머니가 호랑이에게 준 떡이 모두 41개라면, 호랑이를 만난 첫 날에 준 떡의 수는 2개, 둘째 날에 준 떡의 수는 7개이다. 즉 셋째 날에는 9개, 넷째 날에는 16개, 다섯째 날에는 25개, 여섯째  날에는 41개이다. 따라서 A=2, B=7 이 된다. 단 어떤 경우에는 답이 되는 A, B가 하나 이상일 때도 있는데 이 경우에는 그 중 하나만 구해서 출력하면 된다.
<입력값>
첫째 줄에는 할머니가 넘어온 날 D (3 ≤ D ≤ 30)와 그 날 호랑이에게 준 떡의 개수 K (10 ≤ K ≤ 100,000)가 하나의 빈칸을 사이에 두고 주어진다.
<출력값>
첫줄에 첫 날에 준 떡의 개수 A를 출력하고 그 다음 둘째 줄에는 둘째 날에 준 떡의 개수 B를 출력한다. 이 문제에서 주어진 D, K에 대해서는 항상 정수 A, B (1≤A≤B)가 존재한다.

<문제 2503>
정보문화진흥원 정보 영재 동아리에서 동아리 활동을 하던 영수와 민혁이는 쉬는 시간을 틈타 숫자야구 게임을 하기로 했다.

영수는 1에서 9까지의 서로 다른 숫자 세 개로 구성된 세 자리 수를 마음속으로 생각한다. (예: 324)
민혁이는 1에서 9까지의 서로 다른 숫자 세 개로 구성된 세 자리 수를 영수에게 묻는다. (예: 123)
민혁이가 말한 세 자리 수에 있는 숫자들 중 하나가 영수의 세 자리 수의 동일한 자리에 위치하면 스트라이크 한 번으로 센다. 숫자가 영수의 세 자리 수에 있긴 하나 다른 자리에 위치하면 볼 한 번으로 센다.

예) 영수가 324를 갖고 있으면 

429는 1 스트라이크 1 볼이다.
241은 0 스트라이크 2 볼이다.
924는 2 스트라이크 0 볼이다.
영수는 민혁이가 말한 수가 몇 스트라이크 몇 볼인지를 답해준다.
민혁이가 영수의 세 자리 수를 정확하게 맞추어 3 스트라이크가 되면 게임이 끝난다. 아니라면 민혁이는 새로운 수를 생각해 다시 영수에게 묻는다.

현재 민혁이와 영수는 게임을 하고 있는 도중에 있다. 민혁이가 영수에게 어떤 수들을 물어보았는지, 그리고 각각의 물음에 영수가 어떤 대답을 했는지가 입력으로 주어진다. 이 입력을 바탕으로 여러분은 영수가 생각하고 있을 가능성이 있는 수가 총 몇 개인지를 알아맞혀야 한다.
아래와 같은 경우를 생각해보자.  

민혁: 123
영수: 1 스트라이크 1 볼.
민혁: 356
영수: 1 스트라이크 0 볼.
민혁: 327
영수: 2 스트라이크 0 볼.
민혁: 489
영수: 0 스트라이크 1 볼.

이때 가능한 답은 324와 328, 이렇게 두 가지이다.
영수는 동아리의 규율을 잘 따르는 착한 아이라 민혁이의 물음에 곧이곧대로 정직하게 답한다. 그러므로 영수의 답들에는 모순이 없다.
민혁이의 물음들과 각각의 물음에 대한 영수의 답이 입력으로 주어질 때 영수가 생각하고 있을 가능성이 있는 답의 총 개수를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 민혁이가 영수에게 몇 번이나 질문을 했는지를 나타내는 1 이상 100 이하의 자연수 N이 주어진다. 이어지는 N개의 줄에는 각 줄마다 민혁이가 질문한 세 자리 수와 영수가 답한 스트라이크 개수를 나타내는 정수와 볼의 개수를 나타내는 정수, 이렇게 총 세 개의 정수가 빈칸을 사이에 두고 주어진다.
<출력값>
첫 줄에 영수가 생각하고 있을 가능성이 있는 답의 총 개수를 출력한다.

<문제 2504>
4개의 기호 ‘(’, ‘)’, ‘[’, ‘]’를 이용해서 만들어지는 괄호열 중에서 올바른 괄호열이란 다음과 같이 정의된다.

한 쌍의 괄호로만 이루어진 ‘()’와 ‘[]’는 올바른 괄호열이다. 
만일 X가 올바른 괄호열이면 ‘(X)’이나 ‘[X]’도 모두 올바른 괄호열이 된다. 
X와 Y 모두 올바른 괄호열이라면 이들을 결합한 XY도 올바른 괄호열이 된다.

예를 들어 ‘(()[[]])’나 ‘(())[][]’ 는 올바른 괄호열이지만 ‘([)]’ 나 ‘(()()[]’ 은 모두 올바른 괄호열이 아니다. 우리는 어떤 올바른 괄호열 X에 대하여 그 괄호열의 값(괄호값)을 아래와 같이 정의하고 값(X)로 표시한다. 

‘()’ 인 괄호열의 값은 2이다.
‘[]’ 인 괄호열의 값은 3이다.
‘(X)’ 의 괄호값은 2×값(X) 으로 계산된다.
‘[X]’ 의 괄호값은 3×값(X) 으로 계산된다.
올바른 괄호열 X와 Y가 결합된 XY의 괄호값은 값(XY)= 값(X)+값(Y) 로 계산된다.

예를 들어 ‘(()[[]])([])’ 의 괄호값을 구해보자.  ‘()[[]]’ 의 괄호값이 2 + 3×3=11 이므로  ‘(()[[ ]])’의 괄호값은 2×11=22 이다. 그리고  ‘([])’의 값은 2×3=6 이므로 전체 괄호열의 값은 22 + 6 = 28 이다.
여러분이 풀어야 할 문제는 주어진 괄호열을 읽고 그 괄호값을 앞에서 정의한대로 계산하여 출력하는 것이다.
<입력값>
첫째 줄에 괄호열을 나타내는 문자열(스트링)이 주어진다. 단 그 길이는 1 이상, 30 이하이다.
<출력값>
첫째 줄에 그 괄호열의 값을 나타내는 정수를 출력한다. 만일 입력이 올바르지 못한 괄호열이면 반드시 0을 출력해야 한다.

<문제 2505>
1부터 N까지의 숫자가 각 칸에 차례대로 들어있는 놀이판이 있다. 예를 들어 10 칸을 가진 놀이판의 초기 상태는 다음과 같다.  



1
2
3
4
5
6
7
8
9
10



구간[i,j]는 놀이판의 왼쪽 i번째 칸부터 j번째칸 사이에 있는 모든 숫자를 말한다. 단 구간[i,j]에서 항상 i ≤ j라고 가정한다. 우리는 이 놀이판의 한 구간을 잡아서 그 구간을 완전히 뒤집을  수 있다. 만일 초기상태에서 구간[3,8]을 뒤집으면 놀이판은 다음과 같이 변한다.



1
2
8
7
6
5
4
3
9
10



이어 이 상태에서 구간[1,5]를 다시 뒤집으면 놀이판은 다음과 같이 바뀐다. 



6
7
8
2
1
5
4
3
9
10



여러분은 두 번 뒤집힌 놀이판의 상태를 입력으로 받아서 이를 다시 초기 상태로 돌리기 위해서 어떤 두 구간을 차례대로 뒤집어야 하는지를 계산해야 한다. 즉 여러분이 찾아낸 두 개의 구간대로 입력 놀이판을 차례대로 뒤집으면, 놀이판은 초기상태인 1, 2, 3, ...., N 으로 되돌아가야 한다.  
단 어떤 경우에는 초기상태로 되돌릴 수 있는 두 구간이 여러 개 있을 수도 있는데, 그러한 경우에는 그 중 하나만 출력해도 된다. 구간[i,i]를 뒤집으면 아무런 변화가 없는데 이러한 것도 허용이 된다.
<입력값>
첫줄에는 숫자판의 크기를 나타내는 정수 N (5≤N≤10,000)이 주어진다. 그 다음 줄에는 두 개의 구간이 뒤집혀진 놀이판의 상태를 나타내는 숫자들이 하나의 공백을 두고 나타난다.
<출력값>
첫 두 줄에는 뒤집어야 할 각 구간을 차례대로 출력해야 한다. 각 줄에는 구간[i,j]를 나타내는 i와 j를 빈 칸을 사이에 두고 출력해야 한다. 입력에 대한 답은 항상 존재한다.

<문제 2506>
OX 문제는 맞거나 틀린 두 경우의 답을 가지는 문제를 말한다. 여러 개의 OX 문제로 만들어진 시험에서 연속적으로 답을 맞히는 경우에는 가산점을 주기 위해서 다음과 같이 점수 계산을 하기로 하였다. 1번 문제가 맞는 경우에는 1점으로 계산한다. 앞의 문제에 대해서는 답을 틀리다가 답이 맞는 처음 문제는 1점으로 계산한다. 또한, 연속으로 문제의 답이 맞는 경우에서 두 번째 문제는 2점, 세 번째 문제는 3점, ..., K번째 문제는 K점으로 계산한다. 틀린 문제는 0점으로 계산한다.
예를 들어, 아래와 같이 10 개의 OX 문제에서 답이 맞은 문제의 경우에는 1로 표시하고, 틀린 경우에는 0으로 표시하였을 때, 점수 계산은 아래 표와 같이 계산되어, 총 점수는 1+1+2+3+1+2=10 점이다.

시험문제의 채점 결과가 주어졌을 때, 총 점수를 계산하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 문제의 개수 N (1 ≤ N ≤ 100)이 주어진다. 둘째 줄에는 N개 문제의 채점 결과를 나타내는 0 혹은 1이 빈 칸을 사이에 두고 주어진다. 0은 문제의 답이 틀린 경우이고, 1은 문제의 답이 맞는 경우이다.
<출력값>
첫째 줄에 입력에서 주어진 채점 결과에 대하여 가산점을 고려한 총 점수를 출력한다.

<문제 2507>
유시 섬에서 한가롭게 소풍을 즐기던 다리오와 오렌지 공주. 다리오가 잠시 자리를 비운 사이에 못된 악당 후퍼가 공주를 데리고 도망가 버렸다. 다리오는 후퍼가 오렌지 공주를 숨겨놓은 후퍼 섬으로 여행을 떠난다.


유시 섬에서 후퍼 섬까지 가기 위해서는 중간에 있는 여러 개의 섬을 거쳐 가야 한다. 유시 섬과 후퍼 섬을 포함한 모든 섬들은 유시 섬과 후퍼 섬을 지나는 직선상에 있다. 위 그림에서, 섬들을 나타내는 동그라미 아래에 있는 눈금자가 각각의 섬이 유시 섬과 몇 km나 떨어져 있는지를 나타낸다. 가장 왼쪽에 있는 섬이 유시 섬이고, 가장 멀리 있는 후퍼 섬은 15km 떨어져 있다.
한 섬에서 다른 섬으로 건너가기 위해서는 섬마다 하나씩 있는 스프링 발판을 밟아 점프해야 한다. 이 스프링 발판은 내구성이 약해서 한 번 사용하면 부서져 버린다. 이때문에, 시작점인 유시 섬을 제외한 모든 섬들은 두 번 이상 방문하면 안 된다. 
스프링 발판들의 스프링의 세기는 모두 다르다. 섬을 나타내는 동그라미에 쓰여 있는 숫자는 스프링 발판을 딛고 점프했을 때 가장 멀리 도달할 수 있는 거리를 나타낸다. 가령, 유시 섬에서 7km 떨어져 있는 섬의 스프링 발판의 세기가 3이라면, 스프링 발판을 딛고 도달할 수 있는 섬은 유시 섬에서 4km 이상 10km 이하 떨어져 있는 섬들이다.
다리오는 공주를 구하기 위해 앞만 보고 질주한다. 공주를 구하기 전에는 스프링 발판을 밟고 후퍼 섬을 향해서만 점프한다. 하지만 공주를 구한 뒤에는 공주를 들쳐 업고 유시 섬을 향해서만 뒤도 돌아보지 않고 도망친다. 
일부 스프링 발판은 내구도가 너무 약해서 공주를 들쳐 업은 상태에서는 발만 딛어도 부서져버리기도 한다. 그림에서 유시 섬에서 12km 떨어진 곳에 있는 회색으로 표시된 섬의 스프링 발판이 그 예이다. 이런 스프링 발판들은 공주를 구하러 후퍼 섬을 향해 갈 때에만 사용할 수 있다.
유시 섬과 후퍼 섬을 포함한 모든 섬들의 정보와 섬마다 하나씩 있는 스프링 발판의 정보가 주어질 때, 다리오가 유시 섬을 출발해 공주를 구하고 돌아오는 서로 다른 경로의 개수를 1000으로 나눈 나머지를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 섬의 개수 N이 주어진다. N은 유시 섬과 후퍼 섬도 포함한 개수이고 3 이상 500 이하이다. 
이어지는 N개의 줄에는 각각의 섬에 대한 정보가 한 줄에 하나씩 주어진다. 섬의 정보는 유시 섬과의 거리가 가까운 순으로 주어진다. 그러므로 첫 번째로 정보가 주어지는 섬은 항상 유시 섬이고, 마지막으로 정보가 주어지는 섬은 항상 후퍼 섬이다.
섬의 정보를 나타내는 각각의 줄에는 섬에 대한 정보를 표현하는 세 개의 정수가 빈칸을 사이에 두고 주어진다. 첫 번째 정수는 유시 섬과의 거리이다. 유시 섬에 대해서는 이 값이 0이고, 후퍼 섬에서 이 값이 가장 크다. 거리는 0 이상 100,000 이하이다. 이 값이 동일한 두 섬은 존재하지 않는다.
두 번째 정수는 스프링 발판의 세기, 즉 해당 섬에서 좌우로 얼마나 떨어진 섬까지 점프할 수 있는지를 나타내는 값이다. 이 값은 1 이상 1,000 이하이다.
세 번째 정수는 해당 섬의 스프링 발판을 오렌지 공주를 들쳐 업은 상태에서도 사용할 수 있는지를 나타내는 값이다. 1이면 오렌지 공주와 함께 이용할 수 있고, 0이면 이용할 수 없다. 후퍼 섬에서 이 값은 항상 1이다.
<출력값>
첫째 줄에 유시 섬에서 출발해 오렌지 공주를 구해오는 총 경로의 수를 1000으로 나눈 나머지를 출력한다.

<문제 2508>
창영이가 드디어 취직을 했다!! 그가 30세까지 취직을 안하던 이유는 바로 마음에 다니는 직장을 찾지 못해서였다. 이번에 창영이가 취직한 곳은 사탕 공장이다. 사탕 공장에 다니면 사탕 처럼 달콤한 직장생활을 할 줄 알았지만, 8시간동안 사탕 품질을 검사해야 하는 작업은 너무나 지루했다.
사탕의 품질은 다음과 같이 검사한다. 가장 먼저 사탕으로 가득 찬 박스를 연다. 그 다음 사탕의 개수와 사탕이 없는 곳의 개수를 센다.
지루함을 견디지 못한 창영이는 결국 품질을 검사하는 프로그램을 작성하기로 했다.
r행 c열 행렬이 주어진다. 이 행렬은 박스를 위에서 바라본 것이다. 행렬에는 다음과 같은 문자만 있다.

".": 빈 곳
"o": 사탕의 먹을 수 있는 부분
"<>v^": 캔디 껍질

사탕은 오직 2가지 모습만 있다.



>o<




v
o
^


위와 같은 연속된 3개의 문자만 사탕이다.
사탕은 >o.와 같이 사탕의 일부만 존재할 수 있지만, 이 것은 사탕으로 세지 않는다.
r행 c열 행렬이 주어졌을 때, 사탕의 개수를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 테스트 케이스의 개수 t가 주어진다. 각 테스트 케이스는 빈 줄로 구분된다.
각 테스트 케이스의 첫째 줄에는 r과 c 가 주어진다. (1 ≤ r,c ≤ 400) 그 다음 r개의 줄에는 행렬의 각 행이 순서대로 주어진다. 행렬의 각 행은 c개의 문자이며, ".o<>v^"만 포함하고 있다. (각각의 아스키 값은 46, 111, 60, 62, 118, 94이다)
<출력값>
각각의 테스트 케이스에 대해 한 줄에 하나의 정수만 출력한다. 이 값은 박스에 들어있는 사탕의 개수이다.

<문제 2509>
다음과 같이 양수로 이루어진 두 수열이 있다. T=t1,t2,...,tn (텍스트), P=p1,p2,...,pm(패턴).
매칭이란 p1=tk, p2=tk+1, ..., pm=tk+m-1일때, "P는 k에서 T와 매칭된다" 라고 한다. 이러한 매칭은 Knuth-Morris-Pratt 알고리즘으로 찾을 수 있다.
매칭은 쉬우니깐, 조금 더 어려운 매칭을 생각해보자. P가 k에서 T와 매췽된다는 말은 아래와 같은 조건을 만족하는 수열 k=a0 < a1 < ... < am이 있을 때이다.
ta0 + ta0+1 + ... + ta1-1 = p1
ta1 + ta1+1 + ... + ta2-1 = p2
...
tam-1 + tam-1+1 + ... + tam-1 = pm
매췽은 먼저 텍스트를 그룹짓고 그룹 내의 연속된 합을 구한 다음에, 패턴을 찾는 것이다.
예를 들어, T=1,2,1,1,3,2이고, P=3,2일 때를 생각해보자. 이때는 2개의 매췽이 있는데, k=1 (a1=3, a2=5) 일때와 k=5 (a1=6, a2=7)일 때 이다.
매췽의 개수는 P가 k에서 T와 매췽된때 k의 서로 다른 개수이다.
텍스트 P와 두 개의 패턴 P1, P2가 주어졌을 때, 다음을 구하시오.
1. T와 P1의 매췽의 개수
2. T와 P2의 매췽의 개수
3. T와 P1 ⋅ n ⋅ P2의 매췽의 개수를 최대로 하는 가장 작은 양의 정수 n (⋅는 수열을 합치는 것이다)
4. T와 P1 ⋅ n ⋅ P2의 개수 (여기서 n은 3에서 구한 n이다)
<입력값>
첫째 줄에는 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 빈 줄로 구분된다.
각 테스트 케이스는 다음과 같이 여섯 줄로 구성되어 있다.
첫째 줄에는 텍스트의 길이 N이 주어진다.
둘째 줄에는 텍스트의 원소 N개가 주어진다.
셋째 줄에는 첫 번째 패턴의 길이 M1이 주어진다.
넷째 줄에는 첫 번째 패턴의 원소 M1개가 주어진다.
다섯째 줄에는 두 번째 패턴의 길이 M2이 주어진다.
여섯째 줄에는 두 번째 패턴의 원소 M2개가 주어진다.
N<=5000, M1,M2<=600, T와 P1, P2에 포함되어 있는 모든 원소를 합한 값은 11,000을 넘지 않는다.
<출력값>
각 테스트케이스이 대해 한 줄에 문제에서 구하라 했던 순서대로 빈 칸을 사이에 두고 출력한다.

<문제 2510>
다음과 같이 양수로 이루어진 두 수열이 있다. T=t1,t2,...,tn (텍스트), P=p1,p2,...,pm(패턴).
매칭이란 p1=tk, p2=tk+1, ..., pm=tk+m-1일때, "P는 k에서 T와 매칭된다" 라고 한다. 이러한 매칭은 Knuth-Morris-Pratt 알고리즘으로 찾을 수 있다.
매칭은 쉬우니깐, 조금 더 어려운 매칭을 생각해보자. P가 k에서 T와 매췽된다는 말은 아래와 같은 조건을 만족하는 수열 k=a0 < a1 < ... < am이 있을 때이다.

ta0 + ta0+1 + ... + ta1-1 = p1
ta1 + ta1+1 + ... + ta2-1 = p2
...
tam-1 + tam-1+1 + ... + tam-1 = pm

매췽은 먼저 텍스트를 그룹짓고 그룹 내의 연속된 합을 구한 다음에, 패턴을 찾는 것이다.
예를 들어, T=1,2,1,1,3,2이고, P=3,2일 때를 생각해보자. 이때는 2개의 매췽이 있는데, k=1 (a1=3, a2=5) 일때와 k=5 (a1=6, a2=7)일 때 이다.
매췽의 개수는 P가 k에서 T와 매췽된때 k의 서로 다른 개수이다.
텍스트 P와 두 개의 패턴 P1, P2가 주어졌을 때, 다음을 구하시오.

T와 P1의 매췽의 개수
T와 P2의 매췽의 개수
T와 P1 ⋅ n ⋅ P2의 매췽의 개수를 최대로 하는 가장 작은 양의 정수 n (⋅는 수열을 합치는 것이다)
T와 P1 ⋅ n ⋅ P2의 개수 (여기서 n은 3에서 구한 n이다)
<입력값>
첫째 줄에는 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 빈 줄로 구분된다.
각 테스트 케이스는 다음과 같이 여섯 줄로 구성되어 있다.
첫째 줄에는 텍스트의 길이 N이 주어진다.
둘째 줄에는 텍스트의 원소 N개가 주어진다.
셋째 줄에는 첫 번째 패턴의 길이 M1이 주어진다.
넷째 줄에는 첫 번째 패턴의 원소 M1개가 주어진다.
다섯째 줄에는 두 번째 패턴의 길이 M2이 주어진다.
여섯째 줄에는 두 번째 패턴의 원소 M2개가 주어진다.
N<=11*106, M1,M2<=2*106, T와 P1, P2에 포함되어 있는 모든 원소를 합한 값은 22*106을 넘지 않는다.
<출력값>
각 테스트케이스이 대해 한 줄에 문제에서 구하라 했던 순서대로 빈 칸을 사이에 두고 출력한다.

<문제 2511>
0부터 9까지의 숫자가 표시된 카드를 가지고 두 사람 A와 B가 게임을 한다. A와 B에게는 각각 0에서 9까지의 숫자가 하나씩 표시된 10장의 카드뭉치가 주어진다. 두 사람은 카드를 임의의 순서로 섞은 후 숫자가 보이지 않게 일렬로 늘어  놓고 게임을 시작한다. 단, 게임 도중 카드의 순서를 바꿀 수는 없다.
A와 B 각각이 늘어놓은 카드를 뒤집어서 표시된 숫자를 확인하는 것을 한 라운드라고 한다. 게임은 첫 번째 놓인 카드부터 시작하여 순서대로 10번의 라운드로 진행된다. 각 라운드에서는 공개된 숫자가 더 큰 사람이 승자가 된다. 승자에게는 승점 3점이 주어지고 패자에게는 승점이 주어지지 않는다. 만약 공개된 두 숫자가 같아서 비기게 되면, A, B 모두에게 승점 1점이 주어진다. 
10번의 라운드가 모두 진행된 후, 총 승점이 큰 사람이 게임의 승자가 된다. 만약, A와 B의 총 승점이 같은 경우에는, 제일 마지막에 이긴 사람을 게임의 승자로 정한다. 그래도 승부가 나지 않는 경우는 모든 라운드에서 비기는 경우뿐이고 이 경우에 두 사람은 비겼다고 한다.
예를 들어, 다음 표에서 3번째 줄은 각 라운드의 승자를 표시하고 있다. 표에서 D는 무승부를 나타낸다. 이 경우에 A의 총 승점은 16점이고, B는 13점이어서, A가 게임의 승자가 된다. 


아래 표의 경우에는 A와 B의 총 승점은 13점으로 같다. 마지막으로 승부가 난 라운드는 7번째 라운드이고, 이 라운드의 승자인 B가 게임의 승자가 된다. 


A와 B가 늘어놓은 카드의 숫자가 순서대로 주어질 때, 게임의 승자가 A인지 B인지, 또는 비겼는지 결정하는 프로그램을 작성하시오.
<입력값>
입력 파일은 두 개의 줄로 이루어진다. 첫 번째 줄에는 A가 늘어놓은 카드의 숫자들이 빈칸을 사이에 두고 순서대로 주어진다. 두 번째 줄에는 B가 늘어놓은 카드의 숫자들이 빈칸을 사이에 두고 순서대로 주어진다.
<출력값>
첫 번째 줄에는 게임이 끝난 후, A와 B가 받은 총 승점을 순서대로 빈칸을 사이에 두고 출력한다. 두 번째 줄에는 이긴 사람이 A인지 B인지 결정해서, 이긴 사람을 문자 A 또는 B로 출력한다. 만약 비기는 경우에는 문자 D를 출력한다.

<문제 2512>
국가의 역할 중 하나는 여러 지방의 예산요청을 심사하여 국가의 예산을 분배하는 것이다. 국가예산의 총액은 미리 정해져 있어서 모든 예산요청을 배정해 주기는 어려울 수도 있다. 그래서 정해진 총액 이하에서 가능한 한 최대의 총 예산을 다음과 같은 방법으로 배정한다.

모든 요청이 배정될 수 있는 경우에는 요청한 금액을 그대로 배정한다.
모든 요청이 배정될 수 없는 경우에는 특정한 정수 상한액을 계산하여 그 이상인 예산요청에는 모두 상한액을 배정한다. 상한액 이하의 예산요청에 대해서는 요청한 금액을 그대로 배정한다. 

예를 들어, 전체 국가예산이 485이고 4개 지방의 예산요청이 각각 120, 110, 140, 150이라고 하자. 이 경우, 상한액을 127로 잡으면, 위의 요청들에 대해서 각각 120, 110, 127, 127을 배정하고 그 합이 484로 가능한 최대가 된다. 
여러 지방의 예산요청과 국가예산의 총액이 주어졌을 때, 위의 조건을 모두 만족하도록 예산을 배정하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 지방의 수를 의미하는 정수 N이 주어진다. N은 3 이상 10,000 이하이다. 다음 줄에는 각 지방의 예산요청을 표현하는 N개의 정수가 빈칸을 사이에 두고 주어진다. 이 값들은 모두 1 이상 100,000 이하이다. 그 다음 줄에는 총 예산을 나타내는 정수 M이 주어진다. M은 N 이상 1,000,000,000 이하이다.
<출력값>
첫째 줄에는 배정된 예산들 중 최댓값인 정수를 출력한다.

<문제 2513>
주택난을 해결하기 위해서 직선 도로 하나를 따라 여러 아파트 단지들을 지었다. 또, 이 아파트 단지 주민을 위해 도로 위 한 지점에 학교 하나를 신설하였다. 아파트 단지들이 서로 멀리 떨어져 있기 때문에 반드시 통학버스를 이용해서만 다닐 수 있고, 통학버스는 한 대이다.
각각의 아파트 단지와 학교의 위치는 도로 위의 좌표로 주어지며, 또 각 아파트 단지마다 여기에 사는 학생들의 수도 주어진다. 통학버스는 아침에 학교를 출발하여 각 아파트 단지에 있는 학생들을 태우고 학교로 다시 돌아온다. 이 통학버스는 정원을 초과하여 학생을 태울 수 없고, 모든 학생을 등교시킬 때까지 이 과정을 반복한다. 


위 규칙을 따라서 모든 학생들을 학교에 등교시키는 예를 보자. 아파트 단지 A, B, C가 각각 좌표 0, 2, 5에 있고 이 단지에 사는 학생은 각각 1, 2, 1명이라고 하자. 두 지점 간의 거리는 두 지점 좌표의 차이로 정의된다. 최대 4명이 탈 수 있는 통학버스가 좌표 4에 있는 학교에서 출발해서 모든 학생들을 등교시킬 때, 버스는 먼저 단지 B를 들러 2명을 태우고, 단지 A를 들러서 1명을 태우고 다시 학교로 돌아온다면 이동 거리는 2 + 2 + 4 = 8이다. 다시 학교에서 아파트 단지 C로 이동하여 1명을 태우고 돌아오면 이동 거리는 1 + 1 = 2가 되고, 총 이동거리는 8 + 2 = 10이 된다. 
학교의 위치, 각각의 아파트 단지의 위치와 학생 수, 통학버스의 정원이 주어졌을 때, 모든 학생을 등교시키는데 필요한 통학버스의 총 이동 거리의 최솟값을 계산하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 세 개의 양의 정수 N, K, S가 빈칸을 사이에 두고 순서대로 주어진다. 첫 번째 정수 N은 아파트 단지의 수이며 2<=N<=30,000이다. 두 번째 정수 K는 1<=K<=2,000이며, 통학버스의 정원이다. 세 번째 정수 S는 학교의 위치를 나타낸다. 둘째 줄부터 N+1번째 줄에는 각 아파트 단지의 위치를 나타내는 정수와 이 단지에 사는 학생 수를 나타내는 정수가 빈칸을 사이에 두고 주어진다. 학교와 아파트 단지의 좌표는 0 이상 100,000 이하이며, 이 좌표들은 모두 서로 다르다. 각 아파트 단지의 학생 수는 1 이상 2,000 이하이다.
<출력값>
첫째 줄에 주어진 입력에서 통학버스의 최소 이동 거리를 출력한다. 최소 이동 거리가 1,000,000,000을 초과하는 경우는 없다.

<문제 2514>
어떤 농장은 다음 그림과 같이 가로 세로 8*8의 단위 구역으로 나누어져 있다. 이 농장에는 많은 곡식을 생산하기 위하여 비료액 또는 제초제를 뿌리는 자동분무기가 단위 구역에 설치되어 있다. 이 자동분무기는 놓인 위치에서 상하좌우 4방향으로 액체를 뿌린다. 예를 들어 X 구역에 자동분무기가 놓여있다면 그 장치로 부터 액체가 뿌려지는 단위 구역은 {X,a, b,c,d,e,f,g,h,i,j,k,l,m,n}이다. 만일 Y 구역에 자동분무기가 놓여있다면 액체가 뿌려지는 단위 구역은 {Y,A,B,c,C,D,E,F,G,H, I,J,k,K,L}이다.


자동분무기를 설치하지 않았을 때에는 각 단위 구역의 생산량은 모두 정확하게 같고, 이를 기본 생산량이라고 하자. 자동분무기를 설치한 후, 비료액이 뿌려진 단위 구역은 생산량이 1씩 증가하고, 제초제가 뿌려진 단위 구역은 잡초와 해충은 제거되지만 생산량이 1씩 감소한다. 기본 생산량이 30이라고 하자. X 구역에 비료액 자동분무기를, 그리고 Y 구역에 제초제 자동분무기를 설치하면 최종 생산량은 다음과 같다. 

단, 한 단위 구역에 배치될 수 있는 자동분무기는 최대 1대이다. 따라서 한 단위 구역에 제초제 자동분무기와 비료액 자동분무기가 동시에 배치되거나 같은 종류의 자동분무기가 2대 이상 설치될 수 없다. 
기본 생산량이 M인  농장의 최종 생산량 자료가 주어졌을 때, 자동분무기가 놓인 위치와 종류를 찾아내는 프로그램을 작성하시오.
<입력값>
첫 줄에는 기본 생산량 M (30<=M<=40)이 주어진다. 두 번째 줄에는 이 농장에 놓인 자동분무기의 개수 K (1<=K<=63)가 주어진다. 그 다음에는 전체 8*8 농장의 최종 생산량이 위에서 아래로 한 줄씩 총 8줄에 걸쳐서 주어진다. 같은 줄에 있는 8개의 단위 구역의 생산량은 빈칸을 사이에 두고 구분된다. 모든 값은 양의 정수이다.
<출력값>
파일의 각 줄에는 입력에서 읽은 순서대로, 각 단위 구역마다 자동분무기의 유무와 종류 정보를 총 8줄에 출력한다. 비료액 자동분무기가 놓인 단위 구역은 ‘+’ 기호로, 제초제 자동분무기가 놓인 단위 구역은 ‘-’(마이너스) 기호로,  자동분무기가 없는 단위 구역은 ‘.’ 기호로 표현한다. 같은 줄에 있는 단위 구역 정보는 하나의 빈칸을 사이에 두고 출력한다.

<문제 2515>
전시장에서 그림을 판매하는 업체에 하나의 전시대가 배정된다. 전시될 그림은 직사각형의 모양을 가지고 있고, 그림의 높이는 다를 수 있지만 폭은 모두 동일하다고 가정한다. 각 그림에는 가격이 매겨져 있다. 

업체는 그림들을 관람객에게 보이기 위해 전시대에 배치하는데, 전시대의 폭이 그림의 폭과 동일하여 겹쳐서 배치해야만 한다. 예를 들어, 위의 그림은 전시대에 네 개의 그림 A, B, C, D를 C, B, A, D의 순서로 겹쳐서 배치한 상황을 보여준다.
위 그림의 오른쪽 부분은 전시된 그림들의 배치를 옆에서 본 모양을 나타내고, 왼쪽 부분은 배치한 그림들을 앞에서 보아서 관람객들이 보게 될 모양을 나타낸다. 그림 A는 앞의 그림 B때문에 가려져서 관람객에게 전혀 보이지 않고, 부분적으로라도 보이는 그림은 B, C, D 뿐이다. 
보이는 부분의 세로 길이가 특정 정수 S이상인 그림만 관람객이 관심을 보이고 사게 된다고 가정한다. 전시된 그림들 중 보이는 부분의 세로 길이가 S이상인 그림을 판매가능 그림이라고 부른다. 
그림의 높이와 가격이 주어질 때, 판매가능 그림들의 가격의 합이 최대가 되도록 그림을 배치할 때, 그 최대합을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 그림의 개수 N (1<=N<=300,000)과 판매가능 그림을 정의하는 1이상의 정수 S가 빈칸을 사이에 두고 주어진다. 다음 이어지는 N개의 줄 각각에는 한 그림의 높이와 가격을 나타내는 정수 H와 C가 빈칸을 사이에 두고 주어진다. 단, 1 ≤ S ≤ H ≤ 20,000,000, 1 ≤ C ≤ 1,000이다.
<출력값>
첫째 줄에 판매가능 그림들의 가격의 합이 최대가 되도록 배치했을 때 그 최대 합을 출력한다.

<문제 2516>
KOI 동물원에는 N마리의 원숭이가 있고, 이 원숭이들을 수용할 수 있는 두 개의 큰 우리가 있다. 모든 원숭이들은 1부터 N까지의 번호가 매겨져 있다.
원숭이들 사이에는 유달리 서로 앙숙관계인 원숭이들이 있어서 같은 우리에 두었을 경우 서로 싸우는 경우가 많다. 두 원숭이 x와 y가 앙숙관계라는 것은 두 원숭이 x, y가 서로 싫어하는 관계임을 의미한다. 또한, 각각의 한 원숭이에 대해 앙숙관계에 있는 원숭이들의 수는 기껏해야 세 마리라고 가정한다. 동물원에서는 원숭이들의 앙숙관계를 조사하여 아래의 두 조건을 만족하도록 원숭이들을 두 개의 우리에 나누어 수용하려고 한다. 
(조건 1) 각 원숭이에 대해 같은 우리 안에 있으며 앙숙관계인 원숭이는 한 마리 이하이다.
(조건 2) 비어있는 우리는 없다. (즉, 하나의 우리에 원숭이를 모두 수용 가능한 경우가 있더라도 각각의 우리에는 적어도 한 마리 이상의 원숭이를 수용하여야 한다.)
예를 들어, N=5 인 경우에 1번 원숭이는 {2, 3, 4}와 2는 {1, 3, 5}와 앙숙관계이고, 그리고 3은 {1, 2, 4}와 4는 {1, 3, 5}, 그리고 5는 {2, 4}와 앙숙관계라고 하자. 위의 조건을 만족하도록 원숭이들을 두 개의 우리로 나누려면 {1, 3, 5}를 하나의 우리에, 그리고 {2, 4}를 다른 우리에 수용하면 된다.
원숭이들의 수와 각 원숭이들의 앙숙관계가 입력으로 주어질 때, 위의 조건을 만족하도록 원숭이들을 두 개의 우리에 나누어 수용하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 원숭이들의 수를 나타내는 하나의 정수 N이 주어진다. 단, N은 3이상 100,000이하의 정수이다. 둘째 줄부터 N개의 줄에는 1번부터 번호순서대로 각 원숭이에 대해 앙숙관계에 있는 원숭이의 수 M이 주어지고, 이어서 각 원숭이 번호 M개가 오름차순으로 하나의 줄에 주어진다. 모든 정수들 사이에는 빈칸이 있다. 조건에 맞도록 원숭이들을 나누지 못하는 경우는 존재하지 않는다.
<출력값>
첫째 줄에는 하나의 우리에 수용되는 원숭이의 수와 원숭이들의 번호를 빈칸을 사이에 두고 임의의 순서대로 출력하고, 둘째 줄에는 또 다른 하나의 우리에 수용되는 원숭이의 수와 원숭이들의 번호를 빈칸을 사이에 두고 임의의 순서대로 출력한다. 만약, 조건에 맞게 원숭이들을 수용하는 경우가 여러 개일 경우에는 그 중의 하나를 출력한다.

<문제 2517>
KOI 장거리 달리기 대회가 진행되어 모든 선수가 반환점을 넘었다. 각 선수의 입장에서 자기보다 앞에 달리고 있는 선수들 중 평소 실력이 자기보다 좋은 선수를 남은 거리 동안 앞지르는 것은 불가능하다. 반대로, 평소 실력이 자기보다 좋지 않은 선수가 앞에 달리고 있으면 남은 거리 동안 앞지르는 것이 가능하다. 이러한 가정 하에서 각 선수는 자신이 앞으로 얻을 수 있는 최선의 등수를 알 수 있다. 
각 선수의 평소 실력은 정수로 주어지는데 더 큰 값이 더 좋은 실력을 의미한다. 현재 달리고 있는 선수를 앞에서 부터 표시했을 때 평소 실력이 각각 2, 8, 10, 7, 1, 9, 4, 15라고 하면 각 선수가 얻을 수 있는 최선의 등수는 (같은 순서로) 각각 1, 1, 1, 3, 5, 2, 5, 1이 된다. 예를 들어, 4번째로 달리고 있는 평소 실력이 7인 선수는 그 앞에서 달리고 있는 선수들 중 평소 실력이 2인 선수만 앞지르는 것이 가능하고 평소실력이 8과 10인 선수들은 앞지르는 것이 불가능하므로, 최선의 등수는 3등이 된다.
선수들의 평소 실력을 현재 달리고 있는 순서대로 입력 받아서 각 선수의 최선의 등수를 계산하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 선수의 수를 의미하는 정수 N이 주어진다. N은 3 이상 500,000 이하이다. 이후 N개의 줄에는 정수가 한 줄에 하나씩 주어진다. 이 값들은 각 선수들의 평소 실력을 앞에서 달리고 있는 선수부터 제시한 것이다. 각 정수는 1 이상 1,000,000,000 이하이다. 단, 참가한 선수들의 평소 실력은 모두 다르다.
<출력값>
각 선수의 최선의 등수를 나타내는 정수 N개를 입력에 주어진 선수 순서와 동일한 순서로 한 줄에 하나씩 출력한다.

<문제 2518>
현이네 가족은 3명이다. 현이네 가족은 주말마다 찾아가는 단골 중식당이 있다. 현이네 가족이 오면 식당에서는 N개의 요리를 회전 테이블에 같은 간격으로 올려준다. 각 요리 접시에는 시계 방향으로 1부터 N까지 번호가 붙여져 있다. N은 항상 3의 배수이다. N=3k라고 할 때, 테이블에서 아빠 자리는 1번 요리가 놓인 곳이고, 엄마 자리는 k+1번 요리, 현이 자리는 2k+1번 요리가 놓인 곳이다. 아래 그림은 N=9일 때 식사를 시작하기 전에 요리가 놓여 있는 예를 보여준다.

가족 각자는 먹고 싶어 하는 요리의 순서를 가지고 있다. 예를 들면, 아빠는 3번, 7번, 1번 순서로 요리를 먹고 싶어 하고, 엄마는 2번, 4번, 1번, 2번 순서로, 현이는 9번, 5번, 6번, 5번 순서로 요리를 먹고 싶어 할 수 있다. 같은 요리를 여러 번 먹어도 되지만, 반드시 순서대로 먹는다. 또한 요리 접시가 자기 바로 앞에 올 때만 식사할 수 있다. 그래서 테이블을 회전시켜가면서 식사를 해야 한다. 각 요리는 여러 번 먹을 수 있을 만큼 충분하다.
자기 바로 오른쪽에 놓인 요리 접시가 자기 앞으로 오도록 테이블을 돌리는 경우에 테이블을 시계방향으로 1칸 돌린다고 말하고, 바로 왼쪽에 놓인 요리 접시가 자기 앞으로 오도록 회전시키는 것을 반시계방향으로 1칸 돌린다고 말한다. 
아빠가 혼자 (3, 7, 1) 순서로 식사를 하려면, 테이블을 반시계방향으로 2칸 돌려서 3번 요리를, 그 다음 4칸을 돌려서 7번 요리를, 그 다음 3칸을 돌려서 1번 요리를 먹으면 된다. 이 경우 테이블을 총 9칸 돌려서 식사를 마치게 된다.
아빠가 (3, 7, 1), 엄마가 (2, 4, 1, 2), 현이가 (9, 5, 6, 5) 순서로 식사를 한다고 하자. 아빠, 엄마, 현이가 차례대로 한사람씩 식사를 마친 후에 그 다음 사람이 식사를 하는 방식을 아래 순서와 같이 나타낼 수 있다. 이 순서에서 L과 R은 각각 테이블을 시계방향과 반시계방향으로 1칸 돌리는 것을 의미한다. 이 방식으로는 가족 모두 식사를 마치기 위해 테이블을 총 27칸 돌려야 한다.
RRRRRRRRRLLRRLLLRRRRRLLLLRL
만일 아래에 표시된 순서대로 테이블을 회전시켜 가면서 식사를 한다면 테이블을 13칸만 돌려도 가족 모두 식사를 마칠 수 있다. 
RRRRRRRRRLLLR
가족 모두가 식사를 마치는데 필요한 테이블 회전 칸수의 최솟값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 요리의 개수를 나타내는 정수 N (3<=N<=300,000)이 주어진다. N은 항상 3의 배수이다. 둘째 줄부터 넷째 줄에는 아빠, 엄마, 현이 순서대로 각 줄마다 한 사람씩 먹고 싶어 하는 요리 순서의 길이 pi가 주어지고 이어서 pi개의 요리 번호가 빈칸을 사이에 두고 주어진다(i=1, 2, 3). 정수 pi는 1 이상 100 이하이고, 요리 번호는 1과 N 사이의 정수이며 같은 번호가 나올 수도 있다.
<출력값>
첫째 줄에 현이네 가족이 식사를 마치는데 필요한 테이블 회전 칸수의 최솟값을 출력한다.

<문제 2519>
곧은 막대기를 세 개씩 가지고 있는 학생들이 모든 막대기를 바닥으로 던졌다. 각자 가지고 있던 막대기를 최대 한 개를 제거할 때, 바닥에 있는 나머지 막대기들이 서로 겹치지 않을 수 있는 지를 알아보기로 하였다. 단, 막대기가 제거될 때 다른 막대기의 위치는 변하지 않는다고 가정한다.
예를 들어, 학생 세 명이 각자 가지고 있는 막대기 ①②③, ④⑤⑥, ⑦⑧⑨를 바닥에 던진 막대기 모양이 아래와 같을 때, 막대기 한 개씩 ②, ④, ⑧을 제거하면 나머지 여섯 개의 막대기는 서로 겹치지 않게 된다.


또한, 학생 두 명이 던진 막대기 모양이 아래와 같은 경우에는 각자 어떠한 막대기를 한 개씩 제거하더라도 나머지 막대기들 중에서 적어도 두 개는 서로 겹치게 된다. 


바닥에 던져진 막대기의 양 끝점의 좌표가 주어졌을 때, 바닥에 남아 있는 막대기들이 서로 겹치지 않도록 각자 가지고 있던 막대기들 중에서 제거할 최대 한 개의 막대기를 찾는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 학생들의 수를 나타내는 정수 N이 주어진다. N은 2 이상 1,000 이하이다. 두 번째 줄부터 3N개의 줄에는 한 줄에 막대기 한 개의 양 끝에 해당되는 두 끝점의 좌표를 나타내는 네 개의 정수 X1, Y1, X2, Y2가 빈칸을 사이에 두고 나타난다. 각 정수는 한 개의 막대기의 두 끝점의 좌표 (X1, Y1), (X2, Y2)를 나타낸다. 이 정수들은 –10,000 이상 10,000 이하이다. 두 번째 줄부터 나타나는 각 막대기는 1번부터 3N번까지 순서대로 번호가 부여되며, 연속적인 세 개의 번호 3i-2, 3i-1, 3i (1<=i<=N)는 i번째 학생이 가지고 있는 막대기 세 개의 번호를 나타낸다.
입력 데이터는 다음 세 조건을 항상 만족한다고 가정한다. 
(조건 1) 막대기들의 끝점의 좌표가 같은 경우는 없다. 
(조건 2) 세 개의 끝점이 임의의 일직선상에 위치하는 경우는 없다. 
(조건 3) 세 개의 막대기가 한 점에서 만나는 경우는 없다.
<출력값>
첫째 줄에는 서로 겹치지 않도록 막대기를 제거할 수 없는 경우에는 -1을 출력한다. 그렇지 않은 경우에는 첫째 줄에 제거된 막대기의 수인 K (0<=K<=N)를 출력한다. K가 최소일 필요는 없다. 두 번째 줄에는 제거된 막대기 K개의 번호를 빈칸을 사이에 두고 오름차순으로 출력한다. 단, K가 0인 경우에는 막대기 번호를 출력하지 않는다. 답이 여러 개인 경우에는 그 중 하나를 출력한다.

<문제 2520>
오늘은 내가 팬케이크 요리사!
은주는 팬케이크를 만들기로 했다. 은주 앞에는 지금 재료들이 있다. 이 재료들을 보고 있자니, 팬케이크를 최대 몇 개나 만들 수 있을지 궁금해졌다.
팬케이크를 만들기 위해서는 먼저 반죽을 해야 한다. 우유 8컵, 계란 노른자 8개, 설탕 4스푼, 소금 1스푼, 밀가루 9컵이 있으면 팬케이크 반죽 16개를 만들 수 있다. 어떤 0 이상의 실수 x에 대해 모든 재료가 앞에 주어진 양의 x배 이상 있다면 은주는 ⌊16x⌋개의 반죽을 만들 수 있다.
그 다음 반죽에 토핑을 얹고 구우면 팬케이크가 만들어진다. 은주가 만들 수 있는 팬케이크의 종류와 각각에 필요한 토핑의 목록은 다음과 같다.

바나나 팬케이크: 바나나 1개
딸기 팬케이크: 딸기잼 30그램
초콜릿 팬케이크: 초콜릿 스프레드 25그램
호두 팬케이크: 호두 10개

바나나는 여러 조각으로 나누거나 여러 조각을 합쳐서 사용할 수 있다. 예를 들어 1/3 크기의 바나나 조각이 3개 있으면 하나로 합쳐서 바나나 팬케이크를 만들 수 있다.
은주가 가지고 있는 재료들의 양이 주어졌을 때, 만들 수 있는 팬케이크의 최대 개수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 테스트 케이스의 개수가 주어진다. 각 테스트 케이스는 빈 줄로 구분되며, 두 줄로 이루어져 있다.
테스트케이스의 첫째 줄에는 5개의 정수가 있다. 처음부터 차례대로 cm, y, ssu, ssa, f이다. 은주는 우유 cm컵, 계란 노른자 y개, 설탕 ssu스푼, 소금 ssa스푼, 밀가루 f컵을 가지고 있는 것이다.
두 번째 줄에는 4개의 정수가 있다. 이 수는 b, gs, gc, w이다. 은주는 바나나 b개, 딸기잼 gs그램, 초콜릿 gc그램, 호두 w개가 있다.
주어지는 모든 양은 0보다 크거나 같고, 106보다 작거나 같다.
<출력값>
각 테스트 케이스에 대해 한 줄에 하나의 정수를 출력한다. 이 정수는 은주가 만들 수 있는 팬케이크의 최대 개수이다.

<문제 2521>
오늘은 내가 팬케이크 요리사!
은주는 팬케이크를 만들기로 했다. 은주 앞에는 지금 재료들이 있다. 이 재료들을 보고 있자니, 팬케이크를 최대 몇 개나 만들 수 있을지 궁금해졌다.
팬케이크를 만들기 위해서는 먼저 반죽을 해야 한다. 우유 8컵, 계란 노른자 8개, 설탕 4스푼, 소금 1스푼, 밀가루 9컵이 있으면 팬케이크 반죽 16개를 만들 수 있다. 어떤 0 이상의 실수 x에 대해 모든 재료가 앞에 주어진 양의 x배 이상 있다면 은주는 ⌊16x⌋개의 반죽을 만들 수 있다.
그 다음 반죽에 토핑을 얹고 구우면 팬케이크가 만들어진다. 은주가 만들 수 있는 팬케이크의 종류와 각각에 필요한 토핑의 목록은 다음과 같다.

바나나 팬케이크: 바나나 1개
딸기 팬케이크: 딸기잼 30그램
초콜릿 팬케이크: 초콜릿 스프레드 25그램
호두 팬케이크: 호두 10개
초콜릿 듬뿍 바나나 팬케이크: 바나나 3/4개, 초콜릿 스프레드 10그램
초콜릿 가득 호두 팬케이크: 초콜릿 스프레드 10그램, 호두 7개
섞어 섞어 팬케이크: 바나나 1/3개, 딸기잼 5그램, 초콜릿 스프레드 5그램, 호두 3개

바나나는 여러 조각으로 나누거나 여러 조각을 합쳐서 사용할 수 있다. 예를 들어 1/3 크기의 바나나 조각이 3개 있으면 하나로 합쳐서 바나나 팬케이크를 만들 수 있다.
은주가 가지고 있는 재료들의 양이 주어졌을 때, 만들 수 있는 팬케이크의 최대 개수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 테스트 케이스의 개수가 주어진다. 각 테스트 케이스는 빈 줄로 구분되며, 두 줄로 이루어져 있다.
테스트케이스의 첫째 줄에는 5개의 정수가 있다. 처음부터 차례대로 cm, y, ssu, ssa, f이다. 은주는 우유 cm컵, 계란 노른자 y개, 설탕 ssu스푼, 소금 ssa스푼, 밀가루 f컵을 가지고 있는 것이다.
두 번째 줄에는 4개의 정수가 있다. 이 수는 b, gs, gc, w이다. 은주는 바나나 b개, 딸기잼 gs그램, 초콜릿 gc그램, 호두 w개가 있다.
주어지는 모든 양은 0보다 크거나 같고, 106보다 작거나 같다.
<출력값>
각 테스트 케이스에 대해 한 줄에 하나의 정수를 출력한다. 이 정수는 은주가 만들 수 있는 팬케이크의 최대 개수이다.

<문제 2522>
예제를 보고 규칙을 유추한 뒤에 별을 찍어 보세요.
<입력값>
첫째 줄에 N(1 ≤ N ≤ 100)이 주어진다.
<출력값>
첫째 줄부터 2×N-1번째 줄까지 차례대로 별을 출력한다.

<문제 2523>
예제를 보고 규칙을 유추한 뒤에 별을 찍어 보세요.
<입력값>
첫째 줄에 N(1 ≤ N ≤ 100)이 주어진다.
<출력값>
첫째 줄부터 2×N-1번째 줄까지 차례대로 별을 출력한다.

<문제 2524>
뉴욕은 미국의 북동부, 뉴욕 주의 남쪽 끝에 있는 도시이다. 이곳은 미국에서 가장 인구가 많은 도시로, 세계에서 가장 인구가 많은 대도시 중 하나이다. 뉴욕은 세계적인 대도시로, 상업, 금융, 미디어, 예술, 패션, 연구, 기술, 교육, 엔터테인먼트 등 많은 분야에 걸쳐 큰 영향을 미친다. 또한 뉴욕에는 유엔 본부가 위치하고 있어 국제 외교에 있어 중요한 중심지이며, 세계의 문화 수도로 불리기도 한다.
뉴욕 항은 세계에서 가장 큰 자연적 항구 중 한 곳이며, 뉴욕은 맨해튼, 브루클린, 퀸스, 브롱크스, 스태튼아일랜드와 같은 다섯 개의 자치구로 나눠져있다. 이 자치구들은 각각 독립되어 있었다가 1898년 뉴욕에 합병되었다. 뉴욕의 인구는 2011년을 기준으로 8,244,910만 명으로 305 평방 마일 (790㎢)에 걸쳐 분산되어있다. 뉴욕은 미국에서 인구 밀도가 가장 높은 주요한 도시이다. 뉴욕은 800개 넘는 언어가 사용되는데, 세계에서 가장 다양한 언어가 공존하는 도시이다. 뉴욕 대도시권에는 6,720 평방 마일(17,400㎢)에 걸쳐 1,890만 명의 인구가 살고있다.
뉴욕은 1624년 네덜란드 공화국의 이주민들이 무역항으로서 설립했고, 1626년 네덜란드인들이 뉴 암스테르담이라는 지명을 붙였다. 1664년에는 영국인들이 강제 점령해 도시와 그 주변 지역을 통치했고, 찰스 2세가 동생 요크공에게 땅을 주면서 뉴욕이라 부르기 시작했다. 뉴욕은 1789년부터 1791년까지 미국의 공식적인 수도였다. 1790년부터는 미국에서 가장 큰 도시로 성장했다. 이후 19세기 말부터 20세기 초까지 수 백만의 이민자들이 배를 타고 뉴욕으로 왔다. 그리고 민주주의는 미국의 상징으로 세계적 인정을 받았다.
뉴욕에는 5번 애버뉴를 포함한 거리, 자유의 여신상을 포함한 랜드마크가 많이 있으며, 연간 5천만명의 관광객이 방문한다. 타임스 스퀘어는 세계의 교차로라고 불리며, 브로드웨이 연극이 상연된다. 또한, 뉴욕은 엔터테인먼트 산업의 중심지이다. 엠파이어 스테이트 빌딩을 포함한 초고층 건물, 센트럴 파크를 포함한 공원, 다리도 많이 있다. 로어맨해튼에는 월 스트리트가 있어, 경제 수도로도 불린다. 그리고, 월 스트리트에는 뉴욕 증권거래소도 위치하고 있다. 맨해튼의 부동산 시장은 세계에서 가장 비싸다. 뉴욕 지하철은 세계 최대의 지하철망이며, 컬럼비아 대학교, 뉴욕 대학교를 포함한 수많은 대학교도 뉴욕에 위치하고 있다. 뉴욕 양키스는 뉴욕의 메이저 리그 야구 팀으로, 뉴욕의 상징으로도 볼 수 있다.
뉴욕은 잠들지 않는 도시, 빅 애플, 고섬 등의 애칭이 있다. 2012년, 싱크탱크가 발표한 사업, 인재, 문화, 정치 등을 대상으로 한 종합적인 세계 도시 순위에서 세계 1위의 도시로 평가되었다. (출처: 위키백과)
이 곳이 바로 희원이가 사는 곳이다.
희원이는 뉴욕의 맨해튼에 살고 있다. 
맨해튼(Manhattan)은 뉴욕의 자치구 중 가장 인구 밀도가 높은 자치구로, 허드슨 강에 있는 섬을 포함하여 본토의 몇 블록을 포함하는 지역을 가리킨다. 맨해튼은 뉴욕 군(New York County)과 동일한 영토로, 뉴욕 주의 군이 된다. 자치구와 군으로 구성된 맨해튼 섬(Manhattan Island)은 루스벨트 섬, 랜들스아일랜드, 워즈 섬, 거버너스 섬, 리버티 섬, 밀 록, 엘리스 섬과 같은 작은 섬들을 포함하고 있다. 브롱크스와 밀접해있는 지역인 마블힐까지 포함한다.
뉴욕 군은 미국에서 가장 인구 밀도가 높은 군이며, 세계에서도 가장 인구 밀도가 높은 지역이다. 2010년 인구조사에 의하면, 인구는 1,585,873명이다. 또한, 미국의 군 중 가장 부유한 군으로, 2005년 기준으로 1인당 소득은 100,000달러를 넘었다. 맨해튼은 뉴욕의 자치구 중에서 3번째로 인구가 많으며, 면적으로는 제일 작다.
맨해튼은 미국에서 상업적, 재정적, 문화적으로 중요한 장소이다. 로어맨해튼에는 뉴욕 증권거래소와 NASDAQ이 있는 월 스트리트가 있다. 뉴스, 잡지, 책과 같은 여러 대중 매체의 출판업자들뿐만 아니라 미국에 있는 대부분의 주요한 라디오, 텔레비전, 통신 회사들이 이곳에 기반을 두고 있다.
맨해튼에는 유명한 랜드마크, 관광지, 박물관, 대학교가 많다. 또한 국제 연합 본부가 있는 곳이다. 맨해튼은 뉴욕과 뉴욕 대도시권의 중심지이며, 비즈니스, 엔터테인먼트 활동의 중심지이기도 하다. 그 결과, 뉴욕의 다른 자치구인 브루클린과 퀸스 지역 주민들은 맨해튼에 여행 가는 것을 종종 "도시로 간다."라고 표현하기도 한다. (출처: 위키백과)
맨해튼은 도시가 직사각형 격자판 모양이다. 그래서 코너 A(Ax,Ay)에서 코너 B(Bx,By)로  갈 때, 가장 짧은 거리는 |Ax-Bx| + |Ay-By| 이다.
하지만, 위와 같은 계산 방법은 브로드웨이를 고려하지 않는다. 브로드웨이는 이런 격자를 비스듬히 가로질러서 가는 큰 도로이다.
브로드웨이는 브로드웨이(영어: Broadway)는 미국 뉴욕 주 슬리피할로에서 시작되어 뉴욕 맨해튼 남쪽 끝까지 이어지는 거리이며, 그 근처 지역을 뜻하는 지역명이다. 브로드웨이에서 제일 번화한 곳은 타임스 스퀘어와 그 부근 지역이다. (출처: 위키백과)
희원이가 현재 있는 곳 A와 가려고하는 곳 B의 좌표와, 브로드웨이의 정보가 주어진다. 이때, A에서 B로 가는 가장 짧은 경로의 길이를 구하는 프로그램을 작성하시오.
맨해튼의 도로는 총 3가지 종류가 있는데, 아래와 같이 표현한다.

모든 정수 Z에 대해서, avenue는 x = Z로 표현한다.
모든 정수 Z에 대해서, street는 y = Z로 표현한다.
브로드웨이는 방정식 Px+Qy = R로 표현한다.

  A에서 B로 갈 때, 도로가 교차하는 지점에서만 도로를 바꿀 수 있다.
<입력값>
처음 4개의 숫자는 Ax, Ay, Bx, By이다. (A=(Ax,Ay), B=(Bx,By)
다음 3개 숫자 P, Q, R은 위에서 설명한 브로드웨이를 나타내는 방정식이다.
<출력값>
A에서 B로 가는 가장 짧은 길이를 출력한다. 절대/상대 오차는 10-9까지 허용한다.

<문제 2525>
KOI 전자에서는 건강에 좋고 맛있는 훈제오리구이 요리를 간편하게 만드는 인공지능 오븐을 개발하려고 한다. 인공지능 오븐을 사용하는 방법은 적당한 양의 오리 훈제 재료를 인공지능 오븐에 넣으면 된다. 그러면 인공지능 오븐은 오븐구이가 끝나는 시간을 분 단위로 자동적으로 계산한다. 
또한, KOI 전자의 인공지능 오븐 앞면에는 사용자에게 훈제오리구이 요리가 끝나는 시각을 알려 주는 디지털 시계가 있다. 
훈제오리구이를 시작하는 시각과 오븐구이를 하는 데 필요한 시간이 분단위로 주어졌을 때, 오븐구이가 끝나는 시각을 계산하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 현재 시각이 나온다. 현재 시각은 시 A (0<=A<=23) 와 분 B (0<=B<=59)가 정수로 빈칸을 사이에 두고 순서대로 주어진다. 두 번째 줄에는 요리하는 데 필요한 시간 C (0<=C<=1,000)가 분 단위로 주어진다.
<출력값>
첫째 줄에 종료되는 시각의 시와 분을 공백을 사이에 두고 출력한다. (단, 시는 0부터 23까지의 정수, 분은 0부터 59까지의 정수이다. 디지털 시계는 23시 59분에서 1분이 지나면 0시 0분이 된다.)

<문제 2526>
두 자연수 N과 P를 가지고  다음 과정을 거쳐서 나오는 숫자들을 차례대로 출력해보자. 처음 출력하는 숫자는 N이고, 두 번째 이후 출력하는  숫자들은 N을 곱하고 P로 나눈 나머지를 구하는 과정을 반복하여 구한다. 즉, 먼저 N에 N을 곱하고, 이 수를 P로 나눈 나머지를 두 번째에 출력한다. 다음에는 이 나머지에 N을 곱하고 P로 나눈 나머지를 출력한다. 다음에는 이 나머지에 N을 곱한 후 P로 나눈 나머지를 출력한다. 이 과정을 계속 반복해보면 출력되는 숫자들에는 반복되는 부분이 있다. 

	예를 들어서, N=67, P=31인 경우를 생각해보자. 처음 출력되는 숫자는 67이고, 두 번째로 출력되는 숫자는 67*67 = 4489를 31로 나눈 나머지 25이다. 다음에는 25*67 = 1675를 31로 나눈 나머지 1, 다음에는 1*67 = 67을 31로 나눈 나머지 5가 차례대로 출력된다. 다음에는 5*67 = 335를 31로 나눈 나머지 25가 출력되는데, 이 수는 이미 이전에 출력된 수이다. 이 과정을 그림으로 보이면 다음과 같다.


즉 이 과정을 반복하면, 처음 67을 제외하면 3개의 숫자 25, 1, 5가 계속 무한히 반복되게 된다.   또 다른 예로, N=9, P=3을 가지고 시작하면, 9*9 = 81이고 3으로 나눈 나머지는 0이며, 0*3 = 0이고 3으로 나눈 나머지도 0이기 때문에 처음 9를 제외하면 0이 무한히 반복되게 된다. 

	N과 P를 입력받아 위와 같이 정의된 연산을 수행하였을 때,  반복되는 부분에 포함된 서로 다른 숫자의 개수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 처음 시작하는  N과 P가 공백을 사이에 두고 주어진다. 단, 1<=N<=1,000, 2<=P<=97이다.
<출력값>
첫째 줄에 반복되는 부분에 포함된 서로 다른 숫자의 개수를 출력한다.

<문제 2527>
x2차원 격자공간에 두 개의 꼭짓점 좌표로 표현되는 직사각형이 있다. 직사각형은 아래와 같이 왼쪽 아래 꼭짓점 좌표 (x, y)와 오른쪽 위 꼭짓점 좌표 (p, q)로  주어진다.  


이 문제에서 모든 직사각형은 두 꼭짓점의 좌표를 나타내는 4개의 정수 x y p q 로 표현된다. 단 항상 x<p, y<q 이다. 예를 들어 위 그림에 제시된 직사각형이라면 아래와 같이 표현된다.

             3 2 9 8
두 개의 직사각형은 그 겹치는 부분의 특성에 따라 다음 4가지 경우로 분류될 수 있다. 
먼저 두 직사각형의 겹치는 부분이 직사각형인 경우이다. 아래 그림(a)는 공통부분이 직사각형인 경우의 3가지 예를 보여준다,    


또는 겹치는 부분이 아래 그림 (b)와 같이 선분이 될 수도 있고, 그림 (c)와 같이 점도 될 수 있다.   

마지막으로 아래 그림 (d)와 같이 공통부분 없이 두 직사각형이 완전히 분리된 경우도 있다.


여러분은 두 직사각형의 겹치는 부분이 직사각형인지, 선분인지, 점인지, 아니면 전혀 없는 지를 판별해서 해당되는 코드 문자를 출력해야 한다.
<입력값>
4개의 줄로 이루어져 있다. 각 줄에는  8개의 정수가 하나의 공백을 두고 나타나는데, 첫 4개의 정수는 첫 번째 직사각형을, 나머지 4개의 정수는 두 번째 직사각형을 각각 나타낸다. 단 입력 직사각형의 좌표 값은 1이상 50,000 이하의 정수로 제한된다.
<출력값>
4개의 각 줄에 주어진 두 직사각형의 공통부분을 조사해서 해당하는 코드 문자를 출력파일의 첫 4개의 줄에 각각 차례대로 출력해야 한다.

<문제 2528>
여러 층으로 이루어진 직사각형 모양의 건물이 있다. 아래 그림 1은 5개의 층으로 이루어진 직사각형 건물의 예이다. 각 층에는 하나의 막대기가 있는데, 각 막대기의 길이는 서로 다를 수 있다. 그리고 막대기들은 시간 0에서 시작해서 동시에 왼쪽에서 오른쪽으로 혹은 오른쪽에서 왼쪽으로 움직인다. 시간은 정수시간 단위(0, 1, 2, ...)로 흐르고, 모든 막대기들은 단위시간당 길이 1만큼 움직인다. 
아래 그림 1에서처럼 초기(시간 0)에 각 막대기는 직사각형의 왼쪽 변 또는 오른쪽 변에 닿아있다. 시간이 지남에 따라 각 막대기는 주어진 방향으로 움직이고 막대기의 양쪽 끝 중에 하나가 직사각형의 왼쪽 변 또는 오른쪽 변에 닿으면 진행하는 방향과 반대 방향으로 계속해서 움직인다. 

철수(그림 1의 검정색 원)는 초기에 가장 아래층막대기 위에 위치하고 있다. 그리고 아래 조건 1)을 만족하면서 현재 막대기 위에서 움직일 수 있고, 조건 2)를 만족한다면, 하나 위층의 막대기로 올라 갈 수 있다. 
조건 1) 현재 위치하고 있는 막대기 위에서는 0시간에 움직일 수 있다. (즉, 막대기 위에서의 움직임은 시간이 걸리지 않는다.)
조건 2) 철수가 현재 위치하고 있는 막대기의 임의의 위치에서 수직으로 이동 했을 때, 바로 위 층의 막대기 구간 안에 있으면(구간의 양쪽 끝 포함) 0시간에 바로 위 층의 막대기로 수직으로 올라갈 수 있다. (즉, 이 조건을 만족해서 하나 위층으로 올라 갈 수 있다면, 올라가는 움직임은 시간이 걸리지 않는다.)
예를 들어서, 아래 그림 2에서처럼 철수는 시간 2에 두 번째 층을 지나 세 번째 층의 막대기로 움직일 수 있다. 그리고 그림 3에서처럼 시간 4에 네 번째 층을 지나 다섯 번째 층의 막대기에 도달할 수 있다. 

시간 0의 초기 상태에서 출발해서 철수가 가장 아래층의 막대기에서 가장 위층의 막대기로 올라가는데 걸리는 최소 시간을 구하는 프로그램을 작성하시오.
<입력값>
첫 번째 줄에 층 수 N (1<=N<=3,000)과 층의 길이 L (1<=L<=3,000, L은 짝수)이 주어진다. 가장 아래층은 1층이고 가장 위층은 N층이다.  다음 N개의 줄 중 i번째 줄에는 i층의 막대기의 길이  l (1<=l<=L, l은 짝수)과 초기에 막대기가 움직이는 방향 d (d=0,1)가 주어진다. 여기서, d의 값 0은 왼쪽에서 오른쪽, 1은 오른쪽에서 왼쪽을 의미한다. 또한 초기에 막대기들은 방향이 0인 경우 층의 왼쪽 벽에, 1인 경우 층의 오른쪽 벽에 닿아 있다고 가정한다.
<출력값>
첫째 줄에 철수가 가장 아래층 막대기에서 가장 위층 막대기로 올라가는데 걸리는 최소 시간을 하나의 정수로 출력한다.

<문제 2529>
두 종류의 부등호 기호 ‘<’와 ‘>’가 k개 나열된 순서열  A가 있다. 우리는 이 부등호 기호 앞뒤에 서로 다른 한 자릿수 숫자를 넣어서 모든 부등호 관계를 만족시키려고 한다. 예를 들어, 제시된 부등호 순서열 A가 다음과 같다고 하자. 
A =>  < < < > < < > < >
부등호 기호 앞뒤에 넣을 수 있는 숫자는 0부터 9까지의 정수이며 선택된 숫자는 모두 달라야 한다. 아래는 부등호 순서열 A를 만족시키는 한 예이다. 
3 < 4 < 5 < 6 > 1 < 2 < 8 > 7 < 9 > 0
이 상황에서 부등호 기호를 제거한 뒤, 숫자를 모두 붙이면 하나의 수를 만들 수 있는데 이 수를 주어진 부등호 관계를 만족시키는 정수라고 한다. 그런데 주어진 부등호 관계를 만족하는 정수는 하나 이상 존재한다. 예를 들어 3456128790 뿐만 아니라 5689023174도 아래와 같이 부등호 관계 A를 만족시킨다. 
5 < 6 < 8 < 9 > 0 < 2 < 3 > 1 < 7 > 4
여러분은 제시된 k개의 부등호 순서를 만족하는 (k+1)자리의 정수 중에서 최댓값과 최솟값을 찾아야 한다. 앞서 설명한 대로 각 부등호의 앞뒤에 들어가는 숫자는 { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }중에서 선택해야 하며 선택된 숫자는 모두 달라야 한다.
<입력값>
첫 줄에 부등호 문자의 개수를 나타내는 정수 k가 주어진다. 그 다음 줄에는 k개의 부등호 기호가 하나의 공백을 두고 한 줄에 모두 제시된다. k의 범위는 2 ≤ k ≤ 9 이다.
<출력값>
여러분은 제시된 부등호 관계를 만족하는 k+1 자리의 최대, 최소 정수를 첫째 줄과 둘째 줄에 각각 출력해야 한다. 단 아래 예(1)과 같이 첫 자리가 0인 경우도 정수에 포함되어야 한다. 모든 입력에 답은 항상 존재하며 출력 정수는 하나의 문자열이 되도록 해야 한다.

<문제 2530>
KOI 전자에서는 건강에 좋고 맛있는 훈제오리구이 요리를 간편하게 만드는 인공지능 오븐을 개발하려고 한다. 인공지능 오븐을 사용하는 방법은 적당한 양의 오리 훈제 재료를 인공지능 오븐에 넣으면 된다. 그러면 인공지능 오븐은 오븐구이가 끝나는 시간을 초 단위로 자동적으로 계산한다. 
또한, KOI 전자의 인공지능 오븐 앞면에는 사용자에게 훈제오리구이 요리가 끝나는 시각을 알려 주는 디지털 시계가 있다.  
훈제오리구이를 시작하는 시각과 오븐구이를 하는 데 필요한 시간이 초 단위로 주어졌을 때, 오븐구이가 끝나는 시각을 계산하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 현재 시각이 나온다. 현재 시각은 시 A (0 ≤ A ≤ 23), 분 B (0 ≤ B ≤ 59)와 초 C (0 ≤ C ≤ 59)가 정수로 빈칸을 사이에 두고 순서대로 주어진다. 두 번째 줄에는 요리하는 데 필요한 시간 D (0 ≤ D ≤ 500,000)가 초 단위로 주어진다.
<출력값>
첫째 줄에 종료되는 시각의 시, 분, 초을 공백을 사이에 두고 출력한다. (단, 시는 0부터 23까지의 정수이며, 분, 초는 0부터 59까지의 정수이다. 디지털 시계는 23시 59분 59초에서 1초가 지나면 0시 0분 0초가 된다.)

<문제 2531>
회전 초밥 음식점에는 회전하는 벨트 위에 여러 가지 종류의 초밥이 접시에 담겨 놓여 있고, 손님은 이 중에서 자기가 좋아하는 초밥을 골라서 먹는다. 초밥의 종류를 번호로 표현할 때, 다음 그림은 회전 초밥 음식점의 벨트 상태의 예를 보여주고 있다. 벨트 위에는 같은 종류의 초밥이 둘 이상 있을 수 있다. 

새로 문을 연 회전 초밥 음식점이 불경기로 영업이 어려워서, 다음과 같이 두 가지 행사를 통해서 매상을 올리고자 한다.

원래 회전 초밥은 손님이 마음대로 초밥을  고르고, 먹은 초밥만큼 식대를 계산하지만, 벨트의 임의의 한 위치부터 k개의 접시를 연속해서 먹을 경우 할인된 정액 가격으로 제공한다. 
각 고객에게 초밥의 종류 하나가 쓰인 쿠폰을 발행하고, 1번 행사에 참가할 경우 이 쿠폰에 적혀진 종류의 초밥 하나를 추가로 무료로 제공한다. 만약 이 번호에 적혀진 초밥이 현재 벨트 위에 없을 경우, 요리사가 새로 만들어 손님에게 제공한다.  

위 할인 행사에 참여하여 가능한 한 다양한 종류의 초밥을 먹으려고 한다. 위 그림의 예를 가지고 생각해보자. k=4이고, 30번 초밥을 쿠폰으로 받았다고 가정하자. 쿠폰을 고려하지 않으면 4가지 다른 초밥을 먹을 수 있는 경우는 (9, 7, 30, 2), (30, 2, 7, 9), (2, 7, 9, 25) 세 가지 경우가 있는데, 30번 초밥을 추가로 쿠폰으로 먹을 수 있으므로 (2, 7, 9, 25)를 고르면 5가지 종류의 초밥을 먹을 수 있다. 
회전 초밥 음식점의 벨트 상태, 메뉴에 있는 초밥의 가짓수, 연속해서 먹는 접시의 개수, 쿠폰 번호가 주어졌을 때, 손님이 먹을 수 있는 초밥 가짓수의 최댓값을 구하는 프로그램을 작성하시오.
<입력값>
첫 번째 줄에는 회전 초밥 벨트에 놓인 접시의 수 N, 초밥의 가짓수 d, 연속해서 먹는 접시의 수 k, 쿠폰 번호 c가 각각 하나의 빈 칸을 사이에 두고 주어진다. 단, 2 ≤ N ≤ 30,000, 2 ≤ d ≤ 3,000, 2 ≤ k ≤ 3,000 (k ≤ N), 1 ≤ c ≤ d이다. 두 번째 줄부터 N개의 줄에는 벨트의 한 위치부터 시작하여 회전 방향을 따라갈 때 초밥의 종류를 나타내는 1 이상 d 이하의 정수가 각 줄마다 하나씩 주어진다.
<출력값>
주어진 회전 초밥 벨트에서 먹을 수 있는 초밥의 가짓수의 최댓값을 하나의 정수로 출력한다.

<문제 2532>
1부터 N까지 번호가 붙여져 있는 N마리 서로 다른 동물이 있다. 모든 동물은 동일한 하나의 수평선 상에서 연속된 구간 내에서 활동한다. 이 구간을 그 동물의 활동영역이라 한다. 동물의 활동영역은 구간의 왼쪽 위치와 오른쪽 위치 쌍으로 나타낸다. 예를 들어, 7마리 동물의 활동영역이 다음 그림과 같다고 하자. 각 동물의 활동 영역은 선분으로 나타내어져 있다. 아래에서 동물 1의 활동영역은 (2, 4), 동물 2의 활동영역은 (6, 10), ..., 동물 7의 활동영역은 (3, 4)이다.

활동영역이 (x1,x2)인 동물 i와 (x3,x4)인 동물 j에 대하여, 다음 세 조건 중 하나를 만족하면 i가 j보다 먹이사슬에서 상위에 있다고 한다. 
조건 1: x1 < x3 이고  x2 > x4
조건 2: x1 = x3 이고 x2 > x4  
조건 3: x1 < x3 이고 x2 = x4 
동물들의 집단에 대하여 다음 조건을 만족하면서 모든 동물들을 나열 할 수 있으면, 이 집단은 먹이사슬 구조를 가진다고 말한다.
조건: 나열된 각 동물은 뒤에 나오는 모든 동물보다 먹이사슬에서 상위에 있다. 
단, 하나의 동물로 이루어진 집단도 먹이사슬 구조를 가진다고 말한다. 먹이사슬 구조를 가지는 동물 집단의 크기는 이 집단에 속하는 동물의 수로 정의한다. 
동물들의 활동영역이 주어질 때, 먹이사슬 구조를 가지는 동물 집단의 최대 크기를 구하는 프로그램을 작성하시오. 
앞의 그림 예에서 먹이사슬 구조를 가지는 동물 집단의 예로 {1}, {2, 4}, {2, 6}, {1, 3}, {1, 3, 7}, ... 등이 있다. 집단 {1, 3, 7}에서  3은 1보다 상위이고 1은 7보다 상위로서 먹이사슬 구조를 가지는 최대 크기의 집단이다. 최대 크기 집단은 하나 이상일 수 있다.
<입력값>
첫 번째 줄에는 동물의 수를 나타내는 N (1<=N<=500,000)이 주어진다. 다음 각 줄에 동물의 번호, 동물의 활동영역의 왼쪽 위치 L, 오른쪽 위치 R이 빈 칸을 사이에 두고 나온다. L, R은 1 이상 1,000,000,000 이하의 양의 정수이다.
<출력값>
먹이사슬 구조를 가지는 최대 집단의 크기를 출력한다.

<문제 2533>
페이스북, 트위터, 카카오톡과 같은 사회망 서비스(SNS)가 널리 사용됨에 따라, 사회망을 통하여 사람들이 어떻게 새로운 아이디어를 받아들이게 되는가를 이해하는 문제가 중요해졌다. 사회망에서 사람들의 친구 관계는 그래프로 표현할 수 있는데,  이 그래프에서 사람은 정점으로 표현되고, 두 정점을 잇는 에지는 두 정점으로 표현되는 두 사람이 서로 친구 관계임을 표현한다. 
예를 들어, 철수와 영희, 철수와 만수, 영희와 순희가 서로 친구 관계라면 이를 표현하는 친구 관계 그래프는 다음과 같다. 

친구 관계 그래프를 이용하면 사회망 서비스에서 어떤 새로운 아이디어가 전파되는 과정을 이해하는데 도움을 줄 수 있다. 어떤 새로운 아이디어를 먼저 받아들인 사람을 얼리 아답터(early adaptor)라고 하는데, 사회망 서비스에 속한 사람들은 얼리 아답터이거나 얼리 아답터가 아니다. 얼리 아답터가 아닌 사람들은 자신의 모든 친구들이 얼리 아답터일 때만 이 아이디어를 받아들인다. 
어떤 아이디어를 사회망 서비스에서 퍼뜨리고자 할 때, 가능한 한 최소의 수의 얼리 아답터를 확보하여 모든 사람이 이 아이디어를 받아들이게 하는  문제는 매우 중요하다. 
일반적인 그래프에서 이 문제를 푸는 것이 매우 어렵다는 것이 알려져 있기 때문에, 친구 관계 그래프가 트리인 경우, 즉 모든 두 정점 사이에 이들을 잇는 경로가 존재하면서 사이클이 존재하지 않는 경우만 고려한다. 
예를 들어, 8명의 사람으로 이루어진 다음 친구 관계 트리를 생각해보자. 2, 3, 4번 노드가 표현하는 사람들이 얼리 아답터라면, 얼리 아답터가 아닌 사람들은 자신의 모든 친구가 얼리 아답터이기 때문에 새로운 아이디어를 받아들인다.

친구 관계 트리가 주어졌을 때, 모든 개인이 새로운 아이디어를 수용하기 위하여 필요한 최소 얼리 어답터의 수를 구하는 프로그램을 작성하시오.
<입력값>
첫 번째 줄에는 친구 관계 트리의 정점 개수 N이 주어진다. 단, 2 <= N <= 1,000,000이며, 각 정점은 1부터 N까지 일련번호로 표현된다. 두 번째 줄부터 N-1개의 줄에는 각 줄마다 친구 관계 트리의 에지 (u, v)를 나타내는 두 정수 u 와 v가 하나의 빈칸을 사이에 두고 주어진다.
<출력값>
주어진 친구 관계 그래프에서 아이디어를 전파하는데 필요한 얼리 아답터의 최소 수를 하나의 정수로 출력한다.

<문제 2534>
하나의 숫자가 쓰여 있는 카드가 N장이 있다. 쓰여 있는 숫자는 0부터 N-1 사이의 숫자 중 하나이며, 모든 카드의 숫자는 서로 다르다. 
이 카드들 중에서 k개의 카드를 선택하여 배열한 순서를 Ck-1, Ck-2, ..., C0 라고 하자. 이렇게 배열된 k장의 카드가 N진법의 수를 나타낸다고 하면, 카드 Ci는 N진법의 수에서의 한 자리수를 의미하며 그 자릿수의 값은 Ci*Ni이다. 그러므로 배열된 카드의 수의 값은 Ck-1*Nk-1 + Ck-2*Nk-2 + ... + C0*N0이 된다.
배열되는 카드들 사이에는 Ci > Cj 형태의 제약조건이 주어진다. 제약조건  Ci > Cj는  Ci 숫자가  Cj 숫자보다 커야함을 의미한다. 단, i != j.
예를 들어, N=4, K=3인 경우에 C2 > C0, C0 > C1의 제약조건이 주어졌다고 하자. 이 경우 가능한 카드의 배열은 (2, 0, 1), (3, 1, 2), (3, 0, 1), 그리고 (3, 0, 2) 네 가지 경우가 있다. 
이 네 개의 경우들 중에서 가장 큰 수가 되는 카드의 배열은 (3, 1, 2)이고 이 수의 값은 3*42 + 1*41 + 2 = 54 이다. 또한, 가장 작은 수가 되는 카드 배열은 (2, 0, 1)이고 이 수의 값은 2*42 + 0*41 + 1 = 33이다.
전체 카드의 수와 선택할 카드의 수 그리고 제약조건들이 주어질 때, 제약조건을 만족하는 카드배열 중에서 가장 큰 값을 갖는 카드배열과 가장 작은 값을 갖는 카드배열을 찾아서 그 값의 차이를 구하는 프로그램을 작성하시오.
<입력값>
첫 번째 줄에는 전체 카드의 수를 나타내는 N과 선택하는 카드의 수 k와 제약조건의 수 P가 하나의 빈칸을 사이에 두고 주어진다. 단, 3<=k<=N<=300,000, 0<=P<=1,000,000이다. 두 번째 줄부터 P개의 줄에는 각 줄마다 하나의 제약조건을 나타내는 두 개의 정수 a, b가 하나의 빈칸을 사이에 두고 주어진다. 이는 제약조건 Ca > Cb를 의미한다.
<출력값>
제약조건을 만족하는 카드배열 중에서 가장 큰 값을 갖는 카드배열과 가장 작은 값을 갖는 카드배열을 찾고, 그 값의 차이를 1,000,000,007로 나눈 나머지를 출력한다. 단, 제약조건을 만족하는 카드의 배열이 존재하지 않는 경우는 없다.

<문제 2535>
최근 아시아 지역의 학생들만 참여하는 정보 올림피아드 대회가 만들어졌다. 이 대회는 온라인으로 치러지기 때문에 각 나라에서 이 대회에 참여하는 학생 수의 제한은 없다. 
참여한 학생들의 성적순서대로 세 명에게만 금, 은, 동메달을 수여한다. 단, 동점자는 없다고 가정한다. 그리고 나라별 메달 수는 최대 두 개다.
예를 들어, 대회 결과가 다음의 표와 같이 주어졌다고 하자.

이 경우, 금메달 수상자는 1번 국가의 1번 학생이고, 은메달 수상자는 1번 국가의 2번 학생이며, 동메달 수상자는 3번 국가의 4번 학생이다. (1번 국가의 3번 학생의 성적이 동메달 수여자보다 높지만, 나라 별 메달 수가 두 개 이하 이므로 1번 국가 3번 학생은 동메달을 받을 수 없다.)
대회 결과가 입력으로 주어질 때, 메달 수상자를 결정하여 출력하는 프로그램을 작성하시오.
<입력값>
첫 번째 줄에는 대회참가 학생 수를 나타내는 N이 주어진다. 단, 3<=N<=100이다. 두 번째 줄부터 N개의 줄에는 각 줄마다 한 학생의 소속 국가 번호, 학생 번호, 그리고 성적이 하나의 빈칸을 사이에 두고 주어진다. 단, 국가 번호는 1부터 순서대로 하나의 정수로 주어지며, 각 학생번호는 각 나라별로 1부터 순서대로 하나의 정수로 주어진다, 점수는 0 이상 1000 이하의 정수이고, 동점자는 없다고 가정한다. 입력으로 제공되는 국가는 적어도 두 나라 이상이다.
<출력값>
메달을 받는 학생들을 금, 은, 동메달 순서대로 한 줄에 한 명씩 출력한다. 즉, 첫 번째 줄에는 금메달 수상자를, 두 번째 줄에는 은메달 수상자를, 세 번째 줄에는 동메달 수상자를 출력한다. 하나의 줄에는 소속국가 번호와 학생 번호를 하나의 빈칸을 사이에 두고 출력한다.

<문제 2536>
2차원 평면상에 m개의 수직선과 n개의 수평선으로 이루어진 격자 형태의 도로망이 있다. 아래 그림은 7개의 수직선과 6개의 수평선으로 이루어진 도로망의 예이다.  


수직선과 수평선이 만나는 교차점들 중 가장 왼쪽 아래 점의 위치는 (1,1)이고, 가장 오른쪽 위 점의 좌표는 (m,n)이다. 이 도로망을 운행하는 버스들이 k개 있고, 각  버스는 하나의 수평선 상의 두 교차점 사이 선분이나 하나의 수직선 상의 두 교차점 사이 선분을 왕복 운행한다. 각 버스는 운행하는 선분 사이의 모든 교차점(선분의 양 끝 교차점 포함)에서 정차한다. 
출발지 교차점과 목적지 교차점 (출발지와 목적지는 다름)이 주어질 때, 출발지에서 목적지로 버스만을 이용하여 가려고 한다. 이용하는 버스의 최소 수를 구하는 프로그램을 작성하시오.  
예를 들어,  8대의 버스가 다음과 같이 운행한다고 하자.

	1번 버스: (2, 1) - (2, 2)

	2번 버스: (1, 1) - (5, 1)

	3번 버스: (3, 2) - (6, 2)

	4번 버스: (5, 6) - (5, 1)

	5번 버스: (1, 5) - (7, 5)

	6번 버스: (7, 3) - (7, 6)  

	7번 버스: (2, 1) - (2, 6) 

	8번 버스: (3, 5) - (6, 5)
출발지가 (2, 1)이고 목적지가 (7, 4)라 하자. 한 가지 방법으로, 처음에 2번 버스를 타고 교차점 (5, 1)에서 내려, 4번 버스를 타고 (5, 5)에서 내리고, 5번 버스를 탄 후 (7, 5)에서 내려, 마지막으로 6번 버스를 타서 목적지 (7, 4)에서 내린다. 그러면 이용하는 버스 수는 4이다. 다른 방법으로, 7번 버스를 타고 (2, 5)에서 내려, 5번 버스를 타고 (7, 5)에서 내린 후, 마지막으로 6번 버스를 타서 목적지 (7, 4)에서 내린다. 그러면 이용하는 버스 수는 3이고 이것이 최소이다.
<입력값>
첫 번째 줄에 수직선의 수 m과 수평선의 수 n이 빈칸을 사이에 두고 주어진다 (1 ≤ m,n ≤ 100,000). 두 번째 줄에 버스의 수 k (1 ≤ k ≤ 5,000)가 주어진다. 세 번째 줄부터 k 줄에 걸쳐 각 줄에 버스의 운행구간을 나타내는 5개의 수 b, x1, y1, x2, y2가 빈칸을 사이에 두고 주어진다. 여기서 b (1 ≤ b ≤ k) 는 버스의 번호, (x1,y1) 과 (x2, y2)는 이 버스가 운행하는 양쪽 끝 교차점의 좌표를 나타낸다. 마지막 줄에 출발지와 목적지 좌표를 나타내는 네 개의 수 sx, sy, dx, dy가 빈칸을 사이에 두고 주어진다. 여기서 (sx, sy)는 출발지 좌표이고 (dx, dy)는 목적지 좌표이다.  1 ≤ x1, x2, sx, dx ≤ m이고, 1 ≤ y1, y2, sy, dy ≤ n이다. 
모든 입력에 대하여, 출발지와 목적지는 다르게 주어지며 출발지에서 목적지로 가는 방법은 한 가지 이상 존재한다.
<출력값>
첫째 줄에 이용하는 최소 버스 수를 출력한다.

<문제 2537>
여러 층으로 이루어진 직사각형 모양의 건물이 있다. 아래 그림 1은 5개의 층으로 이루어진 직사각형 건물의 예이다. 각 층에는 하나의 막대기가 있는데, 각 막대기의 길이는 서로 다를 수 있다. 그리고 막대기들은 시간 0에서 시작해서 동시에 각각 일정한 속도로 왼쪽에서 오른쪽으로 혹은 오른쪽에서 왼쪽으로 움직인다. 각 막대기의 움직이는 속도는 양의 정수로 주어진다.  
그림 1에서처럼 초기(시간 0)에 각 막대기는 직사각형의 왼쪽 변 또는 오른쪽 변에 닿아있다. 시간이 지남에 따라 각 막대기는 주어진 방향으로 주어진 속도로 움직이고 막대기의 양쪽 끝 중에 하나가 직사각형의 왼쪽 변 또는 오른쪽 변에 닿으면 진행하는 방향과 반대 방향으로 계속해서 움직인다. 

철수(그림 1의 검정색 원)는 초기에 가장 아래층막대기 위에 위치하고 있다. 그리고 아래 조건 1)을 만족하면서 현재 막대기 위에서 움직일 수 있고, 조건 2)를 만족한다면, 위층에 있는 막대기 중 하나로 올라 갈 수 있다. 
조건 1) 현재 위치하고 있는 막대기 위에서는 0시간에 움직일 수 있다. (즉, 막대기 위에서의 움직임은 시간이 걸리지 않는다.)
조건 2) 주어진 정수 K (1 <= K <= N-1)에 대해서, 철수가 현재 위치하고 있는 막대기 위의 임의의 위치가 현재 층에서 최대 K개 위의 어떤 층의 막대기 구간 안에 있게 되면(구간의 양쪽 끝 포함) 0시간에 그 층의 막대기로 수직으로 올라갈 수 있다. (즉, 이 조건을 만족해서 위 층으로 올라 갈 수 있다면, 올라가는 움직임은 시간이 걸리지 않는다.)
조건 2)의 예로, K=3인 경우에 그림 1에서 철수는 시간 0에 네 번째 층의 막대기로 올라 갈 수 있고 곧바로 가장 위층의 막대기로 올라 갈 수 있다. 따라서 시간 0에 가장 위층에 도달하게 된다. 
시간 0의 초기 상태에서 출발해서 철수가 가장 아래층의 막대기에서 가장 위층의 막대기로 올라가는데 걸리는 최소 시간을 구하는 프로그램을 작성하시오.
<입력값>
첫 번째 줄에 층 수 N(1 ≤ N ≤ 1,000), 층의 길이 L(1 ≤ L ≤ 3,000)과 조건 2)에서 주어진 정수  K(1 ≤ K ≤ N-1)가 주어진다. 가장 아래층은 1층이고 가장 위층은 N층이다. 다음 N개의 줄 중 i번째 줄에는 i층의 막대기의 길이 li(1 ≤ li ≤ L), 초기에 막대기가 움직이는 방향 di(di = 0,1)와 막대기의 움직이는 속도 vi (1 ≤ vi ≤ L)가 주어진다. 여기서, 속도 vi는 정수로 주어지고, di의 값 0은 왼쪽에서 오른쪽, 1은 오른쪽에서 왼쪽을 의미한다. 또한 초기에 막대기들은 방향이 0인 경우 층의 왼쪽 벽에, 1인 경우 층의 오른쪽 벽에 닿아 있다고 가정한다.
<출력값>
첫째 줄에 철수가 가장 아래층 막대기에서 가장 위층 막대기로 올라가는데 걸리는 최소 시간을 출력한다. 절대/상대 오차는 10-5까지 허용한다.

<문제 2538>
1㎝ 간격으로 가로선과 세로선이 그어진 직사각형 모양의 모눈종이 위에 한 개의 다각형이 그려져 있다. 다각형의 모든 변은 모눈종이에 그어진 선 위에 있다. 다각형의 변을 따라 모눈종이에서 다각형을 오려내고 나면 하나 이상의 조각들이 남는다.
모눈종이의 가로 길이, 세로 길이와 다각형 한 개가 주어질 때, 이 다각형을 오려낸 후 남은 조각들의 개수와 둘레가 가장 긴 조각의 둘레 길이를 출력하는 프로그램을 작성하시오.
예를 들어, 다음 그림과 같이 모눈종이에 그려진 다각형을 오려내면, 세 개의 조각이 만들어 진다. 조각 1, 조각 2, 조각 3의 둘레 길이는 각각 36㎝, 14㎝, 30㎝이므로, 가장 둘레가 긴 조각의 둘레 길이는 36㎝이다. 


모눈종이에서 다각형을 오려낸 후 남은 조각에 구멍이 있는 경우, 이 조각의 둘레 길이는 모눈종이의 둘레 길이와 다각형의 둘레 길이의 합이다. 예를 들어, 다음 그림에서 조각의 둘레의 길이는 44㎝이다.


단, 아래 그림과 같이 두 꼭짓점의 위치가 같거나 두 변이 서로 교차하는 경우, 두 변이 일부라도 서로 겹치는 경우는 모두 다각형이 아니다.

모눈종이에 그려진 다각형은 임의의 꼭짓점부터 시작하여 시계반대방향으로 차례로 주어진 꼭짓점들의 위치에 의하여 결정된다. 다각형의 각 꼭짓점의 위치는 모눈종이의 왼쪽 아래 꼭짓점으로부터 오른쪽으로 몇 칸, 위쪽으로 몇 칸 떨어져 있는 지를 나타내는 두 수로 주어진다.
<입력값>
첫째 줄에는 모눈종이의 가로 길이와 세로 길이를 나타내는 자연수가 빈칸을 사이에 두고 주어진다. 가로와 세로의 길이는 모두 200000 이하이다. 둘째 줄에는 오려내고자 하는 다각형의 꼭짓점 개수를 나타내는 500000 이하의 자연수가 주어진다. 셋째 줄부터 마지막 줄까지 다각형의 꼭짓점의 위치가 시계반대방향으로 한 줄에 하나씩 차례대로 주어진다. 다각형 꼭짓점의 위치는 모눈종이의 왼쪽 아래 꼭짓점으로부터 오른쪽으로 몇 칸, 위쪽으로 몇 칸 떨어져 있는 지를 나타내는 두 수가 빈칸을 사이에 두고 차례로 주어진다.
<출력값>
첫째 줄에 다각형을 오려낸 후 남은 조각들의 개수와 이들 중 가장 긴 둘레의 길이를 출력한다. 단 길이의 단위인 ㎝는 출력하지 않는다.

<문제 2539>
수찬이는 선생님을 도와서 교실 벽면을 장식할 모자이크 그림을 그리기로 하였다. 이를 위하여 직사각형 모양의 큰 도화지를 준비하여 교실 벽에 붙이고 1cm 간격으로 가로선과 세로선을 그려서 정사각형 모양의 칸을 만들고, 각 칸마다 같은 색의 물감으로 색칠을 하였다. 그런데 잘못 칠해진 칸이 있음을 발견하게 되었다.
수찬이는 도화지와 색깔이 같은 색종이를 사서 잘못 칠해진 칸에 색종이를 붙이고 다시 그리는 것이 좋겠다고 생각하고 선생님께 상의를 드렸다. 선생님께서는 정해진 장수의 색종이를 사용하여 아래와 같은 조건을 따르면서 잘못 칠해진 칸을 모두 가리되, 가장 작은 색종이의 크기를 구하는 새로운 문제를 내셨다.

사용되는 색종이는 모두 크기가 같고 정사각형 모양이다.
색종이 크기는 한 변의 길이로 나타내며, 원하는 크기의 색종이는 모두 구할 수 있다.
모든 색종이는 반드시 도화지의 밑변에 맞추어 붙인다. 이때 색종이를 겹쳐서 붙일 수 있다.

도화지 위의 행은 다음 그림과 같이 맨 아래에서 위쪽으로 1번부터 순서대로 번호가 매겨져 있고, 열은 왼쪽에서 오른쪽으로 1번부터 번호가 매겨져 있다. 이 그림은 도화지에 가로선과 세로선을 그어서 4개의 행과 14개의 열, 그리고 56개의 칸으로 나눈 모양을 보여준다. 잘못 칠해진 칸은 회색으로 표시되어 있다.  

도화지 위의 칸은 행 번호와 열 번호로 나타낸다. 예를 들어 위 그림에서 가장 왼쪽에 있는 잘못 칠해진 칸 A의 위치는 (2, 1)이다. 위 그림과 같이 도화지에서 잘못 칠해진 칸이 9개 주어지고 색종이 4장을 사용한다면 가장 작은 색종이의 크기는 3cm이다.
도화지의 행의 개수와 열의 개수, 그리고 도화지에 잘못 칠해진 칸들의 위치가 주어질 때, 주어진 장수의 색종이를 사용하여 앞의 세 가지 조건에 따라 모든 잘못 칠해진 칸을 가릴 수 있는 가장 작은 색종이의 크기를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 도화지 위의 행의 개수와 열의 개수를 나타내는 자연수가 빈칸을 사이에 두고 주어진다. 행의 개수와 열의 개수는 모두 1000000 이하이다. 둘째 줄에는 사용할 색종이의 장수를 나타내는 자연수가 주어진다. 사용할 색종이는 100장 이하이다. 셋째 줄에는 도화지에 잘못 칠해진 칸의 개수를 나타내는 자연수가 주어진다. 잘못 칠해진 칸은 1000개 이하이다. 넷째 줄부터 마지막 줄까지 잘못 칠해진 칸의 위치가 한 줄에 하나씩 주어진다. 잘못 칠해진 칸의 위치는 빈칸을 사이에 두고 행 번호가 주어진 다음 열 번호가 주어진다.
<출력값>
첫째 줄에 주어진 장수의 색종이를 사용하여 잘못 칠해진 칸을 모두 가릴 수 있는 가장 작은 색종이의 크기가 몇 cm인지를 나타내는 자연수를 출력한다.

<문제 2540>
네 개의 바구니에 계란이 나뉘어 담겨있다. 우리는 아래의 글상자에 제시된 단위 작업을 통하여 계란을 한 바구니에 모두 옮겨 담고자 한다. 
계란이 하나 이상 들어 있는 두 개의 서로 다른 바구니 A, B를 선택한다. 선택된 각 바구니에서 계란을 하나씩 꺼내서 A, B가 아닌 다른 바구니에 이 두 개의 계란을 담는다. 
예를 들어 바구니에 계란이 세 개, 한 개 담겨있다고 하자. 이 상태는 (3, 1, 0, 0)로 표시된다. 그러면 이 상태에서 아래와 같은 세 번의 단위 작업으로 계란을 한 바구니에 모을 수 있다. 

	(3,1,0,0) → (2,0,2,0) → (1,0,1,2) → (0,0,0,4)
괄호속의 숫자는 각 바구니에 들어있는 계란의 수를 표시한 것이다. 
문제는 가능한 적은 횟수의 단위 작업을 사용하여 모든 계란을 한 곳에 모으는 것이다. 여러분은 입력으로 받은 초기 바구니 상태에서 출발하여 계란이 한 바구니에 모두 담기는 최종상태까지의 중간 단계를 차례대로 출력해야 한다.
<입력값>
첫째 줄에는 채점의 기준이 되는 단위 작업의 사용 횟수 K가 주어진다. 그 다음 줄에는 각 바구니에 들어있는 계란의 수가 공백을 두고 나타난다. 전체 계란의 수는 4개 이상, 3000개 이하이다.
<출력값>
첫 줄에는 초기 바구니의 상태를 입력형식과 동일하게 출력해야 한다. 그 다음 줄부터는 각 단계별 바구니 상태를 하나씩 출력해야 한다. 마지막 줄에는 반드시 한 바구니에 계란이 모두 모인 상태가 출력되어야 한다.

<문제 2541>
좌표 평면에 자연수 좌표를 갖는 점 하나로 구성된 집합 S가 주어진다. S에 속하는 점으로부터 아래의 세 가지 생성규칙 중 하나를 적용하여 새로운 점을 만들고, 그 점을 집합 S에 추가한다. 이 과정을 반복적으로 수행하면, 매번 새로운 점을 집합 S에 계속 추가할 수 있다. 

규칙 1: 점 (x, y)가 S에 속해 있다면,  점 (x+1, y+1)을 S에 추가한다. 
규칙 2: 점 (x, y)가 S에 속해 있고, x와 y가 모두 짝수이면, 점 (x/2, y/2)를 S에 추가한다.
규칙 3: 두 점 (x, y)와 (y, z)가 S에 속해 있다면, 점 (x, z)를 S에 추가한다.

예를 들어, S = {(3, 5)}일 때, 규칙 1을 점 (3, 5)에 적용하여 만들어진 점 (4, 6)을 S에 추가하면, S = {(3, 5), (4, 6)}이 된다. 다시 점 (4, 6)에 규칙 1을 적용하면, S = {(3, 5), (4, 6), (5, 7)}이 된다. 다음에 점 (4, 6)에 규칙 2를 적용하면  S = {(3, 5), (4, 6), (5, 7), (2, 3)}이 된다. 또 두 점 (3, 5)와 (5, 7)에 규칙 3을 적용하면, S = {(3, 5), (4, 6), (5, 7), (2, 3), (3, 7)}이 된다. 
문제는 집합 S를 구성하는 점 (a, b)가 주어질 때, 이 집합에 위의 세 가지 규칙을 임의의 순서로 반복 적용하여 새로운 점 (p, q)가 S에 추가될 수 있는지를 판명하는 것이다.
<입력값>
첫째 줄에는 처음에 S에 속하는 점 (a, b)의 좌표인 두 자연수 a와 b가 하나의 공백을 두고 순서대로 주어진다. 그리고 그 다음 다섯 줄에는 각 줄마다 한 개의 점 (p, q)의 두 자연수 p와 q가 하나의 공백을 두고 순서대로 주어진다. 입력되는 모든 점의 좌표는 1 이상 100,000 이하의 자연수이다.
<출력값>
첫째 줄에는 입력 파일에 제시된 다섯 개의 점에 대하여, 각 점이 세 개의 규칙을 반복 적용하여 만들어질 수 있는지의 여부를 출력한다. 가능하면 Y를, 불가능하면 N을 한 줄에 하나씩 순서대로 출력한다.

<문제 2542>
Ag, Bg, 1g짜리 세 종류의 추가 있다. A와 B는 서로 다른 실수이다. 여러분에게 이 추들을 양팔저울에 올려서 얻은 몇 개의 실험결과가 주어진다. 단 실험결과는 양팔저울이 왼쪽 혹은 오른쪽으로 기울어진 경우만을 포함한다. 
문제는 양팔저울의 왼쪽과 오른쪽에 올려질 추들이 주어진 경우, 양팔저울을 사용하지 않고 주어진 실험결과만을 사용하여 저울이 어느 쪽으로 기울어지는가를 판단하는 것이다. 
예를 들어 양팔 저울을 이용해서 다음 두 개의 실험결과를 얻었다고 하자. 

<결과 1>: [B, B] < [A, A, B, 1, 1]
<결과 2>: [A, A, B, 1, 1] > [A, A, A, 1, 1, 1]

<결과 1>은 왼쪽에 Bg의 추 두 개를 올리고, 오른쪽에 Ag의 추 두 개, Bg의 추 한 개, 1g의 추 두 개를 올린 경우 오른쪽으로 기울어진 결과를  나타낸다. <결과 2>는 왼쪽에 Ag의 추 두 개, Bg의 추 한 개, 1g의 추 두 개를 올리고, 오른쪽에 Ag의 추 세 개와 1g의 추 세 개를 올려서 왼쪽으로 기울어진 결과를 나타낸다.   
주어진 문제가 [A]와 [B, 1]의 무게를 비교하는 경우,  위의 두 개의 실험결과를 이용하면 항상 [A] < [B, 1]인 것을 알 수 있다. 
하지만 어떤 경우에는 주어진 실험결과만으로 판단할 수 없는 경우도 있다. 예를 들어 [A, A] < [B, B, B] 인 실험결과만 주어지고, 문제가 [A]와 [B]의 무게를 비교하는 경우, [A] > [B]일 수도 있고, [A] < [B]도 가능하므로 판단할 수 없다.
<입력값>
첫째 줄에는 주어지는 양팔저울의 실험횟수를 나타내는 정수 K (1 ≤ K ≤ 10)가 입력된다. 그 다음 K개의 줄에는 한 줄에 하나의 실험결과가 입력되며, 양쪽에 놓인 추가 각각 하나의 공백을 두고 입력되고, 그 중간은 > 또는 < 기호로 저울의 균형의 상태를 나타낸다. 각 줄의 끝은 \$로 표시되어 있다.
마지막 다섯 개의 줄에는 여러분이 판단해야하는 문제가 한 줄에 하나씩 입력되며, 양쪽에 놓인 추가 각각 하나씩의 공백을 두고 입력되고, 왼쪽과 오른쪽은 | (세로 바)로 구분된다. 끝은 역시 \$로 표시되어 있다.
양팔 저울의 한 쪽에 올려 놓을 수 있는 추의 개수는 최대 1000개를 넘지 않는다.
<출력값>
다섯 개의 문제에 대한 답을 한 줄에 하나씩 출력하며, 왼쪽이 무거운 경우는 >, 오른쪽이 무거운 경우는 <, 판정할 수 없는 경우는 ?를 출력한다. 단, 저울이 평형인 경우는 없다.

<문제 2543>
최고 속력 600 km/h로 운행하는 것을 목표로 하는 ‘한국형 초고속철도 사업’이 순조롭게 진행되고 있다. 이미 초고속철도의 시험선로를 구축하였고 열차를 시험운행하고 있다. 그리고 선로의 상태를 검사하기 위하여, 선로의 지정된 검사구간을 담당하는 로봇을 설치하였다. 그런데 검사구간이 서로 겹치는 로봇 사이에는 빈번한 데이터 교환이 필요하다. 따라서 이를 지원할 데이터 송수신 장치를 모든 로봇에 설치할 뿐만 아니라, 특별한 데이터 처리장치를 로봇에 부착하기로 하였다. 그러나 이 처리장치는 모든 로봇에 부착하지 않아도 되지만, 두 로봇이 담당하고 있는 검사구간이 서로 겹치면 이 두 로봇 중에서 적어도 하나에는 반드시 부착되어야 한다.
아래 그림과 같은 시험선로에서 네 개의 로봇 a, b, c, d가 있고, 각 로봇의 검사구간은 아래와 같다고 하자. 로봇 a와 b는 담당하는 선로의 검사구간이 겹치므로 둘 중 최소한 하나에 처리장치가 부착되어야 한다. 로봇 b와 c, b와 d, 그리고 c와 d의 경우도 마찬가지이다.

위의 조건을 만족하면서 처리장치를 부착하는 것은 여러 가지 경우가 있을 수 있다. 위 그림의 예에서 {a, b, c, d} 모두에 부착할 수도 있고, {b, c}에 부착할 수도 있다. 우리 팀에서는 어떤 로봇에 처리장치를 부착하는 것이 좋은 지를 연구하고 있는데, 우선 위 조건을 만족하면서 처리장치를 부착할 수 있는 모든 경우의 수를 구하여 보기로 하였다. 위의 예에서 가능한 경우를 모두 나열해보면 {a, b, c, d}, {a, b, c}, {a, b, d}, {a, c, d}, {b, c, d}, {b, d}, {b, c}, 총 일곱 가지 경우가 있다.
시험선로를 눈금이 매겨진 직선으로 나타내며, 로봇의 검사구간은 이 직선 위에 있다고 할 때, 로봇들이 담당하는 선로의 검사구간을 입력 받아 로봇에 처리장치를 부착할 수 있는 모든 경우의 수를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 로봇의 개수 N (1 ≤ N ≤ 100,000)이 입력된다. 둘째 줄부터 N 개의 줄에 한 줄에 하나씩 로봇이 담당하는 검사구간의 왼쪽 끝점의 좌표와 오른쪽 끝점의 좌표가 빈 칸을 사이에 두고 주어진다. 이들 좌표는 모두 0 이상 10,000,000 이하인 정수이다. 각 검사구간의 왼쪽 끝점의 좌표가 오른쪽 끝점의 좌표보다 항상 작다. 또한 검사구간들의 끝점들의 좌표는 모두 서로 다르다. 다시 말하면, 어떤 좌표 값에도 두 개 이상의 검사구간의 끝점이 위치하지 않는다.
<출력값>
첫째 줄에 문제의 조건을 만족하면서 처리장치를 부착할 수 있는 경우의 수를 출력한다. 만약 경우의 수가 20,070,713 이상일 때에는 20,070,713으로 나눈 나머지를 출력한다. 또한 계산 도중 오버플로우가 발생할 수 있음을 유의하라.

<문제 2544>
N개의 행과 M개의 열로 구성된 격자판의 각 칸에 숫자들이 들어있다. 정수 K (K >= 2)가 주어진다. K는 N보다 작고, M보다도 작다. 격자판에서 R개의 행과 C개의 열을 R + C = K가 만족하도록 선택하고, 선택된 행과 열을 제외한 나머지 칸에 있는 숫자들 가운데 가장 큰 숫자가 최소가 되도록 하려고 한다.  N = 4, M = 5인 경우의 격자판의 예가 다음 그림과 같이 주어졌다고 하자.


위의 예에서 K = 3인 경우, 1행, 3행과 4열을 선택하면 다음 그림과 같이 선택된 행과 열을 제외한 나머지 칸에 있는 숫자들 가운데 제일 큰 숫자는 5이다.

3행, 3열과 4열을 선택하여도 선택된 행과 열을 제외한 나머지 칸 가운데 제일 큰 숫자는 5이다.  그러나 달리 선택하여 나머지 칸에 있는 숫자들이 모두 5보다 작게 만들 수는 없다.
숫자들이 들어있는 격자판과 선택할 수 있는 행의 개수와 열의 개수의 합이 주어졌을 때, 선택한 행과 열을 제외한 나머지 칸에 있는 숫자들 가운데 가장 큰 숫자가 최소가 되도록 행과 열을 선택하기 위한 프로그램을 작성하시오.
<입력값>
첫 줄에는 격자판의 크기를 나타내는 정수 N과 M이  주어진다. N과 M은 3 이상이며, 300 이하인 정수이다. 둘째 줄에는 선택할 수 있는 행과 열의 개수의 합 K (K < N, K < M)가 주어진다. 셋째 줄부터 격자판에 들어있는 양의 정수들이 한 줄에 한 행씩 1행부터 차례대로 주어진다. 격자판에 들어있는 각 숫자는 1 이상 500,000 이하의 정수이다. 같은 줄에 입력되는 각 정수들 사이에는 한 개의 공백이 있다.
<출력값>
첫 번째 줄에 R + C = K를 만족하는 R개의 행과 C개의 열을 선택하여, 선택된 행과 열을 제외한 나머지 칸에 있는 숫자들 가운데 가장 큰 숫자의 최솟값을 출력한다. 둘째 줄에는 선택한 행의 개수와 이어서 행 번호를 오름차순으로 출력한다. 셋째 줄에는 선택한 열의 개수와 이어서 열 번호를 오름차순으로 출력한다. 행의 개수나 열의 개수가 0인 경우에는 해당하는 줄에 0만 출력한다. 같은 줄에 출력되는 각 정수들 사이에는 한 개의 공백을 둔다.
조건을 만족하는 답이 여러 개인 경우에는 그 중에서 하나만 출력하면 된다.

<문제 2545>
오늘 아침 은주는 팬케익을 만들었다. 자 이제 신혜는 이 팬케익을 먹으려고 한다.

	은주가 만든 팬케익은 박스 모양이고, 가로 Acm, 세로 Bcm, 높이 Ccm 크기이다.

	신혜는 팬케익을 D번 먹으려고 한다. 매번 신혜가 팬케익을 먹으려고 할 때, 은주는 팬케익을 변에 평행하게 자른 후에 신혜에게 준다.

	은주는 뛰어난 요리사이기 때문에, 자르는 케익은 모두 두께가 1cm이다.

	원래 은주는 팬케익을 다 먹으려고 했으나, 어쩔수 없이 신혜에게 주는 것이다. 따라서, 최대한 많은 양을 남기려고 한다.

	신혜가 팬케익을 D번 먹은 후에 남은 케익의 양은 은주가 케익을 자르는 방법에 따라서 달라지게 된다.

	A, B, C, D가 주어졌을 때, 신헤가 팬케익을 D번 먹은 후에 남은 팬케익 부피의 가능한 최댓값을 구하시오.
<입력값>
첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 빈 줄로 구분되며, 다음과 같이 구성되어 있다.

	테스트 케이스의 첫째 줄에 A, B, C, D가 주어진다. 0 < A,B,C <= 10^18 이고, 0 <= D <= A+B+C-3 이다.
<출력값>
각 테스트 케이스에 대해 은주가 남길 수 있는 팬케익의 최대 부피를 차례대로 한 줄에 하나씩 출력한다. 이 부피는 부호있는 64비트 정수 범위 안에 들어온다.

<문제 2546>
C언어 성적이 나쁜 학생이 C언어를 드랍하고 경제학 원론을 듣는다면, 그 학생은 두 과목 수강생의 평균 IQ를 올려준다.

	이 말은 어떤 학생이 직접 C언어를 드랍하고 경제학 원론을 수강하면서 증명하였다.

	각 학생의 IQ가 주어진다. 이때, C언어 수강생 중에 C언어를 드랍하고 경제학 원론을 수강해서 두 과목의 평균 IQ를 모두 올려줄 수 있는 사람의 수를 구하시오.
<입력값>
첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 빈 줄로 구분되며, 다음과 같이 구성되어 있다. 

	테스트 케이스의 첫째 줄에는 C언어 수강생의 수 N과 경제학 원론 수강생의 수 M이 주어진다. 둘째 줄에는 N+M 개의 숫자가 공백으로 구분되어 주어진다. 

	처음 N개의 숫자는 C언어 수강생의 IQ이며, 다음 M개의 숫자는 경제학 원론 수강생의 IQ이다.

	N과 M은 200,000보다 작거나 같은 자연수이고, N은 2보다 크거나 같다. IQ는 100,000보다 작거나 같은 자연수이다.
<출력값>
각 테스트 케이스의 정답을 한 줄에 하나씩 차례대로 출력한다.

<문제 2547>
사탕 박사 고창영은 사탕 공장을 그만 두고 초등학교 선생님으로 취직했다.

	오늘은 창영이네 반 학생들과 소풍을 가는 날이다. N명의 학생은 모두 가방에 사탕을 가득 담아왔다.

	그런데, 사탕을 많이 가져온 학생들이 사탕을 적게 가져온 학생들을 놀리기 시작했다.

	창영이는 "얘들아~ 그러면 안되지ㅜㅜ 사탕을 모두 여기에 가져와보렴. 선생님이 공평하게 나눠줄게"

	창영이는 모든 학생들이 같은 사탕을 가지게 하려고 한다.

	이것이 가능한 일일까?
<입력값>
첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 빈 줄로 구분되어 있고, 다음과 같이 구성되어 있다.

	테스트 케이스의 첫째 줄에 학생의 수 N이 주어진다. 다음 N개의 줄에는 각 학생들이 가져온 사탕의 수가 주어진다.

	N은 100,000보다 작거나 같은 자연수이고, 사탕의 개수는 0보다 크거나 같은 정수이다. 학생들이 가져온 사탕 개수는 10^18보다 작거나 같다. (학생들이 가져온 사탕 개수의 합은 10^18을 넘어갈 수 있다)
<출력값>
각 테스트 케이스에 대해 모두에게 같은 사탕을 나눠줄 수 있으면 YES를, 없으면 NO를 출력한다.

<문제 2548>
정보초등학교의 연아는 여러 개의 자연수가 주어졌을 때, 이를 대표할 수 있는 대표 자연수에 대하여 연구하였다. 그 결과 어떤 자연수가 다음과 같은 성질을 가지면 대표 자연수로 적당할 것이라고 판단하였다.

	“대표 자연수는 주어진 모든 자연수들에 대하여 그 차이를 계산하여 그 차이들 전체의 합을 최소로 하는 자연수이다.”

	예를 들어 주어진 자연수들이 [4, 3, 2, 2, 9, 10]이라 하자. 이때 대표 자연수는 3 혹은 4가 된다. 왜냐하면 (4와 3의 차이) + (3과 3의 차이) + (2와 3의 차이) + (2와 3의 차이) + (9와 3의 차이) + (10과 3의 차이) = 1+0+1+1+6+7 = 16이고, (4와 4의 차이) + (3과 4의 차이) + (2와 4의 차이) + (2와 4의 차이) + (9와 4의 차이) + (10과 4의 차이) = 0+1+2+2+5+6 = 16으로 같으며, 이 두 경우가 차이들의 합을 최소로 하기 때문이다. 비교를 위하여 평균값인 5의 경우를 생각하여 보면, (4와 5의 차이) + (3과 5의 차이) + (2와 5의 차이) + (2와 5의 차이) + (9와 5의 차이) + (10과 5의 차이) = 1+2+3+3+4+5 = 18로 위의 두 경우보다 차이들의 합이 더 커짐을 볼 수 있다.

	연아를 도와서 위의 성질을 만족하는 대표 자연수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 자연수의 개수 N이 입력된다. N은 1 이상 20,000 이하이다. 둘째 줄에는 N개의 자연수가 빈칸을 사이에 두고 입력되며, 이 수들은 모두 1 이상 10,000 이하이다.
<출력값>
첫째 줄에 대표 자연수를 출력한다. 대표 자연수가 두 개 이상일 경우 그 중 제일 작은 것을 출력한다.

<문제 2549>
4×4 격자판에 1에서 16까지 정수 번호가 매겨진 16개 타일이 임의로 놓여져 있다. 타일을 움직여 그림 1과 같이 타일을 놓이게 하려고 한다.



	그림 1

	타일을 움직이는 방법은 하나의 행(가로줄)을 오른쪽으로 원하는 칸 수만큼 순환적으로 움직이거나, 하나의 열(세로줄)을 원하는 칸 수만큼 아래쪽으로 순환적으로 움직이는 것이다. 그림 2는 그림 1의 2번째 행을 오른쪽으로 2칸 움직인 것이다. 그림 1의 2번째 행의 오른쪽 끝에 있는 7번 타일과 8번 타일이 오른쪽 경계를 넘어가서 왼쪽 끝으로 옮겨갔다.



	그림 2

	그림 3은 그림 2의 3번째 열을 아래쪽으로 1칸 움직인 것이다. 그림 2의 3번째 열의 가장 아래에 있는 15번 타일이 가장 위쪽으로 옮겨갔다.



	그림 3

	그림 3과 같이 타일이 놓여진 격자판이 주어졌다면 3번째 열을 3칸 움직인 다음, 2번째 행을 2칸 움직이면 그림 1과 같이 타일이 놓이게 된다. 따라서 2번 움직이면 된다.

	1에서 16까지 번호가 매겨진 타일이 임의로 놓여져 있을 때 그림 1과 같이 타일이 놓일 수 있도록 타일을 움직이는 순서를 출력하는 프로그램을 작성하시오. 여기서 움직이는 횟수는 최소로 하여야 한다.
<입력값>
4×4 격자판에 놓여진 타일 번호가 행단 위로 4개 줄에 주어진다. 타일 번호는 1부터 16까지의 정수이다.

	각 줄에는 해당하는 행에 놓여지는 4개 타일의 번호가 빈칸을 사이에 두고 순서대로 주어진다.
<출력값>
첫 번째 줄에는 움직이는 횟수를, 두 번째 줄부터는 한 줄에 하나씩 타일을 움직이는 방법을 순서대로 출력한다.

	이때, 격자판의 i번째 행을 k칸 움직였다면 정수 1과 i와 k를 빈칸을 사이에 두고 한 줄에 출력한다. 그리고 격자판의 i번째 열을 k칸 움직였다면 정수 2와 i와 k를 빈칸을 사이에 두고 한 줄에 출력한다. 여기서 i는 1 이상 4 이하, k는 1 이상 3 이하의 정수이다.

<문제 2550>
N개의 스위치와 N개의 전구를 가진 하나의 스위칭 박스가 있다. 이 박스의 왼편에는 스위치가 있고, 오른편에는 전구가 달려있다. 모든 스위치와 전구들은 1에서부터 N까지의 번호를 가지며 같은 번호의 스위치와 전구는 전선으로 서로 연결되어 있다.



	하나의 스위치를 누르면 그 스위치와 연결된 전구에 불이 들어오게 된다. 두 개 이상의 스위치를 같이 누르는 경우, 전선이 서로 만나면 만난 전선에 연결된 전구들의 불은 켜지지 않는다.

	위 그림에서 1번과 4번의 스위치를 같이 누르면 1번과 4번의 전구에는 불이 켜지지만, 1번과 2번의 스위치를 같이 누르면 1번과 2번 전구의 불은 켜지지 않는다. 1번과 3번 그리고 5번 스위치를 같이 누르면 전선이 만나는 1번과 5번 전구는 켜지지 않지만 3번 전구는 켜지게 된다.

	여러분이 할 일은 가장 많은 전구가 켜지도록 스위치를 누르는 것이다. 위 그림에서는 3번과 4번 그리고 5번 스위치를 누르는 경우와 1번과 3번 그리고 4번을 누르는 경우에 세 개의 전구가 켜지게 되고, 이 두 가지 경우가 가장 많은 전구가 켜지는 경우이다.

	스위치의 번호순서와 전구의 번호순서가 주어질 때, 어떤 스위치를 누르면 가장 많은 전구가 켜지는지를 알아내는 프로그램을 작성하시오.
<입력값>
첫 번째 줄에는 스위치의 수(전구의 수)를 나타내는 정수 N (1≤N≤10,000)이 주어진다. 두 번째 줄에는 N개의 스위치 번호들이 위에서부터 순서대로 빈칸을 사이에 두고 주어진다. 세 번째 줄에는 N개의 전구 번호들이 위에서부터 순서대로 빈칸을 사이에 두고 주어진다.
<출력값>
첫 번째 줄에는 가장 많은 전구가 켜지게 하는 스위치의 수를 출력한다. 두 번째 줄에는 눌러야 하는 스위치의 번호를 오름차순(번호가 커지는 순서)으로 빈칸을 사이에 두고 하나의 줄에 출력한다. 단, 두 번째 줄에 출력할 수 있는 답이 두 가지 이상일 때에는 그 중 한 가지만 출력한다.

<문제 2551>
한국정보중학교의 태환은 여러 개의 자연수가 주어졌을 때, 이를 대표할 수 있는 대표 자연수에 대하여 연구하였다. 태환은 다음과 같은 두 가지 아이디어를 제시하였다.
① 주어진 자연수들과의 차이의 합을 가장 작게 하는 자연수를 대표 자연수라고 하자.
예를 들어, 주어진 자연수들 [4, 3, 2, 2, 10, 10]에 대한 대표 자연수는 3 또는 4이다. 왜냐하면 ｜4-3｜+｜3-3｜+ ｜2-3｜+｜2-3｜+｜10-3｜+｜10-3｜= 1 + 0 + 1 + 1 + 7 + 7 = 17이고, ｜4-4｜+｜3-4｜+｜2-4｜+｜2-4｜+｜10-4｜+｜10-4｜ = 0 + 1 + 2 + 2 + 6 + 6 = 17로 같고, 차이의 합을 최소로 하기 때문이다.
비교를 위하여 5를 생각하여 보면, ｜4-5｜+｜3-5｜+｜2-5｜+｜2-5｜+｜10-5｜+｜10-5｜ = 1 + 2 + 3 + 3 + 5 + 5 = 19로 3 또는 4에 대한 차이의 합보다 더 커짐을 알 수 있다.
② 주어진 자연수들과의 차이의 제곱의 합을 가장 작게 하는 자연수를 대표 자연수라고 하자.
이 경우 위에서 주어진 자연수들에 대한 대표 자연수는 5 이다. 왜냐하면 (4-5)2 + (3-5)2 + (2-5)2 + (2-5)2 + (10-5)2 + (10-5)2 = 73이고, 이 값은 차이의 제곱의 합을 최소로 하기 때문이다.
자연수들이 입력되면 아이디어 ①과 ② 각각에 대한 대표 자연수를 구하는 프로그램을 작성하시오. 대표 자연수는 원래 주어진 자연수들에 반드시 포함되어야 하는 것은 아니라는 것에 유의하시오.
<입력값>
첫째 줄에 자연수의 개수 N이 입력된다. N은 1 이상 5,000,000 이하의 수이다. 둘째 줄에 N개의 자연수들이 빈칸을 사이에 두고 입력되며, 이 수들은 모두 1 이상 10,000 이하이다.
<출력값>
첫째 줄에 아이디어 ①에 의한 대표 자연수와 아이디어 ②에 의한 대표 자연수를 빈칸을 사이에 두고 출력한다. 각 아이디어로 구한 대표 자연수가 두 개 이상일 경우 그 중 제일 작은 것을 출력한다.

<문제 2552>
아래 그림과 같이 박스 위쪽에 N개의 스위치, 아래쪽에는 그와 연결된 N개의 전구가 달린 스위칭 박스가 있다. 스위치는 왼쪽부터 1부터 N까지의 정수로 표시되고, 전구는 오른쪽부터 B1, B2, …, BN으로 표시된다.

각 스위치에는 하나의 전구만 연결되어 있고, 스위치를 누르면 연결된 전구에 불이 들어오게 된다. 예를 들어 4번 스위치를 누르면 B1에, 2번 스위치를 누르면 B6에 불이 들어온다.
두 개 이상의 스위치를 같이 누르는 경우, 전선이 서로 만나면 만난 전선에 연결된 전구들의 불은 켜지지 않는다.
예를 들어 위 그림에서 스위치 {2,3,4}를 누르면 전구 B6, B4, B1에 불이 들어오지만 스위치 {1,2}를 같이 누르거나 스위치 {4,5,6}을 같이 누르면 불이 켜지는 전구는 하나도 없다. 그리고 스위치 {1,2,3}을 같이 누르면 B4에만 불이 켜지게 된다. 이렇게 스위치를 조작해서 전구를 켤 때, 켜지는 전구의 값을 1로 표시한다면 전구가 켜진 상태는 N비트의 이진수로 볼 수 있다. 이 이진수를 해당 스위치 박스의 전구숫자라고 부른다.
어떤 스위치 박스의 연결구조가 주어지면 우리는 다양한 전구숫자를 만들어 낼 수 있다. 그러나 어떤 이진수는 전구숫자가 될 수 없다. 예를 들어 위의 그림에서 B6, B5 모두가 1인 전구숫자는 만들어 낼 수 없어 11로 시작하는 이진수는 불가능하다.
주어진 스위치 박스가 생성하는 모든 전구숫자 중에서 K번째의 수를 찾아내는 프로그램을 작성하시오.
앞의 그림에서 제시된 스위치 박스의 경우에 가능한 전구숫자를 오름차순으로 11개까지 나열하면 다음과 같다. 모든 스위치 박스에서 첫 번째인 전구숫자는 어떤 스위치도 누르지 않은 상태인 0000…0이다.

여러분은 입력으로 주어진 숫자 K에 대하여 오름차순으로 K번째 전구숫자를 찾아서 그 값을 십진수로 출력해야 한다. 예를 들어 위의 경우에서 K=6이라면 전구숫자 001000의 십진수 값인 8을 출력해야 한다.
<입력값>
첫 번째 줄에는 스위치의 수(전구의 수)를 나타내는 양의 정수 N (3 ≤ N ≤ 30)이 나타나고 그 다음 줄에는 전구 BN, BN-1, …, B1에 연결된 스위치 번호들이 차례대로 빈칸을 사이에 두고 주어진다. 그리고 마지막 줄에 K(1 ≤ K ≤ 1,000,000,000)가 주어진다.
<출력값>
첫 번째 줄에 해당되는 K번째 전구숫자의 십진수 값을 출력한다. 만일 K가 가능한 전구숫자의 개수보다 커서 해당되는 전구 숫자가 없을 경우에는 -1을 출력한다.

<문제 2553>
N!의 값을 계산한 후에, 0이 아닌 가장 낮은 자리 수를 구하시오.
예를 들어, 4! = 24 이기 때문에, 0이 아닌 가장 낮은 자리 수는 4이다. 또, 5! = 120이기 때문에, 0이 아닌 가장 낮은 자리 수는 2 이다.
<입력값>
첫째 줄에 N이 주어진다. N은 20,000보다 작거나 같은 자연수 이다.
<출력값>
첫째 줄에 N!의 0이 아닌 마지막 자리수를 출력한다.

<문제 2554>
N!의 값을 계산한 후에, 0이 아닌 가장 낮은 자리 수를 구하시오.
예를 들어, 4! = 24 이기 때문에, 0이 아닌 가장 낮은 자리 수는 4이다. 또, 5! = 120이기 때문에, 0이 아닌 가장 낮은 자리 수는 2 이다.
<입력값>
첫째 줄에 N이 주어진다. N은 최대 100자리인 자연수이다.
<출력값>
첫째 줄에 N!의 0이 아닌 마지막 자리수를 출력한다.

<문제 2555>
이 문제를 만든 사람의 생일을 출력하시오.
<입력값>

<출력값>
월/일 형식으로 출력하면 된다. 예를 들어, 7월 4일인 경우에는 7/4, 9월 20일인 경우에는 9/20, 11월 4일인 경우에는 11/4와 같이 출력하면 된다.

<문제 2556>
지금까지 안 나온 별 찍기가 뭐가 있는지 생각해본 후, 별을 적절히 찍으세요.
<입력값>
첫째 줄에 N(1 ≤ N ≤ 100)이 주어진다.
<출력값>
N개의 줄에 걸쳐 별을 적절히 찍는다.

<문제 2557>
Hello World!를 출력하시오.
<입력값>
없음
<출력값>
Hello World!를 출력하시오.

<문제 2558>
두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 A, 둘째 줄에 B가 주어진다. (0 < A, B < 10)
<출력값>
첫째 줄에 A+B를 출력한다.

<문제 2559>
매일 아침 9시에 학교에서 측정한 온도가 어떤 정수의 수열로 주어졌을 때, 연속적인 며칠 동안의 온도의 합이 가장 큰 값을 알아보고자 한다.

	예를 들어, 아래와 같이 10일 간의 온도가 주어졌을 때, 

	3 -2 -4 -9 0 3 7 13 8 -3

	모든 연속적인 이틀간의 온도의 합은 아래와 같다.




		이때, 온도의 합이 가장 큰 값은 21이다. 

		또 다른 예로 위와 같은 온도가 주어졌을 때, 모든 연속적인 5일 간의 온도의 합은 아래와 같으며, 




			이때, 온도의 합이 가장 큰 값은 31이다.

			매일 측정한 온도가 정수의 수열로 주어졌을 때, 연속적인 며칠 동안의 온도의 합이 가장 큰 값을 계산하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 두 개의 정수 N과 K가 한 개의 공백을 사이에 두고 순서대로 주어진다. 첫 번째 정수 N은 온도를 측정한 전체 날짜의 수이다. N은 2 이상 100,000 이하이다. 두 번째 정수 K는 합을 구하기 위한 연속적인 날짜의 수이다. K는 1과 N 사이의 정수이다. 둘째 줄에는 매일 측정한 온도를 나타내는 N개의 정수가 빈칸을 사이에 두고 주어진다. 이 수들은 모두 -100 이상 100 이하이다.
<출력값>
첫째 줄에는 입력되는 온도의 수열에서 연속적인 K일의 온도의 합이 최대가 되는 값을 출력한다.

<문제 2560>
한 생물학자가 새로 발견된 짚신벌레 종의 생태에 대해 연구하고 있다. 매우 번식력이 강하다고 알려진 이 종은 아래와 같은 특징을 가지고 있다.

	무성 생식을 한다.

	태어난 이후 a일째 되는 날 성체가 된다.

	성체가 된 날부터 매일 한 마리씩 새로운 개체를 만들어낸다: 성체가 되자마자 첫 개체를 만들어내고, 그 이후로 하루가 지날 때마다 새로운 개체를 하나씩 만들어낸다. 새로운 개체 역시 태어난 이후로 a일째 되는 날부터 성체가 되어 새로운 개체를 만든다.

	태어난 이후로 b일째 되는 순간부터는 새로운 개체를 더 이상 만들지 않는다. 태어난 지 a일째 날부터 b일째 되는 날의 전날까지 새로운 개체를 만들어내므로 일생동안 총 b-a 마리의 개체를 만들어낸다.

	태어난 이후로 d일째 되는 순간 죽는다.

	아래는 a=2, b=4, d=6일 때 수조에 새로 태어난 짚신벌레 한 마리를 넣고 매일 관찰한 결과를 기록한 것이다. 괄호 안의 숫자들은 수조 안의 짚신벌레들이 각각 태어난 이후 며칠이 되었는지를 나타내는 정수이다.

	태어난 날: (0) - 새로운 개체를 집어넣음

	1일째 되는 날: (1) - 짚신벌레가 자람

	2일째 되는 날: (2, 0) - 짚신벌레가 태어난 지 2일째가 되므로 성체가 되고 새 개체를 만들어 냄

	3일째 되는 날: (3, 1, 0) - 2일째 성체가 된 짚신벌레가 오늘도 새 개체를 하나 만들어 냄

	4일 째 되는 날: (4, 2, 1, 0) - 2일째 되는 날 만들어진 짚신벌레가 새로운 개체를 만들어 냄 (처음에 넣은 짚신벌레는 새 개체를 만들어내지 못함)

	5일 째 되는 날: (5, 3, 2, 1, 0, 0)

	6일 째 되는 날: (4, 3, 2, 1, 1, 0, 0) - 처음에 넣은 개체는 죽는다.

	6일 째 되는 날 수조안에 살아있는 짚신벌레는 총 7마리가 된다.

	짚신벌레의 번식 정보 a, b, d에 대하여, 새로 태어난 짚신벌레 한 마리를 수조 안에 넣은 이후 N일째 되는 날 살아있는 짚신벌레 수를 1000으로 나눈 나머지를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 a, b, d, N을 나타내는 네 정수가 빈칸 하나를 사이에 두고 차례로 주어진다. 단, 0＜a＜b＜d≤10,000이고, 1≤N≤1,000,000이다.
<출력값>
첫째 줄에, 수조에 짚신벌레 한 마리를 넣은 지 N일째 되는 날 수조에 살아 있는 짚신벌레의 수를 1000으로 나눈 나머지를 출력한다.

<문제 2561>
1부터 N까지의 숫자가 각 칸에 차례대로 들어있는 놀이판이 있다. 예를 들어 10 칸을 가진 놀이판의 초기 상태는 다음과 같다.  



1
2
3
4
5
6
7
8
9
10



구간[i,j]는 놀이판의 왼쪽 i번째 칸부터 j번째칸 사이에 있는 모든 숫자를 말한다. 단 구간[i,j]에서 항상 i ≤ j 라고 가정한다. 우리는 이 놀이판의 한 구간을 잡아서 그 구간을 완전히 뒤집을  수 있다. 만일 초기상태에서 구간[3,8]을 뒤집으면 놀이판은 다음과 같이 변한다.



1
2
8
7
6
5
4
3
9
10



이어 이 상태에서 구간[1,5] 구간[6,9]를 연이어 뒤집으면 놀이판은 다음과 같이 각각 바뀐다. 



6
7
8
2
1
5
4
3
9
10






6
7
8
2
1
9
3
4
5
10



여러분은 세 번 뒤집힌 놀이판의 상태를 입력으로 받아서 이를 다시 초기 상태로 돌리기 위해서 어떤 세 구간을 차례대로 뒤집어야 하는지를 계산해야 한다. 즉 여러분이 찾아낸 세 개의 구간대로 입력 놀이판을 차례대로 뒤집으면, 놀이판은 초기상태인 1, 2, 3, ...., N 으로 되돌아가야 한다.  
단 어떤 경우에는 초기상태로 되돌릴 수 있는 세 구간이 여러 개 있을 수도 있는데, 그러한 경우에는 그 중 하나만 출력해도 된다. 구간[i,i]를 뒤집으면 아무런 변화가 없는데 이러한 것도 허용이 된다.
<입력값>
첫줄에는 숫자판의 크기를 나타내는 정수 N (5≤N≤1000)이 주어진다. 그 다음 줄에는 세 개의 구간이 뒤집혀진 놀이판의 상태를 나타내는 숫자들이 하나의 공백을 두고 나타난다.
<출력값>
첫 세 줄에 뒤집어야 할 각 구간을 차례대로 출력해야 한다. 각 줄에는 구간[i, j]를 나타내는 i와 j를 빈 칸을 사이에 두고 출력해야 한다. 입력에 대한 답은 항상 존재한다.

<문제 2562>
9개의 서로 다른 자연수가 주어질 때, 이들 중 최댓값을 찾고 그 최댓값이 몇 번째 수인지를 구하는 프로그램을 작성하시오.
예를 들어, 서로 다른 9개의 자연수
3, 29, 38, 12, 57, 74, 40, 85, 61
이 주어지면, 이들 중 최댓값은 85이고, 이 값은 8번째 수이다.
<입력값>
첫째 줄부터 아홉 번째 줄까지 한 줄에 하나의 자연수가 주어진다. 주어지는 자연수는 100 보다 작다.
<출력값>
첫째 줄에 최댓값을 출력하고, 둘째 줄에 최댓값이 몇 번째 수인지를 출력한다.

<문제 2563>
가로, 세로의 크기가 각각 100인 정사각형 모양의 흰색 도화지가 있다. 이 도화지 위에 가로, 세로의 크기가 각각 10인 정사각형 모양의 검은색 색종이를 색종이의 변과 도화지의 변이 평행하도록 붙인다. 이러한 방식으로 색종이를 한 장 또는 여러 장 붙인 후 색종이가 붙은 검은 영역의 넓이를 구하는 프로그램을 작성하시오.

예를 들어 흰색 도화지 위에 세 장의 검은색 색종이를 그림과 같은 모양으로 붙였다면 검은색 영역의 넓이는 260이 된다.
<입력값>
첫째 줄에 색종이의 수가 주어진다. 이어 둘째 줄부터 한 줄에 하나씩 색종이를 붙인 위치가 주어진다. 색종이를 붙인 위치는 두 개의 자연수로 주어지는데 첫 번째 자연수는 색종이의 왼쪽 변과 도화지의 왼쪽 변 사이의 거리이고, 두 번째 자연수는 색종이의 아래쪽 변과 도화지의 아래쪽 변 사이의 거리이다. 색종이의 수는 100 이하이며, 색종이가 도화지 밖으로 나가는 경우는 없다
<출력값>
첫째 줄에 색종이가 붙은 검은 영역의 넓이를 출력한다.

<문제 2564>
동근이는 무인 경비 회사 경비원으로 항상 대기하고 있다가 호출이 들어오면 경비차를 몰고 그 곳으로 달려가야 한다. 동근이가 담당하고 있는 곳은 직사각형 모양의 블록으로 블록 중간을 가로질러 차가 통과할만한 길이 없다. 이 블록 경계에 무인 경비를 의뢰한 상점들이 있다.
예를 들어 가로의 길이가 10, 세로의 길이가 5인 블록의 경계에 무인 경비를 의뢰한 3개의 상점이 있다고 하자. <그림 1>과 같이 이들은 1, 2, 3으로 표시되어 있고, 동근이는 X로 표시한 위치에 있다.

1번 상점에서 호출이 들어 왔을 때 동근이가 블록을 시계방향으로 돌아 이동하면 이동 거리가 12가 된다. 반면 반시계방향으로 돌아 이동하면 이동 거리는 18이 된다. 따라서 동근이가 1번 상점으로 가는 최단 거리는 12가 된다. 마찬가지로 동근이의 위치에서 2번 상점까지의 최단 거리는 6, 3번 상점까지의 최단 거리는 5가 된다.
블록의 크기와 상점의 개수 및 위치 그리고 동근이의 위치가 주어질 때 동근이의 위치와 각 상점 사이의 최단 거리의 합을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 블록의 가로의 길이와 세로의 길이가 차례로 주어진다. 둘째 줄에 상점의 개수가 주어진다. 블록의 가로의 길이와 세로의 길이, 상점의 개수는 모두 100이하의 자연수이다. 이어 한 줄에 하나씩 상점의 위치가 주어진다. 상점의 위치는 두 개의 자연수로 표시된다. 첫째 수는 상점이 위치한 방향을 나타내는데, 1은 블록의 북쪽, 2는 블록의 남쪽, 3은 블록의 서쪽, 4는 블록의 동쪽에 상점이 있음을 의미한다. 둘째 수는 상점이 블록의 북쪽 또는 남쪽에 위치한 경우 블록의 왼쪽 경계로부터의 거리를 나타내고, 상점이 블록의 동쪽 또는 서쪽에 위치한 경우 블록의 위쪽 경계로부터의 거리를 나타낸다. 마지막 줄에는 동근이의 위치가 상점의 위치와 같은 방식으로 주어진다. 상점의 위치나 동근이의 위치는 블록의 꼭짓점이 될 수 없다.
<출력값>
첫째 줄에 동근이의 위치와 각 상점 사이의 최단 거리의 합을 출력한다.

<문제 2565>
두 전봇대 A와 B 사이에 하나 둘씩 전깃줄을 추가하다 보니 전깃줄이 서로 교차하는 경우가 발생하였다. 합선의 위험이 있어 이들 중 몇 개의 전깃줄을 없애 전깃줄이 교차하지 않도록 만들려고 한다.
예를 들어, <그림 1>과 같이 전깃줄이 연결되어 있는 경우 A의 1번 위치와 B의 8번 위치를 잇는 전깃줄, A의 3번 위치와 B의 9번 위치를 잇는 전깃줄, A의 4번 위치와 B의 1번 위치를 잇는 전깃줄을 없애면 남아있는 모든 전깃줄이 서로 교차하지 않게 된다.

전깃줄이 전봇대에 연결되는 위치는 전봇대 위에서부터 차례대로 번호가 매겨진다. 전깃줄의 개수와 전깃줄들이 두 전봇대에 연결되는 위치의 번호가 주어질 때, 남아있는 모든 전깃줄이 서로 교차하지 않게 하기 위해 없애야 하는 전깃줄의 최소 개수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 두 전봇대 사이의 전깃줄의 개수가 주어진다. 전깃줄의 개수는 100 이하의 자연수이다. 둘째 줄부터 한 줄에 하나씩 전깃줄이 A전봇대와 연결되는 위치의 번호와 B전봇대와 연결되는 위치의 번호가 차례로 주어진다. 위치의 번호는 500 이하의 자연수이고, 같은 위치에 두 개 이상의 전깃줄이 연결될 수 없다.
<출력값>
첫째 줄에 남아있는 모든 전깃줄이 서로 교차하지 않게 하기 위해 없애야 하는 전깃줄의 최소 개수를 출력한다.

<문제 2566>
<그림 1>과 같이 9×9 격자판에 쓰여진 81개의 자연수가 주어질 때, 이들 중 최댓값을 찾고 그 최댓값이 몇 행 몇 열에 위치한 수인지 구하는 프로그램을 작성하시오.

	예를 들어, 다음과 같이 81개의 수가 주어지면



	이들 중 최댓값은 90이고, 이 값은 5행 7열에 위치한다.
<입력값>
첫째 줄부터 아홉 번째 줄까지 한 줄에 아홉 개씩 자연수가 주어진다. 주어지는 자연수는 100보다 작다.
<출력값>
첫째 줄에 최댓값을 출력하고, 둘째 줄에 최댓값이 위치한 행 번호와 열 번호를 빈칸을 사이에 두고 차례로 출력한다. 최댓값이 두 개 이상인 경우 그 중 한 곳의 위치를 출력한다.

<문제 2567>
가로, 세로의 크기가 각각 100인 정사각형 모양의 흰색 도화지가 있다. 이 도화지 위에 가로, 세로의 크기가 각각 10인 정사각형 모양의 검은색 색종이를 색종이의 변과 도화지의 변이 평행하도록 붙인다. 이러한 방식으로 색종이를 한 장 또는 여러 장 붙인 후 색종이가 붙은 검은 영역의 둘레의 길이를 구하는 프로그램을 작성하시오.
예를 들어 흰색 도화지 위에 네 장의 검은색 색종이를 <그림 1>과 같은 모양으로 붙였다면 검은색 영역의 둘레는 96 이 된다.
<입력값>
첫째 줄에 색종이의 수가 주어진다. 이어 둘째 줄부터 한 줄에 하나씩 색종이를 붙인 위치가 주어진다. 색종이를 붙인 위치는 두 개의 자연수로 주어지는데 첫 번째 자연수는 색종이의 왼쪽 변과 도화지의 왼쪽 변 사이의 거리이고, 두 번째 자연수는 색종이의 아래쪽 변과 도화지의 아래쪽 변 사이의 거리이다. 색종이의 수는 100이하이며, 색종이가 도화지 밖으로 나가는 경우는 없다.
<출력값>
첫째 줄에 색종이가 붙은 검은 영역의 둘레의 길이를 출력한다.

<문제 2568>
두 전봇대 A와 B 사이에 하나 둘씩 전깃줄을 추가하다 보니 전깃줄이 서로 교차하는 경우가 발생하였다. 합선의 위험이 있어 이들 중 몇 개의 전깃줄을 없애 전깃줄이 교차하지 않도록 만들려고 한다.
예를 들어, <그림 1>과 같이 전깃줄이 연결되어 있는 경우 A의 1번 위치와 B의 8번 위치를 잇는 전깃줄, A의 3번 위치와 B의 9번 위치를 잇는 전깃줄, A의 4번 위치와 B의 1번 위치를 잇는 전깃줄을 없애면 남아있는 모든 전깃줄이 서로 교차하지 않게 된다. 

전깃줄이 전봇대에 연결되는 위치는 전봇대 위에서부터 차례대로 번호가 매겨진다. 전깃줄의 개수와 전깃줄들이 두 전봇대에 연결되는 위치의 번호가 주어질 때, 남아있는 모든 전깃줄이 서로 교차하지 않게 하기 위해 없애야 하는 최소 개수의 전깃줄을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 두 전봇대 사이의 전깃줄의 개수가 주어진다. 전깃줄의 개수는 100,000 이하의 자연수이다. 둘째 줄부터 한 줄에 하나씩 전깃줄이 A전봇대와 연결되는 위치의 번호와 B전봇대와 연결되는 위치의 번호가 차례로 주어진다. 위치의 번호는 500,000 이하의 자연수이고, 같은 위치에 두 개 이상의 전깃줄이 연결될 수 없다.
<출력값>
첫째 줄에 남아있는 모든 전깃줄이 서로 교차하지 않게 하기 위해 없애야 하는 전깃줄의 최소 개수를 출력한다. 둘째 줄부터 한 줄에 하나씩 없애야 하는 전깃줄의 A전봇대에 연결되는 위치의 번호를 오름차순으로 출력한다. 만약 답이 두 가지 이상이라면 그 중 하나를 출력한다.

<문제 2569>
일렬로 놓인 짐칸에는 서로 다른 무게를 갖는 짐이 한 칸에 하나씩 놓여 있다. 가장 앞에 위치한 짐칸에 가장 가벼운 짐이 놓이고 이어 무게 순서대로 짐이 놓여 가장 마지막에 위치한 짐칸에는 가장 무거운 짐이 놓이도록 짐칸을 정리하려 한다. 짐을 옮길 때는 두 짐의 위치를 서로 바꾸어 주어야 하며, 이때 두 짐의 무게의 합만큼의 힘이 든다.
짐칸의 개수와 짐칸에 놓인 짐의 무게가 차례대로 주어질 때 짐칸을 정리하기 위해 필요한 최소 힘을 구하는 프로그램을 작성하시오.
예를 들어, 무게가 각각 10, 2, 8, 5인 네 개의 짐이 짐칸에 차례로 놓여 있다고 하자. 무게가 10인 짐과 무게가 2인 짐의 위치를 서로 바꾸어 주고, 이어 무게가 10인 짐과 무게가 5인 짐의 위치를 서로 바꾸어 주면 짐칸 정리를 마치게 된다. 이때 드는 총 힘은 < 그림 1 >과 같이 (10+2) + (10+5) = 27 이 된다.

반면 먼저 무게가 2인 짐과 5인 짐의 위치를 서로 바꾸어 주고, 이어 무게가 10인 짐과 2인 짐의 위치를 서로 바꾸어 주어도 짐칸이 정리된다. 이렇게 했을 때 드는 총 힘은 < 그림 2 >와 같이 (2+5) + (10+2) = 19 가 된다.
<입력값>
첫째 줄에 짐칸의 수가 주어진다. 이어 둘째 줄부터 한 줄에 하나씩 짐의 무게가 차례대로 주어진다. 짐칸의 수는 1,000이하의 자연수이며, 짐의 무게는 10,000이하의 자연수이다. 모든 짐의 무게는 서로 다르다.
<출력값>
첫째 줄에 짐칸을 정리하기 위해 필요한 최소 힘을 출력한다.

<문제 2570>
서양장기인 체스에는 대각선 방향으로 움직일 수 있는 비숍(bishop)이 있다. < 그림 1 >과 같이 크기가 5인 정사각형 체스판 위에 B라고 표시된 곳에 비숍이 있을 때 비숍은 대각선 방향으로 움직여 O로 표시된 칸에 있는 다른 말을 잡을 수 있다.



	그런데 체스판 위에는 비숍이 지나갈 수 없는 장애물이 놓일 수 있다. 예를 들어 < 그림 2 >와 같이 체스판 중앙에 비숍이 지나갈 수 없는 장애물이 놓이면 비숍은 장애물 오른쪽 아래 대각선 방향으로는 움직일 수 없다.




		정사각형 체스판의 한 변에 놓인 칸의 개수를 체스판의 크기라고 한다. 체스판의 크기와 체스판에 놓인 장애물들의 위치가 주어질 때, 체스판 위에 서로가 서로를 잡을 수 없도록 하면서 최대 몇 개의 비숍을 놓을 수 있는지를 구하는 프로그램을 작성하시오.

		예를 들어 < 그림 2 >와 같이 체스판이 주어지면 < 그림 3 >과 같이 서로가 서로를 잡지 못하도록 하면서 최대 10개의 비숍을 놓을 수 있다.
<입력값>
첫째 줄에 정사각형 체스판의 크기 N이 주어진다. 둘째 줄에는 체스판 위에 놓인 장애물의 개수 M이 주어진다. N은 100이하의 자연수이고 M은 음이 아닌 정수이다. 이어 셋째 줄부터 한 줄에 하나씩 장애물의 위치가 주어진다. 장애물이 놓인 칸의 위치는 위에서부터 몇 번째 행인지와 왼쪽부터 몇 번째 열인지를 나타내는 두 개의 자연수가 차례로 주어진다.
<출력값>
첫째 줄에 주어진 체스판 위에 놓을 수 있는 비숍의 최대 개수를 출력한다.

<문제 2571>
가로, 세로의 크기가 각각 100인 정사각형 모양의 흰색 도화지가 있다. 이 도화지 위에 가로, 세로의 크기가 각각 10인 정사각형 모양의 검은색 색종이를 색종이의 변과 도화지의 변이 평행하도록 붙인다. 이러한 방식으로 색종이를 한 장 또는 여러 장 붙인 후 도화지에서 검은색 직사각형을 잘라내려고 한다. 직사각형 또한 그 변이 도화지의 변과 평행하도록 잘라내어야 한다.

	예를 들어 흰색 도화지 위에 세 장의 검은색 색종이를 <그림 1>과 같은 모양으로 붙였다. <그림 1>에 표시된 대로 검은색 직사각형을 잘라내면 그 넓이는 22×5=110이 된다.


반면 <그림 2>에 표시된 대로 검은색 직사각형을 잘라내면 그 넓이는 8×15=120이 된다.

	검은색 색종이의 수와 각 색종이를 붙인 위치가 주어질 때 잘라낼 수 있는 검은색 직사각형의 최대 넓이를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 색종이의 수가 주어진다. 이어 둘째 줄부터 한 줄에 하나씩 색종이를 붙인 위치가 주어진다. 색종이를 붙인 위치는 두 개의 자연수로 주어지는데 첫 번째 자연수는 색종이의 왼쪽 변과 도화지의 왼쪽 변 사이의 거리이고, 두 번째 자연수는 색종이의 아래쪽 변과 도화지의 아래쪽 변 사이의 거리이다. 색종이의 수는 100이하이며, 색종이가 도화지 밖으로 나가는 경우는 없다.
<출력값>
첫째 줄에 잘라낼 수 있는 검은색 직사각형의 최대 넓이를 출력한다.

<문제 2572>
KOI 보드 게임은 N장의 카드를 갖고 시작한다. 각각의 카드 앞면에는 1번부터 N번까지 번호가 순서대로 적혀 있고, 뒷면에는 빨간색(R), 녹색(G), 파란색(B) 중 하나의 색깔이 칠해져 있다.

	항상 1번 마을로부터 시작하여 길이 연결되어 있는 이웃 마을로 이동해 가는데 한 번 이동할 때마다 갖고 있는 카드를 번호 순서대로 한 장씩 내야 한다. 각 길은 빨간색(R), 녹색(G), 파란색(B) 중 하나의 색깔이 칠해져 있는데 만약 내놓은 카드의 색깔과 길의 색깔이 일치하면 10점의 점수를 얻는다.

	예를 들어 N이 5이고 1번부터 5번까지의 카드 색깔이 R, G, R, B, G이라고 하자. 지도가 <그림 1>과 같이 주어졌다고 할 때,



	1번 마을에서 시작하여 2번 마을로 가면 길의 색깔과 1번 카드의 색깔이 R로 일치하므로 10점을 받게 된다. 다음 3번 마을로 가면 마찬가지로 길의 색깔과 2번 카드의 색깔이 G로 일치하므로 10점을 추가로 받게 된다. 이어 1번, 2번, 3번 마을로 이동하면 총 30점을 받는다. 하지만 1번 마을에서 시작하여 2번 마을을 거쳐 3번, 4번, 3번, 2번 마을로 이동하면 총 40점을 받게 된다.

	갖고 있는 카드의 정보와 지도가 주어질 때 받을 수 있는 최대 점수를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 카드의 수 N이 주어진다. 둘째 줄에 N장의 카드의 색깔이 번호 순서대로 빈칸을 사이에 두고 주어진다. 셋째 줄에는 마을의 수 M과 길의 수 K가 빈칸을 사이에 두고 주어진다. 이어 K개의 줄에 길의 정보가 주어진다. 길의 정보는 양 끝 마을의 번호를 나타내는 서로 다른 두 개의 자연수와 길의 색깔이 빈칸을 사이에 두고 주어진다. 두 마을을 잇는 길은 최대 1개이다. N은 1000이하의 자연수, M은 500이하의 자연수, K는 10000이하의 자연수이다. 카드의 색깔과 길의 색깔은 R, G, B중 하나이다.
<출력값>
첫째 줄에 보드 게임에서 받을 수 있는 최대 점수를 출력한다.

<문제 2573>
지구 온난화로 인하여 북극의 빙산이 녹고 있다. 빙산을 그림 1과 같이 2차원 배열에 표시한다고 하자. 빙산의 각 부분별 높이 정보는 배열의 각 칸에 양의 정수로 저장된다. 빙산 이외의 바다에 해당되는 칸에는 0이 저장된다. 그림 1에서 빈칸은 모두 0으로 채워져 있다고 생각한다.

그림 1. 행의 개수가 5이고 열의 개수가 7인 2차원 배열에 저장된 빙산의 높이 정보
빙산의 높이는 바닷물에 많이 접해있는 부분에서 더 빨리 줄어들기 때문에, 배열에서 빙산의 각 부분에 해당되는 칸에 있는 높이는 일년마다 그 칸에 동서남북 네 방향으로 붙어있는 0이 저장된 칸의 개수만큼 줄어든다. 단, 각 칸에 저장된 높이는 0보다 더 줄어들지 않는다. 바닷물은 호수처럼 빙산에 둘러싸여 있을 수도 있다. 따라서 그림 1의 빙산은 일년후에 그림 2와 같이 변형된다.
그림 3은 그림 1의 빙산이 2년 후에 변한 모습을 보여준다. 2차원 배열에서 동서남북 방향으로 붙어있는 칸들은 서로 연결되어 있다고 말한다. 따라서 그림 2의 빙산은 한 덩어리이지만, 그림 3의 빙산은 세 덩어리로 분리되어 있다.

한 덩어리의 빙산이 주어질 때, 이 빙산이 두 덩어리 이상으로 분리되는 최초의 시간(년)을 구하는 프로그램을 작성하시오. 그림 1의 빙산에 대해서는 2가 답이다. 만일 전부 다 녹을 때까지 두 덩어리 이상으로 분리되지 않으면 프로그램은 0을 출력한다.
<입력값>
첫 줄에는 이차원 배열의 행의 개수와 열의 개수를 나타내는 두 정수 N과 M이 한 개의 빈칸을 사이에 두고 주어진다. N과 M은 3 이상 300 이하이다. 그 다음 N개의 줄에는 각 줄마다 배열의 각 행을 나타내는 M개의 정수가 한 개의 빈 칸을 사이에 두고 주어진다. 각 칸에 들어가는 값은 0 이상 10 이하이다. 배열에서 빙산이 차지하는 칸의 개수, 즉, 1 이상의 정수가 들어가는 칸의 개수는 10,000 개 이하이다. 배열의 첫 번째 행과 열, 마지막 행과 열에는 항상 0으로 채워진다.
<출력값>
첫 줄에 빙산이 분리되는 최초의 시간(년)을 출력한다. 만일 빙산이 다 녹을 때까지 분리되지 않으면 0을 출력한다.

<문제 2574>
1 간격으로 수평선과 수직선이 그어진 직사각형 모양의 마법 색종이를 가로 방향과 세로 방향으로 잘라서 작은 직사각형 조각들로 나누려고 한다. 처음에는 흰색 색종이 한 조각이 주어진다. 이 후로 한 점씩 주어질 때마다 아래의 규칙을 따르면서 색종이 조각을 자른다.

주어진 점이 흰색 색종이 조각에 포함되면, 그 점을 지나는 ‘수평선’을 따라 자른다. 이때 잘려진 두 조각 모두 ‘검정색’으로 색깔이 변한다. 
주어진 점이 검정색 색종이 조각에 포함되면, 그 점을 지나는 ‘수직선’을 따라 자른다. 이때 잘려진 두 조각 모두 ‘흰색’으로 색깔이 변한다.

흰색 마법 색종이의 가로 길이와 세로 길이, 그리고 색종이 안에 점들이 순서를 가지고 주어질 때, 위의 규칙을 따라 색종이를 모두 자른 후 만들어지는 색종이 조각들 중에서 넓이가 가장 큰 조각과 넓이가 가장 작은 조각의 넓이를 각각 구하는 프로그램을 작성하시오. 단, 입력으로 주어지는 점들 중 어떤 두 점도 같은 수평선 위에 놓이거나 같은 수직선 위에 놓이지 않는다. 또한 맨 처음 주어진 색종이의 둘레에 위치하는 점들도 입력되지 않는다.
색종이의 가로 길이와 세로 길이는 모두 양의 정수로 주어진다. 그리고 색종이를 자르기 위해서 주어지는 점들의 위치는 자르기 전 색종이의 왼쪽 아래 꼭짓점에서 가로 방향으로 떨어진 거리와 세로 방향으로 떨어진 거리를 나타내는 두개의 정수로 주어진다. 예를 들어 아래 그림들에서 점 1의 위치는 (5,4)이다.
만약 가로의 길이와 세로의 길이가 각각 8과 7인 색종이를 자르기 위한 점들의 위치가 (5,4), (2,3), (3,1), (7,6), (6,2)의 순서로 주어진다고 하자. 먼저 첫째 점에 의해서 색종이는 그림 1과 같이 두 검정색 조각으로 잘려진다.

그림 1
이어서 두 번째 점에 의해서 그림 1의 아래쪽 검정색 조각이 그림 2와 같이 두 흰색 조각으로 나누어진다.

그림 2
나머지 점들에 대해서도 모두 위와 같은 방식으로 색종이를 자르면 그림 3과 같이 된다. 이 경우 가장 큰 색종이 조각의 넓이는 21이고 가장 작은 색종이 조각의 넓이는 3이다.

그림 3
<입력값>
첫째 줄에는 색종이의 가로의 길이와 세로의 길이를 나타내는 양의 정수가 빈칸을 사이에 두고 주어진다. 가로와 세로의 길이는 모두 40,000 이하이다. 둘째 줄에는 색종이를 자르기 위한 점의 개수를 나타내는 양의 정수 N이 주어진다. N은 30,000 이하이다. 셋째 줄부터 마지막 줄까지 색종이를 자르기 위한 점들의 위치가 한 줄에 하나씩 순서대로 주어진다. 점들의 위치는 빈칸을 사이에 두고 가로 방향의 거리가 주어진 다음 세로 방향의 거리가 주어진다.
<출력값>
첫째 줄에 잘려진 색종이 조각 중에서 가장 넓이가 큰 조각의 넓이와 가장 작은 조각의 넓이가 몇 인지를 빈칸을 사이에 두고 순서대로 출력한다.

<문제 2575>
우리는 양의 정수들이 나열된 수열 을 구하는 다음과 같은 두 문제를 풀려고 한다. 수열의 길이는 수열에 포함된 정수들의 개수 n이라고 정의한다. 

	문제 A: 양의 정수 M이 주어질 때, a1+a2+...+an=M을 만족하면서 a1*a2*...an의 값이 가장 크게 되는 수열 을 구하시오. 단, a1*a2*...*an의 값이 가장 크게 되는 서로 다른 길이의 수열이 두 개 이상 존재할 경우, 수열의 길이 n이 최대인 수열을 구하시오. 

	문제 B: 양의 정수 M이 주어질 때, a1*a2*...*am=M을 만족하면서 a1+a2+...+am의 값이 가장 작게 되는 수열 을 구하시오. 단, a1+a2+...+am의 값이 가장 작게 되는 서로 다른 길이의 수열이 두 개 이상 존재할 경우, 수열의 길이 m이 최소인 수열을 구한다.

	문제 A에서 구한 수열의 길이 n과 문제 B에서 구한 수열의 길이 m을 출력하는 프로그램을 작성하시오.

	예를 들어, M=6이면, 문제 A에서 구한 수열은 <3,3>이므로 이 수열의 길이는 2이고, 문제 B에서 구한 수열은 <2,3>이므로 이 수열의 길이는 2이다.
<입력값>
첫째 줄에 정수 M이 주어진다. 1<=M<=1,000,000 이다.
<출력값>
첫째 줄에 문제 A에서 구한 수열의 길이 n과 문제 B에서 구한 수열의 길이 m을 한 개의 빈칸을 사이에 두고 차례대로 출력한다.

<문제 2576>
7개의 자연수가 주어질 때, 이들 중 홀수인 자연수들을 모두 골라 그 합을 구하고, 고른 홀수들 중 최솟값을 찾는 프로그램을 작성하시오.
예를 들어, 7개의 자연수 12, 77, 38, 41, 53, 92, 85가 주어지면 이들 중 홀수는 77, 41, 53, 85이므로 그 합은
77 + 41 + 53 + 85 = 256
이 되고,
41 < 53 < 77 < 85
이므로 홀수들 중 최솟값은 41이 된다.
<입력값>
입력의 첫째 줄부터 일곱 번째 줄까지 한 줄에 하나의 자연수가 주어진다. 주어지는 자연수는 100보다 작다.
<출력값>
홀수가 존재하지 않는 경우에는 첫째 줄에 -1을 출력한다. 홀수가 존재하는 경우 첫째 줄에 홀수들의 합을 출력하고, 둘째 줄에 홀수들 중 최솟값을 출력한다.

<문제 2577>
세 개의 자연수 A, B, C가 주어질 때 A × B × C를 계산한 결과에 0부터 9까지 각각의 숫자가 몇 번씩 쓰였는지를 구하는 프로그램을 작성하시오.
예를 들어 A = 150, B = 266, C = 427 이라면 A × B × C = 150 × 266 × 427 = 17037300 이 되고, 계산한 결과 17037300 에는 0이 3번, 1이 1번, 3이 2번, 7이 2번 쓰였다.
<입력값>
첫째 줄에 A, 둘째 줄에 B, 셋째 줄에 C가 주어진다. A, B, C는 모두 100보다 같거나 크고, 1,000보다 작은 자연수이다.
<출력값>
첫째 줄에는 A × B × C의 결과에 0 이 몇 번 쓰였는지 출력한다. 마찬가지로 둘째 줄부터 열 번째 줄까지 A × B × C의 결과에 1부터 9까지의 숫자가 각각 몇 번 쓰였는지 차례로 한 줄에 하나씩 출력한다.

<문제 2578>
빙고 게임은 다음과 같은 방식으로 이루어진다.

	먼저 아래와 같이 25개의 칸으로 이루어진 빙고판에 1부터 25까지 자연수를 한 칸에 하나씩 쓴다



	다음은 사회자가 부르는 수를 차례로 지워나간다. 예를 들어 5, 10, 7이 불렸다면 이 세 수를 지운 뒤 빙고판의 모습은 다음과 같다.



	차례로 수를 지워가다가 같은 가로줄, 세로줄 또는 대각선 위에 있는 5개의 모든 수가 지워지는 경우 그 줄에 선을 긋는다.



	이러한 선이 세 개 이상 그어지는 순간 "빙고"라고 외치는데, 가장 먼저 외치는 사람이 게임의 승자가 된다.



	철수는 친구들과 빙고 게임을 하고 있다. 철수가 빙고판에 쓴 수들과 사회자가 부르는 수의 순서가 주어질 때, 사회자가 몇 번째 수를 부른 후 철수가 "빙고"를 외치게 되는지를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄부터 다섯째 줄까지 빙고판에 쓰여진 수가 가장 위 가로줄부터 차례대로 한 줄에 다섯 개씩 빈 칸을 사이에 두고 주어진다. 여섯째 줄부터 열째 줄까지 사회자가 부르는 수가 차례대로 한 줄에 다섯 개씩 빈 칸을 사이에 두고 주어진다. 빙고판에 쓰여진 수와 사회자가 부르는 수는 각각 1부터 25까지의 수가 한 번씩 사용된다.
<출력값>
첫째 줄에 사회자가 몇 번째 수를 부른 후 철수가 "빙고"를 외치게 되는지 출력한다.

<문제 2579>
계단 오르기 게임은 계단 아래 시작점부터 계단 꼭대기에 위치한 도착점까지 가는 게임이다. <그림 1>과 같이 각각의 계단에는 일정한 점수가 쓰여 있는데 계단을 밟으면 그 계단에 쓰여 있는 점수를 얻게 된다.

예를 들어 <그림 2>와 같이 시작점에서부터 첫 번째, 두 번째, 네 번째, 여섯 번째 계단을 밟아 도착점에 도달하면 총 점수는 10 + 20 + 25 + 20 = 75점이 된다.

계단 오르는 데는 다음과 같은 규칙이 있다.

계단은 한 번에 한 계단씩 또는 두 계단씩 오를 수 있다. 즉, 한 계단을 밟으면서 이어서 다음 계단이나, 다음 다음 계단으로 오를 수 있다.
연속된 세 개의 계단을 모두 밟아서는 안 된다. 단, 시작점은 계단에 포함되지 않는다.
마지막 도착 계단은 반드시 밟아야 한다.

따라서 첫 번째 계단을 밟고 이어 두 번째 계단이나, 세 번째 계단으로 오를 수 있다. 하지만, 첫 번째 계단을 밟고 이어 네 번째 계단으로 올라가거나, 첫 번째, 두 번째, 세 번째 계단을 연속해서 모두 밟을 수는 없다.
각 계단에 쓰여 있는 점수가 주어질 때 이 게임에서 얻을 수 있는 총 점수의 최댓값을 구하는 프로그램을 작성하시오.
<입력값>
입력의 첫째 줄에 계단의 개수가 주어진다.
둘째 줄부터 한 줄에 하나씩 제일 아래에 놓인 계단부터 순서대로 각 계단에 쓰여 있는 점수가 주어진다. 계단의 개수는 300이하의 자연수이고, 계단에 쓰여 있는 점수는 10,000이하의 자연수이다.
<출력값>
첫째 줄에 계단 오르기 게임에서 얻을 수 있는 총 점수의 최댓값을 출력한다.

<문제 2580>
스도쿠는 18세기 스위스 수학자가 만든 '라틴 사각형'이랑 퍼즐에서 유래한 것으로 현재 많은 인기를 누리고 있다. 이 게임은 아래 그림과 같이 가로, 세로 각각 9개씩 총 81개의 작은 칸으로 이루어진 정사각형 판 위에서 이뤄지는데, 게임 시작 전 일부 칸에는 1부터 9까지의 숫자 중 하나가 쓰여 있다.

나머지 빈 칸을 채우는 방식은 다음과 같다.

각각의 가로줄과 세로줄에는 1부터 9까지의 숫자가 한 번씩만 나타나야 한다.
굵은 선으로 구분되어 있는 3x3 정사각형 안에도 1부터 9까지의 숫자가 한 번씩만 나타나야 한다.

위의 예의 경우, 첫째 줄에는 1을 제외한 나머지 2부터 9까지의 숫자들이 이미 나타나 있으므로 첫째 줄 빈칸에는 1이 들어가야 한다.

또한 위쪽 가운데 위치한 3x3 정사각형의 경우에는 3을 제외한 나머지 숫자들이 이미 쓰여있으므로 가운데 빈 칸에는 3이 들어가야 한다.

이와 같이 빈 칸을 차례로 채워 가면 다음과 같은 최종 결과를 얻을 수 있다.

게임 시작 전 스도쿠 판에 쓰여 있는 숫자들의 정보가 주어질 때 모든 빈 칸이 채워진 최종 모습을 출력하는 프로그램을 작성하시오.
<입력값>
아홉 줄에 걸쳐 한 줄에 9개씩 게임 시작 전 스도쿠판 각 줄에 쓰여 있는 숫자가 한 칸씩 띄워서 차례로 주어진다. 스도쿠 판의 빈 칸의 경우에는 0이 주어진다. 스도쿠 판을 규칙대로 채울 수 없는 경우의 입력은 주어지지 않는다.
<출력값>
모든 빈 칸이 채워진 스도쿠 판의 최종 모습을 아홉 줄에 걸쳐 한 줄에 9개씩 한 칸씩 띄워서 출력한다.
스도쿠 판을 채우는 방법이 여럿인 경우는 그 중 하나만을 출력한다.

<문제 2581>
자연수 M과 N이 주어질 때 M이상 N이하의 자연수 중 소수인 것을 모두 골라 이들 소수의 합과 최솟값을 찾는 프로그램을 작성하시오.
예를 들어 M=60, N=100인 경우 60이상 100이하의 자연수 중 소수는 61, 67, 71, 73, 79, 83, 89, 97 총 8개가 있으므로, 이들 소수의 합은 620이고, 최솟값은 61이 된다.
<입력값>
입력의 첫째 줄에 M이, 둘째 줄에 N이 주어진다.
M과 N은 10,000이하의 자연수이며, M은 N보다 작거나 같다.
<출력값>
M이상 N이하의 자연수 중 소수인 것을 모두 찾아 첫째 줄에 그 합을, 둘째 줄에 그 중 최솟값을 출력한다. 
단, M이상 N이하의 자연수 중 소수가 없을 경우는 첫째 줄에 -1을 출력한다.

<문제 2582>
N2개의 동전이 N행 N열을 이루어 탁자 위에 놓여 있다. 그 중 일부는 앞면(H)이 위를 향하도록 놓여 있고, 나머지는 뒷면(T)이 위를 향하도록 놓여 있다. <그림 1>은 N이 3일 때의 예이다.

이들 N2개의 동전에 대하여 임의의 한 행 또는 한 열에 놓인 N개의 동전을 모두 뒤집는 작업을 수행할 수 있다. 예를 들어 <그림 1>의 상태에서 첫 번째 열에 놓인 동전을 모두 뒤집으면 <그림 2>와 같이 되고, <그림 2>의 상태에서 첫 번째 행에 놓인 동전을 모두 뒤집으면 <그림 3>과 같이 된다.

<그림 3>의 상태에서 뒷면이 위를 향하여 놓인 동전의 개수는 두 개이다. <그림 1>의 상태에서 이와 같이 한 행 또는 한 열에 놓인 N개의 동전을 모두 뒤집는 작업을 계속 수행할 때 뒷면이 위를 향하도록 놓인 동전의 개수를 2개보다 작게 만들 수는 없다.
N2개의 동전들의 초기 상태가 주어질 때, 한 행 또는 한 열에 놓인 N개의 동전을 모두 뒤집는 작업들을 수행하여 뒷면이 위를 향하는 동전 개수를 최소로 하려 한다. 이때의 최소 개수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 32 이하의 자연수 N이 주어진다. 둘째 줄부터 N줄에 걸쳐 N개씩 동전들의 초기 상태가 주어진다. 각 줄에는 한 행에 놓인 N개의 동전의 상태가 왼쪽부터 차례대로 주어지는데, 앞면이 위를 향하도록 놓인 경우 H, 뒤면이 위를 향하도록 놓인 경우 T로 표시되며 이들 사이에 공백은 없다.
<출력값>
첫째 줄에 한 행 또는 한 열에 놓이 N개의 동전을 모두 뒤집는 작업들을 수행하여 뒷면이 위를 향하여 놓일 수 있는 동전의 최소 개수를 출력한다.

<문제 2583>
눈금의 간격이 1인 M×N(M,N≤100)크기의 모눈종이가 있다. 이 모눈종이 위에 눈금에 맞추어 K개의 직사각형을 그릴 때, 이들 K개의 직사각형의 내부를 제외한 나머지 부분이 몇 개의 분리된 영역으로 나누어진다.
예를 들어 M=5, N=7 인 모눈종이 위에 <그림 1>과 같이 직사각형 3개를 그렸다면, 그 나머지 영역은 <그림 2>와 같이 3개의 분리된 영역으로 나누어지게 된다.

<그림 2>와 같이 분리된 세 영역의 넓이는 각각 1, 7, 13이 된다.
M, N과 K 그리고 K개의 직사각형의 좌표가 주어질 때, K개의 직사각형 내부를 제외한 나머지 부분이 몇 개의 분리된 영역으로 나누어지는지, 그리고 분리된 각 영역의 넓이가 얼마인지를 구하여 이를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 M과 N, 그리고 K가 빈칸을 사이에 두고 차례로 주어진다. M, N, K는 모두 100 이하의 자연수이다. 둘째 줄부터 K개의 줄에는 한 줄에 하나씩 직사각형의 왼쪽 아래 꼭짓점의 x, y좌표값과 오른쪽 위 꼭짓점의 x, y좌표값이 빈칸을 사이에 두고 차례로 주어진다. 모눈종이의 왼쪽 아래 꼭짓점의 좌표는 (0,0)이고, 오른쪽 위 꼭짓점의 좌표는(N,M)이다. 입력되는 K개의 직사각형들이 모눈종이 전체를 채우는 경우는 없다.
<출력값>
첫째 줄에 분리되어 나누어지는 영역의 개수를 출력한다. 둘째 줄에는 각 영역의 넓이를 오름차순으로 정렬하여 빈칸을 사이에 두고 출력한다.

<문제 2584>
N개의 정점과 이들 사이에 가중치를 갖는 간선으로 이루어진 트리가 있다. 주어진 자연수 K(K＜N)에 대해, 주어진 트리에서 K개의 정점을 선택하여 그 정점과 이들 사이에 이어진 간선으로 하나의 그래프를 만들고, 나머지 N-K개의 정점과 그들 사이에 이어진 간선으로 또 하나의 그래프를 만들려고 한다.



	예를 들어 <그림 1>과 같이 7개의 정점으로 이루어진 트리에서 1번, 2번 정점을 선택하여 그래프를 만들려면 <그림 2>의 (A)와 같이 되고, 나머지 정점들로 그래프를 만들면 <그림 2>의 (B)와 같이 된다.



	또한 <그림 1>의 트리에서 3번, 4번 정점을 선택한 경우 마찬가지로 <그림 3>의 (A),(B)와 같이 두 그래프가 만들어진다.



	<그림 2>의 두 그래프에서 모든 간선의 가중치의 합은 10+20+10+25=65가 되고<그림 3>의 두 그래프에서 모든 간선의 가충치의 합은 10이된다.

	트리에 대한 정보와 K가 주어질 때, K개의 정점을 선택하여 위와 같은 방법으로 만들어진 두 그래프에 있는 모든 간선의 가중치 합의 최솟값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 중에는 N과 K가 빈 칸을 사이에 두고 차례로 주어진다. 트리의 정점에는 1번부터 N번까지 번호가 매겨진다. 이어 둘째 줄부터 N-1개의 각 줄에는 간선 하나의 정보가 주어진다. 간선의 정보는 양 끝 정점 번호와 가중치가 빈 칸을 사이에 두고 차례대도 주어진다. N은 1,000이하의 자연수, K는 N보다 작은 자연수이고 간선의 가중치는 1,000이하의 자연수 이다.
<출력값>
첫째 줄에 K개 정점을 선택하여 만들어진 두 개의 그래프에 있는 모든 간선의 가중치 합의 최솟값을 출력하고, 둘째 줄에 그 때 선택한 K개 정점들의 번호를 오름차순으로 빈 칸을 사이에 두고 한 줄에 출력한다. K개의 정점을 선택하는 방법이 둘 이상인 경우 그 중 한 경우만 출력한다.

<문제 2585>
경비행기 독수리호가 출발지 S에서 목적지 T로 가능한 빠른 속도로 안전하게 이동하고자 한다. 이때, 경비행기의 연료통의 크기를 정하는 것이 중요한 문제가 된다. 큰 연료통을 장착하면 중간에 내려서 급유를 받는 횟수가 적은 장점이 있지만 연료통의 무게로 인하여 속도가 느려지고, 안정성에도 문제가 있을 수 있다. 한편 작은 연료통을 장착하면 비행기의 속도가 빨라지는 장점이 있지만 중간에 내려서 급유를 받아야 하는 횟수가 많아지는 단점이 있다. 문제는 중간에 내려서 급유를 받는 횟수가 k이하 일 때 연료통의 최소용량을 구하는 것이다. 아래 예를 보자.

위 그림은 S, T와 7개의 중간 비행장의 위치를 나타내고 있는 그림이다. 위 예제에서 중간급유를 위한 착륙 허용 최대횟수 k=2라면 S-a-b-T로 가는 항로가 S-p-q-T로 가는 항로 보다 연료통이 작게 된다. 왜냐하면, S-p-q-T항로에서 q-T의 길이가 매우 길어서 이 구간을 위해서 상당히 큰 연료통이 필요하기 때문이다. 문제는 이와 같이 중간에 최대 K번 내려서 갈 수 있을 때 최소 연료통의 크기가 얼마인지를 결정하여 출력하면 된다. 참고사항은 다음과 같다.

모든 비행기는 두 지점 사이를 반드시 직선으로 날아간다. 거리의 단위는 ㎞이고 연료의 단위는 ℓ(리터)이다. 1ℓ당 비행거리는 10㎞이고 연료주입은 ℓ단위로 한다.
두 위치간의 거리는 평면상의 거리이다. 예를 들면, 두 점 g=(2,1)와 h=(37,43)간의 거리 d(g,h)는 \(\sqrt{(2-37)^2 + (1-43)^2}\) = 54.671... 이고 50＜d(g,h)≤60이므로 필요한 연료는 6ℓ가 된다.
출발지 S의 좌표는 항상 (0,0)이고 목적지 T의 좌표는 (10000,10000)으로 모든 입력 데이터에서 고정되어 있다.
출발지와 목적지를 제외한 비행장의 수 n은 3≤n≤1000이고 그 좌표 값 (x,y)의 범위는 0＜x,y＜10000의 정수이다. 그리고 최대 허용 중간급유 횟수 k는 0≤k≤1000이다.
<입력값>
첫 줄에는 n과 k가 하나의 공백을 사이에 두고 주어진다. 그 다음 n개의 줄에는 각 비행장 (급유지)의 정수좌표가 x y 형식으로 주어진다.
<출력값>
S에서 T까지 k번 이하로 중간급유 하여 갈 수 있는 항로에서의 최소 연료통 용량에 해당되는 정수를 출력한다.

<문제 2586>
직선 위에 여러 개의 소방 펌프가 있다. 여러 대의 소방차가 물을 채우기 위해서 급하게 이 직선 위에 정차했다. 펌프의 수는 소방차의 수 보다 크거나 같다.



	그림에는 두 대의 소방차 (위치는 27과 73)가 세 개의 펌프 (위치는 12, 50, 81) 사이에 정차한 것을 보여 주고 있다.

	소방차에 물을 채우기 위해 펌프와 소방차 사이를 호스로 연결한다. 시간을 절약하기 위하여 모든 소방차에 동시에 물을 채우려 한다. 하나의 펌프에는 하나의 소방차만 연결할 수 있다. 사용하는 호스의 길이는 펌프와 소방차 사이의 거리이다.

	그림의 경우, 첫 번째 소방차는 첫 번째 펌프에 연결하고 (호스 길이는 15), 두 번째 소방차는 세 번째 펌프와 연결하면 (호스 길이는 8), 사용하는 호스 길이의 합은 23=15+8이다. 이렇게 하는 것이 호스 길이의 합을 최소로 한다.

	펌프들의 위치와 소방차들의 위치가 주어질 때, 호스 길이의 합을 최소로 하면서 펌프들을 소방차들에 연결하는 방법을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 펌프의 수를 나타내는 정수 P와 소방차의 수를 나타내는 정수 F가 주어진다. 1≤P≤100,000 이고 1≤F≤100,000 이며, P≥F 이다. 둘째 줄에는 펌프들의 위치를 나타내는 서로 다른 P개의 정수가 증가하는 순서로 주어진다. 셋째 줄에는 소방차들의 위치를 나타내는 서로 다른 F개의 정수가 증가하는 순서대로 주어진다. 펌프와 소방차가 같은 위치에 있을 수도 있다. 주어지는 정수는 모두 1,000,000 이하의 양수이다.
<출력값>
사용하는 호스 길이의 합을 출력한다. 출력 결과는 231-1을 넘지 않는다.

<문제 2587>
어떤 수들이 있을 때, 그 수들을 대표하는 값으로 가장 흔하게 쓰이는 것은 평균이다. 평균은 주어진 모든 수의 합을 수의 개수로 나눈 것이다. 예를 들어 10, 40, 30, 60, 30의 평균은

가 된다.

	평균 이외의 또 다른 대표값으로 중앙값이라는 것이 있다. 중앙값은 주어진 수를 크기 순서대로 늘어 놓았을 때 가장 중앙에 놓인 값이다. 예를 들어 10, 40, 30, 60, 30의 경우, 크기 순서대로 늘어 놓으면

	10 30 30 40 60

	이 되고 따라서 중앙값은 30 이 된다.

	다섯 개의 자연수가 주어질 때 이들의 평균과 중앙값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄부터 다섯 번째 줄까지 한 줄에 하나씩 자연수가 주어진다. 주어지는 자연수는 100 보다 작은 10 의 배수이다.
<출력값>
첫째 줄에는 평균을 출력하고, 둘째 줄에는 중앙값을 출력한다. 평균과 중앙값은 모두 자연수이다.

<문제 2588>
(세 자리 수) × (세 자리 수)는 다음과 같은 과정을 통하여 이루어진다.



	(1)과 (2)위치에 들어갈 세 자리 자연수가 주어질 때 (3), (4), (5), (6)위치에 들어갈 값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 (1)의 위치에 들어갈 세 자리 자연수가, 둘째 줄에 (2)의 위치에 들어갈 세자리 자연수가 주어진다.
<출력값>
첫째 줄부터 넷째 줄까지 차례대로 (3), (4), (5), (6)에 들어갈 값을 출력한다.

<문제 2589>
보물섬 지도를 발견한 후크 선장은 보물을 찾아나섰다. 보물섬 지도는 아래 그림과 같이 직사각형 모양이며 여러 칸으로 나뉘어져 있다. 각 칸은 육지(L)나 바다(W)로 표시되어 있다. 이 지도에서 이동은 상하좌우로 이웃한 육지로만 가능하며, 한 칸 이동하는데 한 시간이 걸린다. 보물은 서로 간에 최단 거리로 이동하는데 있어 가장 긴 시간이 걸리는 육지 두 곳에 나뉘어 묻혀있다. 육지를 나타내는 두 곳 사이를 최단 거리로 이동하려면 같은 곳을 두 번 이상 지나가거나, 멀리 돌아가서는 안 된다.

예를 들어 위와 같이 지도가 주어졌다면 보물은 아래 표시된 두 곳에 묻혀 있게 되고, 이 둘 사이의 최단 거리로 이동하는 시간은 8시간이 된다.

보물 지도가 주어질 때, 보물이 묻혀 있는 두 곳 간의 최단 거리로 이동하는 시간을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 보물 지도의 세로의 크기와 가로의 크기가 빈칸을 사이에 두고 주어진다. 이어 L과 W로 표시된 보물 지도가 아래의 예와 같이 주어지며, 각 문자 사이에는 빈 칸이 없다. 보물 지도의 가로, 세로의 크기는 각각 50이하이다.
<출력값>
첫째 줄에 보물이 묻혀 있는 두 곳 사이를 최단 거리로 이동하는 시간을 출력한다.

<문제 2590>
<그림 1>과 같이 정사각형 모양을 한 여섯 종류의 색종이가 있다. ①번 색종이는 한 변의 길이가 1cm이고, 차례대로 그 길이가 1cm씩 커져, ⑥번 색종이의 한 변의 길이는 6cm가 된다.

주어진 색종이를 <그림 2>와 같이 가로, 세로의 길이가 각각 6cm인 판 위에 붙이려고 한다. 색종이를 붙일 때는 색종이가 판의 경계 밖으로 삐져 나가서는 안되며, 색종이가 서로 겹쳐서도 안 된다. 또한 하나의 색종이는 하나의 판에만 붙여야 한다.

각 종류별로 색종이의 장수가 주어질 때, 그 색종이를 모두 붙이기 위해서 위와 같은 판이 최소 몇 개가 필요한지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄부터 여섯째 줄까지 각 종류의 색종이의 장수가 ①번부터 ⑥번까지 차례로 주어진다. 각 종류의 색종이의 장수는 최대 100이다.
<출력값>
첫째 줄에 필요한 판의 최소 개수를 출력한다.

<문제 2591>
1부터 34까지 수가 적힌 카드가 충분히 많이 있다. 이들 중 몇 장을 일렬로 늘어놓고, 그 숫자를 차례로 적었다. 예를 들어 아래와 같이 카드가 놓인 경우 숫자를 차례로 적으면 27123이 된다.



	나중에, 적어 놓은 것에 맞게 다시 카드를 늘어놓으려고 보니, 방법이 여러 가지일 수 있다는 것을 알았다. 예를 들어 27123의 경우 아래와 같이 여섯 가지 다른 방법이 있다.



	카드의 숫자를 차례로 적어 놓은 것이 주어질 때, 위와 같이 그것을 가지고 거꾸로 카드의 배열을 찾으려고 한다. 가능한 카드의 배열이 모두 몇 개인지 구하는 프로그램을 작성하시오.
<입력값>
첫 줄에 카드의 숫자를 차례로 적어 놓은 것이 주어지며, 이것은 최대 40자 이하의 숫자로 이루어진다.
<출력값>
첫 줄에 가능한 카드 배열이 몇 개인지를 출력한다.

<문제 2592>
어떤 수들이 있을 때, 그 수들을 대표하는 값으로 가장 흔하게 쓰이는 것은 평균이다. 평균은 주어진 모든 수의 합을 수의 개수로 나눈 것이다. 예를 들어 10, 40, 30, 60, 30, 20, 60, 30, 40, 50의 평균은

이 된다.

	평균 이외의 또 다른 대표값으로 최빈값이라는 것이 있다. 최빈값은 주어진 수들 가운데 가장 많이 나타나는 수이다. 예를 들어 10, 40, 30, 60, 30, 20, 60, 30, 40, 50 이 주어질 경우,

	30 이 세 번,

	40 과 60 이 각각 두 번,

	10, 20, 50 이 각각 한 번씩 나오므로, 최빈값은 30 이 된다.

	열 개의 자연수가 주어질 때 이들의 평균과 최빈값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄부터 열 번째 줄까지 한 줄에 하나씩 자연수가 주어진다. 주어지는 자연수는 1,000 보다 작은 10 의 배수이다.
<출력값>
첫째 줄에는 평균을 출력하고, 둘째 줄에는 최빈값을 출력한다. 최빈값이 둘 이상일 경우 그 중 하나만 출력한다. 평균과 최빈값은 모두 자연수이다.

<문제 2593>
N층으로 이뤄진 고층 아파트에 M대의 엘리베이터가 있다. 각 엘리베이터에는 1부터 M까지 번호가 매겨져있다.
아파트 관리인은 유지비를 줄이기 위하여 각 엘리베이터가 특정한 층에서만 서도록 하였다. 그 결과 i번 엘리베이터는 Xi번째 층에서부터 시작하여 매 Yi번째 층에서만 선다. 예를 들어 Xi = 4, Yi = 3이라면 i번 엘리베이터는 4층, 7층, 10층, …에서만 서게 된다.
이 아파트 A층에서 사는 철수는 B층에 있는 친구 집에 놀러 가려고 한다. 그런데 가능하면 엘리베이터를 타는 횟수를 줄이고 싶어 한다.
예를 들어 아파트가 총 12층이고, 엘리베이터가 3대 있으며, 각 엘리베이터가 다음과 같이 운행한다고 하자.

10층에서 8층으로 가기 위해서는 1번 - 2번 - 3번 엘리베이터를 차례로 탈 수도 있고, 1번 - 3번 엘리베이터를 탈 수도 있다. 어떤 방법이든 최소 두 번 엘리베이터를 타야한다.
N과 M 그리고 엘리베이터 운행 정보가 주어질 때 철수가 최소 몇 번 엘리베이터를 타야하는지와 타야할 엘리베이터의 순서를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 N과 M이 빈 칸을 사이에 두고 주어진다. 둘째 줄부터 M줄에 걸쳐 엘리베이터 번호 순서대로 Xi와 Yi가 빈 칸을 사이에 두고 주어지며, 마지막 줄에는 A와 B가 주어진다. N은 100,000이하, M은 100이하의 자연수이며, Xi, Yi, A, B는 모두 N이하의 자연수이다. A와 B는 서로 다른 수이다.
<출력값>
첫째 줄에는 A층에서 B층으로 가기 위해 최소 몇 번 엘리베이터를 타야하는지를 출력한다. 다음 줄부터 타야하는 엘리베이터의 번호를 한 줄에 하나씩 타는 순서대로 출력한다. 또한 엘리베이터를 타는 방법이 여러 가지인 경우에는 그 중의 한 방법만을 출력한다. 만약 A층에서 B층으로 갈 수 없다면 첫째 줄에 -1을 출력한다.

<문제 2594>
놀이공원에서 여러 개의 놀이기구를 맡아 일하는 세혁이와 근영이는 서로 좋아하는 사이이다. 그들은 쉬는 시간을 이용하여 둘만의 시간을 가지기를 원한다. 그래서 매일 일과 시작 전에 놀이기구의 운영 일정을 보고, 그날 둘이 함께할 수 있는 가장 긴 휴식시간이 언제인지를 찾으려고 한다.
놀이공원에서 일하는 모든 사람들은 어떤 놀이기구가 작동을 시작하기 10분 전부터, 모든 놀이기구가 작동을 멈춘 후 10분 후까지는 쉴 수 없고, 그 나머지 일과 시간에만 쉴 수 있다.
하루 일과를 시작하는 시각은 오전 10시이고, 일과를 마치는 시각은 오후 10시이다. 예를 들어 세 개의 놀이기구가 작동하는 시간이 다음과 같다고 하면,
놀이기구 1: 오전 10시 30분 ~ 오후 1시
놀이기구 2: 오후 7시 00분 ~ 오후 9시 10분
놀이기구 3: 오후 12시 30분 ~ 오후 4시 50분
세혁이와 근영이는 놀이기구 1이 운행되기 전에 20분, 놀이기구 3의 운행이 끝나고 놀이기구 2의 운행시작 전 사이에 1시간 50분, 놀이기구 2의 운행이 끝난 후에 40분 동안 쉴 수 있다. 따라서 둘이 함께할 수 있는 가장 긴 시간은 1시간 50분이다.
놀이기구 운영 일정이 주어질 때, 그 날 세혁이와 근영이가 함께할 수 있는 가장 긴 시간을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 놀이기구의 개수 N이 주어진다. 이어 N줄에 걸쳐 각 놀이기구의 운행시작 시각과 종료 시각이 빈 칸을 사이에 두고 주어진다. 시각은 시간단위 두 자리, 분 단위 두 자리로 구성되며 오후 1시는 13시, 오후 2시는 14시, ... , 오후 10시는 22시로 표현된다. N은 50 이하의 자연수이다.
<출력값>
첫째 줄에 세혁이와 근영이가 함께할 수 있는 가장 긴 시간을 분 단위로 출력한다. 만약 함께할 수 있는 시간이 없다면 첫째 줄에 0을 출력한다.

<문제 2595>
자연수 N의 양의 배수 중 각 자릿수를 이루는 숫자의 종류가 가장 적은 수를 찾으려고 한다.
예를 들어 N이 125인 경우, 125의 배수인 250은 2, 5, 0 세 개의 서로 다른 숫자로 이루어져 있다. 125의 또 다른 배수인 500은 5, 0 두 개의 서로 다른 숫자로 이루어져 있다. 125의 배수 중 각 자릿수를 이루는 숫자의 종류가 가장 적은 수 중 하나는 500이다.
N이 주어질 때 위의 조건을 만족하는 N의 가장 작은 양의 배수를 구하는 프로그램을 작성하시오.
<입력값>
N은 30,000이하의 자연수이다.
<출력값>
주어진 N에 대하여 위의 조건을 만족하는 N의 가장 작은 양의 배수를 첫째 줄에 출력한다.

<문제 2596>
병현이는 지은이에게 문자 A, B, C, D, E, F, G, H 로 쓰여진 편지를 날마다 보내는데, 컴퓨터로 보내는 비밀편지로, 한 문자마다 0 또는 1인 숫자 여섯 개를 사용하여 보낸다. 둘 사이의 약속은 다음과 같다.

A 000000
B 001111
C 010011
D 011100
E 100110
F 101001
G 110101
H 111010

병현이가 어느 날 001111000000011100 을 보내면 지은이는 이것을 BAD로 이해하게 된다. 그런데 둘 사이에 약속이 잘 만들어져 있기 때문에, 통신에 문제가 생겨서 한 문자를 표시하는 여섯 숫자 중 어느 한 숫자만 틀리게 오는 경우, 지은이는 원래 보내려는 문자를 알아 낼 수가 있다.
예를 들어 지은이가 000100을 받았을 때, A와 숫자 한자만 다르고, 다른 문자들과는 각각 숫자 두 자 이상이 다르므로 지은이는 이것이 A라고 알아보게 된다.
다만 111111과 같이 모든 문자의 표현과 숫자 두 자 이상이 다른 경우에는 무슨 문자인지 알 수가 없게 된다. 예를 들어 지은이가 011111000000111111000000111111 을 받았을 때, BA 다음에 알아 볼 수 없는 문자가 나오는데. 이 경우 이런 것이 처음 나오는 문자의 위치인 3을 출력한다.
지은이가 받은 편지를 보고 문자들을 알아내어 출력하거나, 모르는 문자가 있는 경우, 이것이 처음 나오는 위치를 출력하는 프로그램을 작성하시오.
<입력값>
첫줄에는 보낸 문자의 개수(10개 보다 작다.)가 입력된다. 다음 줄에는 문자의 개수의 여섯 배 만큼의 숫자 입력이 주어진다.
<출력값>
주어진 입력에서 지은이가 이해한 문자들을 출력하거나, 모르는 문자가 나오는 경우 그런 것이 처음 나오는 위치를 출력한다.

<문제 2597>
준성이는 1㎝ 간격으로 눈금이 매겨져 있는 줄자를 가지고 있다. 그 줄자에 있는 서로 다른 눈금 6개에 한 눈금에 하나씩 점이 찍혀 있는데, 빨간 점, 파란 점, 노란 점이 각각 두 개씩 있다.

	준성이는 먼저 빨간 점이 만나도록 줄자를 접었다. 그런 후 두 파란 점이 만나도록 줄자를 접고, 또 다시 두 노란 점이 만나도록 줄자를 접었다. 줄자는 투명하여 접더라도 점들을 잘 볼 수 있다. 어떤 색깔의 두 점이 만나도록 줄자를 접었을 때, 그 다음에 접으려는 색깔의 두 점이 이미 만나고 있으면, 그 두 점에 대해서는 줄자를 접지 않는다.

	예를 들어 길이 10㎝ 인 줄자에 아래 그림과 같이 2㎝ 와 7㎝ 위에에 두 빨간 점이 찍혀 있고, 5㎝ 와 4㎝위치에 파란 점이, 10㎝ 와 3㎝ 위치에 노란 점이 찍혀 있다고 하자. (그림에서 빨간 점은 별표로, 파란 점은 동그라미, 그리고 노란 점은 네모로 표시되어 있다.) 빨간 두 점이 만나도록 줄자를 접으면 줄자의 4.5㎝ 위치에서 접히고 4㎝ 와 5㎝ 눈금이 서로 만나게 된다. 그러면 줄자의 왼쪽 부분의 길이는 4.5㎝ 이고 오른쪽 부분의 길이는 5.5㎝가 되어, 접힌 줄자의 길이는 5.5㎝ 가 된다. 파란 두 점은 이미 만나므로 줄자를 접지 않고, 그런 다음 노란 두 점이 만나도록 접으면 줄자의 길이는 3.5㎝ 가 된다.



	줄자의 길이와 각 색깔의 점들이 찍혀있는 위치가 주어질 때, 준성이가 빨간 색, 파란 색, 노란 색의 순서로 두 점이 만나도록 줄자를 접으면 줄자의 길이가 얼마가 되는지를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 줄자의 길이가 입력된다. 줄자의 길이는 10㎝ 이상, 1,000㎝ 이하이고 단위를 나타내는 ㎝은 입력되지 않는다. 둘째 줄에는 두 빨간 점의 위치를 나타내는 정수가 빈칸을 사이에 두고 입력된다. 셋째 줄에는 두 파란 점의 위치가, 넷째 줄에는 두 노란 점의 위치를 나타내는 정수가 빈칸을 사이에 두고 입력된다. 모든 점들의 위치는 서로 다르다.
<출력값>
한 줄에 접은 후의 줄자의 길이를 소수점 이하 한자리까지 출력한다. 소수점 이하 한자리가 0 이면 0 도 출력한다.(예 4.0)

<문제 2598>
주사위 모양의 정육면체에 각 면이 빨강(R), 초록(G), 파랑(B), 노랑(Y) 가운데 어떤 색으로 칠해져 있다. 이러한 정육면체 4개를 기둥 모양으로 쌓아 올려서 기둥의 각 옆면에 4가지 색이 모두 나타나게 하고 싶다. 이러한 기둥을 모두 몇 개나 만들 수 있는지 구하는 프로그램을 작성하시오.



	정육면체를 쌓을 때 1번 정육면체를 맨 아래에 놓고, 그 위에 2번 정육면체, 3번 정육면체, 맨 위에 4번 정육면체를 놓는다. 각 정육면체는 마음대로 위치를 바꾸어서 놓을 수 있다. 예를 들어서, 그림 1과 같은 4개의 정육면체를 쌓아서 그림 2와 그림 3의 두 개의 기둥을 만들 수 있다.

	하지만, 기둥을 옆으로 회전시켜서 같은 모양이 되는 것은 같은 기둥으로 본다. 예를 들어서 그림 3에 있는 기둥과 그림 4에 있는 기둥은 같은 기둥이다. 기둥의 윗면의 색이 다른 것은 다른 기둥이며, 기둥의 밑면은 보이지 않으므로 고려하지 않는다.
<입력값>
첫줄에는 1번 정육면체, 두 번째 줄에 2번 정육면체, 세 번째 줄에 3번 정육면체, 네 번째 줄에 4번 정육면체가 입력된다. 각 줄은 6개의 영문자로 이루어진다. 영문자는 R, G, B, Y 중의 하나이다. 6개의 영문자는 순서대로 그림 5의 가, 나, 다, 라, 마, 바 면의 색을 나타낸다.
<출력값>
조건을 만족하는 기둥의 개수를 출력한다. 조건을 만족하는 기둥이 하나도 만들어지지 않으면 0을 출력한다.

<문제 2599>
어떤 시골의 중학교에는 부근의 3개 초등학교를 졸업한 남녀 학생들이 입학한다. 1학년 1반을 맡게 된 김갑동 선생님은 자기 반에 배정된 학생들을 대상으로 하여 짝을 정하려고 한다. 1학년 1반에 배정 된 학생들은 남자와 여자가 각각 N 명씩이다. 김갑동 선생님은 서로 모르는 학생끼리 짝이 되도록 하기 위해 같은 초등학교 출신이 아닌 남학생과 여학생을 짝으로 정하기로 원칙을 세웠다. 예를 들어, 다음 표와 같이 1학년 1반에 학생들이 왔다고 하자.



	위의 경우에는 다음과 같이 짝을 하면 서로 다른 초등학교 출신의 남녀 학생들로 짝을 정할 수 있다.

	A초등 남학생 3명과 B초등 여학생 3명

	A초등 남학생 1명과 C초등 여학생 1명

	B초등 남학생 1명과 A초등 여학생 1명

	C초등 남학생 1명과 A초등 여학생 1명

	김갑동 선생님의 문제를 해결하는 프로그램을 작성하시오.
<입력값>
첫 줄에는 남학생 (또는, 여학생) 수를 나타내는 정수 N (3≤N≤100,000)이 주어진다. 둘째 줄에는 A초등학교 출신의 남학생 수와 여학생 수가 주어진다. 셋째 줄에는 B초등학교 출신의 남학생 수와 여학생 수가 주어진다. 넷째 줄에는 C초등학교 출신의 남 학생 수와 여학생 수가 주어진다. 모든 학생수는 0 이상이다.
<출력값>
김갑동 선생님의 원칙대로 모든 학생들의 짝을 정할 수 있으면 첫 줄에 1을 출력하고, 그렇지 않으면 0을 출력한다.

	첫 줄에 1을 출력한 경우는, 

	둘째 줄에 A초등 남학생과 B초등 여학생의 짝 수와 A초등 남학생과 C초등 여학생의 짝 수를, 

	셋째 줄에 B초등 남학생과 A초등 여학생의 짝 수와 B초등 남학생과 C초등 여학생의 짝 수를, 

	넷째 줄에 C초등 남학생과 A초등 여학생의 짝 수와 C초등 남학생과 B초등 여학생의 짝 수를 출력한다. 

	숫자와 숫자 사이에는 빈칸을 하나 둔다.

	짝 정하는 방법이 여럿인 경우에는 아무거나 한 방법을 출력한다.

<문제 2600>
두 사람 A와 B가 번갈아 가면서 두 개의 구슬 통에서 몇 개씩의 구슬을 꺼내는 게임을 한다.

	한번에 한 사람이 한 통에서 꺼낼 수 있는 구슬의 개수는 세 가지 뿐이다. 그리고 구슬을 꺼낼 경우 두 개의 구슬 통 중에서 하나를 마음대로 선택해서 그 안에서만 꺼낼 수 있다. 즉 두 개의 통 모두에서 동시에 몇 개씩 꺼낼 수는 없다.

	게임은 항상 A가 먼저하고 그 다음 B, 그 다음 A 순으로 번갈아가면서 진행된다. 그리고 자신의 차례 가 되었을 때에 정해진 규칙대로 구슬을 꺼낼 수 없는 사람이 게임에서 지게 되고, 상대방은 승리하게 된다.

	예를 들어 한번에 꺼낼 수 있는 구슬의 개수를 1개, 3개, 또는 4개라고 하자. 만일 두 개의 구슬 통 에 각각 4개, 1개의 구슬이 있다고 하면 처음 선택을 하게 되는 A가 이긴다. 그러나 만일 두 통속의 구슬이 각각 5개, 5개라면 B가 이긴다.

	즉 한번에 꺼낼 수 있는 구슬 개수인 b1 , b2 , b3가 주어지고, 두 구슬 통 속에 들어있는 구슬의 수 인 k1, k2이 정해지면, 이러한 b1 , b2 , b3와 k1, k2에 따라서 승패는 결정된다. 문제는 주어진 b1 , b2 , b3와 k1, k2에 대하여 A, B중 누가 승자인지를 결정하는 것이다.

	처음 두 통 속에 들어 있는 구슬의 수 k1, k2와 한 번에 꺼낼 수 있는 구슬의 수 b1 , b2 , b3에 대 한 제한조건은 다음과 같다.

	1≤b1 < b2< b3 ≤30 

	1≤k 1, k 2 ≤500
<입력값>
첫 줄에는 한번에 꺼낼 수 있는 구슬의 개수를 나타내는 세 개 의 정수 b1 , b2, b3 가 나타난다. 그 다음 5개의 각 줄에는 두 통속에 처음 담겨있는 구슬의 개수 k1, k2가 각각 표시되어 있다.
<출력값>
각 5개의 k1 , k2 경우에 대하 여 그에 대응되는 승자(A 또는 B)를 각각 한 줄에 하나씩 차례대로 다섯 개를 출력해야 한다.

<문제 2601>
우리 학교는 다른 학교가 부러워하는 도서실을 가지고 있다. 장서를 다량 보유하고 있을 뿐 아니라 전자도서를 볼 수 있는 컴퓨터도 여러 대 설치되어 있고, 바닥에는 카펫이 깔려있다. 최근 도서실의 가구배치를 새로 하게 되었는데, 가구가 놓여있던 자리에는 얼룩이 져서 아주 보기가 흉하였다. 그래서 새로산 카펫 한 장으로 얼룩진 부분을 가리기로 하였다.

	도서실은 직사각형 모양이고, 얼룩진 부분도 모두 직사각형 모양이며, 변은 도서실 벽과 평행하다. 새 카펫은 정사각형이다. 이 정사각형 카펫을 도서실의 벽과 평행하도록 놓는데, 완전히 가려지는 얼룩의 수를 최대화 하고자 한다.

	예를 들어, 다음 그림과 같이 얼룩이 위치하고 있다고 하자. 점선으로 표시된 여분의 카펫으로 완전히 가릴 수 있는 얼룩의 최대 수는 4개가 되고, 이러한 카펫의 위치는 유일하지 않을 수 있다.



	이러한 카펫으로 완전히 가려지는 최대 얼룩의 수를 구하는 프로그램을 작성하시오.
<입력값>
모든 사각형의 좌표는 1,000,000 보다 작은 음이 아닌 정수이고 가로 세로의 길이는 1,000,000 보다 작은 양의 정수이다. 얼룩 직사각형은 서로 겹치지 않지만 접할 수는 있다. 얼룩 직사각형과 카펫 정사각형은 당연히 도서실 직사각형에 완전히 포함된다. 얼룩 직사각형의 수는 최대 100,000개 이다.

	첫째 줄에는 도서실 직사각형의 왼쪽 위 꼭지 점과 오른쪽 아래 꼭지 점의 좌표가 주어진다. 둘째 줄에는 카펫 정사각형의 가로 길이가 주어진다. 셋째 줄에는 얼룩의 수가 주어지고, 넷째 줄부터는 얼룩 직사각형들의 왼쪽 위 꼭지 점과 오른쪽 아래 꼭지 점의 좌표가 주어진다.
<출력값>
첫 줄에 여분의 카펫으로 완전히 가릴 수 있는 얼룩의 최대 수를 출력한다.

<문제 2602>
절대반지를 얻기 위하여 반지원정대가 출발한다. 원정대가 지나가야할 다리는 두 개의 인접한 돌다리로 구성되어 있다. 하나는 <악마의 돌다리>이고 다른 하나는 <천사의 돌다리>이다.
아래 그림 1은 길이가 6인 다리의 한 가지 모습을 보여준다. 그림에서 위의 가로줄은 <악마의 돌다리>를 표시하는 것이고, 아래의 가로줄은 <천사의 돌다리>를 표시한다. 두 돌다리의 길이는 항상 동일하며, 각 칸의 문자는 해당 돌에 새겨진 문자를 나타낸다. 두 다리에 새겨진 각 문자는 {R, I, N, G, S} 중 하나이다.



출발
R
I
N
G
S
R
도착


G
R
G
G
N
S



반지원정대가 소유하고 있는 마법의 두루마리에 <악마의 돌다리>와 <천사의 돌다리>를 건너갈 때 반드시 순서대로 밟고 지나가야할 문자들이 적혀있다. 이 순서대로 지나가지 않으면 돌다리는 무너져 반지원정대는 화산 속으로 떨어지게 된다.
다리를 건널 때 다음의 제한 조건을 모두 만족하면서 건너야 한다.

왼쪽(출발지역)에서 오른쪽(도착지역)으로 다리를 지나가야 하며, 반드시 마법의 두루마리에 적힌 문자열의 순서대로 모두 밟고 지나가야 한다.
반드시 <악마의 돌다리>와 <천사의 돌다리>를 번갈아가면서 돌을 밟아야 한다. 단, 출발은 어떤 돌다리에서 시작해도 된다.
반드시 한 칸 이상 오른쪽으로 전진해야하며, 건너뛰는 칸의 수에는 상관이 없다. 만일 돌다리의 모양이 그림 1과 같고 두루마리의 문자열이 "RGS"라면 돌다리를 건너갈 수 있는 경우는 다음의 3가지 뿐이다. (아래 그림에서 빨간색 문자는 밟고 지나가는 돌다리를 나타낸다.)




출발
R
I
N
G
S
R
도착


G
R
G
G
N
S






출발
R
I
N
G
S
R
도착


G
R
G
G
N
S






출발
R
I
N
G
S
R
도착


G
R
G
G
N
S



아래의 세 방법은 실패한 방법이다.



출발
R
I
N
G
S
R
도착


G
R
G
G
N
S






출발
R
I
N
G
S
R
도착


G
R
G
G
N
S






출발
R
I
N
G
S
R
도착


G
R
G
G
N
S



왜냐하면 첫 번째는 문자열 "RGS"를 모두 밟고 지나가야 하는 조건 1)을 만족하지 않으며, 두 번째는 번갈아가면서 돌을 밟아야 하는 조건 2)를, 세 번째는 앞으로 전진을 하여야하는 조건 3)을 만족하지 않기 때문이다.
마법의 두루마리에 적힌 문자열과 두 다리의 돌에 새겨진 문자열이 주어졌을 때, 돌다리를 통과할 수 있는 모든 가능한 방법의 수를 계산하는 프로그램을 작성하시오. 예를 들어, 그림 1의 경우는 통과하는 방법이 3가지가 있으므로 3을 출력해야 한다.
<입력값>
첫째 줄에는 마법의 두루마리에 적힌 문자열(R, I, N, G, S 로만 구성된)이 주어진다. 이 문자열의 길이는 최소 1, 최대 20 이다. 그 다음 줄에는 각각 <악마의 돌다리>와 <천사의 돌다리>를 나타내는 같은 길이의 문자열이 주어진다. 그 길이는 1 이상, 100 이하이다.
<출력값>
마법의 두루마리에 적힌 문자열의 순서대로 다리를 건너갈 수 있는 방법의 수를 출력한다. 그러한 방법이 없으면 0을 출력한다.
모든 테스트 데이터에 대한 출력결과는 231-1 이하이다.

<문제 2603>
세 국가 A, B, C는 서로 국경을 마주하고 있으며, 각 국가에는 N개의 도시들이 있다. 이들 도시들에 대하여 국경을 통과하는 고속버스 노선을 N개 만들려고 한다. 전체 3N개의 도시들 중에서 2N개의 도 시들은 노선의 출발지 또는 도착지로 하고, 나머지 N개의 도시들은 어떤 노선의 중간 경유지가 되도록 고속버스 노선을 정하려고 한다. N개의 각 노선의 (출발지, 도착지)는 미리 주어져 있으며, 각 노선의 출발지와 도착지는 서로 다르다. 이때, 정하고자 하는 노선들은 다음 조건들을 모두 만족해야 한다.
(1) 출발지 또는 도착지가 아닌 도시는 임의의 노선의 중간 경유지가 될 수 있고, 반드시 어떤 노선의 중간 경유지로 포함되어야 하며, 하나의 노선에만 포함될 수 있다.
(2) 하나의 노선은 2개 이하의 중간 경유지를 갖는다. 노선에 중간 경유지를 포함할 때, 이 중간 경유지가 속한 국가는 출발지나 도착지가 속한 국가와는 달라야 한다. 그리고 노선의 중간 경유지가 2개인 경우에 이들 두 경유지는 모두 같은 국가에 속할 수 없다. (그러므로 출발지와 도착지가 서로 다른 국가에 속하는 노선은 많아야 1개의 중간 경유지만 가질 수 있다.)
(3) 출발지와 도착지가 같은 국가에 속한 노선은 반드시 1개 이상의 중간 경유지를 포함해야 한다. 각 도시의 이름은 국가이름과 번호로 나타낸다 (1 ≤번호 ≤N). A1은 국가 A의 1번 도시의 이름이고, B3은 국가 B의 3번 도시의 이름이다. 여기서 국가이름과 번호 사이에는 공백이 없다.
예를 들어, 각 국가에 3개의 도시가 있다 하자. 그리고 세 노선의 출발지, 도착지가 각각 (A1, B1), (A2, A3), (B2, C2)라 하자. 그러면 세 개의 노선을 다음과 같이 만들 수 있다.
노선 1: A1→C1→B1
노선 2: A2→B3→C3→A3
노선 3: B2→C2
출발지와 도착지의 쌍이 N개 주어진 경우, 위의 조건들을 만족하는 고속버스 노선들을 항상 정할 수 있다. 이러한 노선들을 출력하는 프로그램을 작성하시오. 만약 위의 조건들을 만족하는 고속버스 노선들 의 집합이 여러 개일 경우 임의의 하나만 출력하면 된다.
<입력값>
첫째 줄에는 도시들의 개수를 나타내는 정수 N(1≤N≤50,000) 이 주어진다. 둘째 줄부터 N + 1번째 줄까지 각 줄에 노선의 출발지와 도착지가 공백을 사이에 두고 주어진다.
<출력값>
첫째 줄부터 N번째 줄까지 입력에 주어진 노선 순서대로 각 줄에 해당 노선에 포함되는 도시들의 이름을 출발지부터 도착지까지 순서대로 출력한다. 한 노선에 속 하는 도시이름과 도시이름 사이에는 공백을 하나 둔다.

<문제 2604>
현재 KOI 마을의 논들은 전체 모양이 직사각형인 토지를 아래의 그림과 같이 선분인 논둑을 경계로 나누어져 있다. KOI 마을의 김 하진 이장님은 마을 회의를 열어 논 관리와 벼농사를 효율적으로 하기 위해 각각의 논을 같은 면적의 직사각형 모양이 되도록 농지를 정리하기로 하였다. 이렇게 농지 정리를 하기 위해서는 현재 분할되어 있는 각 논들의 정확한 면적을 알아야 한다.

현재 분할된 논들을 표현하기 위해 마을 전체의 토지인 직사각형의 가로, 세로의 크기를 나타내는 정 수들 w와 h가 주어지고, 그리고 선분인 각 논둑의 양 끝점의 위치 (x1, y1)과 (x2, y2)가 주어져 있다. 여기서 마을 전체의 직사각형 토지의 왼쪽 아래 모퉁이의 위치는 (0, 0)이고, 오른쪽 위 모퉁이의 위치는 (w, h)이다.
분할된 모습이 위와 같이 주어진 KOI 마을의 논들 가운데 면적이 가장 큰 논의 면적을 계산하여 출력 하는 프로그램을 작성하시오. 여기서 논둑이 차지하는 면적은 0이라 가정한다. 위의 그림에서 면적이 가장 큰 논은 빗금 친 부분이고 그 면적은 13이다.
<입력값>
첫째 줄에는 마을 전체의 토지인 직사각형의 가로와 세로의 길이를 나타내는 두 정수 w와 h가 주어진다. (1 ≤ w, h ≤ 20,000) 둘째 줄에는 선분인 논둑의 개수 N이 정수로 주어진다. (1 ≤ N ≤ 4,000) 그 다음 N줄에는 각 줄에 논둑의 양 끝점의 위치를 나타내는 네 정수 x1, y1, x2, y2가 한 줄로 주어진다. (0 ≤ x1, x2 ≤ w, 0 ≤ y1, y2 ≤ h) 각 선분은 양 끝점 외에는 다른 선분과 만나지 않는다.
<출력값>
입력으로 주어진 분할된 논들 가운데 면적이 가장 큰 논의 면적을 계산하여 출력하면 된다. 면적은 소수점 이하 한자리까지 계산한다.

<문제 2605>
점심시간이 되면 반 학생 모두가 한 줄로 줄을 서서 급식을 탄다. 그런데 매일 같이 앞자리에 앉은 학생들이 앞에 줄을 서 먼저 점심을 먹고, 뒷자리에 앉은 학생들은 뒤에 줄을 서 늦게 점심을 먹게 된다. 어떻게 하면 이러한 상황을 바꾸어 볼 수 있을까 고민하던 중 선생님이 한 가지 방법을 내 놓았다. 그 방법은 다음과 같다.
학생들이 한 줄로 줄을 선 후, 첫 번째 학생부터 차례로 번호를 뽑는다. 첫 번째로 줄을 선 학생은 무조건 0번 번호를 받아 제일 앞에 줄을 선다. 두 번째로 줄을 선 학생은 0번 또는 1번 둘 중 하나의 번호를 뽑는다. 0번을 뽑으면 그 자리에 그대로 있고, 1번을 뽑으면 바로 앞의 학생 앞으로 가서 줄을 선다. 세 번째로 줄을 선 학생은 0, 1 또는 2 중 하나의 번호를 뽑는다. 그리고 뽑은 번호만큼 앞자리로 가서 줄을 선다. 마지막에 줄을 선 학생까지 이와 같은 방식으로 뽑은 번호만큼 앞으로 가서 줄을 서게 된다. 각자 뽑은 번호는 자신이 처음에 선 순서보다는 작은 수이다.
예를 들어 5명의 학생이 줄을 서고, 첫 번째로 줄을 선 학생부터 다섯 번째로 줄을 선 학생까지 차례로 0, 1, 1, 3, 2번의 번호를 뽑았다고 하자, 첫 번째 학생부터 다섯 번째 학생까지 1부터 5로 표시하면 학생들이 줄을 선 순서는 다음과 같이 된다.

첫 번째 학생이 번호를 뽑은 후 : 1
두 번째 학생이 번호를 뽑은 후 : 2 1
세 번째 학생이 번호를 뽑은 후 : 2 3 1
네 번째 학생이 번호를 뽑은 후 : 4 2 3 1
다섯 번째 학생이 번호를 뽑은 후 : 4 2 5 3 1

따라서 최종적으로 학생들이 줄을 선 순서는 4, 2, 5, 3, 1이 된다.
줄을 선 학생들이 차례로 뽑은 번호가 주어질 때 학생들이 최종적으로 줄을 선 순서를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 학생의 수가 주어지고 둘째 줄에는 줄을 선 차례대로 학생들이 뽑은 번호가 주어진다. 학생의 수가 100 이하이고, 학생들이 뽑는 번호는 0 또는 자연수이며 학생들이 뽑은 번호 사이에는 빈 칸이 하나씩 있다.
<출력값>
학생들이 처음에 줄을 선 순서대로 1번부터 번호를 매길 때, 첫째 줄에 학생들이 최종적으로 줄을 선 순서를 그 번호로 출력한다. 학생 번호 사이에는 한 칸의 공백을 출력한다.

<문제 2606>
신종 바이러스인 웜 바이러스는 네트워크를 통해 전파된다. 한 컴퓨터가 웜 바이러스에 걸리면 그 컴퓨터와 네트워크 상에서 연결되어 있는 모든 컴퓨터는 웜 바이러스에 걸리게 된다.
예를 들어 7대의 컴퓨터가 <그림 1>과 같이 네트워크 상에서 연결되어 있다고 하자. 1번 컴퓨터가 웜 바이러스에 걸리면 웜 바이러스는 2번과 5번 컴퓨터를 거쳐 3번과 6번 컴퓨터까지 전파되어 2, 3, 5, 6 네 대의 컴퓨터는 웜 바이러스에 걸리게 된다. 하지만 4번과 7번 컴퓨터는 1번 컴퓨터와 네트워크상에서 연결되어 있지 않기 때문에 영향을 받지 않는다.

어느 날 1번 컴퓨터가 웜 바이러스에 걸렸다. 컴퓨터의 수와 네트워크 상에서 서로 연결되어 있는 정보가 주어질 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 컴퓨터의 수가 주어진다. 컴퓨터의 수는 100 이하이고 각 컴퓨터에는 1번 부터 차례대로 번호가 매겨진다. 둘째 줄에는 네트워크 상에서 직접 연결되어 있는 컴퓨터 쌍의 수가 주어진다. 이어서 그 수만큼 한 줄에 한 쌍씩 네트워크 상에서 직접 연결되어 있는 컴퓨터의 번호 쌍이 주어진다.
<출력값>
1번 컴퓨터가 웜 바이러스에 걸렸을 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 첫째 줄에 출력한다.

<문제 2607>
영문 알파벳 대문자로 이루어진 두 단어가 다음의 두 가지 조건을 만족하면 같은 구성을 갖는다고 말한다.

두 개의 단어가 같은 종류의 문자로 이루어져 있다.
같은 문자는 같은 개수 만큼 있다.

예를 들어 "DOG"와 "GOD"은 둘 다 'D', 'G', 'O' 세 종류의 문자로 이루어져 있으며 양쪽 모두 'D', 'G', 'O' 가 하나씩 있으므로 이 둘은 같은 구성을 갖는다. 하지만 "GOD"과 "GOOD"의 경우 "GOD"에는 'O'가 하나, "GOOD"에는 'O'가 두 개 있으므로 이 둘은 다른 구성을 갖는다.
두 단어가 같은 구성을 갖는 경우, 또는 한 단어에서 한 문자를 더하거나, 빼거나, 하나의 문자를 다른 문자로 바꾸어 나머지 한 단어와 같은 구성을 갖게 되는 경우에 이들 두 단어를 서로 비슷한 단어라고 한다.
예를 들어 "DOG"와 "GOD"은 같은 구성을 가지므로 이 둘은 비슷한 단어이다. 또한 "GOD"에서 'O'를 하나 추가하면 "GOOD" 과 같은 구성을 갖게 되므로 이 둘 또한 비슷한 단어이다. 하지만 "DOG"에서 하나의 문자를 더하거나, 빼거나, 바꾸어도 "DOLL"과 같은 구성이 되지는 않으므로 "DOG"과 "DOLL"은 비슷한 단어가 아니다.
입력으로 여러 개의 서로 다른 단어가 주어질 때, 첫 번째 단어와 비슷한 단어가 모두 몇 개인지 찾아 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 단어의 개수가 주어지고 둘째 줄부터는 한 줄에 하나씩 단어가 주어진다. 모든 단어는 영문 알파벳 대문자로 이루어져 있다. 단어의 개수는 100개 이하이며, 각 단어의 길이는 10 이하이다.
<출력값>
입력으로 주어진 첫 번째 단어와 비슷한 단어가 몇 개인지 첫째 줄에 출력한다.

<문제 2608>
로마 시대 때는 현재 사용하는 아라비아 숫자가 아닌 다른 방법으로 수를 표현하였다.
로마 숫자는 다음과 같은 7개의 기호로 이루어진다.



기호
I
V
X
L
C
D
M




값
1
5
10
50
100
500
1000



수를 만드는 규칙은 다음과 같다.

보통 큰 숫자를 왼쪽에 작은 숫자를 오른쪽에 쓴다. 그리고 그 값은 모든 숫자의 값을 더한 값이 된다. 예를 들어 LX = 50 + 10 = 60 이 되고, MLI = 1000 + 50 + 1 = 1051 이 된다.
V, L, D는 한 번만 사용할 수 있고 I, X, C, M은 연속해서 세 번까지만 사용할 수 있다. 예를 들어 VV나 LXIIII 와 같은 수는 없다. 그리고 같은 숫자가 반복되면 그 값은 모든 숫자의 값을 더한 값이 된다. 예를 들어 XXX = 10 + 10 + 10 = 30 이 되고, CCLIII = 100 + 100 + 50 + 1 + 1 + 1 = 253 이 된다.
작은 숫자가 큰 숫자의 왼쪽에 오는 경우는 다음과 같다. IV = 4, IX = 9, XL = 40, XC = 90, CD = 400, CM = 900 을 나타낸다. 이들 각각은 한 번씩만 사용할 수 있다. 그런데 IV 와 IX 는 같이 쓸 수 없으며 XL 과 XC, CD 와 CM 또한 같이 쓸 수 없다. 이들 외에는 작은 숫자가 큰 숫자 왼쪽 어디에도 나올 수 없다. 예를 들어 XCXC 나 CMCD, VX 나 IIX 와 같은 수는 없다. 참고로 LIX = 50 + 9 = 59, CXC = 100 + 90 = 190 이 된다.
모든 수는 가능한 가장 적은 개수의 로마 숫자들로 표현해야 한다. 예를 들어 60 은 LX 이지 XLXX 가 아니고, 5 는 V 이지 IVI 가 아니다.

아래의 예를 참고 하시오.

DLIII = 500 + 50 + 3 = 553
MCMXL = 1000 + 900 + 40 = 1940
235 = CCXXXV
2493 = MMCDXCIII

로마 숫자로 이루어진 두 수를 입력받아 그 둘을 더한 값을 아라비아 숫자와 로마 숫자로 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄과 둘째 줄에 하나씩 로마 숫자로 표현된 수가 주어진다. 입력된 각 수는 2000 보다 작거나 같고, 두 수의 합은 4000보다 작다.
<출력값>
입력으로 주어진 두 수를 더한 값을 첫째 줄에 아라비아숫자로 출력하고 둘째 줄에는 로마 숫자로 출력한다.

<문제 2609>
두 개의 자연수를 입력받아 최대 공약수와 최소 공배수를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 두 개의 자연수가 주어진다. 이 둘은 10,000이하의 자연수이며 사이에 한 칸의 공백이 주어진다.
<출력값>
첫째 줄에는 입력으로 주어진 두 수의 최대공약수를, 둘째 줄에는 입력으로 주어진 두 수의 최소 공배수를 출력한다.

<문제 2610>
KOI 준비를 위해 회의를 개최하려 한다. 주최측에서는 회의에 참석하는 사람의 수와 참석자들 사이의 관계를 따져 하나 이상의 위원회를 구성하려고 한다. 위원회를 구성하는 방식은 다음과 같다.

서로 알고 있는 사람은 반드시 같은 위원회에 속해야 한다.
효율적인 회의 진행을 위해 위원회의 수는 최대가 되어야 한다.

이런 방식으로 위원회를 구성한 후에 각 위원회의 대표를 한 명씩 뽑아야 한다. 각 위원회의 대표만이 회의 시간 중 발언권을 가지며, 따라서 회의 참석자들이 자신의 의견을 말하기 위해서는 자신이 속한 위원회의 대표에게 자신의 의견을 전달해야 한다. 그런데 각 참석자는 자신이 알고 있는 사람에게만 의견을 전달할 수 있어 대표에게 의견을 전달하기 위해서는 때로 여러 사람을 거쳐야 한다. 대표에게 의견을 전달하는 경로가 여러 개 있을 경우에는 가장 적은 사람을 거치는 경로로 의견을 전달하며 이때 거치는 사람의 수를 참석자의 의사전달시간이라고 한다.
위원회에서 모든 참석자들의 의사전달시간 중 최댓값이 최소가 되도록 대표를 정하는 프로그램을 작성하시오.
예를 들어 1번, 2번, 3번 세 사람으로 구성되어 있는 위원회에서 1번과 2번, 2번과 3번이 서로 알고 있다고 하자. 1번이 대표가 되면 3번이 대표인 1번에게 의견을 전달하기 위해서 2번을 거쳐야만 한다. 반대로 3번이 대표가 되어도 1번이 대표인 3번에게 의견을 전달하려면 2번을 거쳐야만 한다. 하지만 2번이 대표가 되면 1번과 3번 둘 다 아무도 거치지 않고 대표에게 직접 의견을 전달 할 수 있다. 따라서 이와 같은 경우 2번이 대표가 되어야 한다.
<입력값>
첫째 중에 회의에 참석하는 사람의 수 N이 주어진다. 참석자들은 1부터 N까지의 자연수로 표현되며 회의에 참석하는 인원은 100 이하이다. 둘째 줄에는 서로 알고 있는 관계의 수 M이 주어진다. 이어 M개의 각 줄에는 서로 아는 사이인 참석자를 나타내는 두개의 자연수가 주어진다.
<출력값>
첫째 줄에는 구성되는 위원회의 수 K를 출력한다. 다음 K줄에는 각 위원회의 대표 번호를 작은 수부터 차례로 한 줄에 하나씩 출력한다. 한 위원회의 대표가 될 수 있는 사람이 둘 이상일 경우 그중 한 명만 출력하면 된다.

<문제 2611>
자동차 경주로는 <그림 1>의 예와 같이 표현된다. 화살표는 각 지점을 잇는 도로를 의미하며 모든 도로는 일방통행 도로로 화살표 방향으로만 움직일 수 있다.

자동차 경주의 코스는 1번 지점에서 출발하여 다시 1번 지점으로 되돌아오는 것이다. 단, 중간에는 1번 지점을 지나서는 안 된다. 경주로는 1번 지점을 제외한 어느 지점에서 출발하여도 1번 지점을 지나가지 않고서는 같은 지점으로 돌아올 수 없도록 되어 있다. 또한 1번 지점에서 다른 모든 지점으로 갈 수 있고, 다른 모든 지점에서 1번 지점으로 갈 수 있다.
각 도로에는 <그림 2>의 예와 같이 그 도로를 지날 때 얻는 점수가 있다.

1번 지점에서 출발하여 가장 많은 점수를 얻어 다시 1번 지점으로 돌아오는 팀이 우승을 하게 된다. 가장 많은 점수를 얻어 1번 지점으로 돌아오는 경로를 찾아 그 얻는 점수와 경로를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 지점의 개수 N이 주어진다. 각 지점에는 1부터 N까지의 서로 다른 번호가 부여된다. 둘째 줄에는 도로의 개수 M이 주어진다. 이어 M개의 줄에는 p ,q ,r의 형식으로 도로의 정보가 주어지는데 이는 p번 지점부터 q번 지점으로 갈 수 있는 도로가 있고 그 도로에 부여된 점수가 r이라는 뜻이다. N은 1000이하의 자연수이고, p와 q는 1이상의 N이하의 자연수이며 r은 100이하의 자연수 이다. p와 q는 같지 않다.
<출력값>
가장 많은 점수를 얻은 경로를 찾아, 첫째 줄에는 그 얻는 점수를 출력하고 둘째 줄에는 그 경로를 출력한다. 경로를 출력할 때는 지나는 지점들의 번호를 사이에 한 칸의 공백을 두어 출력한다. 출력하는 경로는 반드시 1번 지점에서 시작하여 1번 지점으로 끝나야 한다. 만약 같은 점수를 얻는 경로가 둘 이상일 경우 그 중 하나만 출력하면 된다.

<문제 2612>
모든 생물의 DNA 서열은 A, C, G, T 네 개의 문자로 표현된다.
두 DNA 서열이 얼마나 비슷한가를 알아내기 위하여 유사도를 측정한다. 두DNA 서열의 유사도를 측정하기 위해서 먼저 각 서열의 임의의 위치에 공백을 넣어 길이를 같게 만든다.
이렇게 길이가 같아진 두 서열 간의 점수는 다음과 같이 계산된다.
1. 같은 위치에 공백이 아닌 같은 문자가 있으면 3을 더한다. 
2. 같은 위치에 서로 다른 문자가 있거나 둘 중 하나의 위치에 공백이 있으면 2를 뺀다.
두 DNA 서열의 유사도는 각 DNA 서열의 임의의 위치에 공백을 넣어 위의 방법대로 얻을 수 있는 최대 점수이다. 예를 들어 AGTCAG와 ATGTG라는 두 DNA서열의 경우 , <그림 1>과 같이 공백을 넣으면 점수가 3이 되고, <그림 2>와 같이 공백을 넣으면 점수는 6이 된다.

A G T C A G
|   |     |
A   T G T G
<그림 1>

A   G T C A G
|   | |     |
A T G T     G
<그림 2>
AGTCAG와 ATGTG의 경우 임의의 위치에 공백을 넣어 얻을 수 있는 최대 점수는 6이므로 AGTCAG와 ATGTG의 유사도는 6이 된다.
DNA 서열의 부분 서열은 DNA 서열 중 연속한 일부분을 추출하여 얻을 수 있는 서열을 말한다.예를 들어 AGTCAG라는 서열에서 첫 번째 문자부터 세 번째 문자까지를 추출하면 AGT라는 부분 서열을 얻을 수 있고,두 번째 문자부터 다섯 번째 문자까지 추출하면 GTCA라는 부분 서열을 얻을 수 있다.
두 DNA 서열에서 같은 정보를 담고 있는 부분을 찾아내는 방법 중에 하나는 두 DNA의 부분 서열 쌍 중 유사도가 가장 큰것을 찾아내는 것이다.
예를 들어 두 DNA 서열 AGTCAG 와 ATGTG의 경우 AGTCAG에서 부분 서열 AGT를 얻고, ATGTG에서 부분 서열 ATGT를 얻으면 이 둘의 유사도는 아래와 같이 7이 된다.

A   G T
|   | |
A T G T
두 DNA 서열을 입력받아 이들 DNA의 부분 서열 쌍 중 유사도가 가장 큰것을 찾아 그 유사도와 부분 서열 쌍을 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 첫 번째 DNA의 서열의 길이가 추어지고 둘째 줄에는 첫 번째 DNA서열이 주어진다. 셋째 줄에는 두 번째 DNA의 서열의 길이가 주어지고 넷째 줄에는 두 번째 DNA 서열이 주어진다. DNA 서열의 길이는 1000이하이며, DNA 서열을 나타내는 문자들 사이에는 공백이 없다. 첫 번째 DNA와 두 번째 DNA는 적어도 하나 이상 공통 문자를 갖는다.
<출력값>
첫째 줄에는 두 DNA 서열의 부분 서열 쌍 중 유사도가 가장 큰 것의 유사도를 출력한다. 둘째 줄과 셋째 줄에는 유사도가 가장 큰 부분 서열의 쌍을 출력하는데, 둘째 줄에는 첫 번째 DNA 서열에서 추출한 부분 서열을 출력하고, 셋째 줄에는 두 번째 DNA 서열에서 추출한 부분 서열을 출력한다. 만약 두 DNA 서열의 부분 서열 쌍 중 유사도가 가장 큰 쌍이 둘 이상일 경우 하나만 출력하면 된다.

<문제 2613>
N개의 숫자 구슬이 <그림 1>과 같이 막대에 꿰어져 일자로 놓여 있다. 이들 구슬은 막대에서 빼낼 수 없고, 바꿀 수 없다.

이 숫자 구슬을 M개의 그룹으로 나누었을 때 각각의 그룹의 합 중 최댓값이 최소가 되도록 하려 하다. 예를 들어 세 그룹으로 나눈다고 할 때 <그림 2>와 같이 그룹을 나누면 그룹의 합은 각각 11, 15, 18이 되어 그 중 최댓값은 18이 되고, <그림 3>과 같이 나누면 각 그룹의 합은 각각 17, 12, 15가 되어 그 중 최댓값은 17이 된다. 숫자 구슬의 배열이 위와 같을 때는 그룹의 합 중 최댓값이 17보다 작게 만들 수는 없다. 그룹에 포함된 숫자 구슬의 개수는 0보다 커야 한다.

각 그룹의 합 중 최댓값이 최소가 되도록 M개의 그룹으로 나누었을 때, 그 최댓값과 각 그룹을 구성하는 구슬의 개수를 찾아 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 구슬의 개수 N과 그룹의 수 M이 주어진다. 둘째 줄에는 각 구슬이 적혀진 숫자가 왼쪽부터 차례로 주어진다. N은 300 이하의 자연수, M은 N이하의 자연수이며, 구슬에 적혀진 숫자는 100 이하의 자연수이다.
<출력값>
각 그룹의 합 중 최댓값이 최소가 되도록 M개의 그룹으로 나누었을 때 그 최댓값을 첫째 줄에 출력하고, 둘째 줄에는 각 그룹을 구성하는 구슬의 개수를 왼쪽부터 순서대로 출력한다. 구슬의 개수를 출력할 때는 사이에 한 칸의 공백을 둔다. 만약 그룹의 합의 최댓값이 최소가 되도록 하는 경우가 둘 이상이라면 그 중 하나만을 출력한다.

<문제 2614>
항상 말썽을 일으키는 청개구리는 밤새 논으로 뛰어 들어 벼를 밟곤 한다. 농부는 아침에 벼가 쓰러진 상태를 보고 밤새 몇 마리의 청개구리가 논을 지나갔는지 알아내려고 한다.
논에는 벼가 일직선으로 심어져 있다. 각각의 벼가 심어진 지점에 남겨진 흔적을 살피면 그 지점을 몇 마리의 청개구리가 밟고 지나갔는지를 알 수 있다. 예를 들어 벼가 심어진 지점과 각 지점을 밟고 지나간 청개구리의 수가 <그림 1>과 같다고 하자.(원은 벼가 심어진 지점, 원 안의 숫자는 밟고 지나간 청개구리의 수이다.)

모든 청개구리는 논의 왼쪽에서 들어와 일정한 간격으로 뛰어 벼를 밟고 오른쪽으로 나간다. 가장 왼쪽 지점부터 청개구리가 처음 밟는 지점까지의 간격은 청개구리의 뛰는 간격보다 작다. 중간에 방향을 바꾸는 경우는 없으며 벼가 심어진 지점 이외에 다른 지점을 밟는 경우도 없다. 청개구리의 뛰는 간격은 한계가 있어 6이하이고, 또한 논에 들어오면 적어도 두 곳을 밟아야 밖으로 나갈 수 있다. 
<그림 1>과 같은 모습은 네 마리의 청개구리가 들어와 <그림 2>와 같이 논을 밟고 나가면 생길 수 있다.

다섯 마리의 청개구리가 들어와 < 그림3> 과 같이 논을 밟고 나가도 <그림 1>과 같은 모습이 가능하다.

벼가 심어진 각 지점마다 지나간 청개구리의 수가 주어질 때, 밤새 지나간 최소 청개구리 수와 이들 각각이 어떻게 지나갔는지 그 경로를 구하여 출력하는 프로그램을 작성 하시오.
<입력값>
첫째 줄에는 벼가 심어진 지점의 개수 N(2 ≤ N ≤ 200)이 주어진다. 둘째 줄에는 몇 마리의 청개구리가 각각의 지점을 밟고 지나갔는지가 가장 왼쪽 지점부터 차례대로 주어진다. 청개구리가 각 지점을 밟고 지나간 수 사이에는 한 칸의 공백이 있다. 지나간 청개구리의 수가 100 이하인 답이 존재하는 입력만 주어짐이 보장된다.
<출력값>
첫째 줄에는 밤새 지나간 최소 청개구리 수 M를 출력한다. 둘째 줄부터 M+1줄까지 M개의 줄에는 각각의 청개구리가 처음 밟고 지난간 지점이 왼쪽에서 몇 번째 지점인지와 청개구리의 뛴 간격이 얼마인지를 한 간의 공백을 사이에 두고 차례로 출력한다. 청개구리가 뛴 방법을 출력할 때 출력하는 순서는 상관이 없고 최소 청개구리 수가 되는 방법이 둘 이상일 경우 그중 하나만 출력한다.

<문제 2615>
오목은 바둑판에 검은 바둑알과 흰 바둑알을 교대로 놓아서 겨루는 게임이다. 바둑판에는 19개의 가로줄과 19개의 세로줄이 그려져 있는데 가로줄은 위에서부터 아래로 1번, 2번, ... ,19번의 번호가 붙고 세로줄은 왼쪽에서부터 오른쪽으로 1번, 2번, ... 19번의 번호가 붙는다.

위의 그림에서와 같이 같은 색의 바둑알이 연속적으로 다섯 알을 놓이면 그 색이 이기게 된다. 여기서 연속적이란 가로, 세로 또는 대각선 방향 모두를 뜻한다. 즉, 위의 그림은 검은색이 이긴 경우이다. 하지만 여섯 알 이상이 연속적으로 놓인 경우에는 이긴 것이 아니다.
입력으로 바둑판의 어떤 상태가 주어졌을 때, 검은색이 이겼는지, 흰색이 이겼는지 또는 아직 승부가 결정되지 않았는지를 판단하는 프로그램을 작성하시오. 단, 검은색과 흰색이 동시에 이기거나 검은색 또는 흰색이 두 군데 이상에서 동시에 이기는 경우는 입력으로 들어오지 않는다.
<입력값>
19줄에 각 줄마다 19개의 숫자로 표현되는데, 검은 바둑알은 1, 흰 바둑알은 2, 알이 놓이지 않는 자리는 0으로 표시되며, 숫자는 한 칸씩 띄어서 표시된다.
<출력값>
첫줄에 검은색이 이겼을 경우에는 1을, 흰색이 이겼을 경우에는 2를, 아직 승부가 결정되지 않았을 경우에는 0을 출력한다. 검은색 또는 흰색이 이겼을 경우에는 둘째 줄에 연속된 다섯 개의 바둑알 중에서 가장 왼쪽에 있는 바둑알(연속된 다섯 개의 바둑알이 세로로 놓인 경우, 그 중 가장 위에 있는 것)의 가로줄 번호와, 세로줄 번호를 순서대로 출력한다.

<문제 2616>
기차는 맨 앞에 있는 기관차 1대가 손님이 탄 객차 여러 칸을 끌고 간다. 기관차가 고장나면 기차를 운행할 수 없게 되므로 최근 철도청은 기관차 고장에 대비하여 몇몇 역에 소형 기관차 3대를 배치하기로 결정하였다. 소형 기관차는 평소에 이용하는 기관차보다 훨씬 적은 수의 객차만을 끌 수 있다.
기관차가 고장났을 때 끌고 가던 객차 모두를 소형 기관차 3대가 나누어 끌 수 없기 때문에, 소형 기관차들이 어떤 객차들을 끌고 가는 것이 좋을까하는 문제를 고민하다가 다음과 같이 하기로 결정하였다.

소형 기관차가 최대로 끌 수 있는 객차의 수를 미리 정해 놓고, 그보다 많은 수의 객차를 절대로 끌게 하지 않는다. 3대의 소형 기관차가 최대로 끌 수 있는 객차의 수는 서로 같다.
소형 기관차 3대를 이용하여 최대한 많은 손님을 목적지까지 운송하도록 한다. 각 객차 마다 타고 있는 손님의 수는 미리 알고 있고, 다른 객차로 손님들이 이동하는 것은 허용하지 않는다.
각 소형 기관차는 번호가 연속적으로 이어진 객차를 끌게 한다. 객차는 기관차 바로 뒤에 있는 객차부터 시작하여 1번 부터 차례로 번호가 붙어있다.

예를 들어 기관차가 끌고 가던 객차가 7칸이고, 소형 기관차 1대가 최대로 끌 수 있는 객차 수는 2칸이라고 하자. 그리고 1번 부터 7번까지 각 객차에 타고 있는 손님의 수가 아래 표와 같다고 하자. 괄호속에 있는 숫자는 객차 번호를 나타낸다.

소형 기관차 3대는 각각 1-2번, 3-4번, 그리고 6-7번 객차를 끌고 가면 손님 240명을 운송할 수 있고, 이보다 많은 수의 손님을 운송할 수 없다.
기관차가 끌고 가던 객차의 수와 각 객차에 타고 있던 손님의 수, 그리고 소형 기관차가 최대로 끌수 있는 객차의 수가 주어질 때, 소형 기관차 3대를 이용하여 최대로 운송할 수 있는 손님 수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 기관차가 끌고 가던 객차의 수가 입력된다. 그 수는 50,000 이하이다. 둘째 줄에는 기관차가 끌고 가던 객차에 타고 있는 손님의 수가 1번 객차부터 차례로 입력된다. 한 객차에 타고 있는 손님의 수는 100명 이하이고, 입력되는 숫자들 사이에 빈칸이 하나씩 있다. 셋째 줄에는 소형 기관차가 최대로 끌 수 있는 객차의 수가 입력된다. 그 수는 기관차가 끌고 가던 객차 수의 1/3보다 적다.
<출력값>
한 줄에 소형 기관차 3대를 이용하여 최대로 운송할 수 있는 손님 수를 출력한다.

<문제 2617>
모양은 같으나, 무게가 모두 다른 N개의 구슬이 있다. N은 홀수이며, 구슬에는 번호가 1,2,...,N으로 붙어 있다. 이 구슬 중에서 무게가 전체의 중간인 (무게 순서로 (N+1)/2번째) 구슬을 찾기 위해서 아래와 같은 일을 하려 한다.
우리에게 주어진 것은 양팔 저울이다. 한 쌍의 구슬을 골라서 양팔 저울의 양쪽에 하나씩 올려 보면 어느 쪽이 무거운가를 알 수 있다. 이렇게 M개의 쌍을 골라서 각각 양팔 저울에 올려서 어느 것이 무거운가를 모두 알아냈다. 이 결과를 이용하여 무게가 중간이 될 가능성이 전혀 없는 구슬들은 먼저 제외한다.
예를 들어, N=5이고, M=4 쌍의 구슬에 대해서 어느 쪽이 무거운가를 알아낸 결과가 아래에 있다.

구슬 2번이 구슬 1번보다 무겁다.
구슬 4번이 구슬 3번보다 무겁다.
구슬 5번이 구슬 1번보다 무겁다.
구슬 4번이 구슬 2번보다 무겁다.

위와 같이 네 개의 결과만을 알고 있으면, 무게가 중간인 구슬을 정확하게 찾을 수는 없지만, 1번 구슬과 4번 구슬은 무게가 중간인 구슬이 절대 될 수 없다는 것은 확실히 알 수 있다. 1번 구슬보다 무거운 것이 2, 4, 5번 구슬이고, 4번 보다 가벼운 것이 1, 2, 3번이다. 따라서 답은 2개이다.
M 개의 쌍에 대한 결과를 보고 무게가 중간인 구슬이 될 수 없는 구슬의 개수를 구하는 프로그램을 작성하시오.
<입력값>
첫 줄은 구슬의 개수를 나타내는 정수 N(1 ≤ N ≤ 99)과 저울에 올려 본 쌍의 개수 M(1 ≤ M ≤ N(N-1)/2)이 주어진다. 그 다음 M 개의 줄은 각 줄마다 두 개의 구슬 번호가 주어지는데, 앞 번호의 구슬이 뒤 번호의 구슬보다 무겁다는 것을 뜻한다.
<출력값>
첫 줄에 무게가 중간이 절대로 될 수 없는 구슬의 수를 출력 한다.

<문제 2618>
어떤 도시의 중심가는 N개의 동서방향 도로와 N개의 남북방향 도로로 구성되어 있다.
모든 도로에는 도로 번호가 있으며 남북방향 도로는 왼쪽부터 1에서 시작하여 N까지 번호가 할당되어 있고 동서방향 도로는 위부터 1에서 시작하여 N까지 번호가 할당되어 있다. 또한 동서방향 도로 사이의 거리와 남 북방향 도로 사이의 거리는 모두 1이다. 동서방향 도로와 남북방향 도로가 교차하는 교차로의 위치는 두 도로의 번호의 쌍인 (동서방향 도로 번호, 남북방향 도로 번호)로 나타낸다. N이 6인 경우의 예를 들면 다음과 같다.

이 도시에는 두 대의 경찰차가 있으며 두 차를 경찰차1과 경찰차2로 부른다. 처음에는 항상 경찰차1은 (1, 1)의 위치에 있고 경찰차2는 (N, N)의 위치에 있다. 경찰 본부에서는 처리할 사건이 있으면 그 사건이 발생된 위치를 두 대의 경찰차 중 하나에 알려 주고, 연락 받은 경찰차는 그 위치로 가장 빠른 길을 통해 이동하여 사건을 처리한다. (하나의 사건은 한 대의 경찰차가 처리한다.) 그리고 사건을 처리 한 경찰차는 경찰 본부로부터 다음 연락이 올 때까지 처리한 사건이 발생한 위치에서 기다린다. 경찰 본부에서는 사건이 발생한 순서대로 두 대의 경찰차에 맡기려고 한다. 처리해야 될 사건들은 항상 교차로에서 발생하며 경찰 본부에서는 이러한 사건들을 나누어 두 대의 경찰차에 맡기되, 두 대의 경찰차들이 이동하는 거리의 합을 최소화 하도록 사건을 맡기려고 한다.
예를 들어 앞의 그림처럼 N=6인 경우, 처리해야 하는 사건들이 3개 있고 그 사건들이 발생된 위치 를 순서대로 (3, 5), (5, 5), (2, 3)이라고 하자. (3, 5)의 사건을 경찰차2에 맡기고 (5, 5)의 사건도 경찰차2에 맡기며, (2, 3)의 사건을 경찰차1에 맡기면 두 차가 이동한 거리의 합은 4 + 2 + 3 = 9가 되 고, 더 이상 줄일 수는 없다.
처리해야 할 사건들이 순서대로 주어질 때, 두 대의 경찰차가 이동하는 거리의 합을 최소화 하도록 사건들을 맡기는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 동서방향 도로의 개수를 나타내는 정수 N(5≤N≤1,000)이 주어진다. 둘째 줄에는 처리해야 하는 사건의 개수를 나타내는 정수 W(1≤W≤1,000)가 주어진다. 셋째 줄부터 (W+2)번째 줄까지 사건이 발생된 위치가 한 줄에 하나씩 주어진다. 경찰차들은 이 사건들을 주어진 순서대로 처리해야 한다. 각 위치는 동서방향 도로 번호를 나타내는 정수와 남북방향 도로 번호를 나타내는 정수로 주어지며 두 정수 사이에는 빈칸이 하나 있다. 두 사건이 발생한 위치가 같을 수 있다.
<출력값>
첫째 줄에 두 경찰차가 이동한 총 거리를 출력한다. 둘째 줄부터 시작하여 (i+1)번째 줄에 i(1≤i≤W)번째 사건이 맡겨진 경찰차 번호 1 또는 2를 출력한다.

<문제 2619>
철수는 모눈종이 위의 한 점에서 시작하여 수평, 수직 또는 수직, 수평으로 방향을 바꾸면서 모눈종이 의 선들을 따라서 시작점에 다시 돌아 올 때까지 선을 그렸다. 철수가 그린 선은 여러 개의 수직선분과 수평선분으로 구성되고 다음의 조건들을 만족 한다 (그림1 참조).

	① 각 선분은 서로 교차할 수 있으나 수직선분과 수직선분 또는 수평선분과 수평선분은 서로 연결되 거나 교차 할 수 없다.

	② 각 선분들의 끝점은 항상 다른 하나의 선분과 연결되어 있다.

	철수가 그린 선은 모서리가 직각인 여러 개의 다각형을 구성하게 되는데 철수는 이들 중에서 내부에 어떤 선분도 포함하지 않는 단순사각형의 개수를 구하고자 한다. 아래 예를 살펴보자. 이 선은 16개의 선분으로 구성되어 있고 이 선이 만드는 단순사각형은 B, C, E 3개이다. C, D, E를 합하면 사각형이 되지만 내부에 다른 선분을 포함하고 있으므로 단순사각형이 아니다.



	철수가 모눈 종이위에 그린선이 만드는 단순사각형의 개수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 꼭짓점의 개수를 나타내는 정수 N( 4≤N≤1000)이 나온다. 그 다음 N 개의 줄에는 각각 하나의 꼭짓점에 대한 좌표를 나타내는 두 개의 정수 x와 y (0≤x,y≤10,000)가 입력되는데, 첫 번째 정수 x는 그 꼭짓점의 X-좌표를 나타내며, 두 번째 정수 y 는 그 꼭짓점의 Y-좌표를 나타낸다.
<출력값>
첫째 줄에 단위 사각형의 개수를 출력한다. 만일 그러한 단순 사각형이 없는 경우에는 0을 출력한다.

<문제 2620>
2차원 평면상에서 직각다각형은 그 변을 구성하는 선분이 수직이거나 수평인 다각형이다. 일반 직각다각형이란 그 변을 이루는 선분이 서로 교차할 수 있는 직각다각형이고, 단순 직각다각형이란 그 변을 이루는 선분이 서로 교차하지 않는 다각형이다. 이 문제에서 다루고자하는 다각형은 일반 직각다각형이면서 다음 조건을 만족하는 직각다각형이다.

	① 다각형의 꼭짓점은 서로 같은 지점에 위치할 수 없다.

	② 다각형의 각 꼭짓점에서는 다각형의 변을 이루는 하나의 수직선분과 하나의 수평선분이 그 선분의 끝점에서 만난다.

	③ 다각형의 변이 교차하는 경우는 반드시 수평선분과 수직선분 사이에 교차한다. 즉, 수평선분끼리 교차하거나, 수직선분끼리 교차하는 경우는 없다.



	이렇게 구성된 일반 직각다각형은 평면을 여러 개의 단순 직각다각형으로 분할하게 된다. 예를 들면, 아래 그림은 14개의 선분으로 구성된 일반 직각다각형이다. 이 직각다각형은 다각형의 외부는 제외하고 평면을 6개의 단순 직각다각형 A, B, C, D, E, F 로 분할하고 있으며, 이들 단순 직각다각형 중에서 가장 면적이 넓은 다각형은 F 이다.

	일반 직각다각형이 주어졌을 때, 이 직각다각형에 의하여 분할되는 단순 직각다각형 중에서 그 면적이 가장 큰 단순 직각다각형의 면적을 계산하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 일반 직각다각형의 꼭짓점의 개수를 나타내는 정수 N ( 4≤N≤1,000) 이 나온다. 다음 N 개의 줄에는 각각 하나의 꼭짓점에 대한 좌표를 나타내는 두 개의 정수 x와 y( 0≤x,y≤10, 000)가 입력된다.

	첫 번째 정수 x는 그 꼭짓점의 X-좌표를 나타내며, 두 번째 정수 y는 그 꼭짓점의 Y-좌표를 나타낸다. 연속되는 두 개의 꼭짓점을 선분으로 연결하고, 마지막 꼭짓점과 첫 번째 꼭짓점을 연결하면 입력되는 일반 직각다각형이 구성된다.
<출력값>
첫 번째 줄에 입력되는 일반 직각다각형에 의하여 분할되는 가장 면적이 큰 단순 직각다각형의 면적을 나타내는 정수를 출력한다.

<문제 2621>
근우는 오늘 재미있는 카드 게임을 배우고 있다. 카드는 빨간색, 파란색, 노란색, 녹색의 네 가지 색이 있고, 색깔별로 1부터 9까지 숫자가 쓰여진 카드가 9장씩 있다. 카드는 모두 36(=4x9)장이다. 근우가 배운 카드 게임은 36장의 카드에서 5장을 뽑고, 아래와 같은 규칙으로 정수를 계산하는 것이다.
각 카드는 다음과 같이 나타낸다. 카드의 색깔은 영어 대문자 R, B, Y, G로 나타내는데, R은 빨간색, B는 파란색, Y는 노란색, G는 녹색을 뜻한다. 예를 들어서 Y8은 노란색 8을 나타내고, B5는 파란색 5를 나타낸다.
<점수를 정하는 규칙>

카드 5장이 모두 같은 색이면서 숫자가 연속적일 때, 점수는 가장 높은 숫자에 900을 더한다. 예를 들어, 카드가 Y4, Y3, Y2, Y5, Y6 일 때 점수는 906(=6+900)점이다.
카드 5장 중 4장의 숫자가 같을 때 점수는 같은 숫자에 800을 더한다. 예를 들어, 카드가 B3, R3, B7, Y3, G3 일 때 점수는 803(=3+800)점이다.
카드 5장 중 3장의 숫자가 같고 나머지 2장도 숫자가 같을 때 점수는 3장이 같은 숫자에 10을 곱하고 2장이 같은 숫자를 더한 다음 700을 더한다. 예를 들어, 카드가 R5, Y5, G7, B5, Y7 일 때 점수는 757(=5x10+7+700)점이다.
5장의 카드 색깔이 모두 같을 때 점수는 가장 높은 숫자에 600을 더한다. 예를 들어, 카드가 Y3, Y4, Y8, Y6, Y7 일 때 점수는 608(=8+600)점이다.
카드 5장의 숫자가 연속적일 때 점수는 가장 높은 숫자에 500을 더한다. 예를 들어 R7, R8, G9, Y6, B5 일 때 점수는 509(=9+500)점이다.
카드 5장 중 3장의 숫자가 같을 때 점수는 같은 숫자에 400을 더한다. 예를 들어 R7, Y7, R2, G7, R5 일 때 점수는 407(=7+400)점이다.
카드 5장 중 2장의 숫자가 같고 또 다른 2장의 숫자가 같을 때 점수는 같은 숫자 중 큰 숫자에 10을 곱하고 같은 숫자 중 작은 숫자를 더한 다음 300을 더한다. 예를 들어, R5, Y5, Y4, G9, B4 일 때 점수는 354(=5X10+4+300)점이다.
카드 5장 중 2장의 숫자가 같을 때 점수는 같은 숫자에 200을 더한다. 예를 들어, R5, Y2, B5, B3, G4 일 때 점수는 205(=5+200)점이다.
위의 어떤 경우에도 해당하지 않을 때 점수는 가장 큰 숫자에 100을 더한다. 예를 들어, R1, R2, B4, B8, Y5 일 때 점수는 108(=8+100)점이다.

입력으로 카드 5장이 주어질 때, 카드 게임의 점수를 구하는 프로그램을 작성하시오. 두 가지 이상의 규칙을 적용할 수 있는 경우에는 가장 높은 점수가 카드 게임의 점수이다.
<입력값>
첫째 줄부터 다섯째 줄까지 한 줄에 카드 하나씩 입력된다. 카드의 색깔과 숫자 사이에는 빈 칸이 하나 있다.
<출력값>
한 줄에 카드의 점수를 출력한다.

<문제 2622>
같은 길이의 성냥개비가 여러 개 주어져 있다. 이것들을 평면에 늘어놓아서 삼각형을 만들려고 한다. 삼각형의 한 변은 여러 개의 성냥개비를 직선으로 이어서 만들 수 있지만, 성냥개비를 꺾거나 잘라서 변의 한 부분을 만들 수는 없다. 성냥개비의 개수가 주어졌을 때, 이들 성냥개비를 사용하여 만들 수 있든 서로 다른 삼각형의 개수를 구하는 프로그램을 작성하시오.
예를 들어서 9개의 성냥개비로 만들 수 있는 서로 다른 삼각형은 그림 1과 같이 3가지이다.

<주의사항>

주어진 성냥개비는 모두 사용하여 하나의 삼각형을 만들어야 한다.
삼각형을 한 개도 만들 수 없으면 0을 출력한다. 예를 들어서, 주어진 성냥개비의 수가 1, 2, 또는 4인 경우에는 삼각형을 한 개도 만들 수 없다.
합동인 삼각형들은 같은 삼각형으로 본다. 예를 들어서 성냥개비 5개를 사용하여 만들수 있는 그림 2의 삼각형들은 같은 삼각형으로 본다.
<입력값>
첫째 줄에 성냥개비의 개수가 주어진다. 성냥개비의 개수는 1 이상 50,000 이하이다.
<출력값>
첫째 줄에 만들 수 있는 삼각형의 개수를 출력한다.

<문제 2623>
인터넷 방송 KOI(Korea Open Internet)의 음악 프로그램 PD인 남일이는 자기가 맡은 프로그램 '뮤직 KOI'에서 가수의 출연 순서를 정하는 일을 매우 골치 아파한다. 순서를 정하기 위해서는 많은 조건을 따져야 한다.
그래서 오늘 출연 예정인 여섯 팀의 가수에 대해서 남일이가 보조 PD 세 명에게 각자 담당한 가수의 출연 순서를 정해오게 하였다. 보조 PD들이 가져온 것은 아래와 같다.

1 4 3
6 2 5 4
2 3

첫 번째 보조 PD는 1번 가수가 먼저, 다음에 4번 가수, 다음에 3번 가수가 출연하기로 순서를 정했다. 두 번째 보조 PD는 6번, 2번, 5번, 4번 순으로 자기 담당 가수들의 순서를 정했다. 한 가수를 여러 보조 PD가 담당할 수도 있다. 마지막으로, 세 번째 보조 PD는 2번 먼저, 다음에 3번으로 정했다.
남일이가 할 일은 이 순서들을 모아서 전체 가수의 순서를 정하는 것이다. 남일이는 잠시 생각을 하더니 6 2 1 5 4 3으로 순서를 정했다. 이렇게 가수 순서를 정하면 세 보조 PD가 정해온 순서를 모두 만족한다. 물론, 1 6 2 5 4 3으로 전체 순서를 정해도 괜찮다.
경우에 따라서 남일이가 모두를 만족하는 순서를 정하는 것이 불가능할 수도 있다. 예를 들어, 세 번째 보조 PD가 순서를 2 3 대신에 3 2로 정해오면 남일이가 전체 순서를 정하는 것이 불가능하다. 이번에 남일이는 우리 나라의 월드컵 4강 진출 기념 음악제의 PD를 맡게 되었는데, 출연 가수가 아주 많다. 이제 여러분이 해야 할 일은 보조 PD들이 가져 온 순서들을 보고 남일이가 가수 출연 순서를 정할 수 있도록 도와 주는 일이다.
보조 PD들이 만든 순서들이 입력으로 주어질 때, 전체 가수의 순서를 정하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 가수의 수 N과 보조 PD의 수 M이 주어진다. 가수는 번호 1, 2,…,N 으로 표시한다. 둘째 줄부터 각 보조 PD가 정한 순서들이 한 줄에 하나씩 나온다. 각 줄의 맨 앞에는 보조 PD가 담당한 가수의 수가 나오고, 그 뒤로는 그 가수들의 순서가 나온다. N은 1이상 1,000이하의 정수이고, M은 1이상 100이하의 정수이다.
<출력값>
출력은 N 개의 줄로 이뤄지며, 한 줄에 하나의 번호를 출력한 다. 이들은 남일이가 정한 가수들의 출연 순서를 나타낸다. 답이 여럿일 경우에는 아무거나 하나를 출력 한다. 만약 남일이가 순서를 정하는 것이 불가능할 경우에는 첫째 줄에 0을 출력한다.

<문제 2624>
명보네 동네 가게의 현금 출납기에는 k 가지 동전이 각각 n1, n2, … , nk개 씩 들어있다. 가게 주인은 명보에게 T원의 지폐를 동전으로 바꿔 주려고 한다. 이때, 동전 교환 방법은 여러 가지가 있을 수 있다. 예를 들어, 10원 짜리, 5원 짜리, 1원 짜리 동전이 각각 2개, 3개, 5개씩 있을 때, 20원 짜리 지폐를 다음과 같은 4가지 방법으로 교환할 수 있다.

20 = 10×2 
20 = 10×1 + 5×2 
20 = 10×1 + 5×1 + 1×5 
20 = 5×3 + 1×5

입력으로 지폐의 금액 T, 동전의 가지 수 k, 각 동전 하나의 금액 pi와 개수 ni가 주어질 때 (i=1, 2,…, k) 지폐를 동전으로 교환하는 방법의 가지 수를 계산하는 프로그램을 작성하시오. 방법 의 수는 231-1을 초과 하지 않는 것으로 가정한다.
<입력값>
첫째 줄에는 지폐의 금액 T(0＜T ≤ 10,000), 둘째 줄에는 동전의 가지 수 k(0＜k ≤ 100), 셋째 줄부터 마지막 줄까지는 각 줄에 동전의 금액 pi(0＜pi ≤ T)와 개수 ni(0＜ni ≤ 1,000)가 주어진다. pi와 ni사이에는 빈칸이 하나씩 있다.
<출력값>
첫째 줄에 동전 교환 방법의 가지 수를 출력한다. 방법이 없을 때는 0을 출력한다.

<문제 2625>
모든 생물의 DNA 서열은 A, C, G, T 네 개의 문자로만 표현된다. 한 DNA 서열에서 두 문자의 거리 는 두 문자 사이에 있는 문자들의 개수이다. DNA 서열의 부분서열은 DNA 서열에서 몇 개의 문자를 제 거하여 얻을 수 있는 서열을 말한다. 예로 DNA 서열 AGTCAC에서 두 번째 문자 G와 다섯 번째 문자 A의 사이에는 두 개의 문자 'TC'가 있기 때문에 이 두 문자의 거리는 2이다. 또한 이 DNA 서열에서 세 번째 문자 T와 네 번째 문자 C를 제거하면 부분서열 AGAC를 얻을 수 있다.

	K가 0이상인 정수일 때, K-부분서열이란 부분서열에서 이웃한 모든 두 문자가 원래 DNA 서열에서 거리가 최대 K인 부분서열이다. DNA서열 AGTCAC의 부분서열 AGAC에서 인접한 두 문자인, 두 번째 문자 G와 세 번째 문자 A는 원래 DNA 서열에서 각각 두 번째와 다섯 번째 문자이고 두 문자 사이에는 두 개의 문자 'TC'가 있으므로 AGCATA의 1-부분서열이 될 수 없으나 2-부분서열은 된다.

	두 DNA 서열이 얼마나 비슷한가를 측정하기 위하여 사용하는 방법 중에 하나는 최장 공통 K-부분서 열을 찾는 것이다. (놀랍게도 인간과 쥐의 DNA 서열은 90%이상이 동일하다고 한다.) 두 DNA 서열의 최장 공통 K-부분서열이란 두 서열에서 모두 얻을 수 있는 동일한 K-부분서열 중, 가장 길이가 긴 부 분서열을 말한다. 최장 공통 K-부분서열은 여러 개 있을 수 있다.



	예를 들어서, 위 그림과 같이 두 DNA 서열 AGTCAC와 GATGAGAC가 주어진 경우, AGAC는 최장 공통 2-부분서열은 되지만, 1-부분서열은 될 수 없다. 왜냐하면 DNA 서열 AGTCAC에서 2번째 문자인 G와 5번째 문자인 A사이에 두 개의 문자 'TC'가 있기 때문이다. GTAC도 최장 공통 2-부분서열이다. 최장 공통 1-부분서열은 AGC, GTA, ATA 세 개가 된다. 이 세 개를 사전식(dictionary) 순서로 나열하면 AGC, ATA, GTA가 된다.

	두 DNA 서열과 K가 주어진 경우 두 서열의 최장 공통 K-부분서열을 찾는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 K(0≤K≤30)가 입력된다. 둘째 줄에 는 첫째 DNA 서열의 길이를 나타내는 정수가 입력된다. DNA 서열의 길이는 1,000이하이다. 셋째 줄에 는 첫째 DNA 서열이 주어진다. 넷째 줄에는 둘째 DNA 서열의 길이를 나타내는 정수가 주어진다. 다섯 번째 줄에는 둘째 DNA 서열이 주어진다. 단, DNA 서열을 나타내는 문자들 사이에 공백은 없다.
<출력값>
주어진 두 DNA 서열의 최장 공통 K-부분서열을 출력한다. 답이 여러 개이면 사전식 순서로 가장 앞에 있는 서열을 출력한다.

<문제 2626>
바다 위에 N개의 섬이 있고, 이 섬들에는 사람들이 살고 있다. 이곳 사람들은 혹시 있을지도 모를 응 급 환자들을 위해 병원을 건설하기로 했는데, 각 섬마다 병원을 세우기에는 비용이 너무 많이 들기 때문 에 이 섬들의 중간 지점쯤(바다 위 나 섬 위 모두 가능) 한 곳에 병원과 헬기 착륙장을 건설하기로 하였 다. 멀리 있는 응급 환자를 빨리 수송해야 하므로 이 헬기 착륙장의 위치는 착륙장으로부터 각 섬까지의 직선 거리들 중에서 최대가 되는 거리를 제일 작게 하려고 한다. 이러한 조건을 만족하는 헬기 착륙장의 위치와 이 착륙장으로부터 가장 멀리 떨어져 있는 섬까지의 거리를 구하는 프로그램을 작성하시오.
<입력값>
문제를 간단히 하기 위해서 섬의 크기는 무시하고, 섬의 위치를 2차원 정수 좌표로 표시한다. 첫 줄은 섬의 개수를 나타내는 정수 N(2≤N≤1,000)이다. 그 다음 N개의 줄은 각 줄마다 섬의 x 좌표값, y 좌표값이 각각 정수로 주어지는데, 각 좌표값의 범위는 -30,000 부터 30,000 까지이다.
<출력값>
첫 번째 줄에 헬기 착륙장의 위치를 x 좌표, y 좌표 순서로 출력하고, 두 번째 줄에 착륙장으로부터 가장 멀리 떨어져 있는 섬까지의 거리를 출력한다. 단, 각 좌표 값과 거리는 소수점 이하 넷째 자리에서 반올림하여 셋째 자리까지 출력한다.

<문제 2627>
0-2 이진트리(binary tree)는 다음과 같이 정의된다.

	(1) 항상 루트노드(root node)가 지정되어 있다. 

	(2) 모든 내부노드(internal node)는 반드시 두 개의 자식노드(child node)를 가지며, 왼쪽 자식노드와 오른쪽 자식노드를 구분한다.

	이러한 0-2 이진트리의 루트노드 혹은 루트노드의 오른쪽 자식노드에서 좌회전 연산과 우회전 연산 은 아래 <그림 1>과 같이 표현된다.



	<그림 1-(a)> 이진트리의 노드 'a'에서 좌회전 연산은 

	(1) 노드 'a'의 자리에 노드 'b'를 위치하게 하고, 

	(2) 노드 'a'를 노드 'b'의 왼쪽 자식노드로 만들며, 

	(3) 노드 'b'의 왼쪽 부트리(subtree) T2를 노드 'a'의 오른쪽 부트리로 만든다.

	<그림 1-(a)> 트리의 노드 'a'에 좌회전 연산을 적용하면 <그림 1-(b)> 이진트리로 변환된다.

	이와 유사하게 우회전 연산을 정의할 수 있다. 위 <그림 1-(b)> 이진트리의 노드 'b'에서 우회전 연 산은 

	(1) 노드 'b'의 자리에 노드 'a'를 위치하게 하고, 

	(2) 노드 'b'를 노드 'a'의 오른쪽 자식노드로 만들며, 

	(3) 노드 'a'의 오른쪽 부트리 T2를 노드 'b'의 왼쪽 부트리로 만든다.

	<그림 1-(b)> 트리의 노드 'b'에 우회전 연산을 적용하면 <그림 1-(a)> 이진트리로 변환된다.

	같은 개수의 노드를 가지는 두 개의 0-2 이진트리가 있을 때, 이 두 이진트리의 회전거리는 한 트리 의 루트노드 혹은 루트노드의 오른쪽 자식노드에 좌회전 혹은 우회전 연산을 적용하여 다른 트리로 만 드는 회전연산의 최소 회수를 나타낸다.

	예를 들면, 다음 쪽의 <그림 2-(a)> 트리를 <그림 2-(g)> 트리로 변환하기 위해서는 <그림 2>에서 와 같이 6번의 좌/우회전 연산을 적용하면 된다. 또한 6번 이하 회수의 회전 연산을 사용하여서는 변환 할 수 없으므로, 두 트리 사이의 회전거리는 6이다.

	두 개의 0-2 이진트리가 주어졌을 때, 두 트리 사이의 회전거리를 계산하는 프로그램을 작성하시오.
<입력값>
첫 번째 줄에는 입력되는 두 트리의 노드 개수를 나타내는 정수 N(5≤N≤300)이 주어지며, 각 노드는 1번 부터 N번까지 번호가 부여된다.

	두 번째 줄부터 다음 N개의 줄에는 첫 번째 트리의 구조를 나타내는 데이터가 입력된다. 각 줄에는 세 개의 정수가 주어지는데, 두 번째, 세 번째 정수가 나타내는 노드들은 각각 첫 번째 정수가 나타내는 노드의 왼쪽, 오른쪽 자식임을 나타낸다. 첫 번째 정수가 나타내는 노드가 단말 노드(terminal node)인 경우에는, 두 번째, 세 번째 정수는 모두 0이다. 루트노드의 번호는 항상 1번으로 주어지며, 각 줄은 첫 번째 정수가 1부터 N까지 증가하는 순으로 입력된다.

	다음 N개의 줄에는 두 번째 트리의 구조를 나타내는 데이터가 첫 번째 트리의 구조를 나타내는 데이 터와 같은 형식으로 입력된다.
<출력값>
첫 번째 줄에 입력되는 두 트리의 회전거리를 나타내는 정수 M을 출력한다. 다음 M개의 줄에는 첫 번째 트리를 두 번째 트리로 변환하는 회전연산에 관한 정보를 회전하는 순서대로 출력한다.

	회전정보는 두 개의 문자로 표시한다. 첫 번째 문자는 회전하는 노드를 나타내며, 루트노드에서 회전 하는 경우에는 'T'로, 루트노드의 오른쪽 자식노드에서 회전하는 경우에는 'C'로 표시한다. 두 번째 문 자는 회전하는 방향을 나타내며, 좌회전 연산은 'L'로, 우회전 연산은 'R'로 표시한다.두 문자 사이에는 공백이 없다.

	같은 회전거리를 가지는 회전변환 방법이 여러 가지인 경우는 그 중에서 한 가지 경우만을 출력한다. 입력되는 두 트리가 회전연산을 적용하여 서로 변환될 수 없는 경우에는 첫 번째 줄에 -1을 출력한다.

<문제 2628>
아래 <그림 1>과 같이 직사각형 모양의 종이가 있다. 이 종이는 가로방향과 세로 방향으로 1㎝마다 점선이 그어져 있다. 가로 점선은 위에서 아래로 1번부터 차례로 번호가 붙어 있고, 세로 점선은 왼쪽에서 오른쪽으로 번호가 붙어 있다.



	점선을 따라 이 종이를 칼로 자르려고 한다. 가로 점선을 따라 자르는 경우는 종이의 왼쪽 끝에서 오른쪽 끝까지, 세로 점선인 경우는 위쪽 끝에서 아래쪽 끝까지 한 번에 자른다. 예를 들어, <그림 1>의 가로 길이 10㎝이고 세로 길이 8㎝인 종이를 3번 가로 점선, 4번 세로 점선, 그리고 2번 가로 점선을 따라 자르면 <그림 2>와 같이 여러 개의 종이 조각으로 나뉘게 된다. 이때 가장 큰 종이 조각의 넓이는 30㎠이다.

	입력으로 종이의 가로 세로 길이, 그리고 잘라야할 점선들이 주어질 때, 가장 큰 종이 조각의 넓이가 몇 ㎠인지를 구하는 프로그램을 작성하시오.
<입력값>
첫줄에는 종이의 가로와 세로의 길이가 차례로 자연수로 주어진다. 가로와 세로의 길이는 최대 100㎝이다. 둘째 줄에는 칼로 잘라야하는 점선의 개수가 주어진다. 셋째 줄부터 마지막 줄까지 한 줄에 점선이 하나씩 아래와 같은 방법으로 입력된다. 가로로 자르는 점선은 0과 점선 번호가 차례로 주어지고, 세로로 자르는 점선은 1과 점선 번호가 주어진다. 입력되는 두 숫자 사이에는 빈 칸이 하나씩 있다.
<출력값>
첫째 줄에 가장 큰 종이 조각의 넓이를 출력한다. 단, 넓이의 단위는 출력하지 않는다.

<문제 2629>
양팔 저울과 몇 개의 추가 주어졌을 때, 이를 이용하여 입력으로 주어진 구슬의 무게를 확인할 수 있는지를 결정하려고 한다.
무게가 각각 1g과 4g인 두 개의 추가 있을 경우, 주어진 구슬과 1g 추 하나를 양팔 저울의 양쪽에 각각 올려놓아 수평을 이루면 구슬의 무게는 1g이다. 또 다른 구슬이 4g인지를 확인하려면 1g 추 대신 4g 추를 올려놓으면 된다.
구슬이 3g인 경우 아래 <그림 1>과 같이 구슬과 추를 올려놓으면 양팔 저울이 수평을 이루게 된다. 따라서 각각 1g과 4g인 추가 하나씩 있을 경우 주어진 구슬이 3g인지도 확인해 볼 수 있다.

<그림 2>와 같은 방법을 사용하면 구슬이 5g인지도 확인할 수 있다. 구슬이 2g이면 주어진 추를 가지고는 확인할 수 없다.
추들의 무게와 확인할 구슬들의 무게가 입력되었을 때, 주어진 추만을 사용하여 구슬의 무게를 확인 할 수 있는지를 결정하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 추의 개수가 자연수로 주어진다. 추의 개수는 30 이하이다. 둘째 줄에는 추의 무게들이 자연수로 가벼운 것부터 차례로 주어진다. 같은 무게의 추가 여러 개 있을 수도 있다. 추의 무게는 500g이하이며, 입력되는 무게들 사이에는 빈칸이 하나씩 있 다. 세 번째 줄에는 무게를 확인하고자 하는 구슬들의 개수가 주어진다. 확인할 구슬의 개수는 7이하이다. 네 번째 줄에는 확인하고자 하는 구슬들의 무게가 자연수로 주어지며, 입력되는 무게들 사이에는 빈 칸이 하나씩 있다. 확인하고자 하는 구슬의 무게는 40,000보다 작거나 같은 자연수이다.
<출력값>
주어진 각 구슬의 무게에 대하여 확인이 가능하면 Y, 아니면 N 을 차례로 출력한다. 출력은 한 개의 줄로 이루어지며, 각 구슬에 대한 답 사이에는 빈칸을 하나씩 둔다.

<문제 2630>
아래 <그림 1>과 같이 여러개의 정사각형칸들로 이루어진 정사각형 모양의 종이가 주어져 있고, 각 정사각형들은 하얀색으로 칠해져 있거나 파란색으로 칠해져 있다. 주어진 종이를 일정한 규칙에 따라 잘라서 다양한 크기를 가진 정사각형 모양의 하얀색 또는 파란색 색종이를 만들려고 한다.

전체 종이의 크기가 N×N(N=2k, k는 1 이상 7 이하의 자연수) 이라면 종이를 자르는 규칙은 다음과 같다.
전체 종이가 모두 같은 색으로 칠해져 있지 않으면 가로와 세로로 중간 부분을 잘라서 <그림 2>의 I, II, III, IV와 같이 똑같은 크기의 네 개의 N/2 × N/2색종이로 나눈다. 나누어진 종이 I, II, III, IV 각각에 대해서도 앞에서와 마찬가지로 모두 같은 색으로 칠해져 있지 않으면 같은 방법으로 똑같은 크기의 네 개의 색종이로 나눈다. 이와 같은 과정을 잘라진 종이가 모두 하얀색 또는 모두 파란색으로 칠해져 있거나, 하나의 정사각형 칸이 되어 더 이상 자를 수 없을 때까지 반복한다.
위와 같은 규칙에 따라 잘랐을 때 <그림 3>은 <그림 1>의 종이를 처음 나눈 후의 상태를, <그림 4>는 두 번째 나눈 후의 상태를, <그림 5>는 최종적으로 만들어진 다양한 크기의 9장의 하얀색 색종이와 7장의 파란색 색종이를 보여주고 있다.

입력으로 주어진 종이의 한 변의 길이 N과 각 정사각형칸의 색(하얀색 또는 파란색)이 주어질 때 잘라진 하얀색 색종이와 파란색 색종이의 개수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 전체 종이의 한 변의 길이 N이 주어져 있다. N은 2, 4, 8, 16, 32, 64, 128 중 하나이다. 색종이의 각 가로줄의 정사각형칸들의 색이 윗줄부터 차례로 둘째 줄부터 마지막 줄까지 주어진다. 하얀색으로 칠해진 칸은 0, 파란색으로 칠해진 칸은 1로 주어지며, 각 숫자 사이에는 빈칸이 하나씩 있다.
<출력값>
첫째 줄에는 잘라진 햐얀색 색종이의 개수를 출력하고, 둘째 줄에는 파란색 색종이의 개수를 출력한다.

<문제 2631>
KOI 어린이집에는 N명의 아이들이 있다. 오늘은 소풍을 가는 날이다. 선생님은 1번부터 N번까지 번호가 적혀있는 번호표를 아이들의 가슴에 붙여주었다. 선생님은 아이들을 효과적으로 보호하기 위해 목적지까지 번호순서대로 일렬로 서서 걸어가도록 하였다. 이동 도중에 보니 아이들의 번호순서가 바뀌었다. 그래서 선생님은 다시 번호 순서대로 줄을 세우기 위해서 아이들의 위치를 옮기려고 한다. 그리고 아이들이 혼란스러워하지 않도록 하기 위해 위치를 옮기는 아이들의 수를 최소로 하려고 한다.
예를 들어, 7명의 아이들이 다음과 같은 순서대로 줄을 서 있다고 하자.
3 7 5 2 6 1 4
아이들을 순서대로 줄을 세우기 위해, 먼저 4번 아이를 7번 아이의 뒤로 옮겨보자. 그러면 다음과 같은 순서가 된다.
3 7 4 5 2 6 1
이제, 7번 아이를 맨 뒤로 옮긴다.
3 4 5 2 6 1 7
다음 1번 아이를 맨 앞으로 옮긴다.
1 3 4 5 2 6 7
마지막으로 2번 아이를 1번 아이의 뒤로 옮기면 번호 순서대로 배치된다.
1 2 3 4 5 6 7
위의 방법으로 모두 4명의 아이를 옮겨 번호 순서대로 줄을 세운다. 위의 예에서 3명의 아이만을 옮겨서는 순서대로 배치할 수가 없다. 따라서, 4명을 옮기는 것이 가장 적은 수의 아이를 옮기는 것이다.
N명의 아이들이 임의의 순서로 줄을 서 있을 때, 번호 순서대로 배치하기 위해 옮겨지는 아이의 최소 수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 아이들의 수 N이 주어진다. 둘째 줄부터는 1부터 N까지의 숫자가 한 줄에 하나씩 주어진다. N은 2 이상 200 이하의 정수이다.
<출력값>
첫째 줄에는 번호 순서대로 줄을 세우는데 옮겨지는 아이들의 최소 수를 출력한다.

<문제 2632>
고객이 두 종류의 피자 A와 B를 취급하는 피자가게에서 피자를 주문하고자 한다. <그림 1>과 같이 각 종류의 피자는 다양한 크기의 여러 개의 피자조각으로 나누어져 있다. 각 조각에 쓰여진 숫자는 피자조각의 크기를 나타낸다.

고객이 원하는 피자의 크기를 이야기하면, 피자가게에서는 한 종류의 피자를 2 조각 이상 판매할 때는 반드시 연속된 조각들을 잘라서 판매한다. 이때 판매한 피자조각의 크기 합이 주문한 크기가 되어야 한다. 판매한 피자조각은 모두 A종류이거나, 모두 B종류이거나, 또는 A와 B 종류가 혼합될 수 있다. 예를 들어서, <그림 1> 과 같이 잘라진 피자가 있을 때, 손님이 전체 크기가 7 인 피자를 주문하면, 피자 가게에서는 <그림2>와 같이 5 가지 방법으로 피자를 판매할 수 있다.

피자가게에서 손님이 원하는 크기의 피자를 판매하는 모든 방법의 가지 수를 계산하는 프로그램을 작성하시오
<입력값>
첫 번째 줄에는 손님이 구매하고자 하는 피자크기를 나타내는 2,000,000 이하의 자연수가 주어진다. 두 번째 줄에는 A, B 피자의 피자조각의 개수를 나타내 는 정수 m, n 이 차례로 주어진다 (3 ≤ m, n ≤ 1000). 세 번째 줄부터 차례로 m 개의 줄에는 피자 A의 미리 잘라진 피자조각의 크기를 나타내는 정수가 주어진다. 그 다음 n 개의 줄에는 차례로 피자B의 미리 잘라진 피자조각의 크기를 나타내는 정수가 주어진다. 각 종류의 피자조각의 크기는 시계방향으로 차례로 주어지며, 각 피자 조각의 크기는 1000 이하의 자연수이다.
<출력값>
첫째 줄에는 피자를 판매하는 방법의 가지 수를 나타내는 정수를 출력한다. 피자를 판매하는 방법이 없는 경우에는 숫자 0을 출력한다.

<문제 2633>
이차원 평면상에 변들이 좌표축에 평행한 L-모양 다각형의 장애물들이 있다. 이들 장애물들은 서로 겹치지 않고 또한 변이나 꼭짓점에서 만나지 않는다. 로봇이 어느 한 지점에서 출발하여 정해진 도착지점으로 이들 장애물들을 피해서 이동하고자 한다. 이 로봇은 항상 좌표축과 평행하게 이동하며 장애물의 변을 따라서 이동할 수도 있다. 로봇이 출발지점에서 도착지점까지 이동하는 여러 경로들 중에서 꺾이는 횟수가 최소가 되는 경로를 찾고자 한다. 단, 로봇의 크기를 무시하여 로봇을 이차원 상의 점으로 표현할 수 있다고 가정한다. 또한, 로봇의 출발지점과 도착지점은 항상 장애물의 내부나 경계선에 놓여있지 않다.

	아래 그림의 예를 통해서 로봇이 도착지점에 도달하기 위한 여러 경로가 있음을 알 수 있고, 또한 이 경우에서는 꺾이는 수가 3이 최소임을 알 수 있다.



	L-모양 다각형의 장애물들, 출발지점, 도착지점이 입력으로 주어져 있을 때 로봇이 출발지점에서 도착지점으로 이동하는 경로 중 꺾이는 횟수가 최소인 것을 찾는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 로봇의 출발지점 좌표가 주어지고 둘째 줄에는 로봇의 도착지점 좌표가 주어진다. 셋째 줄에는 장애물의 개수(≤50)가 주어지고, 그 다음 줄부터 각 줄에는 하나의 장애물의 위치를 나타내는 네 점의 좌표 p1, p2, p3, p4 가 차례로 주어지고 이 네 점의 좌표의 위치는 다음의 그림과 같다. 단, 모든 좌표는 x-좌표, y-좌표가 한 칸씩 띄어서 순서대로 주어지며, 좌표의 각 값은 자연수(≤100)이다.
<출력값>
로봇의 경로들 중에서 꺾이는 횟수가 최소가 되는 경로의 꺾이는 횟수를 출력한다.

<문제 2634>
<그림 1>은 어떤 도시의 도로망을 나타내고 있다.

이 도시의 지점은 숫자를 포함하는 동그라미로 표시되어 있고, 두 지점 사이에 있는 도로는 두 지점 을 잇는 선으로 표시되어 있다. 이 도로망의 특성은 다음과 같다.
•특성 1. 임의의 한 지점에서 도로와 지점을 거쳐 모든 다른 지점으로 갈 수 있다. 
•특성 2. 한 지점에서 출발하여 어떤 도로를 두 번이상 거치지 않고는 출발지점으로 되돌아 올 수 없다.
•특성 3. 한 지점과 접한 도로의 개수는 10이하이다.
위의 세 가지 특성을 만족하는 도로망을 트리도로망이라 한다. 이제 이 도시에서 몇 개의 버스노선을 신설하려고 한다. 각각의 버스노선은 한 종점에서 반대편 종점까지 가는 도로와 지점으로 이루어진다. 종점이 될 수 있는 지점은 도로망에서 단말지점(자신과 연결된 다른 지점이 하나 뿐인 곳)이어야 한다. 예를 들어, <그림 1>에서 버스 종점이 될 수 있는 지점은 색칠된 1, 2, 5, 6, 9, 10번 지점이다.
<그림 1>과 같은 경우에 두 개씩의 단말지점으로 짝을 지어 세 개의 서로 다른 버스노선을 만들 수 있다. 단, 버스 노선을 설정하기 위해서는 다음 조건들을 만족해야 한다.
•조건 1. 도시의 모든 지점은 반드시 하나의 노선에 포함되어야 하고, 두 개 이상의 버스 노선에 포함 될 수도 있다. 예를 들어, 1-3-8-10 노선과 9-7-8-4-5 노선과 같이 한 교차지점을 공유하는 것은 허용된다.
•조건 2. 도시의 모든 도로는 하나의 버스노선에는 포함되어야 한다. 그러나 한 도로는 두 개의 버스노 선에 포함될 수는 없다. 예로 <그림 1>에서 6-7-8-10이 버스노선인 경우, 9-7-8-4-5는 도 로 (7, 8)을 공유하게되므로 버스노선이 될 수 없다.
•조건 3. 버스노선의 종점은 단말지점이어야 한다. 그리고 버스노선은 지점과 도로를 한 번씩만 지나야 한다. 예로 <그림 1>에서 2-7-8-3-1은 버스노선으로 가능하지만 2-7-9-7-8-10은 도로 (7, 9)와 지점 7을 두 번 방문하기 때문에 버스노선이 될 수 없다.
•조건 4. 노선이 지나치게 길면 안되므로 위의 세 가지 조건을 만족하는 버스노선 중에서 가장 긴 노 선의 길이가 최대한 짧게 설계되어야 한다. 단, 모든 도로의 길이는 1로 가정한다.
<그림 1>에서 제한조건을 만족하는 버스노선은 다음과 같다.
2-7-8-10
9-7-6
1-3-8-4-5
이 경우 가장 긴 노선의 길이가 4이다.
다음 <그림 2>와 같은 경우라면 위의 조건들을 만족시키는 버스노선은 존재하지 않는다. 왜냐하면 6-2-7-9가 버스노선이 되면 도로 (7, 8)은 다른 노선에 포함될 수 없고, 6번에서 시작하여 9번이 아닌 다른 곳이 종점이 된다면 9번의 다른 쪽 종점을 정할 수 없기 때문이다.

트리도로망이 주어졌을 때, 위의 조건들을 만족하는 버스노선을 찾는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 도로망에 있는 지점 개수 n(2≤n≤500)이 주어진다. 둘째 줄부터 n-1 개의 도로에 대한 정보가 한 줄에 하나씩 주어진다. 만 일 지점 i 와 지점 j 사이에 도로가 있다면 "i j"로 한 줄에 표시한다. 또는 "j i"라고 표시될 수도 있다. 숫자 사이에는 빈칸이 하나 있다. 지점은 1부터 n 까지의 서로 다른 숫자로 표시된다.
<출력값>
첫째 줄에는 제일 긴 노선의 길이를 출력한다. 둘째 줄에는 버스노선의 개수 m 을 출력한다. 다음 m 줄의 각 줄에는 위의 조건을 만족하는 버스노선 을 한 줄에 하나씩 출력한다. 한 버스노선은 노선에 포함된 지점의 개수와 한 종점 번호에서부터 다른 종점까지 거치는 지점 번호들을 차례로 출력한다. 지점 번호 사이에는 빈칸을 하나 둔다. 답이 여러 개인 경우는 그 중에 하나만 출 력한다. 만일 위 네 가지 조건을 만족하는 답이 존재하진 않을 경우에는 첫째 줄에 숫자 0을 출력한다.

<문제 2635>
다음과 같은 규칙에 따라 수들을 만들려고 한다.

첫 번째 수로 양의 정수가 주어진다.
두 번째 수는 양의 정수 중에서 하나를 선택한다.
세 번째부터 이후에 나오는 모든 수는 앞의 앞의 수에서 앞의 수를 빼서 만든다. 예를 들어, 세 번째 수는 첫 번째 수에서 두 번째 수를 뺀 것이고, 네 번째 수는 두 번째 수에서 세 번째 수를 뺀 것이다.
음의 정수가 만들어지면, 이 음의 정수를 버리고 더 이상 수를 만들지 않는다.

첫 번째 수로 100이 주어질 때, 두 번째 수로 60을 선택하여 위의 규칙으로 수들을 만들면 7개의 수들 100, 60, 40, 20, 20 , 0, 20이 만들어진다. 그리고 두 번째 수로 62를 선택하여 위의 규칙으로 수들을 만들면 8개의 수들 100, 62, 38, 24, 14, 10, 4, 6이 만들어진다. 위의 예에서 알 수 있듯이, 첫 번째 수가 같더라도 두 번째 수에 따라서 만들어지는 수들의 개수가 다를 수 있다.
입력으로 첫 번째 수가 주어질 때, 이 수에서 시작하여 위의 규칙으로 만들어지는 최대 개수의 수들을 구하는 프로그램을 작성하시오. 최대 개수의 수들이 여러 개일 때, 그중 하나의 수들만 출력하면 된다.
<입력값>
첫 번째 수가 주어진다. 이 수는 30,000 보다 같거나 작은 양의 정수이다.
<출력값>
첫 번째 줄에는 입력된 첫 번째 수로 시작하여 위의 규칙에 따라 만들 수 있는 수들의 최대 개수를 출력한다.
둘째 줄에 그 최대 개수의 수들을 차례대로 출력한다. 이들 수 사이에는 빈칸을 하나씩 둔다.

<문제 2636>
아래 <그림 1>과 같이 정사각형 칸들로 이루어진 사각형 모양의 판이 있고, 그 위에 얇은 치즈(회색으로 표시된 부분)가 놓여 있다. 판의 가장자리(<그림 1>에서 네모 칸에 X친 부분)에는 치즈가 놓여 있지 않으며 치즈에는 하나 이상의 구멍이 있을 수 있다.
이 치즈를 공기 중에 놓으면 녹게 되는데 공기와 접촉된 칸은 한 시간이 지나면 녹아 없어진다. 치즈의 구멍 속에는 공기가 없지만 구멍을 둘러싼 치즈가 녹아서 구멍이 열리면 구멍 속으로 공기가 들어가게 된다. <그림 1>의 경우, 치즈의 구멍을 둘러싼 치즈는 녹지 않고 ‘c’로 표시된 부분만 한 시간 후에 녹아 없어져서 <그림 2>와 같이 된다.

다시 한 시간 후에는 <그림 2>에서 ‘c’로 표시된 부분이 녹아 없어져서 <그림 3>과 같이 된다.

<그림 3>은 원래 치즈의 두 시간 후 모양을 나타내고 있으며, 남은 조각들은 한 시간이 더 지나면 모두 녹아 없어진다. 그러므로 처음 치즈가 모두 녹아 없어지는 데는 세 시간이 걸린다. <그림 3>과 같이 치즈가 녹는 과정에서 여러 조각으로 나누어 질 수도 있다.
입력으로 사각형 모양의 판의 크기와 한 조각의 치즈가 판 위에 주어졌을 때, 공기 중에서 치즈가 모두 녹아 없어지는 데 걸리는 시간과 모두 녹기 한 시간 전에 남아있는 치즈조각이 놓여 있는 칸의 개수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 사각형 모양 판의 세로와 가로의 길이가 양의 정수로 주어진다. 세로와 가로의 길이는 최대 100이다. 판의 각 가로줄의 모양이 윗 줄부터 차례로 둘째 줄부터 마지막 줄까지 주어진다. 치즈가 없는 칸은 0, 치즈가 있는 칸은 1로 주어지며 각 숫자 사이에는 빈칸이 하나씩 있다.
<출력값>
첫째 줄에는 치즈가 모두 녹아서 없어지는 데 걸리는 시간을 출력하고, 둘째 줄에는 모두 녹기 한 시간 전에 남아있는 치즈조각이 놓여 있는 칸의 개수를 출력한다.

<문제 2637>
우리는 어떤 장난감을 여러 가지 부품으로 조립하여 만들려고 한다. 이 장난감을 만드는데는 기본 부품과 그 기본 부품으로 조립하여 만든 중간 부품이 사용된다. 기본 부품은 다른 부품을 사용하여 조립될 수 없는 부품이다. 중간 부품은 또 다른 중간 부품이나 기본 부품을 이용하여 만들어지는 부품이다.
예를 들어보자. 기본 부품으로서 1, 2, 3, 4가 있다. 중간 부품 5는 2개의 기본 부품 1과 2개의 기본 부품 2로 만들어진다. 그리고 중간 부품 6은 2개의 중간 부품 5, 3개의 기본 부품 3과 4개의 기본 부품 4로 만들어진다. 마지막으로 장난감 완제품 7은 2개의 중간 부품 5, 3개의 중간 부품 6과 5개의 기본 부품 4로 만들어진다. 이런 경우에 장난감 완제품 7을 만드는데 필요한 기본 부품의 개수는 1번 16개, 2번 16개, 3번 9개, 4번 17개이다.
이와 같이 어떤 장난감 완제품과 그에 필요한 부품들 사이의 관계가 주어져 있을 때 하나의 장난감 완제품을 조립하기 위하여 필요한 기본 부품의 종류별 개수를 계산하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 자연수 N(3 ≤ N ≤ 100)이 주어지는데, 1부터 N-1까지는 기본 부품이나 중간 부품의 번호를 나타내고, N은 완제품의 번호를 나타낸다. 그리고 그 다음 줄에는 자연수 M(3 ≤ M ≤ 100)이 주어지고, 그 다음 M개의 줄에는 어떤 부품을 완성하는데 필요한 부품들 간의 관계가 3개의 자연수 X, Y, K로 주어진다. 이 뜻은 "중간 부품이나 완제품 X를 만드는데 중간 부품 혹은 기본 부품 Y가 K개 필요하다"는 뜻이다. 두 중간 부품이 서로를 필요로 하는 경우가 없다.
<출력값>
하나의 완제품을 조립하는데 필요한 기본 부품의 수를 한 줄에 하나씩 출력하되(중간 부품은 출력하지 않음), 반드시 기본 부품의 번호가 작은 것부터 큰 순서가 되도록 한다. 각 줄에는 기본 부품의 번호와 소요 개수를 출력한다.
정답은 2,147,483,647 이하이다.

<문제 2638>
N×M (5≤N, M≤100)의 모눈종이 위에 아주 얇은 치즈가 <그림 1>과 같이 표시되어 있다. 단, N 은 세로 격자의 수이고, M 은 가로 격자의 수이다. 이 치즈는 냉동 보관을 해야만 하는데 실내온도에 내어놓으면 공기와 접촉하여 천천히 녹는다. 그런데 이러한 모눈종이 모양의 치즈에서 각 치즈 격자(작 은 정사각형 모양)의 4변 중에서 적어도 2변 이상이 실내온도의 공기와 접촉한 것은 정확히 한시간만에 녹아 없어져 버린다. 따라서 아래 <그림 1> 모양과 같은 치즈(회색으로 표시된 부분)라면 C로 표시된 모든 치즈 격자는 한 시간 후에 사라진다.

<그림 2>와 같이 치즈 내부에 있는 공간은 치즈 외부 공기와 접촉하지 않는 것으로 가정한다. 그러므 로 이 공간에 접촉한 치즈 격자는 녹지 않고 C로 표시된 치즈 격자만 사라진다. 그러나 한 시간 후, 이 공간으로 외부공기가 유입되면 <그림 3>에서와 같이 C로 표시된 치즈 격자들이 사라지게 된다.

모눈종이의 맨 가장자리에는 치즈가 놓이지 않는 것으로 가정한다. 입력으로 주어진 치즈가 모두 녹아 없어지는데 걸리는 정확한 시간을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 모눈종이의 크기를 나타내는 두 개의 정수 N, M (5≤N, M≤100)이 주어진다. 그 다음 N개의 줄에는 모눈종이 위의 격자에 치즈가 있는 부분은 1로 표시되고, 치즈가 없는 부분은 0으로 표시된다. 또한, 각 0과 1은 하나의 공백으로 분리되어 있다.
<출력값>
출력으로는 주어진 치즈가 모두 녹아 없어지는데 걸리는 정확한 시간을 정수로 첫 줄에 출력한다.

<문제 2639>
<그림 1>과 같이 정사각형 NxN 크기의 주차장이 있다. 이 주차장에는 차들이 많이 있는데, 우리 차를 주차장 밖으로 빼내어야 한다. 그런데 차를 움직일 수 있는 주차관리원은 한 명 뿐이다. 이 주차관리원이 하나의 차를 타고 그 차를 움직이는 것을 하나의 “작업”이라 부르기로 한다. 하나의 작업에 차는 앞뒤로 다른 차와 겹치지 않는 한 얼마든지 움직일 수 있다. 다음의 가정 하에 작업의 횟수를 가장 적게 하면서 우리 차를 주차장 밖으로 빼내기 위해서 움직여야하는 모든 차들의 순서를 계산하는 프로그램을 작성하시오. 답이 여러 가지가 나올 수 있는 경우에는 그 중 하나만 출력한다.
가정

모든 차의 폭은 1이고, 길이는 2 또는 3 이다.
차는 주차되어 있는 방향에 따라 수직차(예:<그림 1>의 4번차), 수평차(예:<그림 1>의 3번차)로 구분한다. 수직차는 상하로만, 수평차는 좌우로만 움직일 수 있고 회전은 할 수 없다.
같은 차에 대해서 여러 번 작업할 수 있다.
우리 차 외에 다른 차는 작업 도중 조금이라도 주차장 밖으로 나갈 수 없으며, 우리 차가 완전히 주차장을 나가는 순간에 전체 작업은 끝난다(<그림 2>).
우리 차가 수평차라면 오른쪽으로만 주차장을 나갈 수 있고, 수직차이면 위쪽으로만 나갈 수 있다.
입력 데이터에서 우리 차는 반드시 주차장을 빠져 나갈 수 있도록 되어 있다.
<입력값>
첫째 줄에는 주차장의 크기를 나타내는 정수 N (3 ≤ N ≤ 15), 다음 N 개의 줄에는 각각 N 개의 숫자가 한 칸씩 띄어서 나타나는데 0은 빈 공간을 뜻하고, 1은 우리 차를 뜻하며, 나머지 차에는 2부터 연속된 정수가 각각 부여된다.
<출력값>
첫째 줄에는 총 작업의 횟수를 나타내는 정수 K를 출력한다. 다음 K 줄은 진행된 작업을 순서대로 출력한다. 한 줄이 한 작업을 나타내며 두 개의 정수로 이루어진다.
첫째 정수는 움직인 차의 번호, 둘째 정수는 움직인 거리를 나타낸다. 단, 거리는 격자의 개수를 의미한다. 수평차인 경우 오른쪽 방향으로 움직인 거리를 양의 정수, 왼쪽 방향으로 움직인 거리를 음의 정수로 나타낸다. 수직차이면 위쪽 방향으로 움직인 거리를 양의 정수, 아래쪽 방향으로 움직인 거리를 음의 정수로 나타낸다.

<문제 2640>
최근에 인간의 유전자 염기서열을 밝히는 인간게놈(genome) 프로젝트가 완료되었다. 염색체내의 유전자의 염기서열을 알아내는 방법은 다음과 같다. 한 염색체의 염기서열이 너무 길면 현재의 기술로는 그 내용을 알아낼 수 없다. 따라서, 이를 PCR이라는 방식을 이용하여 여러 벌로 복제한 다음, 효소를 가하게 되면 염색체 조각들로 나뉘어진다. 이 염색체 조각들은 길이가 충분히 짧으므로 현재의 기술로 그 내용을 밝혀 낼 수 있다. 내용이 밝혀진 염색체 조각들을 다시 이어서 여러 벌의 동일한 염색체로 복구하여, 원래 염색체의 염기서열을 알아낸다. 유전자의 염기는 A, G, T, C라는 네 종류가 있으며, 이 들의 조합으로 염기서열을 표시한다.
예를 들어, 염색체의 염기서열이 있을 때, 이 염기서열을 3벌로 복제한 뒤, 효소를 가하여 11개로 나누고, 그 조각들의 내용을 밝힌 결과가 다음과 같다고 하자.

CGATGCCA
CAGGAAGCG
AGGTGCCC
CAGGA
AGGTGCCCGATGC
GGAAGCGATGGAGCTTT
ATGGAGCTTT
GATGC
CCGTGGA
AGCGATGG
TTTCGA

이 조각들을 다시 모아서 동일한 3벌의 염기서열로 재구성하면 다음과 같이 되고, 이를 통해서 전체 염색체의 염기서열을 알아낼 수 있다. 조각들은 그대로 사용할 수도 있고, 뒤집어서 사용할 수도 있다. 예를 들어 위의 마지막 조각인 TTTCGA는 AGCTTT로 뒤집어서 아래의 마지막 염기서열을 만드는데 사용하였다.

AGGTGCCCGATGC CAGGAAGCG ATGGAGCTTT
AGGTGCC CGATGCCA GGAAGCGATGGAGCTTT
AGGTGCCC GATGC CAGGA AGCGATGG AGCTTT

복제된 염색체의 벌 수와 내용이 밝혀진 염색체 조각들이 입력으로 주어져 있을 때 전체 염기서열을 구하는 프로그램을 작성하시오.
<입력값>
첫 줄에는 복제한 염기서열의 벌 수 k(k는 2이상 20이하)가 주어진다. 그 다음 줄에는 염색체 조각 수 n이 주어진다(n은 200이하). 다음 n개의 줄에 염색체 조각들이 한 줄에 하나씩 주어진다(각 염색체 조각의 길이는 5이상 70이하). 주어진 염색체의 조각에 열거된 순서대로 1번부터 n번까지의 번호를 부여한다. 즉, 앞의 예에서 염색체 조각 CAGGA의 번호는 4이다. 전체 염기서열의 길이는 30이상 700이하이다.
<출력값>
알아낸 k벌의 염기서열을 구성하는 조각의 개수와 조각 번호들을 한 줄에 한 벌씩 순서대로 출력한다. 만일 어떤 염색체 조각이 뒤집어서 사용된 경우는 그 조각 번호의 음의 값을 출력한다. 조각 번호 사이에는 빈 칸을 하나 씩 둔다. 알아낸 염기서열의 시작은 염색체 양 끝 어느 쪽에서 시작해도 무방하며 경우에 따라서 답은 하나 이상일 수가 있는데 이 경우에는 하나만 출력하면 된다. 그리고 출력되는 k벌의 염기서열들의 순서는 상관없다. 단, 출력된 조각번호 순서 대로 구성된 k벌의 염기서열들은 앞 뒤 순서가 모두 같아야 한다.

<문제 2641>
모눈종이에 다각형을 그리려고 한다. 그리는 방법은 모양수열로 표시된다. 모양수열은 1과 4사이의 숫자가 연속되어 나열된 것으로 1은 오른쪽으로, 2는 위쪽으로, 3은 왼쪽으로, 4는 아래쪽으로 한 칸씩 그리는 것을 말한다.

	예를 들어 아래 그림의 다각형 (2)는 점 A에서 시작하여 화살표 방향으로 모양수열 1411433322를 따라서 그린 것이다. 다각형 (3)은 점 B에서 시작하여 화살표 방향으로 모양수열 3221411433을 따라서 그린 것이다. 또한 다각형(4)는 점 C에서 시작하여 화살표 방향으로 모양수열 4411123323을 따라서 그린 것이다. 다각형 (2), (3), (4)는 다각형 (1)과 같으므로 모양수열들 1411433322, 3221411433, 4411123323은 모두 같은 다각형을 그릴 수 있다. 단, 다각형이 회전된 것이나 뒤집어진 것은 같은 다각형이 아니다. 그러므로 아래 그림의 다각형 (5)와 (6)은 다각형 (1)과 다르다.



	한 개의 표본 모양수열과 여러 모양수열들이 주어졌을 때 표본 모양수열과 같은 다각형을 그릴 수 있는 모양수열들을 모두 찾는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 표본 모양수열의 길이(숫자의 개수)가 주어지고, 둘째 줄에는 표본 모양수열이 주어진다. 셋째 줄에는 모양수열의 개수가 주어지고 넷째 줄부터는 각 줄에 표본 모양수열과 같은 길이의 모양수열이 하나씩 주어진다. 단, 모양수열들의 개수는 최대 100 개이고 모양수열의 길이는 최대 50 이다. 모양수열의 각 숫자 사이에는 빈칸이 하나 있다.
<출력값>
첫째 줄에는 입력된 표본 모양수열과 같은 다각형을 그리는 모양수열들의 개수를 출력한다. 둘째 줄부터는 각 줄에 표본 모양수열과 같은 다각형을 그릴 수 있는 모양수열을 출력한다. 출력되는 모양수열의 숫자들은 한 칸 띄고 출력한다.

<문제 2642>
아래에 주어진 전개도의 점선 부분을 접어서 주사위 모양의 정육면체를 만들 수 있는지를 생각해 보자. 전개도의 각 면은 1에서 6까지 서로 다른 정수로 표시되어 있다.

전개도 (1)은 정육면체로 접을 수 있지만, 전개도 (2)는 정육면체로 접을 수 없다. 입력으로 주어진 전개도를 정육면체로 접을 수 있는지를 알아보는 프로그램을 작성하시오.
<입력값>
입력은 여섯 줄로 되어 있으며 각 줄에는 0에서 6까지의 정수들이 여섯 개 있고, 숫자 사이에는 빈칸이 하나씩 있다. 1에서 6까지의 숫자는 전개도의 면을 나타내고, 0은 전개도의 바깥 부분을 나타낸다.
<출력값>
입력된 전개도를 정육면체로 접을 수 있으면, 정육면체에서 1번으로 표시된 면의 맞은 편 면의 번호를 출력하고, 정육면체로 접을 수 없으면 0을 출력한다.

<문제 2643>
크기가 모두 다른 직사각형 모양의 색종이가 여러 장 있다. 색종이를 하나씩 올려 놓아, 되도록 많은 장수의 색종이들을 쌓으려고 한다.
새로 한 장의 색종이를 올려 놓을 때는 지금까지 쌓아 놓은 색종이들 중 맨 위의 색종이 위에 올려놓아야 하며 아래의 두 조건을 모두 만족해야 한다.

조건 1 : 새로 올려 놓는 색종이는 맨 위의 색종이보다 크지 않아야 한다. 즉, 맨 위의 색종이 밖으로 나가지 않아야 한다.
조건 2 : 새로 올려 놓는 색종이와 맨 위의 색종이의 변들은 서로 평행해야 한다.(색종이를 90˚돌려 놓을 수 있다.)

예를 들어, 아래의 그림 중에서 위의 두 조건을 모두 만족하는 경우는 (나)뿐이다.

색종이는 두 변의 길이로 표현된다. (3, 5)는 두 변의 길이가 각각 3과 5인 색종이를 나타낸다. 예를 들어, 다음과 같이 7장의 색종이가 주어졌다고 하자 : (1, 2), (8, 7), (20, 10), (20, 20), (15, 12), (12, 14), (11, 12) 위의 조건을 만족하면서 가장 많이 쌓을 수 있는 색종이들의 순서는 (20, 20), (15, 12), (12, 14), (11, 12), (8, 7), (1, 2)이다.
입력으로 색종이들이 주어졌을 때, 위의 조건 1과 조건 2를 만족하면서 쌓을 수 있는 최대 색종이 장수를 구하는 프로그램을 작성하시오.
<입력값>
첫 번째 줄에는 색종이의 장수가 주어진다. 다음 줄부터 각 줄에 색종이의 두 변의 길이가 주어진다. 두 변의 길이는 한 칸 띄어 주어진다. 색종이의 최대 장수는 100이고, 각 변의 길이는 1000보다 작은 자연수이다.
<출력값>
쌓을 수 있는 최대 색종이 장수를 출력한다.

<문제 2644>
우리 나라는 가족 혹은 친척들 사이의 관계를 촌수라는 단위로 표현하는 독특한 문화를 가지고 있다. 이러한 촌수는 다음과 같은 방식으로 계산된다. 기본적으로 부모와 자식 사이를 1촌으로 정의하고 이로부터 사람들 간의 촌수를 계산한다. 예를 들면 나와 아버지, 아버지와 할아버지는 각각 1촌으로 나와 할아버지는 2촌이 되고, 아버지 형제들과 할아버지는 1촌, 나와 아버지 형제들과는 3촌이 된다.
여러 사람들에 대한 부모 자식들 간의 관계가 주어졌을 때, 주어진 두 사람의 촌수를 계산하는 프로그램을 작성하시오.
<입력값>
사람들은 1, 2, 3, …, n (1≤n≤100)의 연속된 번호로 각각 표시된다. 입력 파일의 첫째 줄에는 전체 사람의 수 n이 주어지고, 둘째 줄에는 촌수를 계산해야 하는 서로 다른 두 사람의 번호가 주어진다. 그리고 셋째 줄에는 부모 자식들 간의 관계의 개수 m이 주어진다. 넷째 줄부터는 부모 자식간의 관계를 나타내는 두 번호 x,y가 각 줄에 나온다. 이때 앞에 나오는 번호 x는 뒤에 나오는 정수 y의 부모 번호를 나타낸다.
각 사람의 부모는 최대 한 명만 주어진다.
<출력값>
입력에서 요구한 두 사람의 촌수를 나타내는 정수를 출력한다. 어떤 경우에는 두 사람의 친척 관계가 전혀 없어 촌수를 계산할 수 없을 때가 있다. 이때에는 -1을 출력해야 한다.

<문제 2645>
회로를 n*n의 격자 판에 배치하려고 한다. 여기서 각 격자(정사각형 칸)는 가장자리에 있는 격자를 제외하고 상, 하, 좌, 우 4개의 이웃 격자를 갖는다. 회로는 시작과 끝이 있는 연속된 이웃 격자들의 길(path)이다. 아래 그림에서는 X와 Y, P와 Q를 연결한 두 개의 회로가 있다. 이미 회로들이 배치되어 있는 격자 판에 새로 배치할 회로의 양 끝 격자가 주어져 있을 때, 이들 두 격자를 잇는 새로운 회로를 배치하려고 한다.

	새로 배치될 회로는 이미 회로가 배치된 격자위에 배치될 수도 있다. 이 회로의 배치 비용은 이 회로가 지나는 격자에 따라 다음과 같이 결정된다. 회로가 배치되지 않은 빈 격자를 지나는 비용은 1이고, 이미 회로가 놓여있는 격자를 지날 때는 비용이 k(k≥2)이다. 주어진 문제는 최소의 비용이 소요되는 새로운 회로를 찾는 것이다.

	예를 들어 아래의 그림에서 k가 4로 주어진다면, 점선을 따라 격자 A와 B를 잇는 회로의 비용은 19이지만, 비용이 16인 최소비용 회로가 존재한다. (이 비용에는 A, B의 비용도 포함된다.)
<입력값>
첫째 줄에는 격자 판의 크기를 나타내는 정수(1≤n≤50)가 주어진다. 둘째 줄에는 새로 배치할 회로의 시작 격자, 마지막 격자의 위치를 나타내는 4개의 정수가 주어진다. 한 격자의 위치는 위 그림에서 주어진 행과 열의 번호 순서로 주어진다. (시작 격자와 마지막 격자의 위치는 같을 수 없다.) 셋째 줄에는 회로가 배치된 격자를 지나는데 드는 비용인 정수 k가 주어진다. 넷째 줄에는 이미 배치된 회로의 개수가 주어진다. 다섯째 줄부터는 한줄에 한 회로의 배치 정보가 다음과 같이 주어진다. 첫째 정수는 회로의 시작 격자, 90°로 꺾이는 방향 전환 격자들, 그리고 마지막 격자의 총 개수이고, 그 다음 부터는 이들 격자의 위치가 시작 격자부터 마지막 격자까지 행과 열의 순서대로 주어진다.
<출력값>
첫째 줄에는 회로의 최소 비용을 출력한다. 둘째 줄에는 최소비용 회로의 정보를 다음과 같이 출력한다. (입력 형식과 동일함) 처음에 회로의 시작 격자, 90°로 꺾이는 방향 전환 격자들, 그리고 마지막 격자의 총 개수를 출력한다. 그 다음부터는 이들 격자의 위치를 시작 격자부터 마지막 격자까지 행과 열의 순서대로 한 개씩 공백을 두고 출력한다.

<문제 2646>
승연이는 길이가 정수인 동일한 막대기를 여러 개 가지고 있는데, 이 막대기들을 각각 정수의 길이를 갖는 여러 개의 토막으로 아무렇게나 잘랐다. 단, 어떤 막대기는 자르지 않을 수도 있다.
승연이는 이렇게 잘려진 토막들을 다시 붙여서 원래 상태의 막대기로 만들려고 하는데 원래 자기가 가지고 있던 막대기의 수와 막대기의 길이를 잊어버렸다. 그래서 승연이는 길이가 모두 같은 가장 짧은 막대기들로 복원하기로 하였다.
문제는 잘려진 모든 토막으로부터 구성될 수 있는 같은 길이의 막대기 중에서 가장 짧은 길이를 계산하는 프로그램을 작성하는 것이다.
아래 <그림>의 예에서 보듯이 같은 막대기 몇 개를 잘라서 길이가 {5,2,1,1,2,5,2,5,1}인 토막으로 만들었다. 문제는 이 토막들로부터 구할 수 있는 같은 길이의 막대기 중에서 가장 짧은 것을 구하는 것이다.
아래 그림의 예에서 길이가 12인 긴 막대기 2개를 만들 수도 있으나 가장 짧은 동일한 막대기들의 길이는 6이 된다.
<입력값>
입력은 두 줄로 구성된다. 첫째 줄에는 잘려진 토막들의 총 수를 나타낸다. 이 수는 최대 50이다. 두 번째 줄에는 작게 잘라진 토막들의 각 길이를 나타내는 정수가 나열된다. 각 토막의 길이를 나타내는 숫자 사이에는 하나씩의 공백이 있다. 각 토막의 길이 l 은 1≤l≤1,000 인 정수이다.
<출력값>
첫째 줄에 복구된 막대기들의 길이를 나타내는 정수를 출력한다. 그 다음 줄에는 각 토막들이 연결된 상태를 아래 출력 파일의 예와 같이 각 줄에 임의의 순서로 표시한다.

<문제 2647>
2n개의 점이 x축의 좌표 1,2,...2n에 놓여 있다. 그 중 n개는 검은 점이고, n개는 하얀 점이다. 하나의 검은 점과 하나의 하얀 점을 연결하여 한 쌍을 만들면, 모두 n개의 쌍이 만들어진다. 한 쌍의 점을 연결할 때는, 왼쪽 점에서 출발하여 수직으로 올라가고, 거기서 수평으로 오른쪽으로 간 후, 다시 수직으로 내려가서 연결하면 하나의 길이 생긴다. 이렇게 생긴 n개의 길들은 서로 겹쳐서는 안되고, 서로 교차해서도 안 된다. 모든 길의 거리의 합을 가장 작게 하도록 n개의 길을 만드는 프로그램을 작성하시오. 단, 거리의 단위는 수직, 수평 모두 1이다.

그림 1의 경우 다른 방법으로 연결할 수도 있지만, 위 방법이 최소 연결 방법이고 거리의 합이 31이다. 그림 2의 경우도 다른 방법이 있지만, 위 방법이 최소 연결이며 거리의 합은 40이다.
<입력값>
첫째 줄에는 점의 개수를 나타내는 정수 2n이 주어진다. 2n은 100이하의 정수이다. 그 다음 줄에는 n개의 0과 n개의 1로 이루어진 문자열이 주어진다. 0은 하얀 점이고, 1은 검은 점이다. 왼쪽부터 차례로 좌표 1,2,...2n에 해당한다.
<출력값>
첫째 줄에는 길의 거리의 합을 출력한다. 다음 n개의 줄의 각 줄에는 연결되는 한 쌍의 점들의 좌표를 나타내는 두 정수를 출력한다. 두 정수 사이에는 빈칸이 하나 있다. 앞의 정수가 뒤 정수보다 작아야하고, n개의 줄은 앞 정수가 커지는 순서로 출력한다.

<문제 2648>
평면상에서 어떤 로봇이 수평 또는 수직으로 선을 그으면서 움직인다. 이 로봇은 처음 정해진 위치에서 시작하여 움직인 뒤 다시 처음 위치로 되돌아 온다.

	로봇이 움직이는 방향은 위(UP), 아래(DOWN), 오른쪽(RIGHT), 왼쪽(LEFT) 4가지 뿐이며, 이는 각각 U, D, R, L로 표시된다. 또 움직인 거리는 양의 정수이다. 움직임은 방향과 거리로써 표현되는데 예를 들어 "R 3"이라고 하면 오른쪽으로 3만큼 움직인 것이다.

	최종적인 궤적을 살펴보면 다양한 다각형이 생겨난다. 이 다각형중에서 그 내부에 다른 점이나 선분을 포함하지 않은 사각형을 단순 사각형이라고 한다. 문제는 주어진 궤적으로 만들어진 단순 사각형 중에서 가장 작은 면적의 단순 사각형을 구하는 것이다.



	위의 그림에서 촤표(4, 9)는 출발점이고 로봇의 움직인은 R 7, D 5, L 10, U 3, ... 으로 진행된다. 위 그림에서 회색으로 표시한 부분이 가장 작은 면적의 단순 사각형이므로 이것이 답이 된다.

	두 선분이 만나는 경우는 수직선분과 수평선분이 한 점에서 만나는 경우 뿐이며 수평선분과 수평선분, 수직선분과 수직선분이 서로 만나거나 겹치는 경우는 없다.
<입력값>
첫째 줄에는 시작점의 x좌표와 y좌표가 하나의 빈칸을 사이에 두고 주어진다. 그 다음 줄에는 움직인 동작의 횟수 n이 주어진다. n은 100 이하의 정수이다. 그 다음 n개의 줄에는 움직임의 방향(U, D, R, L)과 거리가 하나의 빈칸을 사이에 두고 주어진다. 로봇의 움직임은 x, y 모두 1 이상 100 이하의 정수 좌표 내에서 이루어진다.
<출력값>
가장 작은 면적을 갖는 단순 사각형의 왼쪽 아래 꼭짓점의 좌표를 첫째 줄에, 오른쪽 위 꼭짓점의 좌표를 둘째 줄에 출력하면 된다. 좌표의 출력은 x좌표, y좌표 순으로 하며 하나의 빈칸을 사이에 둔다. 가장 작은 면적의 단순 사각형이 여러 개인 경우에는 그 중에서 하나만 출력하면 된다. 만일 단순 사각형이 존재하지 않으면 첫째 줄에 0 을 출력한다.

<문제 2649>
방학 중 비상 연락을 위하여 전체 학생에게 연락할 수 있는 비상 연락망을 구성하였다. 이 연락망의 구성은 반 전체 학생들을 반장을 제외하고 k개의 조로 나누고, 반장은 1조의 학생들의 전화번호를 모두 가지고 있고, 1조의 각 학생은 2조의 학생들 중 일부의 전화번호를, …, i조의 각 학생은 (i+1)조 학생들 중 일부의 전화번호를 가지고 있다. 이 연락망을 이용하여 가장 신속한 비상 연락게획을 결정하려고 한다.

	비상 연락은 반장으로부터 시작하며 연락을 받은 학생은 자기가 전화번호를 가지고 있는 학생에게 전화할 수 있다. 모든 학생은 정확히 1명으로부터만 전화를 받는다. 단, 전화는 한 통화에 1분이 걸리고, 한 사람이 여러 학생에게 전화할 경우 한 명씩 순차적으로 한다.



	위 그림은 비상 연락망의 예이다. 반장은 1번으로 표시하고, 나머지 학생들은 2부터 일련번호로 표시한다. 그림에서 번호가 주어진 사각형은 해당 학생들을 나타내는 노드들이고, 학생 a가 학생 b 의 전화번호를 가지고 있으면 노드 a에서 노드 b로 화살표가 주어진다.

	위 그림과 같이 비상 연락망이 구성되어 있는 경우 아래의 표는 가능한 비상 연락계획 가운데 두가지를 보여주고 있다. 연락계획 A는 4분만에 연락을 완료하고, 연락계획 b는 5분이 걸린다.



	주어진 연락망을 이용하여 모든 학생들에게 연락할 수 있는 가장 신속한 비상 연락계획을 세우는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 전체 반의 학생 수 n이 주어진다. 이때 n은 100이하의 정수이다. 그 다음 n개의 줄에는 각 줄마다 학생의 번호와 그 학생이 전화번호를 가지고 있는 학생들의 번호가 하나의 빈칸을 상이에 두고 주어진다.
<출력값>
첫째 줄에 비상 연락에 걸리는 총 시간을 분 단위로 출력하고 다음 줄부터 순서대로 매분마다 연락이 이루어지는 송신자 번호와 수신자 번호의 순서쌍들을 한 줄에 출력한다.

	예를 들어, 연락계획 A에서 통화시각 2에 연락이 이루어지는 쌍은 (1,3)과 (4,6)이다. 이에 대한 출력은 아래와 같이 첫 칸에 시작하여 하나의 빈칸을 사이에 두고 

	1 3 4 6 또는 

	4 6 1 3

	과 같이 출력한다.

<문제 2650>
직사각형의 변 위에 여러 모양의 점들이 있고, 같은 모양의 점들은 정확히 두 개씩 있다. 단 직사각형의 꼭짓점에 놓인 점은 없다. 이제 같은 모양의 두 점들을 직선이나 곡선으로 연결하려고 한다. 연결된 선들은 반드시 직사각형의 내부만을 지나야 하며, 세 개 이상의 연결선들이 한 점에서 만나서는 안 된다. 연결선과 연결선이 만나는 교차점의 개수를 가장 작게 하려고 할 때 최소 교차점의 개수를 구하는 프로그램을 작성하시오.
예를 들어, 점들이 아래 그림과 같이 주어졌다고 하자. 각 점의 위치는 두 개의 양의 정수로 표시된다. 첫째 숫자는 점이 위치한 변을 나타내는데, 1은 윗변, 2는 밑변, 3은 왼쪽 변, 4는 오른쪽 변을 의미한다. 둘째 숫자는 변 위에서의 위치를 나타낸다. 점이 윗변이나 밑변에 있는 경우는 왼쪽 꼭짓점부터의 거리를 나타내고, 점이 왼쪽 변이나 오른쪽 변에 있는 경우는 위쪽 꼭짓점부터의 거리를 나타낸다. 즉, 점 (4, 7)은 오른쪽 변에 있는 점으로 변의 위쪽 꼭짓점으로부터 거리 7만큼 떨어져 있다. 이 그림에서, 두 점(3, 5)와 (4, 7)을 점선과 같이 연결하여, 세 개의 연결선들이 한 점에서 만나게 하면 안 된다. 이 그림에서 최소 교차점의 개수는 4이다.
<입력값>
입력의 첫째 줄에는 주어진 점들의 개수가 있다. 단, 점들의 개수는 50을 넘지 않는다. 둘째 줄 이후부터는 각 줄에 모양이 같은 두 점의 위치가 네 개의 숫자로 주어지는데, 첫 번째와 두 번째 숫자가 한 점을 나타내고 세 번째와 네 번째 숫자가 다른 한 점을 나타낸다. 주어진 점들의 위치는 모두 다르다. 각 숫자는 양의 정수이며, 숫자 사이에는 빈칸이 하나 있다.
<출력값>
출력의 첫째 줄에는 최소 교차점의 개수를 출력하고, 둘째 줄에 가장 많은 교차점을 갖는 연결선의 교차점 개수를 출력한다.

<문제 2651>
전국 자동차 경주 대회가 매년 열리고 있다. 이 대회에서는 출발지점부터 도착지점까지 거리가 워낙 멀기 때문에 경주 도중에 각 자동차는 정비소를 방문하여 정비를 받아야 한다. 정비소들은 출발지점에서 도착지점으로 가는 길가에 있으며 ①번부터 차례로 번호가 붙어 있다.
이 대회에서는 참가하는 선수의 안전을 위하여 정비를 받지 않고 미리 정한 거리를 초과하여 갈 수 없도록 규칙을 정하였다. 그리고 정비소마다 정비하는데 걸리는 정비 시간이 서로 다를 수 있다.
정비소에서 정비하는데 걸리는 시간을 가장 적게 하려고 할 때 최소 총 정비시간과 방문하는 정비소들을 구하는 프로그램을 작성하시오.
예를 들어, 아래 그림과 같이 정비소가 5개 있고, 한 번 정비를 받고 최대 140㎞를 갈 수 있는 경우를 생각해 보자. 출발지점에서 정비소 ①까지의 거리가 100㎞이고, 정비소 ①을 방문하여 정비할 때 걸리는 시간은 5분이다.

자동차가 출발지점에서 대회 규칙을 지키면서 정비소 ①, ③, ⑤를 차례대로 방문하여 도착지점까지 갈 수 있고, 정비소 ②, ④를 방문하여 갈 수도 있다. 정비소 ①, ③, ⑤를 방문하는 경우에는 16분(=5+4+7분)이 걸리는데, 이것은 정비소 ②, ④를 방문하여 걸리는 21분(=10+11분)보다 총 정비 시간이 적게 걸린다.
<입력값>
첫째 줄에는 정비를 받지 않고 갈 수 있는 최대 거리가 주어진다. 둘째 줄에는 정비소의 개수가 입력되는데 정비소 수는 100개 이하이다. 셋째 줄에는 인접한 정비소 사이의 거리가 차례로 주어지는데 거리는 정비를 받지 않고 갈 수 있는 최대 거리보다 작거나 같고 모든 거리의 합은 231-1 이하이다. 넷째 줄에는 정비소별 정비 시간이 차례로 주어지는데 모든 정비 시간의 합은 231-1 이하이다. 모든 입력은 양의 정수이며 231-1 이하이다.
<출력값>
첫째 줄에 정비소에서 정비하는데 걸리는 총 정비 시간을 출력한다. 둘째 줄에 방문하는 정비소의 개수를 출력한다. 셋째 줄에는 방문하는 정비소의 번호를 한 줄에 차례로 출력하며 정비소 번호 사이에 빈칸을 하나씩 넣는다. 정비소를 전혀 방문하지 않아도 되는 경우에 총 정비 시간은 0이고 정비소 번호는 출력하지 않는다.

<문제 2652>
아래 그림과 같이 정사각형 모양의 판에 'ㄷ'자 모양의 블록들이 여러 개 꽂혀 있다. 이때, 'ㅗ'자 모양의 블록이 1개 주어지면 이 블록을 판에 꽂혀 있는 'ㄷ'자 블록의 오목한 부분에 끼워 넣어 그 모양이 직사각형을 이루는가를 알아내려고 한다.
'ㄷ'자 모양의 블록이란 직사각형 블록에서 작은 직사각형만큼을 뺀 것으로 이때 작은 직사각형의 변은 원래 직사각형의 변 하나와만 겹친다.
예를 들어, 'ㅗ'자 모양의 블록 (a)가 주어지면, 이는 'ㄷ'자 모양의 블록 A, B, C, D 중의 어느 블록에 맞추어도 직사각형을 만들 수 없으나, 블록 (b)를 블록 A에 끼우면 직사각형이 된다. 블록 (c)는 블록 C와 D모두에 맞는 블록이다.

'ㄷ'자 모양의 블록들이 들어 있는 판과 'ㅗ'자 모양의 블록이 1개 주어지면, 이 블록이 끼워져서 직사각형이 될 수 있는 'ㄷ'자 블록들을 구하는 프로그램을 작성하시오.
<주의사항>

정사각형은 직사각형의 일종이다.
'ㅗ'자 모양의 블록을 회전시킬수 있지만, 뒤집을 수는 없다.
'ㅗ'자 모양의 블록을 끼워서 만들어지는 직사각형이 이미 있던 'ㄷ'자 모양의 블록과 겹치면 안 된다.
'ㅗ'자 모양의 블록을 끼워서 만들어지는 직사각형이 판 바깥으로 나가면 안 된다.
<입력값>
첫째 줄은 판의 한 변의 길이가 입력된다. 판의 한 변의 길이는 50이하이다. 둘째 줄에는 오른쪽 그림과 같이 'ㅗ'자 모양의 블록을 나타내는 양의 정수 u, v, w, x, y가 차례로 입력된다. 셋째 줄부터는 판이 입력된다. 'ㄷ'자 모양의 블록이 꽂혀 있는 자리는 1, 블록이 꽂혀 있지 않은 자리는 0으로 표시된다.
주어지는 판에 있는 모든 블록은 'ㄷ'자 모양 블록이며 'ㄷ'자 모양 블록들은 서로 인접해있지 않다.
<출력값>
출력의 첫째 줄은 'ㅗ'자 모양의 블록을 끼워서 직사각형이 될 수 있는 'ㄷ'자 모양 블록의 개수를 출력한다. 둘째 줄부터는 'ㅗ'자 모양의 블록을 끼워서 직사각형이 될 수 있는 'ㄷ'자 모양 블록의 왼쪽 위 구석의 위치를 한 줄에 하나씩 출력한다. 구석의 위치는 판의 윗변에서 떨어진 거리와 판의 왼쪽 변에서 떨어진 거리로 나타낸다. 구석의 위치를 나타내는 두 수 사이에는 빈 칸을 하나 둔다. 출력해야 하는 위치가 여러 개인 경우에 출력하는 순서는 임의로 한다.
'ㅗ'자 모양의 블록을 끼워서 직사각형이 될 수 있는 'ㄷ'자 모양의 블록이 없는 경우는 0만 출력한다.

<문제 2653>
어떤 심리학자는 학교의 학급이나 회사의 부서와 같이 여러 사람들이 모인 집단이 어떤 경우에 안정되어 있는지를 연구하였다. 심리학자는 집단에 속한 모든 사람들이 서로 좋아하거나 혹은 그 집단이 여러 개의 소집단으로 나누어져 각 소집단 내에 있는 사람들끼리는 모두 서로 좋아하고 서로 다른 소집단에 속한 사람들끼리는 모두 서로 싫어한다면 그 집단은 안정되어 있다는 사실을 발견하였다. 단, 소집단은 적어도 2명 이상의 사람들로 구성되어야 한다. 예를 들면, 어떤 한 사람을 좋아하는 사람이 아무도 없다면 이 집단은 안정된 집단이 아니다.

	n명으로 구성된 집단에서 사람들을 1번부터 n번까지 번호를 붙이고 서로 좋아하는 관계인지 아니면 싫어하는 관계인지를 조사하여 서로 좋아하면 0으로 나타내고 서로 싫어하면 1로 나타낸다. 집단 내의 모든 사람들 사이에 이러한 관계가 주어져 있을 때 여러분들은 이 집단이 안정되어 있는지 혹은 그렇지 않은지를 판단하고, 안정되어 있을 경우에는 한 개의 집단인지 혹은 여러 대의 소집단들로 분할되는지를 알아내야 한다.

	< 그림 1 >과 같은 경우에 집단 {1, 2, 3, 4, 5}를 소집단 {1, 4, 5}와 {2, 3}으로 분할했을 때 각 소집단에 속한 사람들끼리는 모두 서로 좋아하고 서로 다른 소집단에 속한 사람들끼리는 모두 서로 싫어하므로 안정된 집단이라고 볼 수 있다.
<입력값>
첫째 줄에는 집단에 속한 사람들의 수 n(2≤n≤100)이 나타나있다. 둘째 줄부터 시작하여 n개의 줄에는 번호 순서대로 각 사람들이 다른 사람들을 좋아하는지 혹은 싫어하는지에 따라 순서대로 0 혹은 1의 값이 주어진다. 각 사람들은 자기 자신을 좋아한다고 가정한다. 그리고, 0과 1사이는 빈칸이 하나씩 있다.
<출력값>
주어진 입력이 안정되지 않은 집단의 경우는 첫줄에 빈칸 없이 0을 출력한다. 안정된 집단의 경우는 첫줄에 서로 좋아하는 소집단의 수를 빈칸 없이 출력하고, 그 다음 줄부터는 각 줄마다 각 소집단에 속하는 사람의 번호를 빈칸 하나에 의해 분리하여 출력한다. 출력 순서는 소집단 내에서는 번호의 오름차순으로 출력하고, 소집단 간에는 그 소집단에 속하는 제일 작은 번호의 오름차순으로 출력한다.

<문제 2654>
평면에 여러 개의 점이 주어져 있다. 이 점들에는 각각 번호가 1번부터 차례대로 붙어 있다. 그리고 같은 번호의 점들은 각각 2개씩의 쌍으로 준비되어 있다. 따라서 전체 점의 수는 반드시 짝수 개이다. 우리는 같은 번호를 가진 두 개의 점을 대각선의 꼭짓점으로 하는 직사각형으로 연결하고자 한다. 이 직사각형을 연결사각형이라고 부른다. 문제는 다음의 세가지 조건을 만족하면서 서로 겹치지 않는 여러 개의 연결사각형을 찾아내는 것이다.

연결사각형은 반드시 같은 번호의 점을 대각선 꼭짓점으로 해야 한다.
	
만일 서로 다른 번호의 점을 직사각형으로 연결하면 안 된다.


각 연결사각형은 반드시 서로 떨어져 있어야 한다.
	
그림-1과 같은 경우는 허용되지 않는다.
그림-2와 같이 두 연결사각형의 변이나 꼭짓점이 서로 붙어있는 경우나, 
그림-3과 같이 어떤 직사각형이 다른 직사각형 안에 포함되는 경우도 
허용되지 않는다. 


연결사각형을 만들었을 때에 얻는 점수는 그 쌍에 부여된 번호와 같다.
	
따라서 그림-4와 같이 연결했을 경우에 얻는 점수는 1+4+5+6=16점이다.




위의 조건을 만족시키면서 가장 높은 점수를 얻도록 하는 프로그램을 작성하시오.
<입력값>
첫 줄에는 쌍의 수가 주어진다. 그 다음 줄부터는 1번부터 순서대로 두 점의 좌표가 나온다. 점들의 수는 50쌍(100개) 이하이다. 각 점의 좌표는 1000 이하의 양의 정수이다. 쌍을 이루는 두 점은 같은 수직선이나 같은 수평선 상에 있지 않다.
<출력값>
첫 줄에는 선택된 쌍의 수를 출력한다. 그 다음 줄에는 선택된 연결사각형의 번호를 오름차순으로 출력한다.

<문제 2655>
밑면이 정사각형인 직육면체 벽돌들을 사용하여 탑을 쌓고자 한다. 탑은 벽돌을 한 개씩 아래에서 위로 쌓으면서 만들어 간다. 아래의 조건을 만족하면서 가장 높은 탑을 쌓을 수 있는 프로그램을 작성하시오.

벽돌은 회전시킬 수 없다. 즉, 옆면을 밑면으로 사용할 수 없다.
밑면의 넓이가 같은 벽돌은 없으며, 또한 무게가 같은 벽돌도 없다.
벽돌들의 높이는 같을 수도 있다.
탑을 쌓을 때 밑면이 좁은 벽돌 위에 밑면이 넓은 벽돌은 놓을 수 없다.
무게가 무거운 벽돌을 무게가 가벼운 벽돌 위에 놓을 수 없다.
<입력값>
첫째 줄에는 입력될 벽돌의 수가 주어진다. 입력으로 주어지는 벽돌의 수는 최대 100개이다. 둘째 줄부터는 각 줄에 한 개의 벽돌에 관한 정보인 벽돌 밑면의 넓이, 벽돌의 높이 그리고 무게가 차례대로 양의 정수로 주어진다. 각 벽돌은 입력되는 순서대로 1부터 연속적인 번호를 가진다. 벽돌의 넓이, 높이 무게는 10,000보다 작거나 같은 자연수이다.
<출력값>
탑을 쌓을 때 사용된 벽돌의 수를 빈칸없이 출력하고, 두 번째 줄부터는 탑의 가장 위 벽돌부터 가장 아래 벽돌까지 차례로 한 줄에 하나씩 벽돌 번호를 빈칸없이 출력한다.

<문제 2656>
여러 그루의 사과나무가 들판에 서 있다. 이들을 포함하는 가장 작은 면적의 직사각형 울타리를 치려고 한다. 이를 결정하는 프로그램을 작성하시오. 사과나무의 위치는 평면상의 좌표로 주어지는데 좌표 값은 모두 정수이다. 구하려는 울타리의 네 꼭짓점도 모두 정수 좌표를 가져야 한다.



	이 경우 구하려는 울타리의 모양은 아래 그림과 같다.
<입력값>
첫째 줄에는 사과나무의 수를 나타내는 정수 n이 주어진다. 그 다음 n개의 줄에는 사과나무의 위치를 나타내는 x좌표와 y좌표가 주어진다. n은 1,000이하의 양의 정수이고 x,y좌표는 -20,000이상, 20,000이하의 정수이다.
<출력값>
직사각형 울타리의 네 꼭짓점을 나타내는 네 개의 좌표를 한 줄에 하나씩 출력한다. 네 꼭짓점은 임의의 한 꼭짓점에서 시작하여 시계 방향 순서로 출력되어야 한다.

<문제 2657>
어떤 도시의 한 운송 회사에서 그 도시에 살고 있는 손님들의 짐을 모아오려고 한다. 그 도시의 도로는 트리 형태여서 한 지점에서 다른 지점으로 가는 경로가 한가지 밖에 없다. 이 운송 회사는 최대 10톤까지 실을 수 있는 화물차 한 대를 사용하여 모든 손님들의 짐을 수거하려고 한다. 각 손님들의 짐은 임의의 정수인 무게로 나누어 실을 수 있고, 운송회사는 항상 지점 1에 있다고 가정한다.

	이 운송 회사의 목표는 모든 손님들의 짐을 다 모아오기 위하여 운행된 화물차의 총 운행거리를 되도록 짧게 하는 것이다. 예를 들어서 다음과 같은 도로를 생각해 보자. 지점 1은 운송 회사가 있는 곳이고 지점들 2, 3, 4, 5, 6은 손님들이 있는 장소이다. 각 지점들을 연결하고 있는 선 옆의 수는 두 지점간의 거리를 나타내며 각 손님들이 있는 지점 옆 괄호 안의 수는 손님이 갖고 있는 짐의 무게이다.



	이 경우, 화물차가 운송회사가 있는 곳인 지점 1에서 출발하여 지점 2와 4를 거쳐 지점 5에서 짐 6톤을 싣고, 지점 4와 2를 거쳐 지점 3의 짐 5톤 중 4톤을 실은 다음, 지점 2를 거쳐서 지점 1로 돌아와서 짐을 내린다. 다시 화물차는 지점 1에서 출발하여 지점 2와 4를 거쳐 지점 6에서 7톤을 싣고 지점 4와 2를 거쳐 지점 3에서 남은 짐 1톤을 싣고 지점 2를 거쳐 지점 1로 돌아오도록 경로를 정할 수 있다. 이때 화물차가 운행한 총 거리는 44 + 40 = 84 이다.

	도시의 도로 상에 있는 n개의 지점에서 손님들의 짐의 무게와 그 지점들 간의 (n-1)개의 거리들이 주어질 경우, 손님들의 모든 짐을 수거하여 회사로 돌아오기 위하여 화물차의 총 운행거리를 되도록 짧게 하는 수거 방법을 찾는 프로그램을 작성하시오.
<입력값>
첫 줄에는 지점들의 개수 n(n≤50)이 주어진다. 다음 줄부터는 지점 2에 있는 짐의 무게, 지점 3에 있는 짐의 무게, ..., 지점 n에 있는 짐의 무게가 한 줄에 하나씩 주어진다.

	그 다음에는 인접한 지점들의 쌍과 그 길이가 한 줄에 하나씩 모두 (n-1)줄이 주어진다.

	이때, 짐의 무게와 지점들 간의 거리는 모두 정수로 주어진다.

	n

	w2

	w3

	...

	wn

	I1 j1 d1

	i2 j2 d2

	...

	in-1 jn-1 dn-1
<출력값>
첫째 줄에 총 주행거리 D를 출력한다.

	그 다음 줄부터는 짐을 실은 순서대로 지점과 무게를 출력하고 지점 1에 돌아왔을 때는 1을 출력한다.

	D

	i1.1  w1.1

	...

	I1.k1  w1.k1

	1

	i2.k2  w2.k2

	...

	1

	...

	1

	ih.1  wh.1

	...

	ih.kh  wh.kh

	1

<문제 2658>
가로 10줄, 세로 10줄에 1 또는 0이 적혀진 배열이 있다. 이러한 배열 안에 있는 숫자 1들이 만드는 모양이 한 개의 직각이등변삼각형인지 아닌지 알아내는 프로그램을 작성하시오.
직각이등변삼각형의 적어도 한 변은 수평선 또는 수직선이다. 단, 직각이등변삼각형의 내부도 1로 채워져 있어야 한다. 입력된 모양은 삼각형이 아닐 수 있다.
<입력값>
입력은 10줄로 이루어지며 각 줄은 첫 칸부터 공백없이 10개의 0또는 1로 이루어진다.
<출력값>
입력된 모양이 직각이등변 삼각형을 이루는 경우에는 세 꼭짓점의 위치를 출력하고, 그렇지 않은 경우에는 0을 출력한다. 각 꼭짓점의 위치를 한 줄에 두 개의 수로 출력한다. 두 수는 하나의 빈 공백을 두고 출력한다. 첫째 수는 그 꼭짓점이 위에서부터 몇 번째 줄에 있는가 나타내며, 두 번째 수는 왼쪽부터 몇 번째 칸에 있는가를 나타내야 한다. 꼭짓점을 출력할때는 첫째 수가 작은 것부터, 첫째 수가 같을 경우 두 번째 수가 작은 것부터 출력한다.

<문제 2659>
위와 같은 십자모양의 한 장의 카드에서, 네 모서리에 1 이상 9 이하의 숫자가 하나씩 씌여 있다. 이 네 개의 숫자 중에는 같은 숫자도 있을 수 있다.

	모든 가능한 십자 카드가 주어질 때, 각각의 카드는 다음과 같은 '시계수'라는 번호를 가진다. 시계수는 카드의 숫자들을 시계 방향으로 읽어서 만들어지는 네 자리 수들 중에서 가장 작은 수이다. 위 그림의 카드는 시계방향으로 3227, 2273, 2732, 7322로 읽을 수 있으므로, 이 카드의 시계수는 가장 작은 수인 2273이다.

	입력으로 주어진 카드의 시계수를 계산하여, 그 시계수가 모든 시계수들 중에서 몇 번째로 작은 시계수인지를 알아내는 프로그램을 작성하시오.

	예를 들어서, 다음과 같은 십자 카드의 시계수는 1122이며, 이 시계수보다 작은 시계수들은 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119 뿐이므로 1122는 10번째로 작은 시계수다. (여기서 십자카드는 0 이 나타날 수 없으므로 1120은 시계수가 될 수 없다. 또한 1121 이 적혀있는 카드의 시계수는 1112이므로, 1121은 시계수가 될 수 없다.
<입력값>
입력은 한 줄로 이루어지며, 이 한 줄은 카드의 네 모서리에 씌여있는 1 이상 9 이하의 숫자 4개가 시계 방향으로 입력된다. 각 숫자 사이에는 빈칸이 하나 있다.
<출력값>
입력된 카드의 시계수가 모든 시계수들 중에서 몇 번째로 작은 시계수인지를 출력한다.

<문제 2660>
월드컵 축구의 응원을 위한 모임에서 회장을 선출하려고 한다. 이 모임은 만들어진지 얼마 되지 않았기 때문에 회원 사이에 서로 모르는 사람도 있지만, 몇 사람을 통하면 모두가 서로 알 수 있다. 각 회원은 다른 회원들과 가까운 정도에 따라 점수를 받게 된다.
예를 들어 어느 회원이 다른 모든 회원과 친구이면, 이 회원의 점수는 1점이다. 어느 회원의 점수가 2점이면, 다른 모든 회원이 친구이거나 친구의 친구임을 말한다. 또한 어느 회원의 점수가 3점이면, 다른 모든 회원이 친구이거나, 친구의 친구이거나, 친구의 친구의 친구임을 말한다.
4점, 5점 등은 같은 방법으로 정해진다. 각 회원의 점수를 정할 때 주의할 점은 어떤 두 회원이 친구사이이면서 동시에 친구의 친구사이이면, 이 두사람은 친구사이라고 본다.
회장은 회원들 중에서 점수가 가장 작은 사람이 된다. 회장의 점수와 회장이 될 수 있는 모든 사람을 찾는 프로그램을 작성하시오.
<입력값>
입력의 첫째 줄에는 회원의 수가 있다. 단, 회원의 수는 50명을 넘지 않는다. 둘째 줄 이후로는 한 줄에 두 개의 회원번호가 있는데, 이것은 두 회원이 서로 친구임을 나타낸다. 회원번호는 1부터 회원의 수만큼 붙어 있다. 마지막 줄에는 -1이 두 개 들어있다.
<출력값>
첫째 줄에는 회장 후보의 점수와 후보의 수를 출력하고, 두 번째 줄에는 회장 후보를 오름차순으로 모두 출력한다.

<문제 2661>
숫자 1, 2, 3으로만 이루어지는 수열이 있다. 임의의 길이의 인접한 두 개의 부분 수열이 동일한 것이 있으면, 그 수열을 나쁜 수열이라고 부른다. 그렇지 않은 수열은 좋은 수열이다.
다음은 나쁜 수열의 예이다.

33
32121323
123123213

다음은 좋은 수열의 예이다.

2
32
32123
1232123

길이가 N인 좋은 수열들을 N자리의 정수로 보아 그중 가장 작은 수를 나타내는 수열을 구하는 프로그램을 작성하라. 예를 들면, 1213121과 2123212는 모두 좋은 수열이지만 그 중에서 작은 수를 나타내는 수열은 1213121이다.
<입력값>
입력은 숫자 N하나로 이루어진다. N은 1 이상 80 이하이다.
<출력값>
첫 번째 줄에 1, 2, 3으로만 이루어져 있는 길이가 N인 좋은 수열들 중에서 가장 작은 수를 나타내는 수열만 출력한다. 수열을 이루는 1, 2, 3들 사이에는 빈칸을 두지 않는다.

<문제 2662>
어떤 투자가가 여러 기업들에게 돈을 투자해서 최대의 이익을 얻고자 한다. 단, 투자는 만원 단위로 할 수 있으며 각 기업은 많이 투자할수록 많은 이익을 투자가에게 돌려준다. 돈을 투자하지 않은 경우는 당연히 얻게 되는 이익도 없다. 예를 들어서, 한 투자가가 4만원을 갖고 두 개의 기업들에 각각 만원 단위로 투자했을 경우 얻을 수 있는 이익은 다음과 같다.



투자 액수 (만원)
기업 A
기업 B




1
5
1


2
6
5


3
7
9


4
8
15 



위의 경우 만일, 기업 A에 1만원, 기업 B에 3만원을 투자하는 경우 투자가가 얻는 이익은 14만원(5만원+9만원)이다. 4만원을 투자해서 가장 많은 이익을 얻을 경우 기업 B에만 4만원을 투자하는 경우로서 이때의 이익은 15만원이다. 여기서 투자가는 한 기업에 돈을 나누어 투자할 수는 없다.
투자액이 정해져 있고, 기업의 개수와 각 기업에 투자했을 경우에 얻게 되는 이익이 주어졌을 때 가장 많은 이익을 얻을 수 있는 투자방식과 이때의 이익금을 구하는 프로그램을 작성하라.
<입력값>
첫째 줄에 투자 금액 N과 투자 가능한 기업들의 개수 M이 주어진다. (1 ≤ N ≤ 300, 1 ≤ M ≤ 20)
둘째 줄부터 N개의 줄에 투자액수와 각 기업이 투자가에게 주는 이익이 주어진다. 투자 금액은 항상 1보다 크거나 같고, N보다 작거나 같고, 같은 투자 금액이 두 번 이상 주어지는 경우는 없다. 즉, i번 줄에 주어지는 투자 금액은 i-1만원이다.
<출력값>
첫 줄에 얻을 수 있는 최대 이익을 출력하고, 둘째 줄에는 각 기업에 투자한 액수를 출력한다. 최대 이익은 231보다 작다.

<문제 2663>
어떤 섬나라의 해변은 수직선분과 수평선분으로만 구성되어 있다. 우리는 이 나라의 해안에 둑을 쌓아 간척지를 만들려고 한다. 이러한 간척지를 만들기 위해서 쌓아야 하는 둑은 수평 선분이거나 수직 선분이어야 한다.이때 간척지의 효율은 (간척지의 넓이)÷(둑의 길이)로 계산된다. 문제는 이 효율을 최대로 하는 간척지의 효율을 구하는 것이다.

만일, (a-b) 지점을 막아서 간척지를 만들면, 그로부터 만들어지는 간척지의 넓이는 5, 둑의 길이는 1이므로 효율은 5÷1=5가 된다. 이와 비교해서 (f-g) 지점을 막으면, 둑의 길이는 3, 그로부터 만들어지는 간척지의 넓이는 8이므로 효율은 8÷3=2.667이 된다. 따라서 (a-b) 둑이 (f-g) 둑보다 더 효율적이라고 본다. 계속해서 (c-d) 지점을 막으면 그 효율은 4÷2=2가 되고 (c-e) 지점을 막으면, 그 효율은 6÷3=2가 된다. 따라서 위의 그림과 같은 섬나라에서는 (a-b) 지점을 막는 것이 가장 효율적이다.
<입력값>
첫째 줄에는 꼭짓점의 개수가 주어진다.두 번째 줄부터는 꼭짓점 좌표가 반시계 방향으로 한 줄에 다섯 개씩 순서대로 들어있다. 꼭짓점의 좌표 값은 250 이하의 양의 정수이며, 꼭짓점의 개수는 100개 이하이다.
<출력값>
첫 번째 줄에 간척지의 최대 효율을 소수 셋째 자리에서 반올리하여 소수 둘째 자리까지 출력한다.

<문제 2664>
n개의 꼭짓점들과 수평선분 및 수직선분들로 구성된 다각형은 꼭짓점들의 좌표가 주어질 때 다음과 같이 표현될 수 있다.
다각형 = {(X1, Y1), (X2, Y2), …,(Xn, Yn)}
여기서 (X1, Y1)은 맨 아래 가장 왼쪽에 있는 꼭짓점의 좌표이며, 그 다음 좌표들은 (X1, Y1)에서 반시계방향으로 다각형의 둘레를 따라 돌면서 만나는 꼭짓점들의 좌표들을 차례로 쓴 것이다.
예를 들어 아래의 그림에서 안에 들어있는 빗금 친 다각형은 다음과 같이 표현된다.
{(5,5), (17,5), (17,13), (14,13), (14,8), (8,8), (8,11), (9,11), (9,13), (5,13)} 다각형이 주어졌을 때 이 다각형의 d- 확장은 주어진 다각형의 둘레를 돌면서 d만큼 바깥쪽으로 확장시키는 것을 말한다.
예를 들어 위의 다각형을 2- 확장시키면 아래 그림에서 밖에 있는 다각형 즉,{(3,3), (19,3), (19,15), (12,15),(12,10), (11,10), (11,15), (3,15)}이 된다.

이때, d-확장에 의해 공간이 메워져서 꼭짓점의 개수가 변할 수 있다. 단, d-확장에 의해서 아래의 예와 같이 다각형 안에 구멍이 생기는 경우는 없다고 가정한다.

입력으로 d값과 다각형이 주어질 때 d-확장된 다각형을 구하는 프로그램을 작성하라.
<입력값>
첫 번째 줄에 d가 주어지고 그 다음 줄에는 n이 주어진다. 그 다음 n개의 줄에 다각형을 나타내는 n개의 좌표가 주어진다. 여기서 1 ≤ d ≤ 500이고, 3 ≤ n ≤ 50이며, X, Y 좌표 값은 2000 이하의 자연수로 한다. 좌표는 반시계 방향으로 주어진다.
<출력값>
확장된 다각형의 꼭짓점의 개수와 좌표들을 x값이 가장 작고, 같은 경우 y값이 가장 작은 꼭짓점부터 반시계방향으로 출력한다.

<문제 2665>
n×n 바둑판 모양으로 총 n2개의 방이 있다. 일부분은 검은 방이고 나머지는 모두 흰 방이다. 검은 방은 사면이 벽으로 싸여 있어 들어갈 수 없다. 서로 붙어 있는 두 개의 흰 방 사이에는 문이 있어서 지나다닐 수 있다. 윗줄 맨 왼쪽 방은 시작방으로서 항상 흰 방이고, 아랫줄 맨 오른쪽 방은 끝방으로서 역시 흰 방이다.
시작방에서 출발하여 길을 찾아서 끝방으로 가는 것이 목적인데, 아래 그림의 경우에는 시작방에서 끝 방으로 갈 수가 없다. 부득이 검은 방 몇 개를 흰 방으로 바꾸어야 하는데 되도록 적은 수의 방의 색을 바꾸고 싶다.
아래 그림은 n=8인 경우의 한 예이다.

위 그림에서는 두 개의 검은 방(예를 들어 (4,4)의 방과 (7,8)의 방)을 흰 방으로 바꾸면, 시작방에서 끝방으로 갈 수 있지만, 어느 검은 방 하나만을 흰 방으로 바꾸어서는 불가능하다. 검은 방에서 흰 방으로 바꾸어야 할 최소의 수를 구하는 프로그램을 작성하시오.
단, 검은 방을 하나도 흰방으로 바꾸지 않아도 되는 경우는 0이 답이다.
<입력값>
첫 줄에는 한 줄에 들어가는 방의 수 n(1≤n≤50)이 주어지고, 다음 n개의 줄의 각 줄마다 0과 1이 이루어진 길이가 n인 수열이 주어진다. 0은 검은 방, 1은 흰 방을 나타낸다.
<출력값>
첫 줄에 흰 방으로 바꾸어야 할 최소의 검은 방의 수를 출력한다.

<문제 2666>
n개의 같은 크기의 벽장들이 일렬로 붙어져 있고 벽장의 문은 n-2개만이 있다. 한 벽장 앞에 있는 문은 이웃 벽장 앞에 문이 없다면(즉, 벽장이 열려있다면) 그 벽장 앞으로 움직일 수 있다.
그림은 7개의 벽장의 예이다. 그림에서 2번 벽장과 5번 벽장이 열려있고, 나머지 벽장은 닫혀 있다.  벽장 문은 좌우 어느 쪽이든 그 이웃 벽장이 열려 있다면 그 쪽으로 한 칸씩 이동할 수 있다. 그림에서 주어진 상태에서는 1번 벽장을 닫고 있는 벽장문을 오른쪽으로 한 칸 이동함으로써 1번 벽장을 사용할 수 있다. 이때 2번 벽장은 닫혀져 사용할 수 없다. 역시 5번 벽장이 열려 있으므로 4번 벽장 또는 6번 벽장 앞의 벽장문을 5번 벽장 앞으로 이동시킬 수 있다.

풀어야 할 문제는 입력으로 주어지는 사용할 벽장의 순서에 따라서 벽장문을 이동하는 순서를 찾는 것이다. 이때 벽장문의 이동횟수를 최소로 하여야 한다. 입력은 다음과 같이 주어지며, 열려있는 벽장의 개수는 항상 2개이다.
예를 들어 사용할 벽장 순서가 3 1 6 5이면, 3번 앞의 문을 2번으로 옮겨서 3번 벽장을 사용하고(문 이동횟수=1), 다음에 1번과 2번 앞에 있는 문을 오른쪽으로 하나씩 옮겨서(문 이동횟수=2) 1번 벽장을 사용하며, 6번 앞에 있는 문을 왼쪽으로 옮겨서 6번 벽장을 사용하고(문 이동횟수=1), 다시 그 문을 오른쪽으로 옮겨서 5번 벽장을 사용한다(문 이동횟수=1), 따라서 문이 이동한 횟수의 합은 5이다.
<입력값>
첫 번째 줄에 벽장의 개수를 나타내는 3보다 크고 20보다 작거나 같은 하나의 정수, 두 번째 줄에 초기에 열려있는 두 개의 벽장을 나타내는 두 개의 정수, 그리고 세 번째 줄에는 사용할 벽장들의 순서의 길이(최대 20), 그리고 그 다음줄부터 사용할 벽장의 번호가 한줄에 하나씩 순서대로 주어진다.
<출력값>
벽장문의 최소 이동횟수를 화면에 출력한다.

<문제 2667>
<그림 1>과 같이 정사각형 모양의 지도가 있다. 1은 집이 있는 곳을, 0은 집이 없는 곳을 나타낸다. 철수는 이 지도를 가지고 연결된 집의 모임인 단지를 정의하고, 단지에 번호를 붙이려 한다. 여기서 연결되었다는 것은 어떤 집이 좌우, 혹은 아래위로 다른 집이 있는 경우를 말한다. 대각선상에 집이 있는 경우는 연결된 것이 아니다. <그림 2>는 <그림 1>을 단지별로 번호를 붙인 것이다. 지도를 입력하여 단지수를 출력하고, 각 단지에 속하는 집의 수를 오름차순으로 정렬하여 출력하는 프로그램을 작성하시오.
<입력값>
첫 번째 줄에는 지도의 크기 N(정사각형이므로 가로와 세로의 크기는 같으며 5≤N≤25)이 입력되고, 그 다음 N줄에는 각각 N개의 자료(0혹은 1)가 입력된다.
<출력값>
첫 번째 줄에는 총 단지수를 출력하시오. 그리고 각 단지내 집의 수를 오름차순으로 정렬하여 한 줄에 하나씩 출력하시오.

<문제 2668>
세로 두 줄, 가로로 N개의 칸으로 이루어진 표가 있다. 첫째 줄의 각 칸에는 정수 1, 2, …, N이 차례대로 들어 있고 둘째 줄의 각 칸에는 1이상 N이하인 정수가 들어 있다. 첫째 줄에서 숫자를 적절히 뽑으면, 그 뽑힌 정수들이 이루는 집합과, 뽑힌 정수들의 바로 밑의 둘째 줄에 들어있는 정수들이 이루는 집합이 일치한다. 이러한 조건을 만족시키도록 정수들을 뽑되, 최대로 많이 뽑는 방법을 찾는 프로그램을 작성하시오. 예를 들어, N=7인 경우 아래와 같이 표가 주어졌다고 하자.

이 경우에는 첫째 줄에서 1, 3, 5를 뽑는 것이 답이다. 첫째 줄의 1, 3, 5밑에는 각각 3, 1, 5가 있으며 두 집합은 일치한다. 이때 집합의 크기는 3이다. 만약 첫째 줄에서 1과 3을 뽑으면, 이들 바로 밑에는 정수 3과 1이 있으므로 두 집합이 일치한다. 그러나, 이 경우에 뽑힌 정수의 개수는 최대가 아니므로 답이 될 수 없다.
<입력값>
첫째 줄에는 N(1≤N≤100)을 나타내는 정수 하나가 주어진다. 그 다음 줄부터는 표의 둘째 줄에 들어가는 정수들이 순서대로 한 줄에 하나씩 입력된다.
<출력값>
첫째 줄에 뽑힌 정수들의 개수를 출력하고, 그 다음 줄부터는 뽑힌 정수들을 작은 수부터 큰 수의 순서로 한 줄에 하나씩 출력한다.

<문제 2669>
평면에 네 개의 직사각형이 놓여 있는데 그 밑변은 모두 가로축에 평행하다. 이 네 개의 직사각형들은 서로 떨어져 있을 수도 있고, 겹쳐 있을 수도 있고, 하나가 다른 하나를 포함할 수도 있으며, 변이나 꼭짓점이 겹칠 수도 있다.

	이 직사각형들이 차지하는 면적을 구하는 프로그램을 작성하시오.
<입력값>
입력은 네 줄이며, 각 줄은 직사각형의 위치를 나타내는 네 개의 정수로 주어진다. 첫 번째와 두 번째의 정수는 사각형의 왼쪽 아래 꼭짓점의 x좌표, y좌표이고 세 번째와 네 번째의 정수는 사각형의 오른쪽 위 꼭짓점의 x좌표, y좌표이다. 모든 x좌표와 y좌표는 1이상이고 100이하인 정수이다.
<출력값>
첫 줄에 네개의 직사각형이 차지하는 면적을 출력한다.

<문제 2670>
N개의 실수가 있을 때, 한 개 이상의 연속된 수들의 곱이 최대가 되는 부분을 찾아, 그 곱을 출력하는 프로그램을 작성하시오. 예를 들어 아래와 같이 8개의 양의 실수가 주어진다면,

색칠된 부분의 곱이 최대가 되며, 그 값은 1.638이다.
<입력값>
첫째 줄은 나열된 양의 실수들의 개수 N이 주어지고, 그 다음 줄부터 N개의 수가 한 줄에 하나씩 들어 있다. N은 10,000 이하의 자연수이다. 실수는 소수점 첫째자리까지 주어지며, 0.0보다 크거나 같고, 9.9보다 작거나 같다.
<출력값>
계산된 최댓값을 소수점 이하 넷째 자리에서 반올림하여 소수점 이하 셋째 자리까지 출력한다.

<문제 2671>
일반적으로 잠수함 엔진이 작동할 때에 나오는 소리는 잠수함의 종류에 따라서 다르다고 한다.
우리는 물속에서 들리는 소리의 패턴을 듣고서 그 소리가 특정한 잠수함에서 나오는 소리인지 아닌지를 알아내려고 한다. 이 문제에서는 잠수함의 소리가 두 종류의 단위 소리의 연속으로 이루어져 있고, 그 단위 소리를 각각 0과 1로 표시한다.
또, 한 특정한 소리의 반복은 ~로 표시한다. 예를 들어 x~는 x가 한번 이상 반복되는 모든 소리의 집합을 말하고, (xyz)~는 괄호 안에 있는 xyz로 표현된 소리가 한번 이상 반복되는 모든 소리의 집합을 말한다. 다음의 예를 보라.

1~ = {1, 11, 111, 1111, ..., 1...1, ...}
(01)~ = {01, 0101, 010101, 01010101. ...}
(1001)~ = {1001, 10011001, ..., 100110011001...1001, ...}
10~11 = {1011, 10011, 100011, ..., 1000...011, ...}
(10~1)~ = {101, 1001, 10001, 100001, ...1011001, ...100110110001101, ...}

​그리고 (x|y)는 x또는 y중에서 아무거나 하나만을 선택해서 만든 소리의 집합, 즉 집합{x, y}를 의미한다. 예를 들면(1001|0101)은 집합으로 {1001, 0101}을 의미한다. 따라서 (0|1)~은 0과 1로 이루어진 모든 스트링의 집합, 즉 모든 소리의 집합을 말한다. 또 한 예를 보면 (100|11)~은 100과 11을 마음대로 섞어서 만들 수 있는 모든 소리의 집합을 의미한다. 즉 (100|11)~에 해당하는 스트링을 집합으로 나타내면 {100, 11, 10011, 100100100, 1110011, ...}이 된다. 우리가 식별하고자 하는 잠수함의 엔진소리의 패턴은 다음과 같다.
(100~1~|01)~
여기에 속하는 소리의 예를 들어보면, 1001, 01, 100001, 010101, 1000001110101, 1001110101, 0101010101, 10010110000001111101, 01010101011000111, 10000111001111, ...이다.
다시 말해서 이것은 100~1~과 01을 임의로 섞어서 만들 수 있는 모든 스트링의 집합을 나타낸다.
입력으로 0과 1로 구성된 스트링이 주어질 때, 이 스트링이 앞에서 기술된 잠수함의 엔진소리인지 아닌지를 판별하는 프로그램을 작성하라.
<입력값>
0과 1로 구성된 스트링이 1개 들어있다. 이때 각 스트링의 길이는 150개 이하로 제한된다.
<출력값>
입력에 들어있는 스트링을 읽고, 이것이 잠수함의 엔진소리를 나타내는 스트링인지 아니면 그냥 물속의 잡음인지를 판정한 후, 잠수함의 엔진 소리에 해당하는 스트링이면 "SUBMARINE"을 출력하고, 그렇지 않으면 "NOISE"를 출력한다.

<문제 2672>
밑변이 모두 x축에 평행한 N개의 직사각형이 주어질 때, 이 N개의 직사각형들이 차지하는 면적을 구하는 프로그램을 작성하시오. 여기서 주어진 직사각형들은 서로 겹칠 수도 있으며, 변이나 꼭짓점을 공유할 수도 있다.
<입력값>
첫째 줄에 직사각형의 개수 N(1 ≤ N ≤ 30)이 주어지고 그 다음 N줄에는 각각의 직사각형에 대한 자료가 주어진다. 이 자료는 4개의 숫자로 표시되는데 첫째, 둘째 숫자는 직사각형의 왼쪽 아래 모서리의 x좌표, y좌표이고 셋째 숫자는 폭, 넷째 숫자는 높이를 나타낸다. 각 수는 최대 소수점 이하 한 자리까지 주어지며, 1000.0보다 작거나 같은 양의 실수이다.
<출력값>
첫째 줄에 N개의 직사각형이 차지하는 면적을 소수점 이하 2자리까지 출력한다. 단, 값이 소수 부분이 없이 정수로 맞아떨어지는 경우는 정수 부분만 출력한다.

<문제 2673>
평면상에 있는 원의 둘레에 100개의 점이 일정한 간격으로 시계방향으로 번호가 1, 2, ... 100으로 붙여져 있다. 이 점들을 끝점으로 갖는 N개의 선분(원의 현)이 입력으로 주어질 때, 이들중에서 서로 교차하지 않는 것들을 최대한 많이 찾아서 그 개수를 출력하는 프로그램을 작성하라.
단, 1 ≤ N ≤ 50이고, 주어진 각 점은 많아야 한 현의 끝점이 될 수 있다.
<입력값>
첫 번째 줄은 주어지는 현의 개수 N이고, 다음의 N줄은 각 현의 양끝점의 번호가 주어진다.
<출력값>
구한 현의 개수를 출력한다.

<문제 2674>
0 또는 1로 채워진 N×N 삼각행렬을 생각해 보자. (1 ≤ N ≤ 20)이 삼각행렬의 i(1 ≤ N)번째 행과 열은 각각 n-I+1개의 문자들로 구성되어 있다. 이때, 이 행렬의 각 행과 각 열은 0과 1로 이루어진 문자열이 됨을 알 수 있다. 이러한 0과 1로 이루어진 문자열에서 연속적인 1들의 부문자열을 이용하여, 다른 형태의 순서열을 생성할 수 있다. i번째 나타난 연속적인 1들의 부문자열을 이용하여, 다른 형태의 순서열을 생성할 수 있다. i번째 나타난 연속적인 1들의 부문자열이 Ii개의 1을 포함하고 서로 겹치지 않는 부문자열의 수가 k개일 때, 새로이 생성되는 순서열은 (l1 l2 ... lk)가 된다.
예을 들어 문자열(0 1 1 0 1 1 1)에 대한 순서열은 (2 3)이다. 이제 우리는 이러한 방법으로 만들어진 순서열이 N개의 행과 N개의 열에 주어졌을 때, 원래의 0과 1로 이루어진 행렬을 만들려고 한다.
삼각 행렬의 각 행과 각 열에 대한 정보가 위에서 설명한 바와 같이 연속된 1로 구성된 부문자열에 포함된 1의 개수를 표현하는 순서열로 주어졌을 때, 그 조건을 만족하는 삼각행렬이 존재하면 재구성하는 프로그램을 작성하라.
조건을 만족하는 삼각행렬이 복수개 존재 할 경우 하나만 출력하고, 답이 존재하지 않은 경우에는 "No Answer"를 출력한다.
다음은 8×8의 경우에 대한 예이다. 각각 왼쪽과 위에 주어진 것이 입력으로 주어지는 순열이 되며, 가운데 사각행렬이 입력으로부터 재구성한 삼각행렬이다.
<입력값>
행렬의 크기와 행과 열에 대한 순서열들이 아래의 형식으로 주어진다.(1 ≤ N ≤ 20)

n
h1 r11 r12 ... r1h1
h2 r21 r22 ... r2h2
...
hn rn1 rn2 ... rnhn
k1 c11 c12 ... c1k1
k2 c21 c22 ... c2k2
...
kn cn1 cn2 ... cnkn

각 행의 정보 hi, ri1, ri2,... rihi에서 hi는 i번째 행의 문자열에 대한 순서열에 포함된 원소의 수이고, ri1, ri2,... rihi 는 각 연속적인 1로 구선된 부문자열의 길이를 순서대로 열거한 것이다. 열에 대한 정보도 같은 형식으로 주어진다.
<출력값>
삼각형 형태의 0과 1로 이루어진 행렬을 출력한다.

a1,1 a1,2 ... a1,n-1 a1,n
a2,1 a2,2 ... a2,n-2 a2,n-1
...
an-1,1 an-1,2
an,1

<문제 2675>
문자열 S를 입력받은 후에, 각 문자를 R번 반복해 새 문자열 P를 만든 후 출력하는 프로그램을 작성하시오. 즉, 첫 번째 문자를 R번 반복하고, 두 번째 문자를 R번 반복하는 식으로 P를 만들면 된다. S에는 QR Code "alphanumeric" 문자만 들어있다.
QR Code "alphanumeric" 문자는 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\$%*+-./: 이다.
<입력값>
첫째 줄에 테스트 케이스의 개수 T(1 ≤ T ≤ 1,000)가 주어진다. 각 테스트 케이스는 반복 횟수 R(1 ≤ R ≤ 8), 문자열 S가 공백으로 구분되어 주어진다. S의 길이는 적어도 1이며, 20글자를 넘지 않는다.
<출력값>
각 테스트 케이스에 대해 P를 출력한다.

<문제 2676>
라스칼의 삼각형은 파스칼의 삼각형과 비슷하다.
라스칼의 삼각형에서 가장 윗 줄은 0번 줄이다. i번째 줄에는 i+1개의 숫자가 들어있고, 차례대로 0번부터 i번이다. R(i,j)는 i번 줄의 j번째 숫자이다.
R(n,m) = 0 (n<0 or m<0 or m>n)
각 줄의 첫 번째와 마지막 숫자는 1이다.
R(n,0) = R(n,n) = 1
나머지 값을 채우는 방법은 (서쪽값 * 동쪽값 + 1) / 북쪽값 이다.

이것을 수식으로 표현해보면 R(n+1,m+1) = (R(n,m) * R(n,m+1) + 1) / R(n-1,m) 이다.
라스칼의 삼각형에서 R(n,m)을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 테스트 케이스의 개수 T(1 <= T <= 1,000)이 주어진다. 각 테스트 케이스는 2개의 숫자 n과 m으로 이루어져 있다. (0 <= m <= n <= 50,000)
<출력값>
각 테스트 케이스에 대해서 한 줄에 하나씩 R(n,m)을 출력한다.

<문제 2677>
EDSAC (ElectronicDelay Storage Automatic Calculator)은 프로그램을 주기억장치에 두고 실행할 수 있는 최초의 디지털 컴퓨터이다. EDSAC에는 가산기를 사용하는 명령어가 내장되어 있으며, 17비트 word 타입과 35비트 double word 타입을 기반으로 계산한다. 또한 입출력을 위해 5비트 텔레타이프 코드를 사용한다.
EDSAC 프로그램은 매우 간단한 어셈블리어로 만들 수 있다. 이 어셈블리어의 각 명령어는 문자 하나와 음이 아닌 십진수 주소값, 그리고 F나 D로 이뤄져 있다. F는 full word타입, D는 double word타입을 의미한다. 예를 들어 명령어 "A 128 F"는 가산기에 메모리 상에서 128 주소에 있는 full word 타입 변수값을 더하라는 의미이다. 이 연산은 이진수로 11100000100000000으로 표현된다. 앞의 11100은 "add"를 의미하는 5비트의 opcode이고, 다음 11비트 00010000000(=128)은 피연산자를 나타내며, 마지막의 0은 full word타입을 연산한다는 것을 의미한다. (double word 타입이라면 마지막 자리는 1이 된다.)
EDSAC 연산은 부동소수점 2의 보수 연산이지만, 단순한 정수 사칙연산이 아닌 현대 컴퓨터와 비슷한 방법으로 수를 연산한다. EDSAC의 연산 장치는 소수점이 가장 높은 자릿수(가장 왼쪽에 있는 자릿수)와 그 다음 자릿수(바로 오른쪽에 있는 자릿수) 사이에 있다고 가정한다. 따라서 17비트 word 타입 x의 표현 범위는 -1.0 ≤ x < 1.0이다.



 값
이진수 표현 




-1.0 
 10000000000000000


 1/2
 01000000000000000


 3/4
 01100000000000000


 -1/2
11000000000000000



따라서 가능한 가장 큰 양의 실수는 01111111111111111 = 0.9999847412109375이고, 가장 작은 양의 실수는 00000000000000001 = 2^(-16) = 0.0000152587890625이다.
우연의 일치인지 의도적인 설계인지, opcode add 연산과 텔레타이프 코드 'A'는 11100으로 일치하며, subtract 연산과 'S' 역시 01100으로 일치한다. 또한 텔레타이프 코드로 표현할 수 있는 알파벳은 "PQWERTYUIOJ#SZK*?F@D!HNM&LXGABCV"로 모두 32자인데, 5비트 opcode로 표현할 수 있는 수의 개수도 32개이다. (텔레타이프 코드로 P는 00000, Q는 00001로 위 순서대로 증가하여 V는 11111으로 표현된다.) 이 특성 덕분에 EDSAC 어셈블러를 만들기가 쉬워졌다.
그러나 EDSAC 어셈블러에는 특별히 데이터 값을 표현하는 특별한 코드가 없다. 그래서 한 EDSAC 프로그래머는 일반 명령어를 데이터 값 표현에 쓰기로 했다. 예를 들어 상수 3/4(01100000000000000)는 “S 0 F로 표현되며, 1/3(약 00101010101010101)은 “T 682 D”로 표현된다. (T=00101, 682=010101010101)
십진수가 입력으로 주어졌을 때 이를 적절한 EDSAC 명령어로 표현하는 프로그램을 작성하시오.
<입력값>
입력의 첫째 줄에는 테스트 케이스의 수를 나타내는 정수 P(1 ≤ P ≤ 1000)가 하나 주어진다. 각 테스트 케이스는 십진수 D가 한 줄 주어진다. D는 sd.ddd....의 형태로 주어지는데, s는 마이너스 부호이고 생략될 수 있다. d는 십진수 한 자리(0-9)이다. 소수점 이하는 최소 한 자리 이상 최대 16자리 이하로 주어진다.
<출력값>
각 테스트 케이스에 대해 입력으로 주어진 수를 표현하기 위한 EDSAC 명령어 한 줄을 출력한다. 출력은 opcode 문자 하나와 공백 하나, 음이 아닌 십진수 정수인 피연산자 하나와 공백 하나, 'F' 또는 'D'로 이뤄져 있다. 만약 입력으로 주어진 수가 정확히 17비트로 표현할 수 없는 수라면, 0에 더 가까운 수로 표현한다. (양수라면 내림, 음수라면 올림한다.)
D가 -1.0 <= D < 1.0 범위의 수가 아니라면 EDSAC 명령어 대신 "INVALID VALUE"를 출력한다.

<문제 2678>
EDSAC (ElectronicDelay Storage Automatic Calculator)은 프로그램을 주기억장치에 두고 실행할 수 있는 최초의 디지털 컴퓨터이다. EDSAC에는 가산기를 사용하는 명령어가 내장되어 있으며, 17비트 word 타입과 35비트 double word 타입을 기반으로 계산한다. 또한 입출력을 위해 5비트 텔레타이프 코드를 사용한다.
EDSAC 프로그램은 매우 간단한 어셈블리어로 만들 수 있다. 이 어셈블리어의 각 명령어는 문자 하나와 음이 아닌 십진수 주소값, 그리고 F나 D로 이뤄져 있다. F는 full word타입, D는 double word타입을 의미한다. 예를 들어 명령어 "A 128 F"는 가산기에 메모리 상에서 128 주소에 있는 full word 타입 변수값을 더하라는 의미이다. 이 연산은 이진수로 11100000100000000으로 표현된다. 앞의 11100은 "add"를 의미하는 5비트의 opcode이고, 다음 11비트 00010000000(=128)은 피연산자를 나타내며, 마지막의 0은 full word타입을 연산한다는 것을 의미한다. (double word 타입이라면 마지막 자리는 1이 된다.)
EDSAC 연산은 고정소수점 2의 보수 연산이지만, 단순한 정수 사칙연산이 아닌 현대 컴퓨터와 비슷한 방법으로 수를 연산한다. EDSAC의 연산 장치는 소수점이 가장 높은 자릿수(가장 왼쪽에 있는 자릿수)와 그 다음 자릿수(바로 오른쪽에 있는 자릿수) 사이에 있다고 가정한다. 따라서 17비트 word 타입 x의 표현 범위는 -1.0 ≤ x < 1.0이다.



값
이진수 표현




-1.0
10000000000000000


1/2
01000000000000000


3/4
01100000000000000


-1/2
11000000000000000



따라서 가능한 가장 큰 양의 실수는 01111111111111111 = 0.9999847412109375이고, 가장 작은 양의 실수는 00000000000000001 = 2^(-16) = 0.0000152587890625이다.
우연의 일치인지 의도적인 설계인지, opcode add 연산과 텔레타이프 코드 'A'는 11100으로 일치하며, subtract 연산과 'S' 역시 01100으로 일치한다. 또한 텔레타이프 코드로 표현할 수 있는 알파벳은 "PQWERTYUIOJ#SZK*?F@D!HNM&LXGABCV"로 모두 32자인데, 5비트 opcode로 표현할 수 있는 수의 개수도 32개이다. (텔레타이프 코드로 P는 00000, Q는 00001로 위 순서대로 증가하여 V는 11111으로 표현된다.) 이 특성 덕분에 EDSAC 어셈블러를 만들기가 쉬워졌다.
그러나 EDSAC 어셈블러에는 특별히 데이터 값을 표현하는 특별한 코드가 없다. 그래서 한 EDSAC 프로그래머는 일반 명령어를 데이터 값 표현에 쓰기로 했다. 예를 들어 상수 3/4(01100000000000000)는 “S 0 F로 표현되며, 1/3(약 00101010101010101)은 “T 682 D”로 표현된다. (T=00101, 682=010101010101)
EDSAC 명령어가 주어졌을 때 이를 해당하는 십진수로 출력하는 프로그램을 작성하시오.
<입력값>
입력의 첫 줄에 테스트 케이스의 수 P(1 ≤ P ≤ 1000)가 주어진다. 각 테스트 케이스는 "c d s" 형태의 EDSAC 명령어가 한 줄에 주어진다. c는 EDSAC 알파벳 문자 한 개이며, d는 부호 없는 십진수(0 <= d < 2^11), s는 'D' 또는 'F'이다.
<출력값>
각 테스트 케이스마다 입력으로 주어진 EDSAC 명령어에 해당하는 하나의 십진수를 sb.ddd...의 형태로 출력한다. s는 마이너스 부호이며 음수일 경우에만 쓴다. b는 1 또는 0이며, d는 십진수 자리(0-9)이다. 소수점 아래 자리는 최소 1자리 이상, 최대 16자리 이하이다. 끝의 필요없는 0(Trailing zeros)은 출력하지 않는다.

<문제 2679>
맨체스터에 있는 도로는 모두 일방 통행이다. 또한 이 도로는 모두 1시간에 지나갈 수 있는 차의 개수 제한이 있다. 길(경로)에도 차의 개수 제한이 있는데, 이것은 이 길에 있는 도로의 제한 중 최솟값이다.

	A에서 B로 가는 중복 비율은 A에서 B로 가는 모든 길을 동시에 이용했을 때 1시간 동안 B에 도착할 수 있는 차의 최대 개수와 길 1개를 이용했을 때 도착할 수 있는 최대 개수의 비율이다.

	최소 중복 비율은 길 1개를 이용했을 때 도착할 수 있는 최대 개수가 가장 큰 값이 된다.

	맨체스터의 도로 정보와 A, B가 주어졌을 때, 최소 중복 비율을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 테스트 케이스의 개수 T(1 <= T <= 1,000)가 주어진다. 각 테스트 케이스는 다음과 같이 구성되어 있다.

	첫째 줄에 정수 4개가 주어진다. 차례대로 N, E, A, B이다. N(2 <= N <= 1,000)은 그래프의 정점의 개수, E(E>=1)는 간선의 개수이다. A(0<=A<N)와 B(0<=B<N, A!=B)는 문제 설명에 나와있는 A와 B이다.

	그 다음 E개 줄은 각 간선에 대한 정보이다. 이 정보는 U V W로 구성되어 있는데, U와 V는 그래프의 정점이고, W는 U에서 V로 향하는 도로의 1시간에 지나갈 수 있는 차의 개수 제한이다.
<출력값>
각 테스트 케이스에 대해 최소 중복 비율을 소수점 셋째자리까지 출력한다.

<문제 2680>
QR 코드는 위와 같이 최소 21*21개의 단위 픽셀로 이루어진 정방형의 흑백 픽셀 매트릭스이다.
각각의 픽셀은 나타내는 내용에 따라 위치 감지 패턴(과녁 모양의 작은 정사각형), 타이밍 패턴(교차하는 흑,백의 선), 서식 정보(작은 점들의 집합), 데이터와 오류 수정 코드(회색 픽셀 8개로 이루어진 블록들), 그리고 더 큰 QR코드의 경우 보정 패턴, 버전 정보 등으로 나뉜다.
21*21의 최소 크기 QR 코드는 26개의 데이터 및 오류 수정 코드를 가지는데, 이는 다시 19개의 데이터 코드와 7개의 오류 수정 코드로 나뉜다.
어떤 정보를 데이터 코드로 만들 때는 10비트당 3개의 숫자, 11비트당 2개의 알파뉴메릭 문자, 8비트당 1개의 기타 8비트 문자, 13비트당 1개의 한자(Kanji)를 저장하며 다음 세 가지 정보를 함께 저장한다.

데이터의 종류(mode)
문자의 수(character count)
문자 정보

mode bit는 QR 코드의 크기에 따라 달라질 수 있으며, 문자 수에 대한 정보(count bits)는 데이터의 타입에 따라 다른 비트 수를 가진다. 
아래는 21*21 크기 QR 코드에서의 mode bit와 count bit에 대한 표이다.



Mode Name      
Mode Bits   
Count Bits




Numeric
0001
10


Alphanumeric
0010
9


8 bit byte
0100
8


Kanji
1000
8


Termination
0000
0



숫자를 표현하기 위해 mode bit로 0001을 사용하며, 그 뒤 10개의 비트는 숫자의 개수를 나타낼 것이다.
터미네이션 코드로 데이터는 종료되며 만일 데이터 코드를 저장할 공간이 없다면 터미네이션 코드는 생략되거나 불완전한 형태일 수도 있다.
터미네이션 코드 이후로 등장하는 불완전한 코드 조각은 비어있는 부분을 0으로 채우게 되며, 그 이후로 남는 빈 공간에는 11101100과 00010001을 교대로 채운다. 이에 대한 예시는 문제 설명 마지막 부분에서 자세히 볼 수 있다.
수로 이루어진 문자열은 한 번에 3자리씩 저장된다. 마지막 남은 문자열이 2글자일 경우엔 7bit로, 1글자일 경우엔 4bit로 저장한다. 아래는 예시이다.
12345678 → 123 456 78 → 0001111011 0111001000 1001110
이 앞에 mode 정보(0001)와 count bit(8 = 0000001000)가 들어간다.
0001 0000001000 0001111011 0111001000 1001110
알파뉴메릭 문자열은 다음 45개 문자들을 포함하고 있는 문자열이다.(<SP>는 스페이스바를 나타낸다)
0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ<SP>\$%*+-./:
각각의 알파벳은 0부터 44의 수로 대응되며, 알파뉴메릭 두 문자는 다음과 같이 인코딩된다.
<first char code> * 45 + <second char code>
만일 한 개의 문자가 남는다면, 이것은 6 비트로 인코딩된다.
예시는 다음과 같다.
AC-42 → (10, 12, 41, 4, 2) → 10*45 + 12 = 462, 41*45 + 4 = 1849, 2 →  00111001110 11100111001 000010
이 앞에 mode bit(0010) 과 count bit(5 = 000000101) 가 삽입되어 총 비트 수는 4+9+11+11+6 bit가 된다.
8비트 문자/숫자와 한자를 저장하는 다음의 과정은 비교적 간단하다. 8비트 문자는 어떤 8비트의 코드로, 한자는 어떤 13비트의 코드로 저장될 것이며 그 문자를 찾는 대신 그저 16진수로 코드를 표현해내기만 하면 된다.
예시는 다음과 같다.
8 bit 0x45 0x92 0xa3 → 01000101 10010010 10100011
이 앞에 mode bit와 count bit가 삽입되어 다음과 같이 된다
0100 00000011 01000101 10010010 10100011
총 비트 수는 4 + 8 + 8 + 8 + 8이 된다.
한자에 대한 예시는 다음과 같다.
Kanji 0x1ABC 0x0345 → 1000 00000010 1101010111100 0001101000101
총 비트 수는 4 + 8 + 13 + 13이다.
19개의 데이터 블록엔 각각의 블록당 위의 규칙에 따라 변환한 코드를 8비트 단위로 끊어서 표현한 이진수 묶음이 입력된다. 모든 정보를 저장한 뒤엔 터미네이트 코드가 주어지며, 터미네이트 코드의 mode bit까지 표현한 후 불완전한 데이터 블록이 생겼다면 남은 부분을 0으로 채운다. 이때 데이터 블록이 19개 미만이라면 11101100과 00010001을 교대로 삽입하여 19개의 데이터 블록을 만든다.
예시는 다음과 같다.
0001 0000001000 0001111011 0111001000 1001110
0010 000000101 00111001110 11100111001 000010
0100 00000011 01000101 10010010 10100011
0000 000000 11101100 00010001 11101100
위의 코드는 다음과 같이 19개의 데이터 블록에 인코딩된다.
00010000 00100000 01111011 01110010 00100111 00010000 00010100 11100111 01110011 10010000 10010000 00001101 00010110 01001010 10001100 00000000 11101100 00010001 11101100
→ HEX 10207B72271014E77390900D164A8C00EC11EC
위의 마지막 결과처럼 16진수로 인코딩된 19개의 데이터 블록이 주어지면 그에 따라 원래 정보를 복원하는 프로그램을 작성하라.
<입력값>
첫 줄에 테스트 케이스의 수 P가 주어진다 (1 ≤ P ≤ 1000)
각각의 테스트 케이스는 한 줄로 표현된 19개의 데이터 블록이며, 38개의 16진수 문자가 주어진다. 0~9, A~F 외의 잘못된 문자가 주어지는 경우는 없다.
<출력값>
각각의 테스트 케이스에 대해 다음과 같이 한 줄을 출력한다.

문자의 수를 나타내는 정수 하나
공백으로 구분하여, 디코딩된 문자열

만일 출력 문자열이 출력 가능한 아스키 문자라면(0x20~0x7e) 그대로 출력하면 되며, 다만 예외로 백슬래시( \ )는 \\ 로, #은 \# 으로 출력하면 된다.
출력 불가능한 문자일 경우엔

8bit 문자일 경우 : \xx, x는 16진수로 표현했을 경우의 자리수(예시 : \AE)
13bit 문자일 경우 : #bxxx : b는 0 또는 1, x는 16진수로 표현했을 경우의 자리수(예시 : #13AC)

를 출력하면 된다.
0x20(스페이스바)보다 작거나 0x7e(~)보다 큰 모든 8bit 아스키 문자 혹은 모든 13bit 문자는 출력 불가능한 문자이다.

<문제 2681>
목장 주인 백승환은 볼록 사변형 모양의 땅을 가지고 있다. 승환이는 이 땅을 자신의 아들 백원, 백조, 백수, 백숙와 딸 백미에게 물려주려고 한다. 아들들은 이 땅을 물려받은 후에 가업을 이어 목장으로 운영하려고 하고, 딸 백미는 물려받은 땅에서 채소를 재배하려고 한다.

	승환이는 누구에게 어디를 물려줄까 고민하면서 땅을 둘러본 후에, 가운데가 채소를 재배하기에 가장 적합하다고 판단했다. 따라서 다음과 같이 땅을 나누려고 한다.

	사변형의 꼭짓점 (반시계 방향으로 A, B, C, D)에서 반대쪽 변의 중심 (A', B', C', D')으로 선을 긋는다. 모든 아들은 삼각형 땅을 받게 되고, 딸은 가운데 사변형 땅을 받게 된다.

	아래 그림을 보면, 백원은 변AB, 변AA', 변BB'로 나눠진 땅을 받게 되고, 백조는 변BC, 변BB', 변CC'로 나눠진 땅을 받게 된다. 나머지 아들도 이와 같은 방법으로 땅을 받게 된다.



	자 이제 승환이는 자신의 자식들이 받게될 땅의 넓이와 백미의 채소밭 둘레를 구하려고 한다. 백미의 채소밭 둘레를 구하는 이유는 채소밭에 울타리를 만들어, 아들들의 소가 채소밭을 망가뜨리는 것을 막기 위해서이다.

	이 문제에서  A는 항상 (0, 0)이고, B는 항상 (x, 0)이다.
<입력값>
첫째 줄에 테스트 케이스의 개수 T (1 <= T <= 1,000)이 주어진다. 각 테스트 케이스는 5개의 수로 이루어져있으며, 소수점일수도 있다. 이 값은 순서대로 B의 x좌표, C의 x좌표, C의 y좌표, D의 x좌표, D의 y좌표이다. 입력되는 사변형은 항상 볼록 사변형이다.
<출력값>
각 테스트 케이스에 대해 백원, 백조, 백수, 백숙, 백미가 물려받는 땅의 넓이와 백미의 울타리 길이를 출력한다. 땅의 넓이는 소수점 셋째자리까지 출력하고, 울타리 길이는 올림해서 정수로 출력한다.

<문제 2682>
P는 1부터 n까지 수로 이루어진 순열이다. 최대 사이클 1은 P(1), P(P(1)), P(P(P(1))), ... 중 최댓값이다.

	예를 들어 수열 P가 (3, 2, 5, 4, 1, 7, 8, 6) 이라면

	P(1) = 3

	P(P(1)) = P(3) = 5

	P(P(P(1))) = P(5) = 1

	따라서 3, 5, 1이 반복되며, 최댓값은 5가 된다.

	정수 n(n > 0)과 k(1 <= k <= n)이 주어졌을 때, 최대 사이클 1의 값이 k인 순열의 개수를 구하시오.
<입력값>
첫째 줄에 테스트 케이스의 개수 T(1 <= T <= 1,000)가 주어진다. 각 테스트 케이스는 두 개의 정수 n과 k로 이루어져 있다. (1 <= k <= n <= 20)
<출력값>
각 테스트 케이스에 대해서 1, ... n으로 이루어진 순열 중에 최대 사이클 1의 값이 k인 순열의 개수를 출력한다.

<문제 2683>
백범로에 있는 서강 은행의 본사는 2002년에 지어졌다. 2013년, 의장인 최준민은 은행 아트리움의 천장을 황금잎으로 재단장하기로 결심했다. (얼마 후 그는 소리소문없이 잠적해버렸다.)

	새 천장은 평범하지 않아서, 아트리움의 일부가 기울어져 있었다. (그래서 아트리움은 더 커보였다) 아트리움의 크기와 기울어진 천장의 위치, 경사도는 정해지지 않았다.

	준민이는 상범마법황금잎회사에서 천장과 기울어진 면을 장식할 황금잎을 얼마나 주문해야하는지 알고 싶었다. 또한 그는 비스듬한 부분이 천장이나 바닥과 닿는 것도 허가했다.

	다음은 아트리움의 예제이다.



	Note: 점선으로 그린 부분은 원래 박스를 나타내며, 빗금친 부분은 기울어진 부분을 표시한다.

	빗금이 두번 쳐진 부분은 원래 천장 부분을 나타낸다. 벽과 바닥은 투명하다.

	황금잎으로 덮을 부분은 천장과 기울어진 부분이다.

	천장을 덮기 위해 얼마나 황금잎이 필요한지 계산하는 프로그램을 작성하시오.
<입력값>
첫째 줄은 데이터 세트의 개수를 나타내는 P(1 ≤ P ≤ 1000)가 입력으로 들어온다. 각각의 데이터 세트는 한 줄로 구성되어 있으며 L, W, H, A, B, C, D가 공백으로 구분되어 들어온다. L,W,H는 가로, 세로, 높이를 뜻하며 단위는 준민이다. (모두 양수) A,B,C,D는 다음 평면의 방정식의 계수로, 평면은 기울어진 부분을 나타낸다.

	Ax + By + Cz = D

	0 ≤ x ≤ L, 0 ≤ y ≤ W, 0 ≤ z ≤ H


		원래 박스의 한쪽 끝은 항상 (0,0,0)에 위치하며 다른 쪽은 (L,W,H)에 위치한다. 평면은 수직이 되지 않으며 (C ≥ 1.0) 항상 박스 안쪽을 지나간다.
<출력값>
각각의 데이터 세트에 대해 한 줄씩 천장을 덮기 위해 필요한 황금잎을 제곱준민 단위(정수)를 공백으로 구분하여 출력한다. (제곱준민 단위를 올림)

<문제 2684>
동전게임은 주로 두 사람이 함께 즐기는 게임이다. 이 중 3-동전게임은 여러 명이 할 수 있는 게임이다. 각 사람은 각각 3-동전수열 중 하나를 선택한다. 3-동전수열이란 앞 뒤 앞과 같은 수열이고, 8가지(뒤뒤뒤,뒤뒤앞,뒤앞뒤,뒤앞앞,앞뒤뒤,앞뒤앞,앞앞뒤,앞앞앞)가 있다.
이제 심판은 동전 1개를 40번 던진다. 그 다음 심판은 동전이 앞인지 뒤인지를 던진 순서대로 종이에 적는다. 그 다음 3-동전수열이 각각 몇 번씩 나왔는지 기록한다. 가장 많이 나온 수열을 선택한 사람이 이긴다.
동전 40번 던진 결과가 주어졌을 때, 3-동전수열이 각각 몇 번 나왔는지를 출력하는 프로그램을 작성하시오. 예를 들어, 40개의 동전이 모두 앞면일 경우 앞앞앞은 38번 나타난다.
<입력값>
첫째 줄에 테스트 케이스의 개수 P(1 ≤ P ≤ 1000)가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 동전을 40번 던진 결과가 주어진다. 이때, 앞면은 H로, 뒷면은 T로 표현한다.
<출력값>
각 테스트 케이스마다 3-동전수열이 몇 번 나타났는지를 출력한다. 뒤뒤뒤, 뒤뒤앞, 뒤앞뒤, 뒤앞앞, 앞뒤뒤, 앞뒤앞, 앞앞뒤, 앞앞앞 순서대로 공백으로 구분해서 출력한다.

<문제 2685>
Nim 게임은 몇 개의 돌무더기를 놓고 매 차례마다 각 플레이어가 한 무더기에서 적게는 1개에서부터 많게는 무더기 전체를 가져가는 게임이다. 일반적인 Nim 게임의 승자는 마지막으로 돌을 가져가는 사람이다. 이 게임에서 가장 널리 알려진 전략은 Nim-2-sum을 이용하는 전략이다.

	FoodVictory에 신제품 algo90을 납품하던 용태는 FoodVictory의 물류 관리자인 영우의 계속되는 횡포에 견디지 못하고 대결을 신청했다. 영우는 가장 자신있어하는 Nim 게임을 종목으로 선정했고, 용태는 Nim 게임의 전략을 인터넷에 검색했다.

	Nim 게임의 전략은 다음과 같다.

	두 개의 음이 아닌 정수 X와 Y의 Nim-B-sum (B진법 nim sum)을 NimSum (B, X, Y)라고 하자. 이 값은 다음과 같이 계산할 수 있다.

	1) X와 Y를 B진법으로 나타낸다.

	2) Nim-B sum의 각 자리 수는 X와 Y의 B진법 표기에서의 각 자리의 합을 B로 나눈 나머지이다.

	예를 들면,

	NimSum (2, 123, 456) = 1111011 ¤ 111001000 = 110110011 = 435

	NimSum (3, 123, 456) = 11120 ¤ 121220 = 102010 = 300

	NumSum (4, 123, 456) = 1323 ¤ 13020 = 10303 = 307

	일반적인 Nim 게임의 전략은 모든 크기의 돌무더기에 대해 Nim-2 Sum T를 계산하는 것이다. 언제든 용태가 T=0이 되게 차례를 끝낸다면, 용태가 반드시 승리하게 된다. 그리고 영우가 아무리 T를 0이 되지 않게 남긴다고 해도 항상 T를 다시 0으로 만들 수 있는 방법이 존재한다. 이것은 각 무더기마다 NimSum (2, T, PS)로 계산하면 되는데 (PS = 무더기에 있는 돌의 수), 이 값이 PS보다 작다면, PS와 Nim-2 sum의 차이를 구하고, 이 값만큼 돌을 가져가면 된다.

	NimSum을 손으로 계산하는 것은 힘들기 때문에 곤란해진 용태를 위해 NimSum (B, X, Y)를 계산하는 프로그램을 짜주자.
<입력값>
입력의 첫 번째 줄에는 테스트 케이스의 수를 나타내는 T가 주어진다. (1 ≤ T ≤ 1000), 그리고 각 테스트 케이스의 첫 줄에는 B, X, Y를 나타내는 정수가 공백을 사이에 두고 주어진다. (2 ≤ B ≤ 2000000, 0 ≤ X ≤ 2000000, 0 ≤ Y ≤ 2000000)
<출력값>
각 테스트 케이스마다 NimSum (B, X, Y)의 10진수 표현을 출력한다.

<문제 2686>
팩스 머신은 run-length encoding(RLE)을 이용해 데이터를 압축한다. 데이터는 같은 값이 연속적으로 많이 나타나는 수열이라 할 수 있다. 이러한 연속적인 같은 값을 run이라 한다. 그래서 RLE는 그 수열을 그대로 저장하는 대신 하나의 데이터 값과 그 값의 개수로 데이터를 표현한다. 이 인코딩 방식은 아이콘이나 텍스트, 선 등의 비교적 간단한 그래픽 이미지 같은 런이 많은 데이터에서 유용하다. 만약 사진과 같이 런이 적은 파일에 적용한다면 오히려 원래 파일 사이즈보다 커질 가능성도 있다. 
한 블록의 데이터를 RLE 알고리즘을 사용해 인코딩하려고 한다. 하나의 런은 2바이트 수열을 사용해 표현한다. 첫 번째 바이트는 하나의 값이 반복된 횟수이고, 두 번째 바이트는 그 값을 나타낸다. 반복 횟수는 최상위 비트가 1이고 나머지 7비트는 반복 횟수 - 3인 8비트 수로 표현된다. 따라서 데이터에서 같은 값은 수열의 2바이트 당 최대130번 나타날 수 있다. 또한 런의 최소 수는 3이다. 런이 아닌 바이트들은 prefix 바이트로 인코딩되는데, 이 바이트는 런이 아닌 바이트의 개수 - 1을 나타내며, 최상위 비트는 항상 0이다. 따라서 prefix 바이트의 범위는 0 ~ 127로, 1부터 128까지의 수를 표현한다.
만약 런이 130바이트보다 크다면 여러 개의 2바이트 수열로 표현한다. 이 경우 수열의 첫 번째는 항상 크기가 130인 런이다. 3회 이상 반복된 값은 반드시 런으로 인코딩되어야 한다. 만약 런이 아닌 값이 128바이트보다 길다면 prefix 바이트를 여러 개 사용해 표현한다. 예를 들어, 길이가 262인 런은 크기가 130인 런 두 개와 크기가 2인 prefix 바이트로 인코딩한다.
<입력값>
입력의 첫 줄에 데이터 셋의 수인 정수 P(1 ≤ P ≤ 1000)가 주어진다.
각 데이터 셋의 첫 줄에는 바이트의 수 B(1 ≤ B ≤ 5000)가 십진수 정수로 주어진다.
다음 줄 부터 인코딩 할 데이터가 주어진다. 데이터의 마지막 줄을 제외한 나머지 줄에는 16진수가 80자리 주어지며, 마지막 줄은 80자리보다 적을 수 있다. 두 16진수 자리가 한 바이트를 표현한다. 16진수 자리는 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F로 이뤄져 있다.
<출력값>
각각의 데이터 셋에 대해 첫 줄에는 인코딩 된 바이트의 수를 출력한다. 나머지 줄에는 인코딩 된 데이터를 16진수로 출력한다. 각 줄은 마지막 줄을 제외하고 16진수 80자리를 출력한다. 마지막 줄은 80자리 이하이다.

<문제 2687>
팩스는 Run-Length Encoding(RLE)라고 불리는 인코딩을 사용한다. RLE란 아주 단순한 데이터 압축으로 데이터를 데이터와 반복된 횟수로 저장하는 방식을 말한다. 이 방식은 상대적으로 단순한 그래픽 이미지(아이콘, 글, 선 긋기)와 같이 반복이 많은 데이터를 압축할 때 좋다. 그러나 사진과 같이 반복이 별로 없다면 별로 좋지 않고, 거의 파일 크기를 두배로 늘린다.

	아주 간단한 RLE 알고리즘을 이용하여 데이터 뭉치를 해독하는 프로그램을 작성해야 한다.

	run은 2바이트를 사용하여 인코딩된다. 첫 번째 바이트는 반복횟수(count)를 뜻하고, 두 번째 바이트는 반복될 문자(값,value)를 뜻한다.

	count 바이트는 첫 번째 비트가 1이며, 남은 7개의 비트로 [반복될 횟수-3]을 저장한다. 그러므로 최대 130번의 반복까지 저장할 수 있다. (즉 3회이상 반복되어야 이런 형식으로 인코딩된다는 뜻이다.) 값을 저장하는 value 바이트는 첫 번째 비트가 0이며 남은 7개의 비트로 [값-1]형태로 저장하여 1부터 128까지의 값을 저장할 수 있다.
<입력값>
첫째 줄은 데이터 세트 수 P(1 ≤ P ≤ 1000)가 입력으로 들어온다. 각각의 데이터 세트는 여러 줄로 구성되어 있는데, 첫째 줄은 문제 번호와 디코딩해야 할 바이트 수 B(1 ≤ B ≤ 5000)가 공백으로 구분되어 들어온다. 남은 줄은 디코드해야할 데이터로 구성되어 있다. 데이터는 한 줄에 각 80개의 16진법 숫자이며 (마지막 줄은 80개보다 적을 수 있다), 16진법 숫자 2개가 하나의 바이트를 나타낸다.

	(16진법 수는 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F로 구성되어 있다)
<출력값>
각각의 데이터 세트에 대해 여러 줄의 출력을 해야한다. 첫째 줄은 코딩한 바이트 수를 출력한다. 남은 줄은 디코딩한 데이터를 출력하는데, 한 줄에 80개의 16진수로 출력한다. (마지막 줄은 80개보다 적을 수 있다)

<문제 2688>
어떤 숫자가 줄어들지 않는다는 것은 그 숫자의 각 자리 수보다 그 왼쪽 자리 수가 작거나 같을 때 이다.

	예를 들어, 1234는 줄어들지 않는다. 

	줄어들지 않는 4자리 수를 예를 들어 보면 0011, 1111, 1112, 1122, 2223이 있다. 줄어들지 않는 4자리수는 총 715개가 있다.

	이 문제에서는 숫자의 앞에 0(leading zero)이 있어도 된다. 0000, 0001, 0002는 올바른 줄어들지 않는 4자리수이다.

	n이 주어졌을 때, 줄어들지 않는 n자리 수의 개수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 테스트 케이스의 개수 T(1 <= T <= 1,000)이 주어진다. 각 테스트 케이스는 숫자 하나 n으로 이루어져 있다. (1 <= n <= 64)
<출력값>
각 테스트 케이스에 대해 한 줄에 하나씩 줄어들지 않는 n자리 수의 개수를 출력한다.

<문제 2689>
I2C (Inter-Integrated Circuit) is a serial communication protocol that is used to attach low-speed peripherals (~100 kbit/sec) to a motherboard, embedded system or cell phone. A single I2C data bus may have several devices attached, each with a different 7-bit address. One of the nice things about I2C is that it only requires two signal lines, SCL (clock) and SDA (data). One bit of data is presented on the I2C data bus (SDA line) per clock (SCL). Typically, one device on the bus is designated as the master, and the other devices are slaves. The master will initiate communication to a specific device on the bus by specifying its address in a transaction.
If there is no activity on the I2C bus, both the SCL and SDA signals are in a high state (1). The master initiates a transaction on the bus by pulling the SDA signal to a low state (0), while the SCL signal is high (1): this is called a START bit. At this point, all slaves on the bus must start paying attention to the signaling to see if the transaction is directed at them. The master will then send the 7-bit slave address (most significant bit first), one bit at-a-time. This is done by bringing the SCL signal low (0), presenting the next bit value on the SDA line, then releasing the SCL signal so it goes high (1). The slaves will read the SDA signal as soon as the clock goes high (1). This operation is repeated 7 times, one for each bit of the desired slave address. Another data bit is presented on the bus in the same manner. This last bit is an indicator as to whether the master wants to read from (1) or write to (0) the addressed slave device. When a slave recognizes its address on the bus, it must acknowledge (ACK) that it is available and ready by pulling the SDA line low. The master will see this the next time it brings the clock high, at which point, the data transfer can begin. If no ACK is seen this means that the slave specified by the address does not exist. Note: If no device pulls a signal low, it will go high by default; a device simply releases a signal, and it will go high.
Data is always transferred as 8 bit bytes, 1 bit at-a-time, most significant bit first. After each byte, the slave must ACK the master by pulling the SDA line low. If the slave is not ready to transmit (or receive) the next byte of data, it may pull the SCL line low. This will cause the master to go into a wait mode until the slave is ready. The slave indicates it is ready by bringing SDA low, and releasing the SCL line so it goes high. The next byte of data can then be transferred. The sequence repeats until the master decides all the data has been transferred, at which point it will send a STOP bit. This is done when the master lets the SDA line go high while the SCL line is high.
For this problem, you will write a program that sniffs the I2C bus signals and displays the details of transactions.
<입력값>
The first line of input contains a single integer P, (1 ≤ P ≤ 1000), which is the number of data sets that follow. Each data set consists of multiple lines which represents a single I2C transaction. The first line contains one integer value: the number of signal samples S, (1 ≤ S ≤ 1161), for the transaction. The remaining line(s) contain(s) the signal samples. Each line of samples contains 40 samples (except the last which may contain less). Each sample consists of 2 binary digits characters representing SCL and SDA in that order.
<출력값>
For each data set, display a single line which is a description of the transaction. There will only be six different descriptions (two non-error cases, and four error cases)
Non-error cases:

WRITE OF n BYTES TO SLAVE xx
READ OF n BYTES FROM SLAVE xx

Error cases:

ERROR NO START BIT
ERROR NO STOP BIT
ERROR NO ACK FROM SLAVE xx
ERROR NO ACK FOR DATA

n is a decimal integer (1 – 128) representing the number of data bytes.
xx is a 2 digit hexadecimal value (00-7F) representing the slave address.
The ERROR NO ACK FROM SLAVE xx case occurs when there is no ACK for the supplied address
The ERROR NO ACK FOR DATA case occurs when there is no ACK after a data byte
For the error cases, only the first error detected should be displayed.

<문제 2690>
배비지등의 디지털 방식 조판이 없었던 시대에는, 조판은 숙련공들만이 할 수 있는 예술의 일종이었다. 인쇄 공간 절약과 아름다움을 위해 특정한 문자의 조합은 하나의 문자로 나타내었으며 이것을 ligature라 한다. 예를 들면 a-e의 ligature는 ‘æ’이며 f-i의 ligature는 ‘ﬁ’이다. (힌트에 가능한 모든 ligature 조합을 표시한 표가 있다)
또한 소문자 s를 나타내는 방법에는 “long s”와 “short s” 두 가지 방법이 있었으며, 오늘날에는“short s”의 형태만 쓰인다. 어떤 방법을 쓸지 결정하는 규칙은 이상하지만 복잡하지는 않다.

Short s는 단어의 끝 또는 하이픈(-)과 어퍼스트로피(`)같은 단어 속에 있는 구두점 앞에 쓴다.
	
예) programs, ſucceſs, hocus-pocus, revis’d


Short s는 ‘f’, ‘b’, ‘k’앞에 쓴다.
	
예) transfer, husband, ask, ſucceſsful


‘ss’로 끝나는 단어 뒤에 ‘s’로 시작하는 단어가 합성되어 ‘sss’가 포함된 단어의 경우, 가운데 s는 short s로, 나머지 s는 long s로 쓴다.
	
예) croſsﬅitch, croſsﬅaﬀ


위의 경우 이외에는 모두 long s로 쓴다.

조판에 있어 “단어”라는 말이 “식별자”와는 다른 것임에 주의하자. 식별자는 ‘_’나 ‘\$’같은 구두점도 포함할 수 있는 반면, 단어는 문자만을 의미한다. 따라서 “radius3”이나 “adios_amigio”같은 식별자는 “radiu∫3”, “adio∫_amigo”가 아니라 “radius3”, “adios_amigo”로 조판된다.
<입력값>
입력의 첫 줄에 테스트의 개수인 정수 P(1 ≤ P ≤ 1000)가 주어진다.
각각의 테스트는 1000자 이하의 문자열이 한 줄로 주어진다. 입력으로 주어지는 문자열은 알파벳 대문자, 소문자, 숫자, 공백 그리고 다음 특수문자 .,"'$;:?()-<>=!로만 이루어져 있다.
<출력값>
각각의 테스트에 대해 입력 문자열을 적절한 ligature와 “long s” 코드로 대체하여 출력한다. 다음 페이지의 표에 기호와 ligature에 대응하는 코드가 표시되어 있다. (short s는 바꾸지 않고 그대로 출력하며, ‘IE’와 ‘OE’는 대문자 I-E, 대문자 O-E조합에 한해서 ligature로 나타낸다.)

<문제 2691>
FoodVictory의 물류 관리자인 영우는 2685번에서 용태에게 패배한 충격으로 그만 바코드 데이터베이스 일부를 날려버렸다. 이 사건이 알려지면 영우는 굉장히 곤란한 상황에 처하게 되므로 지푸라기라도 붙잡는 심정으로 인터넷에 바코드를 검색해 보았다.
UPC-A 바코드는 12자리의 십진수를 번갈아나며 나타나는 "밝은" 부분과 "어두운" 막대로 이루어진 15개의 패턴으로 표현한다. 이 패턴은 SLLLLLLMRRRRRRE와 같은 패턴이다. 여기서 S는 시작 패턴으로 101(1은 "어두운" 막대이고 0은 "밝은" 막대이다)이고, M은 중간 패턴으로 01010이다. 그리고 E는 끝 패턴으로 101이다. L은 왼쪽 패턴으로 각 자리가 10진수의 첫 6자리와 대응되고, R은 오른쪽 패턴으로 각 자리가 10진수의 뒤 6자리와 대응된다. 각 막대의 두께는 일정한 값(바코드의 가로 크기)의 배수이며, 바코드 위의 작은 표시는 패턴(S, L, M, R, E)의 시작을 표시한다. (단, 가장 마지막 표시는 바코드의 끝을 나타낸다) 바코드에는 총 3 + 5 + 3 + 12*7 = 95개의 코드(1,0)가 있어야 하고, 양 끝에 최소한 9개의 "밝은" 막대가 있어야 한다.
바코드의 십진수 마지막 자리는 체크섬 숫자이며, 다음과 같이 계산한다.
(digitN = 십진수의 N번째 자리, check_digit = 마지막 자리)

CheckSum = 3*(digit1 + digit3 + digit5 + digit7 + digit9 + digit11) + digit2 + digit4 + digit6 + digit8 + digit10;
Code = CheckSum % 10;
If (Code == 0) check_digit = 0;
else check_digit = (10 - Code);

바코드 스캐너는 카메라를 이용해 바코드의 좁은 이미지를 읽어내고, 이미지로부터 코드를 추론해낸다.

바코드가 뒤집혀진채로 읽힌다면 코드가 반대 방향으로 읽히게 된다.

안타깝게도, 색상 대비의 부족이나 반짝이는 물체의 반사때문에 이 이미지는 언제나 명확하지는 않다.

위의 그림을 보면, 확실히 밝은 막대인지 어두운 막대인지 제대로 알아볼 수가 없다. 하지만 이런 경우에도 대부분은 바코드를 인식할 수 있는데, 그 이유는 다음과 같다. 첫째, 128가지의 가능한 7-비트 숫자중 20개만이 사용된다. 둘째, 체크섬이 맞아 떨어지는 경우에만 옳은 바코드이다. 마지막으로, 여러 바코드가 매치된다고 해도, 그중 두 개 이상이 같은 목적으로 데이터베이스에 저장되어있을 가능성은 희박하다.
자, 영우의 위기를 막기 위해 손상된 바코드와 매칭될 수 있는 모든 옳은 바코드의 목록을 출력해주자(뒤집혀서 읽힌 경우도 고려할것!). 손상된 바코드는 0과 1, 그리고 ?(손상되어 알 수 없는 부분)으로 이루어진 95자의 코드로 표현된다
<입력값>
첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 두 줄로 이루어져 있는데, 첫째 줄에는 바코드의 첫 50자가, 둘째 줄에는 바코드의 마지막 45자가 주어진다.
<출력값>
각 테스트 케이스마다 첫째 줄에는 입력과 매치되는 올바른 바코드의 개수를 출력하는데, 만약 매치되는 개수가 8보다 크다면 9를 출력한다. 그 다음 줄부터는 매치되는 모든 바코드를 증가하는 순서로 한 줄에 한 개씩 출력한다. (단, 매치되는 바코드의 수가 9 이상이라면 첫 8개만 출력한다)

<문제 2692>
동규는 자신의 쌍둥이 아들 승환이와 규현이를 위해 매년 삼각형 모앙의 생일 케익을 사온다. 동규가 사오는 케익의 모양은 매년 다르다. 케익의 옆은 초콜릿 아이싱이 덮여있고, 위에는 핑크 아이싱이 덮여있다. 승환이와 규현이는 이 2개의 아이싱을 모두 좋아하기 때문에, 서로 같은 양을 먹으려고 한다.

	규현이와 승환이가 같은 양을 먹기 위해서 케익을 자르는 프로그램을 작성하시오.

	삼각형 이퀼라이저란 삼각형을 동일한 둘레와 넓이로 나누는 선이다. 이 선은 삼각형을 통과한다. 아래 그림의 선은 모두 그 삼각형의 삼각형 이퀼라이저이다.

	일반적으로 삼각형은 1, 2, 또는 3개의 이퀼라이저를 갖는다. (2개인 경우는 특수한 조건일 때만 나타난다)



	삼각형이 주어졌을 때, 삼각형 이퀼라이저를 하나만 구하는 프로그램을 작성하시오. 이때, double을 이용해서 계산을 하면 된다.
<입력값>
첫째 줄에 테스트 케이스의 개수 P(1 ≤ P ≤ 1000)가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 각 줄은 6개의 실수로 이루어져 있다. 6개의 실수는 삼각형의 꼭짓점 좌표이고, x0, y0, x1, y1, x2, y2 순서이다.
<출력값>
각 테스트 케이스에 대해서, 주어진 삼각형의 이퀼라이저의 직선의 방정식을 출력한다. 방정식을 Ax + By = C 꼴로 나타낸 뒤, A, B, C를 공백으로 구분해서 소수점 5째자리까지 출력하면 된다. 이때, A*A + B*B = 1.0, A >= 0이다.

<문제 2693>
배열 A가 주어졌을 때, N번째 큰 값을 출력하는 프로그램을 작성하시오.
배열 A의 크기는 항상 10이고, 자연수만 가지고 있다. N은 항상 3이다.
<입력값>
첫째 줄에 테스트 케이스의 개수 T(1 <= T <= 1,000)가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 배열 A의 원소 10개가 공백으로 구분되어 주어진다. 이 원소는 1보다 크거나 같고, 1,000보다 작거나 같은 자연수이다.
<출력값>
각 테스트 케이스에 대해 한 줄에 하나씩 배열 A에서 3번째 큰 값을 출력한다.

<문제 2694>
어떤 수열이 있을 때, 순서를 유지하면서 적절히 그룹으로 나누면서, 각 그룹에 들어있는 수의 합을 같게 만들 수 있다.
예를 들어, 2, 5, 1, 3, 3, 7은 (2, 5), (1, 3, 3), (7)와 같이 나누면 각 그룹에 들어있는 수의 합이 7로 모두 같아진다.
양의 정수로 이루어진 수열이 주어졌을 때, 이를 합이 같은 구간으로 나누는 방법은 여러 가지가 있다. 이때, 합의 최솟값을 구하시오.
참고로 수열을 통째로 그룹 1개에 넣을 수 있다. 그럼 이때, 수의 합은 수열의 합이 된다.
<입력값>
첫째 줄에 테스트 케이스의 개수 T(1 ≤ T ≤ 50)가 주어진다. 각 테스트 케이스는 첫째 줄에 수열의 크기 M이 주어진다. (1 ≤ M ≤ 10,000) 그 다음 줄부터는 그 수열에 들어있는 수가 주어지고, 한 줄에 10개씩 나누어서 주어진다. 따라서 마지막 줄은 수가 10개가 아닐 수도 있다. 수는 10,000보다 작거나 같은 자연수이다.
<출력값>
각 테스트 케이스에 대해 한 줄에 하나씩 문제에서 설명한 가장 작은 합을 출력한다.

<문제 2695>
고전적인 '두 개의 유리 공' 문제는 다음과 같다:

	두 개의 동일한 유리구가 있고, 100층 짜리 빌딩에서 유리구를 떨어뜨려서 깨지는 가장 낮은 층을 찾고 싶다. 유리구가 안깨진다면 아무런 피해가 없다고 가정하자. 어떻게 해야 (최악의 상황에서도) 가장 빨리 찾을 수 있을까?

	우리가 오직 하나의 공이 있다고 가정하자. 그러면 우리는 1층부터 100층까지 차례대로 떨어뜨려보는 방법 밖에 없다.

	최악의 경우는 100번만에 찾는 것이다.

	이제 우리에게 두 개의 공이 있다고 하자. 그리고 첫 번째 공을 n층에서 떨어뜨린다고 하자. 만약에 그게 깨진다면 다시 공 하나가 있는 경우로 돌아가서, 1층부터 n-1층까지 시도해보면된다. 이 경우 최악의 경우 1+(n-1), 즉 n번의 시도만에 찾을 수 있다. 하지만 n층에서 깨지지 않았다면, n+1층에서 100층까지만 실험해보면 된다. 깨지거나 깨지지 않았거나 우리는 한 번의 시도를 하였다. 그래서 실험 횟수는 최악의 경우 모든 n에 대하여 가장 작다.

	B개의 공과 M층 짜리 빌딩에서 최악의 경우에 몇 번 공을 떨어뜨려야 하는지를 계산하는 프로그램을 작성하시오.
<입력값>
첫째 줄은 데이터 세트 수 P(1 ≤ P ≤ 1000)가 입력으로 들어온다. 각각의 데이터 세트는 한 줄로 구성되어 있으며 2개의 숫자가 공백으로 구분되어 있다. 유리공의 개수 B(1 ≤ B ≤ 50), 건물의 층 수 M(1 ≤ M ≤ 1000)
<출력값>
각각의 데이터 세트에 대해 한 줄 씩, B, M에 대해 (최악의 경우에도)가장 적은 횟수의 시도 횟수를 공백으로 구분하여 출력한다.

<문제 2696>
어떤 수열을 읽고, 홀수번째 수를 읽을 때 마다, 지금까지 입력받은 값의 중앙값을 출력하는 프로그램을 작성하시오.

	예를 들어, 수열이 1,5,4,3,2 이면, 홀수번째 수는 1번째 수, 3번째 수, 5번째 수이고, 1번째 수를 읽었을 때 중앙값은 1, 3번째 수를 읽었을 때는 4, 5번째 수를 읽었을 때는 3이다.
<입력값>
첫째 줄에 테스트 케이스의 개수 T(1<=T<=1,000)가 주어진다. 각 테스트 케이스의 첫째 줄에는 수열의 크기 M(1<=M<=9999, M=홀수)이 주어지고, 그 다음 줄부터 이 수열의 원소가 차례대로 주어진다. 원소는 한 줄에 10개씩 나누어져있고, 32비트 부호있는 정수이다. (대부분의 언어에서 int)
<출력값>
각 테스트 케이스에 대해 첫째 줄에 출력하는 중앙값의 개수를 출력하고, 둘째 줄에는 홀수 번째 수를 읽을 때 마다 구한 중앙값을 차례대로 공백으로 구분하여 출력한다. 이때, 한 줄에 10개씩 출력해야 한다.

<문제 2697>
어떤 수 A가 주어졌을 때, A의 다음수를 구하는 프로그램을 작성하시오.
A의 다음수는 A와 구성이 같으면서, A보다 큰 수 중에서 가장 작은 수 이다.
A와 B의 구성이 같다는 말은 A를 이루고 있는 각 자리수의 등장 횟수가, B를 이루는 각 자리수의 등장 횟수와 같을 때 이다.
예를 들어 123과 321은 구성이 같다. 왜냐하면 두 수 모두 1이 1번, 2가 1번, 3이 1번 나오기 때문이다. 마찬가지로 14232와 12243도 구성이 같다.
하지만, 14232와 14432는 구성이 같지 않다.
<입력값>
첫째 줄에 테스트 케이스의 개수 T(1<=T<=1,000)가 주어진다. 둘째 줄부터 T개 줄에는 각 테스트 케이스가 주어진다. 테스트 케이스는 한 줄로 이루어져 있으며, 수 A이다. A는 최대 80자리 자연수이다.
<출력값>
각 테스트 케이스에 대해서, 한 줄에 하나씩 A의 다음수를 출력한다. 만약, A의 다음수가 없을 때는 BIGGEST를 출력한다.

<문제 2698>
0과 1로 이루어진 수열 S가 있다. S의 첫 수는 s1이고, 마지막 수는 sn이다. S의 인접한 비트의 개수는 다음과 같이 구할 수 있다.
s1*s2 + s2*s3 + s3*s4 + ... + sn-1 * sn
위의 식을 이용하면 수열 S에서 인접한 1의 개수를 구할 수 있다. 예를들어, 011101101의 인접한 비트의 개수는 3이 되고, 111101101은 4, 010101010은 0이 된다.
수열 S의 크기 n과 k가 주어졌을 때, 인접한 비트의 개수가 k인 수열 S의 개수를 구하는 프로그램을 작성하시오.
예를 들어, n이 5이고, k가 2이면, 수열 S가 될 수 있는 수열은 다음과 같이 6가지가 있다.
11100, 01110, 00111, 10111, 11101, 11011
<입력값>
첫째 줄에 테스트 케이스의 수 T(1 ≤ T ≤ 1,000)가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 수 2개가 공백으로 구분되어 이루어져 있다. 첫 번째 수는 n이고, 두 번째 수는 k이다. n과 k는 100을 넘지 않는 자연수이다.
<출력값>
각 테스트 케이스에 대해 인접한 비트의 개수가 k인 수열 S의 개수를 한 줄에 하나씩 출력한다. 이 값은 2,147,483,647보다 작거나 같다.

<문제 2699>
정수좌표를 갖는 점을 격자점이라고 한다. 격자 다각형은 모든 꼭짓점이 격자점으로 이루어진 다각형이다.
만약, 다각형의 두 꼭짓점을 잇는 모든 선분이 다각형 내부(또는 경계)에 있다면, 이 다각형을 볼록 다각형이라고 한다. 즉, 다각형의 내부각이 모두 180도 보다 작은 것이다.
격자점으로 이루어진 집합 S가 주어졌을 때, S의 모든 격자점을 포함하는 가장 작은 볼록 (격자) 다각형을 컨벡스 헐이라고 한다. 컨벡스 헐의 꼭짓점은 모두 S에 포함된 격자점이어야 한다. 만약, 모든 점이 같은 일직선 상에 있다면, 컨벡스 헐은 선분이 될 것이다. (오른쪽 그림)
아래 그림에서 집합에 포함된 점은 굵은 점으로, 컨벡스 헐의 꼭짓점은 X로, 변은 선분으로 나타낸 그림이다.

격자 다각형의 꼭짓점의 일반적인 순서는 다음과 같다.

첫 번째 꼭짓점은 y좌표가 가장 큰 점이다. 만약, 그러한 점이 2개라면, x가 작은 점이 첫 번째 점이다.
그 다음 점부터는 시계방향 순서이다.

격자점의 집합이 주어졌을 때, 컨벡스 헐을 일반적인 순서로 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 테스트 케이스의 개수 P(1 ≤ P ≤ 1000)가 주어진다. 각 테스트 케이스의 첫째 줄에는 집합에 포함된 격자점의 수 N(3 ≤ N ≤ 50)이 주어진다. 나머지 줄은 집합에 포함되어 있는 격자점의 좌표가 한 줄에 5개씩 주어진다. (마지막 줄은 이보다 적을 수 있다) 모든 점은 x와 y좌표가 순서대로 주어지며, 공백으로 구분되어 있다. 좌표는 절댓값이 20보다 작거나 같은 정수이다.
<출력값>
각 테스트 케이스에 대해서, 첫째 줄에는 컨벡스 헐에 포함된 점의 수를 출력한다. 그 다음 줄부터 컨벡스헐에 포함된 격자점을 한 줄에 하나씩 일반적인 순서대로 출한다. x와 y를 공백으로 구분하여 출력한다.

<문제 2700>
격자점은 좌표가 정수인 점을 뜻한다.격자 다각형은 모든 꼭짓점이 격자점인 다각형이다.

다각형의 경계에 있는 격자점을 경계점이라 한다. (위 그림에서 열린 점) 또한 다각형 위에 있지 않은 내부의 격자점을 내부점이라 한다. (위 그림에서 닫힌 점)
다각형의 내부에 있는 어떠한 두 점을 골라 만든 선분이 모두 다각형의 내부 또는 경계에 있다면 그 다각형을 볼록하다고 한다. 즉, 내각의 크기가 모두 180도보다 작다. 다각형 내부(경계 위의 점은 제외한다)에 있는 두 점 사이의 모든 선분도 다각형의 내부에 완벽하게 들어간다.
볼록 격자 다각형의 내부점 중 수평선 상의 점에는 가장 왼쪽 점과 가장 오른쪽 점이 존재한다. (가장 왼쪽 점과 가장 오른쪽 점이 같을 수 있다) 아래 그림 A처럼 내부점이 없거나, B처럼 하나뿐인 경우가 있을 수도 있다. 그림 C의 경우 아래 그림과 같다.

볼록 격자 다각형을 아래와 같은 순서로 입력 받아, 수평선을 이루는 내부점을 모두 출력하는 프로그램을 작성하시오.
1. 첫 번째 점은 y값이 가장 큰 점이다. 만약 y값이 같은 점이 있다면 x값이 작은 순으로 주어진다.
2. 점은 시계방향으로 주어진다.
<입력값>
입력의 첫 줄에는 테스트의 개수 P(1 ≤ P ≤ 1000)가 주어진다.
각각의 테스트 첫 줄에는 다각형 점의 개수를 나타내는 정수 N(3 ≤ N ≤ 50)이 주어진다. 나머지 줄에는 위에 설명된 순서대로 점의 x좌표와 y좌표를 나타내는 정수 두 개가 공백을 사이에 두고 주어진다. 입력으로 주어지는 좌표는 -30보다 크거나 같고, 30보다 작거나 같은 자연수이다.
<출력값>
첫 줄에는 수평선의 개수를 출력한다. 만약, 수평선이 하나 이상 있다면, 수평선의 y 좌표 값을 한 줄에 하나씩 출력한다. 이때 y좌표 내림차순으로 출력한다. 각각의 y좌표 값 뒤에 공백을 사이에 두고 가장 왼쪽 x좌표와 가장 오른쪽 x좌표를 출력한다.

<문제 2701>
육각 퍼즐이란 정육각형의 꼭짓점과 중심에 원이 그려져 있는 퍼즐이고, 아래 그림과 같이 원이 연결되어 있다. 또, A, B, C, D, E, F로 글자가 새겨져 있는 동전이 아래 그림과 같이 원 위에 놓여 있다. 퍼즐에서 한 번 움직일 때, 동전을 연결된 빈 칸으로 움직일 수 있다.

	처음 동전이 섞인 상태로 주어졌을 때, 동전을 아래 그림과 같이 맞추는 최소 이동 회수를 구하는 프로그램을 작성하시오. 처음 상태에서 가운데 칸은 비어있다.



	처음 중심 정점은 비어있고 바깥쪽 정점 6 개가 A부터 F의 주어진 순열이 주어졌을 때 원래 ABCDEF 순서로 돌아가게 퍼즐을 푸려고 한다.

	퍼즐의 상태는 위의 그림의 A 위치에 있는 동전부터 F까지 차례대로 주어진다. 퍼즐을 움직인 방법을 출력할 때는, 움직인 동전을 출력하면 된다.

	예를 들어, FACDBE 퍼즐을 풀 때는 BEFAB로 움직이면 풀 수 있다.



	퍼즐의 초기 상태가 주어졌을 때, 이 퍼즐을 푸는 방법을 출력하는 프로그램을 작성하시오. 이때, 움직인 동전의 수를 최소로 해야 한다.
<입력값>
첫째 줄에 테스트 케이스의 개수 T(1 ≤ T ≤ 1000)가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 퍼즐의 초기 상태가 주어진다.
<출력값>
각 테스트 케이스에 대해서 최소 회수를 출력하고 공백을 출력한 뒤, 푸는 방법을 출력한다. 만약, 풀 수 없는 퍼즐이라면 -1을 출력한다.

<문제 2702>
두 정수 a와 b 최소공배수는 두 수의 공통된 배수 중 가장 작은 수이고, 최대공약수는 두 수의 공통된 약수중 가장 큰 수이다.

	a와 b가 주어졌을 때, 최소공배수와 최대공약수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 테스트 케이스의 개수 T(1<=T<=1,000)가 주어진다. 각 테스트 케이스는 두 정수 a와 b로 이루어져 있고, 공백으로 구분되어 있다. (1 <= a,b <= 1,000)
<출력값>
각 테스트 케이스에 대해 최소공배수와 최대공약수를 차례대로 출력한다.

<문제 2703>
Cryptoquote는 어떤 메시지가 있을 때, 각 알파벳을 다른 알파벳으로 변환해 암호화 하는 방법이다.
예를 들어, HPC PJVYMIY란 메시지가 있을 때, 이를 원래 메시지로 바꾼다면 ACM CONTEST가 된다.
위의 예를 바꾸는 규칙은 H=A, P=C, C=M, J=O, V=N, Y=T, M=E, I=S이다. 이처럼 Cryptoquote를 하려면, 문자와 문자 사이의 규칙이 있어야 한다.
암호화된 메시지와 문자와 문자 사이의 규칙이 주어졌을 때, 이를 원래 메시지로 바꾸는 프로그램을 작성하시오.
<입력값>
첫째 줄에 테스트 케이스의 개수 T(1 ≤ T ≤ 1000)가 주어진다. 각 테스트 케이스는 다음과 같이 두 줄로 구성되어 있다.
테스트 케이스의 첫째 줄에는 암호화된 메시지가 주어지고, 둘째 줄에는 변환 규칙이 주어진다. 변환 규칙은 알파벳 대문자 26글자로 이루어져있고, 암호회된 메시지의 길이는 100 이하이다.
첫 번째 문자는 A에 해당하는 문자, 두 번째는 B, ..., 26번째는 Z에 해당하는 문자이다. 변환 규칙은 중복되지 않는다. 암호화된 메시지에는 공백이 있을 수 있고, 이것은 원래 메시지에도 포함되어야 한다.
<출력값>
각 테스트 케이스에 대해서 한 줄에 하나씩 원래 메시지를 출력한다.

<문제 2704>
이진법 시계는 60초-60분-1시간 체계의 일반적인 시간을 이진수로 표시해주는 시계이다. 일반적으로는 3행 혹은 3열의 LED에 0 또는 1을 표시하여 시간을 표시하는 방식이 주로 쓰인다.

3열 방식은 위 왼쪽 그림과 같이 6행 3열로 이루어져 있다. 각 열은 왼쪽부터 차례대로 시간, 분, 초를 나타낸다. 각 행은 첫 행의 수는 2 5를 나타내고 그 아래 수는 24를, 그렇게 6행은 1까지의 값을 갖는다.
3행 방식은 위의 오른쪽 그림처럼 3행 6열로 이루어져 있다. 3열 방식과는 반대로 3개의 행이 각각 시간, 분, 초를 나타내며, 각 열은 1열이 2 5, 2열이 24, ... , 6열이 1을 나타낸다.
위의 시계는 두 경우 모두 10시 37분 49초이다.
시계를 읽는 방식은 두 경우 모두 행우선 좌->우로 읽는다.
예를 들어 10시 37분 49초를 나타내는 이진법 시계의 3열 방식은(위의 예제) 011001100010100011로 읽으며, 3행 방식은 001010100101110001로 읽는다.
문제에서는 1시간-60분-60초 형태에 맞는 올바른 시각 하나가 주어진다.
이제 이 시간을 이진법 시계에서의 방식으로 나타내고, 3열 방식과 3행 방식으로 읽는 프로그램을 작성하면 된다.
<입력값>
첫 줄에 테스트 케이스의 수 N이 주어진다. (1<=N<=1000)
각 케이스마다 10진법에서의 시간, 분, 초로 나타낸 시각이 한 줄에 예제의 형식과 같이 주어진다.
<출력값>
각 테스트 케이스마다, 3열 방식으로 읽은 이진법 시계의 시각과 3행 방식으로 읽은 이진법 시계의 시각을 공백으로 구분하여 출력한다. 각각 18개의 비트를 가져야 한다.

<문제 2705>
양의 정수 N의 파티션은 합이 N이 되는 수열을 말한다. 보통 숫자 사이에 +를 넣어서 나타낸다. 예를 들면
15 = 1+2+3+4+5 = 1+2+1+7+1+2+1 이다.
어떤 파티션을 앞에서 읽을 때와 뒤에서 읽을 때가 같으면 이 파티션을 팰린드롬 파티션이라고 한다. 위의 예에서 첫 번째 파티션은 팰린드롬 파티션이 아니지만, 두 번째 파티션은 팰린드롬 파티션이다.
어떤 파티션이 m개의 정수로 이루어져 있다면, 왼쪽 절반은 처음 floor(m/2)개의 원소, 오른쪽 절반은 마지막 floor(m/2)개의 원소이다. 
재귀적인 팰린드롬 파티션은 어떤 파티션이 팰린드롬이면서, 왼쪽 절반과 오른쪽 절반이 재귀적인 팰린드롬이거나, 비어있을 때 이다. 모든 정수는 적어도 2개의 재귀적인 팰린드롬 파티션을 항상 갖는다. (n과, 1 n개) 
7의 재귀적인 팰린드롬 파티션은 다음과 같이 6가지가 있다.
7, 1+5+1, 2+3+2, 1+1+3+1+1, 3+1+3, 1+1+1+1+1+1+1
어떤 수 N을 입력받은 다음에, 재귀적인 팰린드롬 파티션의 개수를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 테스트 케이스의 개수 T(1 <= T <= 1,000)가 주어진다. 각 테스트 케이스는 양의 정수 1개로 이루어져있고, 이 수가 문제에서 설명한 N이고, 1,000보다 작거나 같다.
<출력값>
각 테스트 케이스에 대해 한 줄에 하나씩 N의 재귀적인 팰린드롬 파티션의 개수를 출력한다.

<문제 2706>
표준 휴대전화의 키패드에는 글자들이 다음과 같이 번호키와 대응되어있다.



	글자 C를 입력하기 위해서는 '2'키를 3번 눌러야 한다. 이와 같이 글자를 입력하기 위해 눌러야 하는 키의 번호와 눌러야 하는 횟수는 글자가 어떤 키의 리스트에 속해있는가와 리스트에서 몇 번째인지에 따라 다르다.

	Exupery Telephone Company (ETC)는 축적된 글자별 사용 빈도 데이터베이스를 이용하여 휴대전화 사용자들의 평균 키 입력 횟수를 줄이기 위해 글자 배치들을 변경하려고 한다. 예를 들어, S를 7키에서 8키로 옮길 수 있다. 

	글자들이 나타나는 순서는 알파벳 순서를 지켜야 하지만 각 키마다 배정되는 글자의 수는 달라도 된다.

	각 알파벳의 빈도수와 키의 개수가 주어졌을 때, 알파벳을 어떻게 배치해야 입력 회수의 평균값이 작아지는지 구하는 프로그램을 작성하시오.

	각 키에 알파벳은 적어도 한 개 있어야 하며, 많아야 여덟 개까지 있을 수 있다.
<입력값>
첫 번째 줄에 테스트 케이스의 수 T가 주어진다. 각 테스트 케이스는 세 줄로 이루어진다: 첫째 줄에는 키의 개수 K가 주어진다 (4 ≤ K ≤ 26) 둘째 줄에는 첫 13개 알파벳의 사용 빈도가 주어진다. 셋째 줄에는 마지막 13개 알파벳의 사용 빈도가 주어진다.
<출력값>
각 테스트 케이스에 대해 최적의 키 배열에서의 평균 키 입력 횟수(소수점 셋째자리까지), A~Z의 배열을 공백을 사이에 두고 출력한다.

<문제 2707>
평범한 방식으로 정렬을 하면, 숫자가 섞여 있는 문자열(string)은 원하는대로 잘 정렬되지 않는다. 예를 들면, xyz100은 xyz2에 앞서는 식으로 말이다. 어떤 프로그램에서는 문자열에 있는 숫자를 숫자로만 취급하여 정렬하는 '노말 정렬'을 사용한다. 다음은 노말 정렬된 예이다.
XYZ001, XYZ2, XYZ003, XYZ08, XYZ23, XYZ100, XYZQ
우리는 노말 정렬을 다음과 같은 두 가지 방법으로 확장하고자 한다.

대소문자는 구분하지 않고 정렬한다. (대문자 취급)
+,- 부호가 숫자 뒤에 등장하지 않으며, 숫자보다 앞에 등장하면 다음에 나오는 숫자의 일부라고 생각한다.

예를 들면 123+456+7890은 3개의 숫자가 + 부호로 구분되어 있는 것이고, A+003은 A3과 같다.
우리의 정렬을 하려면, (라이브러리 정렬 방식을 사용하지만) 비교 방법은 따로 작성해야 한다. 비교하는 부분을 작성하시오 (두 개의 출력가능한 공백이 없는 ASCII 문자 36~126를 입력으로 받는다)
리턴값은 다음과 같다

-1 : 첫 번째 문자열이 두 번째 문자열보다 앞서는 경우
0: 두 문자열이 같은 순서인 경우
1: 두 번째 문자열이 첫 번째 문자열보다 앞서는 경우
<입력값>
첫째 줄은 데이터 세트 수 N(1 ≤ N ≤ 1000)이 입력으로 들어온다. 각각의 데이터 세트는 한 줄로 구성되어 있으며, 공백으로 구분된 비교할 두 개의 문자열이다.
<출력값>
각각의 데이터 세트에 대해, -1, 0, 1 중 하나의 값을 공백으로 구분하여 한 줄 씩 출력한다.

<문제 2708>
폴리큐브는 모서리의 길이가 1인 단위 정육면체를 면과 면끼리 붙여서 만든 입체이다. 아래 그림에서 왼쪽 아래 입체는 선과 선끼리 붙였기 때문에, 폴리큐브가 아니다.

폴리큐브를 이루는 정육면체의 중심은 모두 3차원 공간에 있고, 정수 좌표이다.
폴리큐브를 만들기 위해서 가장 처음 (0, 0, 0)에 있는 큐브부터 시작한다. 그 다음, 폴리큐브를 만드는 각 단계에서 다음 정육면체는 반드시 이전 정육면체와 면이 닿아야 한고, 지금까지 나오지 않은 정육면체이어야 한다. 예를 들어, 그림에서 왼쪽 위에 있는 폴리큐브는 아래와 같이 만들 수 있다.
(0,0,0) (0,0,1) (0,0,2) (0,0,3) (0,0,4)
그리고, 오른쪽 위에 있는 폴리큐브는 다음과 같이 만들 수 있다.
(0,0,0) (0,0,1) (0,1,1) (0,1,0) (1,0,0) (1,0,1) (1,1,1) (1,1,0)
폴리큐브는 단위 정육면체로 이루어져있기 때문에, 이것의 겉넓이은 모두 정수이다.
3차원 공간의 좌표가 주어질 때, 이것이 폴리큐브를 이루어지는지 구하고, 폴리큐브라면 겉넓이를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 테스트 케이스의 개수 T(1<=T<=1,000)가 주어진다. 각 테스트 케이스는 다음과 같이 이루어져 있다. 첫째 줄에는 점의 개수 P(1<=P<=100)가 주어진다. 그 다음줄부터 정육면체의 중심 좌표가 차례대로 한 줄에 8개씩 주어진다.
<출력값>
각 테스트 케이스에 대해서 폴리큐브를 이룬다면 그것의 단면적을 출력하고, 아니라면 NO를 출력한 뒤에, 몇 번째 정육면체 폴리큐브를 이룰 수 없었는지를 출력한다. 첫 번째 정육면체는 1번이다.

<문제 2709>
R이 주어졌을 때, 마지막 R자리가 1과 2로만 이루어진 가장 작은 2k를 구하는 프로그램을 작성하시오. 
예를 들어, 29 = 512이고, 289 = 618970019642690137449562112 이다. 29는 마지막 2자리가 1과 2로 이루어져 있고, 289는 마지막 4자리가 1과 2로만 이루어져 있다.
R이 6일때까지 답을 구해보면 다음과 같다.



R
가장 작은 k
2k




1
1
2


2
9
512


3
89
...112


4
89
...2112


5
589
...22112


6
3089
...122112
<입력값>
첫째 줄에 테스트 케이스의 개수 T(1 ≤ T ≤ 50)가 주어진다. 각 테스트 케이스는 정수 1개로 이루어져 있고, 이 수는 R(1 ≤ R ≤ 20)이다.
<출력값>
각 테스트 케이스에 대해 한 줄에 하나씩 마지막 R자리가 1과 2로만 이루어진 가장 2k의 k를 출력한다.

<문제 2710>
선영이의 조경회사는 컴퓨터 geek을 위한 정원 관리로 유명하다. 그 중 가장 유명한 것은 정삼각형 모양의 테라스에 원형 풀장이 내접하고 있는 형태이다.



	그러나 선영이의 일부 고객은 정원 가운데 정삼각형 모양을 만드는 대신, 정원의 구석이나 비스듬한 면에 테라스를 만들기를 원한다. 선영이는 임의의 삼각형 모양에 대해 아래 그림과 같이 타원형의 풀장이 삼각형 변의 중점에 접하는 형태를 제안했다.



	타원의 두 초점에 막대를 꽂으면, 막대에 줄을 연결해 타원을 그릴 수 있다. 삼각형의 세 꼭짓점의 좌표가 주어졌을 때, 두 초점의 좌표와 필요한 줄의 길이를 출력하는 프로그램을 작성하라. (줄의 길이는 두 초점에서 타원 위의 임의의 점까지의 길이의 합이다.)
<입력값>
입력의 첫 줄에는 테스트의 개수인 정수 N(1 ≤ N ≤ 1000)이 주어진다.

	각각의 테스트에는 세 점의 좌표인 실수 x1, y1, x2, y2, x3, y3가 공백으로 구분되어 한 줄에 주어진다.
<출력값>
각각의 테스트에 대해 한 줄에 fx1, fy1, fx2, fy2, rl(fx1<=fx2, fx1=fx2이면 fy1<=fy2)을 공백으로 구분하여 소수 둘째 자리까지 반올림하여 출력한다. (fx1, fy1)과 (fx2, fy2)는 각각 타원의 초점이며, rl은 줄의 길이이다. 타원이 원일 경우 두 초점은 같다.

<문제 2711>
고창영은 맨날 오타를 낸다. 창영이가 오타를 낸 문장과 오타를 낸 위치가 주어졌을 때, 오타를 지운 문자열을 출력하는 프로그램을 작성하시오.
창영이는 오타를 반드시 1개만 낸다.
<입력값>
첫째 줄에 테스트 케이스의 개수 T(1<=T<=1,000)가 주어진다. 각 테스트 케이스는 한 줄로 구성되어 있다. 첫 숫자는 창영이가 오타를 낸 위치이고, 두 번째 문자열은 창영이가 친 문자열이다. 문자열의 가장 첫 문자는 1번째 문자이고, 문자열의 길이는 80을 넘지 않고, 대문자로만 이루어져 있다. 오타를 낸 위치는 문자열 길이보다 작거나 같다.
<출력값>
각 테스트 케이스에 대해 오타를 지운 문자열을 출력한다.

<문제 2712>
싸이가 강남 스타일로 2012년 10월 4일 현재 빌보드 핫100 차트 2위에 2주 연속 랭크되고 있다. 싸이는 곧 다시 미국으로 가서 해외 활동할 예정이라고 한다.
하지만 미국은 한국과 사용하는 단위 체계가 다르다. 한국은 미터법을 사용하지만, 미국은 미국 단위계를 사용한다. 싸이를 위해 단위를 바꾸어 주는 프로그램을 작성하시오.
아래 표를 참고해서 계산하면 되고, 킬로그램 <-> 파운드, 리터 <-> 갤런만 변환하면 된다.



종류
미터법
미국 단위계




무게
1.000 킬로그램
2.2046 파운드


 
0.4536 킬로그램
1.0000 파운드


부피
1.0000 리터
0.2642 갤런


 
3.7854 리터
1.0000 갤런
<입력값>
첫째 줄에 테스트 케이스의 개수 T(1<=T<=1,000)가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있다. 첫 번째 숫자는 값이고, 두 번째 등장하는 문자는 단위이다. 값은 소수일 수도 있고, 이 경우 소수점 아래 최대 넷째 자리까지 주어진다. 단위는 kg, lb, l, g 중 하나이며, 순서대로 킬로그램, 파운드, 리터, 갤런이다.
<출력값>
각 테스트 케이스에 대해서 바꾼 값과 단위를 출력한다. 값은 반올림해서 소수점 4째자리까지 출력한다. 단위는 kg, lb, l, g중 하나이며, 설명은 입력 설명에 있다.

<문제 2713>
규현이는 승환이에게 사랑을 담은 문자 메시지를 자주 보낸다. 이것을 남에게 보이기 싫었던 규현이는 승환이와 비밀 규칙을 만들었다.
규현이는 비밀 메시지를 만들기 위한 행렬의 행의 수 R과 열의 수 C를 정했다. 그 다음 다음과 같은 규칙으로 비밀 메시지를 만든다.

모든 글자는 알파벳 대문자와 공백으로 이루어져 있다.
글자는 다음과 같이 숫자로 바뀐다. 공백 = 0, A = 1, B = 2, ..., Y = 25, Z = 26

먼저 규현이는 문자를 위 규칙을 이용해 글자를 숫자로 바꾼 다음에 이것은 5자리 이진수로 바꾼다. 그 다음 아래 그림과 같이 소용돌이 패턴으로 행렬에 채운다. 행렬의 모든 칸을 채우지 못할 때는, 0으로 계속 채운다. 예를 들어 규현이가 보내려는 메시지가 "ACM"이고, R=4, C=4로 정했다면, 다음과 같이 행렬을 채우면 된다.

A = 00001, C = 00011, M = 01101, 모자라는 칸은 0으로 채운다.
그 다음 행렬을 행 우선으로 읽은 뒤 (Row Major Order)에 승환이에게 보낸다.
위의 예시를 메시지로 보낸다면 0000110100101100이 된다.
R, C, 규현이가 보내려고 하는 메시지가 주어졌을 때, 이를 승환이에게 보내는 비밀 메시지로 변환하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 테스트 케이스의 개수 T가 주어진다. (1 ≤ T ≤ 1,000) 각 테스트 케이스는 한 줄로 이루어져 있고, R, 공백, C, 공백, 규현이가 보내려고 하는 메시지로 이루어져 있다. (1 ≤ R,C ≤ 21) 메시지는 [A-Z]와 공백으로만 이루어져 있고, 이 길이는 항상 (R*C)/5보다 작거나 같다.
<출력값>
각 테스트 케이스에 대해 규현이가 문자로 보낼 비밀 메시지를 출력한다.

<문제 2714>
규현이는 승환이에게 사랑을 담은 문자 메시지를 자주 보낸다. 이것을 남에게 보이기 싫었던 규현이는 승환이와 비밀 규칙을 만들었다.
규현이는 비밀 메시지를 만들기 위한 행렬의 행의 수 R과 열의 수 C를 정했다. 그 다음 다음과 같은 규칙으로 비밀 메시지를 만든다.

모든 글자는 알파벳 대문자와 공백으로 이루어져 있다.
글자는 다음과 같이 숫자로 바뀐다. 공백 = 0, A = 1, B = 2, ..., Y = 25, Z = 26

먼저 규현이는 문자를 위 규칙을 이용해 글자를 숫자로 바꾼 다음에 이것은 5자리 이진수로 바꾼다. 그 다음 아래 그림과 같이 소용돌이 패턴으로 행렬에 채운다. 행렬의 모든 칸을 채우지 못할 때는, 0으로 계속 채운다. 예를 들어 규현이가 보내려는 메시지가 "ACM"이고, R=4, C=4로 정했다면, 다음과 같이 행렬을 채우면 된다.

A = 00001, C = 00011, M = 01101, 모자라는 칸은 0으로 채운다.
그 다음 행렬을 행 우선으로 읽은 뒤 (Row Major Order)에 승환이에게 보낸다.
위의 예시를 메시지로 보낸다면 0000110100101100이 된다.
승환이가 받은 비밀 메시지와 R과 C가 주어졌을 때, 이를 규현이가 보낸 문자 메시지로 변환하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 테스트 케이스의 개수 T가 주어진다. (1 ≤ T ≤ 1,000) 각 테스트 케이스는 한 줄로 이루어져 있고, R, 공백, C, 공백, 승환이가 받은 메시지로 이루어져 있다. (1 ≤ R, C ≤ 21) 메시지는 0과 1로만 이루어져 있고, 이 길이는 항상 R*C이다.
<출력값>
각 테스트 케이스에 대해 규현이가 보내려고 변환되기 전 문자 메시지를 출력한다. 이때, 원래 문자 메시지가 공백으로 끝난다면, 그 공백을 모두 제거한 뒤에 출력한다.

<문제 2715>
상범 마법 팬케이크 하우스의 요리사는 가끔씩 팬케이크를 만들다가 잠에 빠진다. 그래서 쌓아둔 팬케이크의 한쪽이 종종 타버린다. 명백하게 탄 팬케이크를 서빙하는 건 좋은 생각이 아니다. 서빙하기 전에 웨이트리스는 팬케이크 더미를 배치해서 타버린 쪽이 아래를 향하도록 할 것이다. 또, 가장 위에는 크기가 제일 작은 팬케이크를, 가장 아래에는 크기가 제일 큰 팬케이크를 놓아 크기 순으로 정렬을 하려고 한다. 웨이트리스를 도와 올바르게 팬케이크를 쌓는 프로그램을 작성하시오.

	우리는 한쪽면이 타버린 N개의 팬케이크 더미를 뒤집어야 한다. 우리가 위에서부터 k개의 팬케이크를 하나의 단위로 뒤집으면 맨 위에 있던 팬케이크는 k번째로 들어가고, k번째에 있던 팬케이크는 맨 위로 올라오게 된다.

	예를 들면 다음과 같다.(+는 바닥이 탄 것, -는 위가 탄 것, 숫자는 팬케이크의 크기)

	+1 -3 -2 [flip 2] => +3 -1 -2 [flip 1] => -3 -1 -2 [flip 3] => +2 +1 +3 [flip 1] => -2 +1 +3 [flip 2] => -1 +2 +3 [flip 1] => +1 +2 +3

	최대 3n-2 번의 뒤집기(flip)한 수열을 찾는 프로그램을 만들어야 한다.

	(수열의 처음과 마지막은 처음 주어진 상태와 아래가 모두 탄 팬케이크로 만든 상태가 된다)
<입력값>
첫 줄에 테스트 케이스의 수 N이 입력으로 들어온다. 다음 N줄에는 각각의 줄에 팬케이크 수 M, 과 팬케이크의 크기(1~M)이 섞인 순서로 +또는 -부호를 달고 한번씩 등장한다. (M ≤ 30)
<출력값>
각각의 케이스에 대해 한 줄씩 출력한다. 뒤집는 횟수 K(≥0), 한 번에 뒤집어야 하는 케이크 더미의 수 K개를 공백으로 구분하여 출력한다. 하나의 케이스에 대해 여러 개의 답이 존재할 수 있다. (예로 든 문제에서 3 2 3 또한 답이 될 수 있다.)

<문제 2716>
깊은 아마존 정글에 거대한 나무들에서 갈색 원숭이들이 매우 좋아하는 무화과가 열리고, 이 나무에는 향나무노린재들이 서식하고 있다.
나무 꼭대기에 도달하기 위해서 원숭이들은 매우 조심스럽게 나무에 올라가는 길을 찾아야한다. 거대한 나무는 부서지기 쉬운 덩굴들이 있는데 이 덩굴들은 시소의 원리와 비슷하다. 덩굴의 무게가 불균형 하면 그 덩굴은 끊어지며 그 원숭이들은 땅으로 떨어져버린다. 원숭이들은 서로 협력하여 덩굴의 균형을 유지한다면 그들은 모두 무화과가 열리고 향나무노린재들이 서식하는 나무 꼭대기에 도달할 수 있다는 것을 발견했다.
덩굴은 두개의 덩굴로 나눠질 수 있는데 덩굴이 끊어지지 않기 위해서는 나눠진 두 덩굴은 같은 수의 원숭이들이 매달려 있어야한다. 덩굴의 나눠지는 지점을 "[]"로 정의 내리면 덩굴의 구조를 꺾쇠괄호로 표시할 수 있다. 또한 덩굴의 깊이는 25를 넘지 않는다.

원숭이들은 덩굴의 균형을 유지하면서 나무꼭대기에 도달할 수 있는 최소 원숭이 수를 알고 싶다. 나무 꼭대기에 도달하기 위해서 최소 한 마리 원숭이가 필요하다.
<입력값>
첫째 줄에 테스트 케이스의 개수 N(1 ≤ N ≤ 1000)이 주어진다.
각 테스트 케이스는 한 줄로 이루어져 있고, 덩굴의 구조를 꺾쇠괄호로 표현한 문자열이 주어진다. 문자열의 길이는 0보다 크거나 같고, 150보다 작거나 같다.
<출력값>
각 테스트 케이스마다 덩굴의 균형을 유지하면서 나무꼭대기에 도달할 수 있는 최소 원숭이 수를 출력한다.

<문제 2717>
Just when you thought we had run out of model rocket height problems… 
Yet another method used to determine the height achieved by a model rocket is the vertical line method. Two observers A and B are spaced D feet apart along a base line along one edge of the flat test field. The launch platform is equidistant from observers A and B and L feet from the base line. Each observer has a theodolite or some other device for measuring angle above the horizontal (elevation angle) of a distant object and the azimuth angle (the angle the vertical plane of the sight line makes with the line from A through B measured counter-clockwise). Each measuring device is on a stand. A’s device is HA feet above the level of the launch platform and B’s device is HB feet above the level of the launch platform. When a rocket is fired, near the top of its flight, it deploys a parachute and emits a puff of smoke. Each observer measures the elevation angle and azimuth angle of the puff of smoke from their location. If the peak location is on the wrong side of the baseline or outside the lines determined by A and B perpendicular to the base line, it is out of bounds and disqualified. From this information, the height of the rocket may be determined as follows: 
Each sight line determines a vertical plane. These two planes intersect in a vertical line (thus the name of the method). Each sight line intersects this vertical line in a point. If these points are more than ERRDIST feet apart, an error is assumed and the flight is rejected. Otherwise, the point halfway between the two points where a sight line intersects the vertical line is computed. The rocket height is the distance of this midpoint above the launch platform. 
You must write a program which, given the parameters D (the distance in feet between observers A and B), L (the distance in feet from the base line to the launch platform), HA (the distance of the measuring device A above the launch platform in feet), HB (the distance of the measuring device B above the launch platform in feet), ERRDIST (the maximum distance between the intersection points of a sight line with the vertical line), α (the elevation angle of the rocket in degrees measured by the left observer A), β (the elevation angle of the rocket in degrees observed by the right observer B), γ(the azimuth angle in degrees measured by the left observer A) and δ (the azimuth angle in degrees measured by the right observer B), computes the height of the rocket above the launch platform in feet to the nearest foot.
<입력값>
The first line of input contains a single integer N, (1 ≤ N ≤ 1000) which is the number of datasets that follow. 
The second line contains the parameters D, L, HA, HB and ERRDIST in that order as (floating point) decimal values. These values would be measured once at the beginning of the day and remain fixed through all rocket shots. 
Each succeeding line of input represents a single dataset. Each dataset will contain the angles α, β, γ and δ in that order (measured in degrees) as (floating point) decimal values for a rocket shot.
<출력값>
For each dataset of four angles, the output consists of a single line . If angles α, β and γ are not strictly between 0 and 90 degrees or δ is not strictly between 90 degrees and 180 degrees, the line should contain the word “DISQUALIFIED” (without the quotes). Otherwise, if the distance between the intersection points of a sight line with the vertical line is more that ERRDIST feet, the line should contain the word “ERROR” (without the quotes). Otherwise, the line should contain the height above the launch platform in feet to the nearest foot.

<문제 2718>
4*N 크기의 타일을 2*1, 1*2 크기의 도미노로 완전히 채우려고 한다. 예를 들어 4*2 타일을 채우는 방법은 다음과 같이 5가지가 있다.

N이 주어졌을 때, 타일을 채우는 방법의 개수를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 테스트 케이스의 개수 T가 주어진다. T는 1,000보다 작거나 같은 자연수이다. 각 테스트 케이스는 정수 하나로 이루어져 있다. 이 정수는 문제에서 설명한 타일의 너비 N이다. N은 자연수이다.
N은 타일을 채우는 경우의 수가 2,147,483,647 이하이도록 주어진다.
<출력값>
각 테스트 케이스에 대해 4*N크기의 타일을 채우는 방법의 경우의 수를 출력한다.

<문제 2719>
Exupery Testing Corporation (ETC)는 많은 회사의 인사과에 다양한 시험을 공급하는데, 그중 한 시험에는 다음과 같은 공간지각력을 묻는 질문이 있다.

	다음 정육면체의 전개도를 다시 접었을 때, 다음 중 어는 모양이 되는가?





	안타깝게도, ETC는 최근 이런 문제 중 답이 없거나 답이 두 가지인 경우를 발견하게 되었다.

	ETC는 펼쳐진 정육면체와 코너 뷰(위의 보기와 같은)를 입력받아 이 코너 뷰가 정육면체의 모양과 일치하는지 결정하는 프로그램이 필요하다.

	ETC는 다음과 같은 이미지들을 정육면체의 면에 사용한다. 각 이미지는 세로 축에 대해 대칭이고, 끝 모양이 모두 다르다.



	정육면체의 전개도는 이미지와 끝 모양이 향하는 방향을 나타내는 6개의 쌍으로 이루어진다. 1은 위쪽, 2는 오른쪽, 3은 아래쪽, 4는 왼쪽 (오른쪽 그림 참고) 각 면들은 주어지는 순서에 따라, 왼쪽 그림과 같은 자리를 나타낸다.



	따라서 예로 주어진 문제의 전개도는 "F3E4E2D3C2F3"으로 나타낼 수 있다. ETC는 이런 문자열을 읽어서 전개도를 만드는 프로그램을 가지고있다.

	답지의 보기 이미지는 면의 이미지와 방향을 나타내는 3개의 쌍으로 이루어진다 (아래 그림 참고). 면들은 주어지는 순서에 따라 위, 오른쪽, 왼쪽을 나타내며 (그림의 [] 안 숫자 참고) 방향은 아래 그림의 숫자들을 참고하면 된다.



	예를 들어, 예로 주어진 문제의 보기들은 다음과 같이 나타낼 수 있다. "C2D2F2", "E3F4C4", "F2C2D2", "D1E1F3", "E1C1E1"
<입력값>
첫 번째 줄에는 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 여섯 개의 줄로 이루어진다. 첫 번째 줄에는 정육면체의 전개도가 주어지고, 다음 다섯 개의 줄에는 보기들이 주어진다.
<출력값>
각 테스트 케이스에 대해 두 가지를 공백을 사이에 두고 출력한다. 정답의 개수, 각 보기가 정답인지의 여부. (정답인 경우 Y, 아닌 경우 N. 예) 모두가 정답이라면 Y Y Y Y Y)

<문제 2720>
미국으로 유학간 동혁이는 세탁소를 운영하고 있다. 동혁이는 최근에 아르바이트로 고등학생 리암을 채용했다.
동혁이는 리암에게 실망했다.
리암은 거스름돈을 주는 것을 자꾸 실수한다.
심지어 \$0.5달러를 줘야하는 경우에 거스름돈으로 \$5달러를 주는것이다!
어쩔수 없이 뛰어난 코딩 실력을 발휘해 리암을 도와주는 프로그램을 작성하려고 하지만, 디아블로를 하느라 코딩할 시간이 없어서 이 문제를 읽고 있는 여러분이 대신 해주어야 한다.
거스름돈의 액수가 주어지면 리암이 줘야할 쿼터(Quarter, \$0.25)의 개수, 다임(Dime, \$0.10)의 개수, 니켈(Nickel, \$0.05)의 개수, 페니(Penny, \$0.01)의 개수를 구하는 프로그램을 작성하시오. 거스름돈은 항상 \$5.00 이하이고, 손님이 받는 동전의 개수를 최소로 하려고 한다. 예를 들어, \$1.24를 거슬러 주어야 한다면, 손님은 4쿼터, 2다임, 0니켈, 4페니를 받게 된다.
<입력값>
첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 거스름돈 C를 나타내는 정수 하나로 이루어져 있다. C의 단위는 센트이다. (1달러 = 100센트) (1<=C<=500)
<출력값>
각 테스트케이스에 대해 필요한 쿼터의 개수, 다임의 개수, 니켈의 개수, 페니의 개수를 공백으로 구분하여 출력한다.

<문제 2721>
n번째 삼각수, T(n)은 1부터 n까지의 합이다. T(n) = 1 + ... + n. 이것은 삼각형 모양으로 표현할 수 있다. 아래 그림은 T(4)를 나타낸 것이다.

다음과 같은 식을 통해 가중치를 부여한 삼각수의 합을 구할 수 있다.
W(n) = Sum[k=1..n; k*T(k+1)]
n이 주어졌을 때, W(n)을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 정수 n 하나로 이루어져 있다. (1<=n<=300)
<출력값>
각 테스트 케이스에 대해 W(n)을 한 줄에 하나씩 출력한다.

<문제 2722>
A common pastime for poker players at a poker table is to shuffle stacks of chips. Shuffling chips is performed by starting with two stacks of poker chips, S1 and S2, each stack containing C chips. Each stack may contain chips of several different colors. 
The actual shuffle operation is performed by interleaving a chip from S1 with a chip from S2 as shown below for C=5: 

The single resultant stack, S12, contains 2*C chips. The bottommost chip of S12 is the bottommost chip from S2. On top of that chip, is the bottommost chip from S1. The interleaving process continues taking the 2nd chip from the bottom of S2 and placing that on S12, followed by the 2nd chip from the bottom of S1 and so on until the topmost chip from S1 is placed on top of S12. 
After the shuffle operation, S12 is split into 2 new stacks by taking the bottommost C chips from S12 to form a new S1 and the topmost C chips from S12 to form a new S2. The shuffle operation may then be repeated to form a new S12. 
For this problem, you will write a program to determine if a particular resultant stack S12 can be formed by shuffling two stacks some number of times.
<입력값>
The first line of input contains a single integer N, (1 ≤ N ≤ 1000) which is the number of datasets that follow. 
Each dataset consists of four lines of input. The first line of a dataset specifies an integer C, (1 ≤ C ≤ 100) which is the number of chips in each initial stack (S1 and S2). The second line of each dataset specifies the colors of each of the C chips in stack S1, starting with the bottommost chip. The third line of each dataset specifies the colors of each of the C chips in stack S2 starting with the bottommost chip. Colors are expressed as a single uppercase letter (A through H). There are no blanks or separators between the chip colors. The fourth line of each dataset contains 2*C uppercase letters, (A through H), representing the colors of the desired result of the shuffling of S1 and S2 zero or more times. The bottommost chip’s color is specified first.
<출력값>
Output for each dataset consists of a single line that displays an integer value which is the minimum number of shuffle operations required to get the desired resultant stack. If the desired result can not be reached using the input for the dataset, display the value negative 1 (-1) for the number of shuffle operations.

<문제 2723>
한국 최고의 자물쇠 회사 마선영은 도어락을 생산한다. 이 도어락은 B(1 ≤ B ≤ 11)개의 버튼으로 이루어졌으며 각 버튼은 '1'부터 'B'까지 이름 붙여 있다. 도어락은 버튼 조합으로 이뤄진 비밀번호를 올바른 순서로 누른 후 손잡이를 돌리면 마법처럼-_- 열린다

	버튼 조합은 한 개 이상의 버튼을 동시에 누르는 것이다. 비밀번호는 최소 한 개 이상의 이러한 버튼 조합들로 이뤄져 있다. 어떤 버튼을 한 조합에서 사용하면, 다른 조합에서는 사용할 수 없다. 아래는 B=8인 예이다.

	(1-2-3)(4)(7-8)

	위는 (1-2-3), (4), (7-8)의 조합 세 개로 이뤄진 올바른 비밀번호이다. 버튼 5와 6은 이 비밀번호에 사용하지 않았다.

	(1-2-3)(2-4)(5-6)

	위는 버튼 2가 조합 (1-2-3)과 (2-4)에 두 번 나왔기 때문에 올바른 비밀번호가 아니다.

	마선영의 CEO인 김선영은 정선영에게 B개의 버튼이 있을 때, 가능한 비밀번호의 수를 구하는 프로그램을 작성해 달라고 부탁했다. 프로그램은 고객의 도어락 리스트를 받아 주문 번호와 B값, 가능한 비밀번호 수를 출력해야 한다. 도어락 리스트는 최소 한 개, 최대 백 개의 도어락을 포함하고 있다.

	정선영이 만들어야 하는 프로그램을 우리가 대신 만들어보자.
<입력값>
첫 줄은 도어락 개수인 정수 N(1 ≤ N ≤ 100)이 주어진다. 다음 줄부터 N개의 도어락 버튼의 개수 B가 주어진다.
<출력값>
각각의 도어락마다 가능한 비밀번호의 개수를 한 줄에 하나씩 출력한다.

<문제 2724>
NTCIP(National Transportation Communications for ITS Protocol)는 고속 통신을 하기 위해 메시지를 MULTI(Markup Language for Transportation Information)을 사용한다. MULTI 문자열은 텍스트의 포맷 등을 묘사하는 내장된 태그와 함께 구성되어있다. 태그는 '[',']'로 열고 닫으며, 문자에 '['를 사용하기 위해서는 '[['를 이용하여 표시한다. (닫는 괄호도 마찬가지로 ']]') 각 문자는 배열의 한 칸씩 차지한다.
다음은 태그와 설명이다.



태그
설명




[nl]
새로운 행을 시작한다.


[sc<digit>]
각 문자마다 <digit>개의 공백을 추가한다.


[/sc]
[sc0]과 같다. 공백을 추가하지 않는다.


[jl2]
왼쪽 정렬(left justified text), 첫 번째 문자가 줄의 제일 왼쪽에 등장한다.


[jl3]
가운데 정렬(center justified text), 양쪽 공백의 수가 같거나 뒤쪽 공백의 수가 하나 더 많도록 한다.


[jl4]
오른쪽 정렬(right justified text), 마지막 문자가 줄의 가장 마지막에 등장한다.


[jl5]
양쪽 정렬(줄에 가득차도록 각 문자 사이 공백을 일정하게 최대로 많이 추가한다. 가운데 정렬한다.)



한 줄에 24글자가 있을 때의 예이다. (□는 빈 칸을 나타낸다)



MULTI 문자열
출력




[jl2]MESSAGE
MESSAGE□□□□□□□□□□□□□□□□□


[jl3]MESSAGE
□□□□□□□□MESSAGE□□□□□□□□


[jl4]MESSAGE
□□□□□□□□□□□□□□□□□MESSAGE


[jl2][sc2]MESSAGE
M□□E□□S□□S□□A□□G□□E□□□□□


[jl5]MESSAGE
□□M□□E□□S□□S□□A□□G□□E□□□


[jl2]THIS[jl3]IS A[jl4]MESSAGE
THIS□□□□□□IS A□□□MESSAGE



태그는 대소문자를 구분하지 않는다. [nl]=[NL]=[Nl]=[nL]
기본은 왼쪽 정렬, 공백숫자는 0이다.
정렬과 공백추가 태그는 [nl]태그 다음에도 유지된다.
[jl2]와 [l5] 태그는 줄에 다른 문자가 출력되지 않았을 때만 사용할 수 있다. 그렇지 않으면 에러 (TAG CONFLICT)
[jl5]가 사용되면, 다른 정렬 태그는 사용할 수 없다. 그렇지 않으면 에러 (TAG CONFLICT)
[jl3] 태그는 [jl4] 태그 다음에 사용할 수 없다. (TAG CONFLICT)
[jl?] 태그는 같은 정렬을 또 사용하더라도 TAG CONFLICT가 일어나지 않는다.
양쪽 정렬에서는 [sc]태그가 무시된다.
한 줄에 너무 많은 문자가 필요하거나 메시지에 너무 많은 줄이 필요하면 TOO BIG 에러가 발생한다.
[nl]태그는 다음 문자가 출력되기 전까지 작동하지 않는다.
왼쪽 정렬과 가운데 정렬이 한 줄에 동시에 등장하면, 왼쪽 정렬된 문자의 맨 뒤에 적어도 하나의 공백이 있어야 한다. 그렇지 않을 경우 TOO BIG 에러가 발생한다.
가운데 정렬과 오른쪽 정렬이 한 줄에 동시에 등장하면, 가운데 정렬된 문자의 맨 뒤에 적어도 하나의 공백이 있어야 한다. 그렇지 않을 경우 TOO BIG 에러가 발생한다.
왼쪽 정렬과 오른쪽 정렬이 한 줄에 동시에 등장하면, 왼쪽 정렬된 문자의 맨 뒤에 적어도 하나의 공백이 있어야 한다. 그렇지 않을 경우 TOO BIG 에러가 발생한다.
허용되는 태그는 위의 7개만 가능하다. 그렇지 않으면 BAD TAG 에러가 발생한다.
잘못된 태그 사용이나 괄호 쌍이 맞지 않은 경우도 BAD TAG 에러가 발생한다.
MULTI 문자열을 입력받아서 올바른 메시지 또는 에러 메시지를 출력하는 프로그램을 작성하시오
<입력값>
첫째 줄은 데이터 세트의 수 N(1 ≤ N ≤ 100)이 입력으로 들어온다.각 데이터 세트의 첫 줄은 R(1 ≤ R ≤ 25)과 C(1 ≤ C ≤ 80)가 공백으로 구분되어 들어온다. (R은 행 수, C는 열 수) 다음 R개의 줄에 MULTI 문자열이 들어온다.
<출력값>
각 데이터 세트에 대해 데이터 세트 번호를 출력하고, 다음줄부터 R개의 줄에 에러 메시지 또는 메시지를 출력한다. (C개의 문자열을 정확히 출력해야 한다) 각 데이터 세트의 마지막 줄은 공백으로 구분한다. (채점의 편의를 위해, 에러가 있는 데이터 세트는 한 가지 타입의 에러만 가지고 있다)

<문제 2725>
(0,0)에서 보이는 (x,y)의 개수를 구하려고 한다.(x,y >= 0, 정수)

	(0,0)에서 (x,y)가 보이려면 (0,0)과 (x,y)를 연결하는 직선이 다른 점을 통과하지 않아야 한다. 예를 들어 (4,2)는 (0,0)에서 보이지 않는다. 그 이유는 (0,0)과 (4,2)를 연결하는 직선이 (2,1)을 통과하기 때문이다. 아래 그림은 0 <= x,y<=5인 경우에 (0,0)에서 보이는 점의 개수이다. 단, (0,0)은 계산하지 않는다.



	N이 주어졌을 때, 원점에서 보이는 (x,y) 좌표의 개수를 출력하시오. (0 <= x,y <= N)
<입력값>
첫째 줄에 테스트 케이스의 개수 C(1<=C<=1,000)가 주어진다. 각 테스트 케이스는 자연수 N(1<=N<=1,000) 하나로 이루어져 있고, 한 줄에 하나씩 주어진다.
<출력값>
각 테스트 케이스에 대해 한 줄에 하나씩 (0,0)에서 보이는 점(x,y)의 개수를 출력한다.

<문제 2726>
한 변에 N칸이 있는 삼각형 모양의 체스판이 있다. 이 체스판에서 퀸은 변과 평행하면서 퀸을 포함하는 줄의 모든 칸을 공격할 수 있다. 예를 들어, 아래 그림에서 검정색 칸이 퀸일때, 퀸이 공격할 수 있는 칸을 표시해 놓은 것이다.



	삼각 N-Queen 문제는 한 변에 N칸이 있는 삼각형 체스판에서 퀸을 서로 공격할 수 없게 최대한 배치하는 것이다. 아래 그림은 N=6일때, 퀸을 서로 공격할 수 없게 최대한 배치한 것이다.



	삼각형 한 변의 칸의 수가 N이면, 항상 floor((2*N+1)/3)개의 퀸을 서로 공격할 수 없게 배치할 수 있다.

	N이 주어졌을 때, 삼각 N-Queen문제를 푸는 프로그램을 작성하시오.
<입력값>
첫째 줄에 테스트 케이스의 개수 C(1 ≤ C ≤ 1000)가 주어진다. 각 테스트 케이스는 N(1 ≤ N ≤ 1000)을 포함하고 있으며, 한 줄로 이루어져 있다.
<출력값>
각 테스트 케이스에 대해서, 첫 줄에 놓을 수 있는 퀸의 최대 개수를 출력한다. 둘째 줄부터 N개의 줄에는 퀸의 위치를 출력한다. 제일 윗 줄의 번호는 1이고, 그 줄의 가장 왼쪽 칸의 번호는 1이다. 위치는 줄 번호와 열 번호를 공백으로 구분해서 한 줄에 하나씩 출력하면 된다. 가능한 배치가 여러 가지인 경우에는 아무거나 출력하면 된다.

<문제 2727>
모든 자연수 N은 (2a)(3b)의 합으로 나타낼 수 있다. 이때, 서로 약수/배수 관계인 두 항이 있어서는 안 된다.

1 = (20)(30)
7 = (22)(30) + (20)(31)
31 = (24)(30) + (20)(32) + (21)(31) = (22)(30) + (20)(33)

N이 주어졌을 때, 이를 (2a)(3b)의 합으로 나타내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 테스트 케이스의 개수 T(1 ≤ T ≤ 1,000)가 주어진다. 각 테스트 케이스는 한줄로 이루어져 있고, 정수 N이 주어진다. (1 ≤ N < 231)
<출력값>
각 테스트 케이스에 대해 첫째 줄에는 항의 개수 M을 출력한다. 그다음 M개의 줄에 걸쳐 합을 구성하는 항을 출력한다. 어떤 항이 (2a)(3b)일때, a b를 공백으로 구분하여 출력하면 된다.

<문제 2728>
청계천 근처에 사는 사람들의 주된 주말 취미는 청계천을 산책하면서 마가리타를 마시는 것이다. 청계천은 사람들이 사는 아파트(청계천엔 아파트가 하나)에서 시작해서 규현치킨에서 끝난다. 마가리타는 이 청계천을 따라 걷는 중에 보이는 가판대에서 살 수 있다.
마가리타의 가격은 재료의 양과 품질, 그리고 가판대의 분위기에 따라서 다르다. 마침 오늘 승환이가 청계천 근처로 이사왔고, 이 취미를 한 번 따라해 보려고 한다. 오늘은 승환이가 이사온 날이기 때문에, 서로 다른 마가리타의 맛을 느껴보려고 한다.
각 가판대에서 파는 마가리타 한 잔의 가격이 주어졌을 때, 승환이가 맛을 느낄 수 있는 서로 다른 마가리타의 조합이 몇 개나 되는지 계산해보려고 한다. 
승환이는 각각의 가판대에서 마가리타를 많아야 한 잔만 살 수있다. 그리고, 승환이가 쓴 돈은 자신이 가지고 있는 돈의 양을 넘을 수 없고, 남은 돈으로는 구매하지 않은 그 어떤 마가리타도 살 수 없어야 한다. 
예를 들어, 승환이가 지금 25만원을 가지고 있고, 각각의 가판대에서 파는 마가리타 한 잔의 가격이 다음과 같다고 하자.

A: 8만원
B: 9만원
C: 8만원
D: 7만원
H: 16만원
J: 5만원

위의 조건을 만족하면서, 승환이가 맛을 느낄 수 있는 마가리타의 조합은 다음과 같다.
ABC(25), ABD(24), ABJ(22), ACD(23), ACJ(21), ADJ( 20), AH(24), BCD(24), BCJ(22), BDJ(21), BH(25), CDJ(20), CH(24), DH(23), HJ(21)
따라서, 승환이가 맛을 볼 수 있는 마가리타의 조합은 총 15가지이다.
<입력값>
첫째 줄에 테스트 케이스의 개수 T(1<=T<=1,000)가 주어진다. 각 테스트 케이스는 두 줄로 이루어져 있다. 첫째 줄에는 가판대의 개수 V(1<=V<=30)와 승환이가 가지고 있는 돈의 양 D(1<=D<=1,000)가 주어진다. 두 값은 공백으로 구분되어 있다. 둘째 줄에는 각 가판대에서 파는 마가리타 한 잔의 가격이 주어진다. 마가리타의 비용은 항상 1보다 크다.
문제에서 주어지는 돈의 양은 모두 만원 단위이다. 따라서, 승환이가 가지고 있는 돈이 10이라면, 이는 10만원이다. 또, 마가리타 한 잔의 가격이 2라면, 2만원과 같다.
<출력값>
각 테스트 케이스에 대해, 승환이가 맛 볼 수 있는 마가리타 조합의 개수를 출력한다. 입력은 결과 값이 항상 32 bit unsigned integer로 표현될 수 있도록 주어진다.

<문제 2729>
이진수 덧셈은 매우 간단하고, 십진수 덧셈과 비슷하게 하면 된다. 십진수 덧셈을 할 때는, 오른쪽부터 왼쪽으로 차례대로 숫자 하나씩 더하면 된다. 이진수 덧셈도 이와 비슷하게 하면 된다. 십진수 덧셈은 외워야 할 덧셈이 많지만, 이진수 덧셈은 아래와 같이 5가지만 기억하면 된다.

0 + 0 = 0
1 + 0 = 1
0 + 1 = 1
1 + 1 = 10
1 + 1 + 1 = 11

두 이진수가 주어졌을 때, 그 합을 이진수로 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 테스트 케이스의 수 T(1<=T<=1,000)가 주어진다. 각 테스트 케이스는 숫자 2개로 이루어져있다. 이 숫자는 0과 1로만 이루어진 이진수이며, 길이는 최대 80자리이다. (덧셈 결과는 81자리가 될 수도 있다) 이진수는 0으로 시작할 수도 있다.
<출력값>
각 테스트 케이스에 대해 입력으로 주어진 두 이진수의 합을 구해 이진수로 출력한다. 숫자의 앞에 불필요한 0이 붙으면 안 된다.

<문제 2730>
택희는 OS조교이다. 이번 숙제는 간단히 pintos가 동작하는 화면을 캡쳐한 다음에, 이를 프린트해서 제출하는 것이다. 학생들은 보고서에 자기 학번, 이름과 제출한 날짜를 간단하게 써서 내면 된다. 어차피 올해가 몇 년인지는 모두가 알고 있기 때문에, 월/일만 적어서 내면 된다. 예를 들어, 09/20/2005 (2005년 9월 20일)이라고 쓰는 대신에 9/20이라고 쓰면 된다.
일단 채점하기 전에 과거 채점 기준을 확인하기 위해서 예전에 사람들이 냈던 보고서와 점수를 확인하고 있었다. 그런데... 올해 숙제와 예전 숙제가 섞이고 말았다. 학생들이 보고서에 연도를 쓰지 않았고, 보고서에 채점 결과를 써놓지 않았기 때문에, 보고서만 가지고는 언제 숙제인지 알수가 없게 되었다. 게다가 숙제 마감일은 매년 같다.
따라서 택희는 제출일과 숙제 마감일을 가지고 채점을 해야할지 말아야할지 결정하려고 한다.
숙제 마감일과 각 학생이 제출한 날짜가 주어졌을 때, 이것을 채점해야할지 말아야할지, 결정하는 프로그램을 작성하시오. 출력에 대한 설명은 출력 설명에 자세히 나와있다.
<입력값>
첫째 줄에 테스트 케이스의 개수 T가 주어진다. 둘째 줄부터 T개의 줄에는 각 테스트 케이스의 정보가 주어진다. 테스트 케이스의 정보는 날짜 2개로 이루어져 있다. 첫 번째 날짜는 숙제 마감일이고, 두 번째 날짜는 보고서에 적힌 날짜이다. 숙제 마감일은 월/일/연 형식이다. 숙제마감일은 2000년이상, 2200년 이하이고, 올바른 날짜만 주어진다.  보고서에 적힌 날짜는 월/일 형식이고, 이 날짜도 올바른 날짜만 주어진다.
<출력값>
각 테스트 케이스에 대해서 다음과 같이 출력한다.
m/d/y IS n DAY(S) PRIOR: 보고서에 적힌 날짜가 숙제 마감일보다 7일전 이내 일 때 (같을 때는 제외)
m/d/y IS n DAY(S) AFTER: 보고서에 적힌 날짜가 숙제 마감일보다 7일후 이내 일 때 (같을 때는 제외)
SAME DAY: 보고서에 적힌 날짜와 숙제 마감일이 같을 때
OUT OF RANGE: 보고서에 적힌 날짜가 숙제 마감일보다 7일 후 또는 7일 전 안에 있지 않을 때
m/d/y는 월/일/연이고, y는 1999년 보다 크거나 같고, 2201년 보다 작거나 같다. 이때, 숙제 마감일은 매년 같기 때문에, y가 같은 필요는 없다.

<문제 2731>
1, 3, 7, 9로 끝나는 숫자 S가 주어진다. 이때, 세제곱했을 때, S로 끝나는 수가 반드시 존재한다.

	예를들어, S가 123이면, 947을 세제곱하면 849278123이 되고, 이 수는 123으로 끝난다.

	S가 주어졌을 때, 세제곱했을 때 S로 끝나는 숫자를 찾아 출력하는 프로그램을 작성하시오. 이때 x의 길이는 S의 길이보다 작거나 같아야 한다.
<입력값>
첫째 줄에 테스트 케이스의 개수 T가 주어진다. 둘째 줄 부터 T개 줄에는 테스트 케이스의 정보가 주어진다. 각 테스트 케이스는 숫자 하나로 이루어져 있고, 이 수는 문제에서 설명한 S이다. S는 1, 3, 7, 9로 끝나며, 최대 10자리이다.
<출력값>
각 테스트 케이스에 대해 한 줄에 하나씩 세제곱햇을 때 S가 되는 수 x를 출력한다.

<문제 2732>
The WeeOnes Kindergarten has a strange ceremony as part of its graduation: The children line up with the girls on the left and the boys on the right with a single space between the boys and the girls. By making a sequence of the following four moves, the children are to end up with all the boys on the left and all the girls on the right with a single space between the boys and the girls. 



Move
Operation




Slide left (s)
The child to the right of the empty space moves into the empty space.


Slide right (S)
The child to the left of the empty space moves into the empty space.


Hop left (h)
The child two spaces to the right of the open space leapfrogs over the intervening child to the open space.


Hop right (H)
The child two spaces to the left of the open space leapfrogs over the intervening child to the open space.



In each case, the previous position of the child who moved becomes the new open space. 
For example, with two girls and two boys we begin with: 
GG_BB 
the following moves give the desired result: 

s: GGB_B 
H: G_BGB 
S: _GBGB 
h: BG_GB 
h: BGBG_ 
S: BGB_G 
H: B_BGG 
s: BB_GG 

The teacher would like this process to end in a reasonable amount of time so the parents can go home (the children are probably willing to do this all day). Write a program which takes as input the numbers of girls and boys (nGirls and nBoys respectively) and finds a sequence of at most (nGirls * nBoys + nGirls + nBoys) moves which takes you from the starting position to the ending position. [Each girl must leapfrog over (or be leapfrogged over by) each boy and, on average, each child must move past the empty space.]
<입력값>
The input begins with the number of problems N, (1 <= N <= 1000), on a line by itself followed by N problem instances each on its own line. A problem instance has the form: 
nGirls nBoys 
where 

nGirls is the number of girls. 
nBoys is the number of boys.

There is at least 1 child and at most 24 children in a class.
<출력값>
For each problem instance, output the number of moves on a line. On following line, output the codes for the required moves in order.

<문제 2733>
Brainfuck은 Urban Müller가 1993년에 만든 프로그래밍 언어이다. 그의 목적은 역사상 가장 작은 튜링 완전 언어(Turing -complete language)의 컴파일러를 만드는 것이었다.위키백과에는 다음과 같은 설명이 적혀져 있다. (designed to challenge and amuse programmers, and was not made to be suitable for practical use)
이 언어는 0으로 초기화 된 크기가 32768바이트인 바이트 배열, 배열의 맨 첫 바이트를 가리키는 포인터를 가지고 있다.
다음과 같이 7가지 명령어를 가지고 있으며, 각 명령어는 문자 1글자이다. (원래 8가지 명령어를 가지고 있지만, 문제를 위해 하나를 지웠다)

>: 포인터를 증가시킨다. 만약, 포인터 값이 32767이면 0이된다.
<: 포인터를 감소시킨다. 만약, 포인터 값이 0이면 32767이 된다.
+: 포인터가 가리키는 값을 증가시킨다. 255를 증가시키면 0이 된다.
-: 포인터가 가리키는 값을 감소시킨다. 0을 감소시키면 255가 된다.
.: 포인터가 가리키는 값을 ASCII문자로 출력한다.
[: 포인터가 가리키는 값이 0이면, 짝이 되는 뒤쪽의 ]로 이동한다.
]: 포인터가 가리키는 값이 0이 아니면, 짝이되는 앞쪽의 [로 이동한다.

Brainfuck 프로그램이 주어졌을 때, 이 프로그램의 출력을 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 프로그램의 개수 T(1 ≤ T ≤ 100)가 주어진다. 각 프로그램은 한줄 또는 그 이상으로 구성되어 있으며, end만 적혀있는 줄로 끝난다. 프로그램에 올바르지 않은 문자 (<>+-.[])가 있다면, 이는 무시하고 넘어가야 한다. %는 주석을 의미하며, %가 나온 뒤에 나오는 해당 줄의 문자는 모두 무시한다. 프로그램의 최대 명령어 개수는 128,000이다.
<출력값>
각 프로그램의 결과를 다음과 같이 출력한다. 첫째 줄에 PROGRAM #n을 출력한다. n은 프로그램 번호이다. (첫 번째 프로그램부터 차례대로 1이고, 1 ≤ n ≤ N이다). 둘째 줄에는 프로그램의 결과를 출력한다. 만약 [나 ]가 짝이 맞지 않을 대는 COMPILE ERROR를 출력하면 된다. 출력에서 여러 줄을 출력할 수도 있다.

<문제 2734>
드럼통을 직사각형 쓰레기통에 예쁘게 쌓아보려고 한다. 아랫줄을 제외한 모든 실린더는 항상 자기 바로 아랫줄의 실린더 2개와 닿아있다. 가장 밑 줄의 실린더는 쓰레기통 벽에 닿아있기 때문에, 더이상 굴러가지 않는다. 마지막줄을 제외한 모든 줄은 자기 아랫줄의 드럼통 개수보다 하나 적은 드럼통이 있다.
드럼통의 반지름은 항상 1이다.

가장 위에 있는 실린더의 중심 좌표를 구하는 프로그램을 작성하시오. 값을 계산할 때, double을 사용하면 된다.
<입력값>
첫째 줄에 테스트 케이스의 개수 T(T<=1,000)가 주어진다. 각 테스트 케이스는 한 줄로 구성되어 있다. 첫 번째 숫자는 드럼통의 개수 N이 주어진다. 이어서 들어오는 N개의 숫자는 각 드럼통의 중심 x좌표이다. (드럼통의 바닥과 접하므로 y좌표는 항상 1이다). N은 1보다 크거나 같고, 10보다 작거나 같다. 
인접한 두 드럼통의 중심거리는 적어도 2.0이고, 많아야 3.4이다. (2.0인 이유는 드럼통이 겹치지 않기 위해서, 3.4인 이유는 k줄에 있는 드럼통과 k-2줄에 있는 드럼통이 서로 접하지 않게 하기 위해서)
<출력값>
각 테스트 케이스에 대해 한 줄에 하나씩 가장 위에 있는 드럼통의 중심좌표를 공백으로 구분하여 x좌표와 y좌표 순서대로 소수점 4자리까지 출력한다.

<문제 2735>
The recent Texas Hold’em craze has spawned a bunch of on-line Poker sites. These sites tend to breed a group of poor players whose primary strategy is to never fold or throw away a hand. These players will always play and bet on every card on every hand – no matter what the cost or what cards they have. You have decided to take advantage of these stupid players by developing your own poker site that allows you to always beat these players. 
The way your site will work is: there are only two players in each game: you and your opponent (this is called a heads-up game). Each of the two players will get two “hole cards”; these cards are dealt face down so, presumably, only the player can see them. Four of the five community cards (cards shared by both players) will be dealt face up on the table. We will dispense with any betting for the purpose of this problem: it is irrelevant since each player will always call every bet right to the “river” (the fifth and final community card). You will always be seated at position 1, and your opponent at position 2. The program knows what seat you are sitting at and the hole cards for both players, therefore, it can compute all the cards that remain in the deck that will maximize the amount of money you would get playing the hand – folding is not an option. In the event there is no card that would allow you to win or tie the hand, you will be forced to take a loss on that hand (after all, it looks good if you lose sometimes).
<입력값>
The first line of input contains an integer N which is the number of data sets that follow (1 <= N <= 100). Each data set consists of three lines. The first line of each dataset specifies your two hole cards. The second line is your opponent’s hole cards. The third line is the four community cards. A card is specified by two characters: it’s rank (A,2,3,4,5,6,7,8,9,T,J,Q,K) and it’s suit (S,D,H,C) for Spades, Diamonds, Hearts, and Clubs respectively. For example, the Ace of Hearts would be AH, the Nine of Spades would be 9S. Within a line, there are no spaces or invalid characters. All input will be valid.
<출력값>
For each data set, your program will output (on a new line) the data set number followed by a colon, followed by a space, and a list of card(s) that will maximize the amount of money you could get playing the hand. If no card will allow you to win or tie, just display “LOSER” instead of the cards. Each card should be separated by a single space. Your program will display up to 15 cards on each output line. If more than one output line is required for a dataset, additional lines should be indented by exactly 3 spaces. Cards should be output in suit order (S,D,H,C) and rank order within each suit (Ace high).

<문제 2736>
모델 로켓으로 높이를 측정하는 방법중에 하나로 geodesic 이라는 방법이 있다. 두 관측자 A와 B가 기준선으로부터 100미터 떨어져있는 평평한 실험 구역위의 각 꼭짓점에 서 있는다. 로켓이 발사되는 발사대는 관측자 A와 B로부터 같은 거리만큼 떨어져 있고 기준선으로부터 50미터 떨어져 있다. 각각의 관측자는 경위의(theodolite, 각도를 정밀하게 측정할수 있는 기계)또는 다른 장비를 갖고 있는데, 이 장치들은 떨어져 있는 물체의 앙각(대상을 보는 관측자의 시선이 수평면과 이루는 각)과 방위각(지평선에 따라 측정한 천체의 방향을 나타내는 각/여기서는 수평의 시선을 포함하는 수직면과 A, B를 지나는 선사이의 각도를 반시계방향으로 측정한 것)을 잰다. A의 장비는 발사대보다 HA미터만큼 위에 있고, B의 HB미터만큼 위에 있다. 로켓은 발사된 후, 가장 높게 올라간 이후에 낙하산을 펼치며 많은 양의 연기를 방출한다. 각각의 관측자들은 그들의 위치에서 로켓이 내보낸 연기의 앙각과 방위각을 측정한다.  만약 로켓이 최고로 다다른 위치가 기준선과는 다른 쪽이거나 A와 B가 판단할때 그 위치가 기준선과 수직인 선에서 벗어난 곳이라면 그 측정은 가치가 없다.

	이 정보를 바탕으로 로켓의 높이는 다음과 같이 측정한다.

	각각의 시선위에서, 다른 시선과 가장 가까운 지점을 시선위에서 찾아라. 이렇게 찾아진 두 점의 절반에 위치한 점이 로켓이 가장 최고 높이로 올라간 곳이라고 추정한다. 측정되어진 로켓은 발사대와 구한 점 사이의 수직거리다. 

	HA(발사대 위에 있는 측정 장치 A의 거리)와 HB(발사대 위에 있는 측정 장치 B의 거리), 알파(왼쪽 관측자 A로 부터 측정된 앙각), 베타(오른쪽 관측자 B로부터 측정된 앙각), 감마(왼쪽 측정자 A로부터 측정된 방위각), 델타(오른쪽 측정자 B로부터 측정된 방위각)로부터 로켓의 높이를 측정하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 발사의 수 N(1 <= N <= 100), HA, HB가 주어진다. 이 숫자는 모두 실수이다. 둘째 줄부터 N개의 줄은 매번 발사할 때 마다 측정한 알파, 베타, 감마, 델타가 주어진다. 알파, 베타, 감마의 값은 0 ~ 90도 사이이고, 델타는 90 - 180도 사이이다.
<출력값>
각각의 발사에 대해서, 로켓이 가장 높게 올라간 높이를 출력한다.

<문제 2737>
대부분의 양의 정수는 적어도 2개 이상의 연속된 자연수의 합으로 나타낼 수 있다.

	예를 들면 다음과 같다.

	6 = 1 + 2 + 3

	9 = 5 + 4 = 4 + 3 + 2

	하지만, 8은 연속된 자연수 합으로 나타낼 수가 없다.

	자연수 N이 주어졌을 때, 이 수를 적어도 2개 이상의 연속된 자연수의 합으로 나타낼 수 있는 경우의 수를 출력하시오.
<입력값>
첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 정수 하나로 이루어져 있다. 이 정수는 문제에서 설명한 N이며, 2^31보다 작다.
<출력값>
각 테스트 케이스에 대해서 N을 적어도 2개 이상의 연속된 자연수의 합으로 나타내는 경우의 수를 출력한다.

<문제 2738>
N*M크기의 두 행렬 A와 B가 주어졌을 때, 두 행렬을 더하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 행렬의 크기 N 과 M이 주어진다. 둘째 줄부터 N개의 줄에 행렬 A의 원소 M개가 차례대로 주어진다. 이어서 N개의 줄에 행렬 B의 원소 M개가 차례대로 주어진다. N과 M은 100보다 작거나 같고, 행렬의 원소는 절댓값이 100보다 작거나 같은 정수이다.
<출력값>
첫째 줄부터 N개의 줄에 행렬 A와 B를 더한 행렬을 출력한다. 행렬의 각 원소는 공백으로 구분한다.

<문제 2739>
N을 입력받은 뒤, 구구단 N단을 출력하는 프로그램을 작성하시오. 출력 형식에 맞춰서 출력하면 된다.
<입력값>
첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 9보다 작거나 같다.
<출력값>
출력형식과 같게 N*1부터 N*9까지 출력한다.

<문제 2740>
N*M크기의 행렬 A와 M*K크기의 행렬 B가 주어졌을 때, 두 행렬을 곱하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 행렬 A의 크기 N 과 M이 주어진다. 둘째 줄부터 N개의 줄에 행렬 A의 원소 M개가 순서대로 주어진다. 그 다음 줄에는 행렬 B의 크기 M과 K가 주어진다. 이어서 M개의 줄에 행렬 B의 원소 K개가 차례대로 주어진다. N과 M, 그리고 K는 100보다 작거나 같고, 행렬의 원소는 절댓값이 100보다 작거나 같은 정수이다.
<출력값>
첫째 줄부터 N개의 줄에 행렬 A와 B를 곱한 행렬을 출력한다. 행렬의 각 원소는 공백으로 구분한다.

<문제 2741>
자연수 N이 주어졌을 때, 1부터 N까지 한 줄에 하나씩 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 100,000보다 작거나 같은 자연수 N이 주어진다.
<출력값>
첫째 줄부터 N번째 줄 까지 차례대로 출력한다.

<문제 2742>
자연수 N이 주어졌을 때, N부터 1까지 한 줄에 하나씩 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 100,000보다 작거나 같은 자연수 N이 주어진다.
<출력값>
첫째 줄부터 N번째 줄 까지 차례대로 출력한다.

<문제 2743>
알파벳으로만 이루어진 단어를 입력받아, 그 길이를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 영어 소문자와 대문자로만 이루어진 단어가 주어진다. 단어의 길이는 최대 100이다.
<출력값>
첫째 줄에 입력으로 주어진 단어의 길이를 출력한다.

<문제 2744>
영어 소문자와 대문자로 이루어진 단어를 입력받은 뒤, 대문자는 소문자로, 소문자는 대문자로 바꾸어 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 영어 소문자와 대문자로만 이루어진 단어가 주어진다. 단어의 길이는 최대 100이다.
<출력값>
첫째 줄에 입력으로 주어진 단어에서 대문자는 소문자로, 소문자는 대문자로 바꾼 단어를 출력한다.

<문제 2745>
B진법 수 N이 주어진다. 이 수를 10진법으로 바꿔 출력하는 프로그램을 작성하시오.
10진법을 넘어가는 진법은 숫자로 표시할 수 없는 자리가 있다. 이런 경우에는 다음과 같이 알파벳 대문자를 사용한다.
A: 10, B: 11, ..., F: 15, ..., Y: 34, Z: 35
<입력값>
첫째 줄에 N과 B가 주어진다. (2 ≤ B ≤ 36)
B진법 수 N을 10진법으로 바꾸면, 항상 10억보다 작거나 같다.
<출력값>
첫째 줄에 B진법 수 N을 10진법으로 출력한다.

<문제 2747>
피보나치 수는 0과 1로 시작한다. 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다. 그 다음 2번째 부터는 바로 앞 두 피보나치 수의 합이 된다.
이를 식으로 써보면 Fn = Fn-1 + Fn-2 (n ≥ 2)가 된다.
n=17일때 까지 피보나치 수를 써보면 다음과 같다.
0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597
n이 주어졌을 때, n번째 피보나치 수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 n이 주어진다. n은 45보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 n번째 피보나치 수를 출력한다.

<문제 2748>
피보나치 수는 0과 1로 시작한다. 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다. 그 다음 2번째 부터는 바로 앞 두 피보나치 수의 합이 된다.
이를 식으로 써보면 Fn = Fn-1 + Fn-2 (n ≥ 2)가 된다.
n=17일때 까지 피보나치 수를 써보면 다음과 같다.
0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597
n이 주어졌을 때, n번째 피보나치 수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 n이 주어진다. n은 90보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 n번째 피보나치 수를 출력한다.

<문제 2749>
피보나치 수는 0과 1로 시작한다. 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다. 그 다음 2번째 부터는 바로 앞 두 피보나치 수의 합이 된다.
이를 식으로 써보면 Fn = Fn-1 + Fn-2 (n ≥ 2)가 된다.
n=17일때 까지 피보나치 수를 써보면 다음과 같다.
0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597
n이 주어졌을 때, n번째 피보나치 수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 n이 주어진다. n은 1,000,000,000,000,000,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 n번째 피보나치 수를 1,000,000으로 나눈 나머지를 출력한다.

<문제 2750>
N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 수의 개수 N(1 ≤ N ≤ 1,000)이 주어진다. 둘째 줄부터 N개의 줄에는 숫자가 주어진다. 이 수는 절댓값이 1,000보다 작거나 같은 정수이다. 수는 중복되지 않는다.
<출력값>
첫째 줄부터 N개의 줄에 오름차순으로 정렬한 결과를 한 줄에 하나씩 출력한다.

<문제 2751>
N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 수의 개수 N(1 ≤ N ≤ 1,000,000)이 주어진다. 둘째 줄부터 N개의 줄에는 숫자가 주어진다. 이 수는 절댓값이 1,000,000보다 작거나 같은 정수이다. 수는 중복되지 않는다.
<출력값>
첫째 줄부터 N개의 줄에 오름차순으로 정렬한 결과를 한 줄에 하나씩 출력한다.

<문제 2752>
동규는 세수를 하다가 정렬이 하고싶어졌다.
숫자 세 개를 생각한 뒤에, 이를 오름차순으로 정렬하고 싶어 졌다.
숫자 세 개가 주어졌을 때, 가장 작은 수, 그 다음 수, 가장 큰 수를 출력하는 프로그램을 작성하시오.
<입력값>
숫자 세 개가 주어진다. 이 숫자는 1보다 크거나 같고, 1,000,000보다 작거나 같다. 이 숫자는 모두 다르다.
<출력값>
제일 작은 수, 그 다음 수, 제일 큰 수를 차례대로 출력한다.

<문제 2753>
연도가 주어졌을 때, 윤년이면 1, 아니면 0을 출력하는 프로그램을 작성하시오.
윤년은 연도가 4의 배수이면서, 100의 배수가 아닐 때 또는 400의 배수일 때이다.
예를 들어, 2012년은 4의 배수이면서 100의 배수가 아니라서 윤년이다. 1900년은 100의 배수이고 400의 배수는 아니기 때문에 윤년이 아니다. 하지만, 2000년은 400의 배수이기 때문에 윤년이다.
<입력값>
첫째 줄에 연도가 주어진다. 연도는 1보다 크거나 같고, 4000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 윤년이면 1, 아니면 0을 출력한다.

<문제 2754>
어떤 사람의 C언어 성적이 주어졌을 때, 평점은 몇 점인지 출력하는 프로그램을 작성하시오.
A+: 4.3, A0: 4.0, A-: 3.7
B+: 3.3, B0: 3.0, B-: 2.7
C+: 2.3, C0: 2.0, C-: 1.7
D+: 1.3, D0: 1.0, D-: 0.7
F: 0.0
<입력값>
첫째 줄에 C언어 성적이 주어진다. 성적은 문제에서 설명한 13가지 중 하나이다.
<출력값>
첫째 줄에 C언어 평점을 출력한다.

<문제 2755>
최백준이 이번 학기에 들은 과목과 학점 그리고 성적이 주어졌을 때, 평균 평점을 계산하는 프로그램을 작성하시오.
성적은 A+~F까지 총 13개가 있다.
A+: 4.3, A0: 4.0, A-: 3.7
B+: 3.3, B0: 3.0, B-: 2.7
C+: 2.3, C0: 2.0, C-: 1.7
D+: 1.3, D0: 1.0, D-: 0.7
F: 0.0
평균 평점은 각 과목의 학점*성적을 모두 더한 뒤에, 총 학점으로 나누면 된다.
<입력값>
첫째 줄에, 백준이가 이번 학기에 들은 과목 수가 주어진다. 둘째 줄부터 N개의 줄에 각 과목의 과목명, 학점, 성적이 주어진다. 과목명은 알파벳 소문자와 숫자, 그리고 밑줄 (_)로만 이루어져 있으며, 최대 100글자이고, 학점은 1보다 크거나 같고, 3보다 작거나 같은 자연수이다. 성적은 문제에 설명한 13가지 중 하나이다.
<출력값>
첫째 줄에 평균 평점을 소수점 셋째 자리에서 반올림해서 둘째 자리까지 출력한다. (평균 평점이 1.5이면 1.50을 출력한다.)

<문제 2756>
다트판은 평평한 판과 동심원이 그려진 원형 코르크로 만든다. 사람들은 다트를 다트판에서 가장 중심에 있는 원(불스아이)을 향해 던진다.
다트판의 각 고리에는 점수가 적혀있고, 중심에 가까울수록 점수가 높다.

각 고리의 반지름은 3cm, 6cm, 9cm, 12cm, 15cm이다. (따라서, 불스아이의 지름은 6cm) 간단한 다트게임은 두 플레이어가 게임을 하며, 다음과 같이 플레이한다.
첫 번째 플레이어가 다트 3개를 다트판에 던진다. 다트가 맞춘 영역의 점수의 합이 그 플레이어의 점수가 된다. 첫 번째 플레이어가 던진 다트를 다트판에서 모두 제거한다. 두 번째 플레이어가 다트 3개를 다트판에 던진 뒤, 점수를 계산한다. 높은 점수를 얻은 플레이어가 이긴다.
두 플레이어의 점수를 계산한 뒤, 누가 이기는지를 구하는 프로그램을 작성하시오. 만약 다트가 경계에 걸쳐있다면, 높은 점수를 얻은 것이다. 다트가 다트판 밖을 맞춘다면, 점수를 얻지 못한다. Double precision floating point 연산을 사용하면 된다.
<입력값>
첫째 줄에 테스트 케이스의 개수가 주어진다. 각 테스트 케이스는 한 줄에 12개의 실수(double-precision 값)가 있다. 각 쌍은 중심과 다트의 거리이고, x, y거리 순서이고 단위는 cm이다.  처음 3개의 수는 첫 번째 플레이어가 던진 다트이고, 다음 3개는 두 번째 플레이어가 던진 것이다. (-20.0 ≤ X,Y ≤ 20.0)
<출력값>
각 테스트 케이스에 대해서, 게임을 이긴 사람이 있다면 다음과 같은 형식으로 출력한다.
SCORE: N to M, PLAYER P WINS.
만약, 비겼다면
SCORE: N to M, TIE.
를 출력한다.
N은 첫 번째 플레이어의 점수, M은 두 번째 플레이어의 점수이고, P는 게임을 승리한 사람의 번호 1 또는 2이다. 모든 값은 음이 아닌 정수이다.

<문제 2757>
엑셀의 첫 번째 열은 A이고, 두 번째 열은 B이고, 26번째 열은 Z이다. 26번째 열 다음 열부터는 2글자를 이용한다. 

	예를 들어, 27번째 열은 AA이고, 28번째 열은 AB, 52번째 열은 AZ이다. 그 다음 53번째 열은 BA이며, 이와 같이 계속 열의 이름을 붙인다.

	ZZ열 다음 열은 AAA가 되고, 그 다음은 AAB가 된다.

	엑셀에서 행은 그냥 행 번호를 사용하면 된다.

	엑셀 스프레드시트에서 각 칸은 위에서 설명한 열과 행을 합쳐서 이름을 만들 수 있다. 가장 왼쪽 위에 있는 칸은 A1이 되고, 55열 23행에 있는 칸은 BC23이 된다.

	열과 행이 주어졌을 때, 그 칸의 엑셀 스프레드시트 상에서 이름을 출력하는 프로그램을 작성하시오.
<입력값>
입력은 여러 줄이며, RnCm형태이다. n은 행 번호 (1<=n<=300000000), m은 열 번호 (1<=m<=300000000) 이다. 입력의 마지막은 n과 m이 모두 0이며, 이때는 출력하지 않고 프로그램을 종료하면 된다.
<출력값>
각 입력을 순서대로 한 줄에 하나씩 엑셀 스프레드시트 상에서의 이름을 출력하면 된다.

<문제 2758>
선영이는 매주 엄청난 돈을 로또에 투자한다. 선영이가 하는 로또는 1부터 m까지 숫자 중에 n개의 수를 고르는 로또이다.
이렇게 열심히 로또를 하는데, 아직까지 한 번도 당첨되지 않은 이유는 수를 고를 때 각 숫자는 이전에 고른 수보다 적어도 2배가 되도록 고르기 때문이다.
예를 들어, n=4, m=10일 때, 선영이는 다음과 같이 고를 수 있다.

1 2 4 8
1 2 4 9
1 2 4 10
1 2 5 10

따라서 선영이는 로또를 4개 산다. 
선영이는 돈이 엄청나게 많기 때문에, 수를 고르는 방법의 수 만큼 로또를 구매하며, 같은 방법으로 2장이상 구매하지 않는다.
n과 m이 주어졌을 때, 선영이가 구매하는 로또의 개수를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 n과 m으로 이루어져 있다.
<출력값>
각 테스트 케이스에 대해 선영이가 로또를 몇 개나 구매하는지 출력한다.

<문제 2759>
서로 다른 크기의 n개의 팬케익이 쌓여 있다. 순서 없이 마구 쌓여져있는 팬케익을 크기 순대로 쌓으려고 한다. 가장 위에는 제일 작은 크기의 팬케익이 있어야 되고, 가장 아래에는 제일 큰 크기의 팬케익이 있어야 한다.

	팬케익을 뒤집는 방법은 위에서 k개의 순서를 뒤집는 것이다. 따라서 k번째 팬케익이 가장 위로 올라오게 되고, 제일 위에 있던 팬케익은 k번째가 된다.

	다음 예를 보자.



	팬케익이 쌓여있는 상태가 주어졌을 때, 이를 순서대로 만드는 방법을 찾아 출력하는 프로그램을 작성하시오. 팬케익은 최대 2n-3번 뒤집을 수 있다.
<입력값>
첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 숫자 여러개가 공백으로 구분되어있다. 첫 번째 숫자는 팬케익의 개수 N이고, 그 다음 N개의 숫자는 팬케익의 크기이다. 가장 위에 있는 팬케익이 첫 숫자이고, 마지막 숫자는 제일 아래에 있는 팬케익이다.  N은 30보다 작거나 같다. 팬케익의 크기는 서로 다르며, 1보다 크거나 같고, N보다 작거나 같다.
<출력값>
각 테스트 케이스에 대해 한 줄에 하나씩 뒤집는 방법을 출력한다. 제일 먼저 뒤집는 횟수 K를 출력한다. 그 다음 뒤집는 방법을 순서대로 출력하면 된다. 뒤집는 방법이 여러개일 때는, 아무거나 출력하면 된다.

<문제 2760>
마술사 현우는 마술 대회에 출전하게 되었다. 그에게는 그를 따르는 충실한 조수가 있다. 하지만, 어제 식중독에 걸려서 같이 출전할 수 없게 되었다.
현우는 조수를 뽑을 시간이 없어서 조수가 하는 일을 대신해 주는 로봇을 만들었다. 이제 로봇에게 현우가 하는 카드 마술을 설명해주려고 한다.
일단 조수는 청중에게 표준 52-카드 덱에서 5장의 카드를 고르게 한다. 그 다음 그 카드를 확인하고, 그 중 한 장을 청중에게 돌려주고, 나머지 카드를 한 장씩 특정한 순서로 현우에게 넘겨준다. 이제 현우는 아수라발발타를 외치고.... 현우는 청중이 가지고 있는 카드가 무엇인지 알아낸다.
현우가 카드를 확인하는 방법은 다음과 같다.
카드가 덱에 들어있는 순서는 카드의 숫자에 의해 결정되고, 숫자가 같은 경우에는 무늬에 의해서 결정된다. 따라서, 순서는 AC, AD, AH, AS, 2C, 2D, ..., KH, KS (C: 클럽, D: 다이아, H: 하트, S: 스페이드) 와 같이 된다.
1. 첫 번째 카드의 무늬와 숫자를 기억한다.
2. 나머지 세 카드 중에 가장 작은 카드를 찾고, 이 카드의 위치를 가장 첫 번째 카드의 숫자에 더한다.
3. 세 카드 중에서 가장 큰 두 개의 카드의 순서가 위에서 설명한 것과 맞지 않다면 2번째 과정의 결과에 3을 더한다.
4. 청중이 들고 있는 카드는 세 번째 과정까지 계산된 첫 번째 카드의 수와 무늬를 가지고 있다. (만일 수가 K를 넘어간다면, 수를 K만큼 내린다)
예를 들어 QH, 10D, 10C, 4D가 손에 들어왔다면, 뒤의 세 개 중 가장 작은 카드는 4D이고, 위치는 3이다. 그리고 10D와 10C가 순서를 지키지 않고 있으므로 첫 번째 카드에 6을 더하는데, 이 수가 K를 넘어가므로 K만큼 빼주면, 청중이 가지고 있는 카드가 5H임을 알 수 있다.
현우를 위해 조수의 일을 수행해주는 프로그램을 작성하자
<입력값>
첫 번째 줄에 테스트 케이스의 수 T가 주어진다. 각 테스트 케이스는 카드 5장이 공백을 사이에 두고 한 줄에 주어진다.
<출력값>
각 테스트 케이스에 대해 조수가 청중에게 돌려줄 카드와 나머지 카드를 현우에게 돌려줄 순서대로 공백을 사이에 두고 출력한다.

<문제 2761>
모형 로켓이 얼마나 높이 올라갔는지 측정하는 방법은 여러 가지가 있는데, 그 중 하나는 다음과 같다.

	관측하는 사람 A,B,C가 D 만큼 떨어져서 경위계를 가지고, 수평선에서 떨어진 각도를 측정한다. 각 측정 장비는 지면에서 H만큼 떨어져 있다. 로켓이 발사된 후 가장 높은 지점 근처에서, 낙하산을 펼친 후, 먼지 더미를 분출한다. 각각의 관측자는 먼지 더미와 수평선과의 각도를 측정한다.

	A,B,C가 측정한 각을 각각 a,b,c라 하면 이 값을 이용하여 높이를 측정할 수 있다.

	D,H,a,b,c가 주어졌을 때, 로켓이 올라간 높이(반올림)를 계산하는 프로그램을 작성하시오.
<입력값>
첫 줄은 10진수 D,H가 들어온다. (정수가 아닐 수 있다) 이 값들은 모든 로켓에 대해 같다. 다음 줄부터 각 줄에는 a,b,c(각도)가 들어오며, 마지막 줄에는 0보다 작거나 같은 값이 들어온다. 입력의 마지막을 나타내는 마지막 줄을 제외하고는 모두 0도 초과부터 90도 미만 사이의 각이다.
<출력값>
각각의 3개의 각에 대해 높이를 반올림 하여 정수로 출력한다.

<문제 2762>
구역의 경계가 주어졌을 때, 각 구역을 채우는 프로그램을 작성하시오.
<입력값>
입력은 테스트 케이스 여러개가 주어진다. 각 테스트 케이스의 첫째 줄에는 행의 개수 R, 열의 개수 C, 구역의 개수가 주어진다. 행은 제일 위가 1행이고, 열은 가장 왼쪽이 1열이다. 행은 최대 47행이고, 열은 최대 63행이다.

	다음 둘째 줄부터는 각 구역의 설명이 주어진다. 구역의 설명의 첫째 줄에는 구역을 채우는데 사용할 알파벳, 시작하는 행 번호와 열 번호, 경계선의 개수가 주어진다. 경계선의 개수는 적어도 두 개이다. 알파벳은 중복되지 않으며, 다음 줄은 경계선을 설명하는 줄이다.

H A B
G   C
F E D

	위와 같이 경계선을 시작점부터 시계방향으로 설명한다.
<출력값>
각각의 테스트 케이스에 대해서, R개의 행, C개의 열로 구역을 모두 채운 결과를 출력한다. 구역이 아닌 곳은 마침표('.')로 출력한다.

	다음과 같은 경우가 발생할 때는, 발생한 순서대로 구역을 채운 결과를 출력하기 전에 한 줄에 하나씩 출력한다. (아래 설명에서 A와 B는 해당하는 구역 알파벳으로 바꾸면 된다)

	1. 경계선이 배열의 경계를 넘어갈 때는 다음과 같이 출력한다.

	REGION A GOES OUTSIDE THE ARRAY

	2. 경계선이 닫혀있지 않다면 다음과 같이 출력한다. 즉, 다시 시작점으로 돌아오지 않았을 때이다.

	REGION A BOUNDARY IS NOT CLOSED

	3. 구역 B의 경계가 이전에 채운 구역 A와 겹친다면, 다음과 같이 출력한다.

	REGION B BOUNDARY INTERSECTS REGION A

	각 테스트 케이스는 빈 줄로 구분한다.

<문제 2763>
An application to assist in the analysis of tissue samples is to work as follows. A digital microphotograph of a stained tissue sample is scanned to identify stained pixels. For each region of stained pixels, an outline of the region is obtained. The outline is then analyzed for shape indicators of disease and the outlines (color-coded for possible disease) are overlaid on the microphotograph as it is displayed to the pathologist. 
This problem is to write a program, which processes a bitmap of stained and unstained pixels, finds regions of stained pixels and, for each region, outputs the outline of the region. Regions with fewer stained pixels than a minimum size are ignored. Only the outer boundary is computed (interior holes are ignored). 
A pixel is adjacent to another pixel if the second pixel is directly above, directly below, directly left or directly right of the first pixel. Two stained pixels are connected if there is a sequence of stained pixels starting with one of the pixels and ending with the other for which each pixel in the sequence is adjacent to the next. A region of stained pixels is a set of stained pixels, all of which are connected to a single stained pixel. A stained pixel is a boundary pixel of its region if at least one of the pixels adjacent to it is not stained. (All pixels immediately outside the bitmap are considered unstained so that pixels on the edge of the bitmap are boundary pixels.) In the example below, there are 4 regions (stained pixels are ‘X’, unstained are ‘.’). 

........................................ 
.XX..................................... 
..X.................XXX......XXX........ 
.....................XXX....XXX......... 
.......XXX............XXX..XXX.......... 
.....XXXXXXX...........XXXXXX........... 
....XXXXXXXXX...........XXXX............ 
...XXXX...XXXX...........XX............. 
..XXX.......XXX......................... 
..XXX.......XXX........XXXXXXX.......... 
.XXX.........XXX.......XXXXXXX.......... 
.XXX.........XXX.......XXXXXXX.......... 
.XXX.........XXX.......XXXXXXX.......... 
..XXX.......XXX...........X............. 
..XXX.......XXX...........X............. 
...XXXX...XXXX.........XXXXXXX.......... 
....XXXXXXXXX..........XXXXXXX.......... 
.....XXXXXXX...........XXXXXXX.......... 
.......XXX.............XXXXXXX.......... 
........................................ 

Outlines are to be specified as the left most point of the top most line of the region, a count of boundary pixels and a sequence of moves from one boundary pixel to the next clockwise using the codes (up = A, up right = B, etc.): 

H A B 
G   C 
F E D 

Rows are numbered from top to bottom beginning with 1. Columns are numbered from left to right beginning with 1. For example the outline of the ‘v’ shaped region above would be: 

3 21 22 
CCDDDCBBBCCFFFFFGHHHHH
<입력값>
Input is a sequence of problem instances. Each problem instance begins with a line containing 3 decimal numbers: row-count, column-count and minimum-number-of-pixels. This line is followed by row-count lines of column-count characters. Each character is either a period (.) for an unstained pixel or an upper-case X for a stained pixel. The input ends when the row-count is 0. Row-count will be at most 47, column-count will be at most 63 and minimum-number-of-pixels will be at least 2.
<출력값>
For each problem instance, the output begins with a line starting with a decimal integer giving the number of components of at least minimum-number-of-pixels stained pixels. This is followed by the description of the boundary of each component. The boundaries are to be listed in the order that a first pixel of the component appears while scanning across lines from left to right with line scanned from top to bottom. For each component, the output begins with a line giving the row number of the start pixel, the column number of the start pixel and the number of pixels in the boundary as decimal integers separated by a single space. This line is followed by lines of direction codes ‘A’ through ‘H’. Each line shall have 40 characters except the last line.

<문제 2764>
백준이는 대학에서 ACM-ICPC를 함께 공부한 Sogang ACM-ICPC Team 회원들과 사진을 찍으려고 한다. 
회원들은 여러 줄로 나누어서 설 것이고, 앞 줄에 있는 사람의 수는 뒷 줄에 있는 사람의 수보다 작거나 같다. 그리고, 모든 줄은 왼쪽을 기준으로 정렬해서 줄을 설 것이다.
예를 들어 회원이 12명이라면, 뒤에서부터 앞까지 차례대로 5, 3, 3, 1명이 설 수 있다.

백준이는 모든 사람들이 사진에 나와야 한다고 생각한다. 따라서, 각 줄에 서있는 사람의 키는 왼쪽에서 오른쪽으로 갈 수록 작아져야 하고, 뒤에서 앞으로 올 수록 작아져야 한다.
12명의 학생이 있을 때, 5, 3, 3, 1과 같이 줄을 서는 2가지 경우는 다음과 같다. (1이 제일 키가 큰 사람)

학생의 수와 각 줄에 몇 명이 서야 하는 지가 주어졌을 때, 사진을 찍을 수 있는 서로 다른 대형의 수를 구하려고 한다.
학생이 6명이고, 3, 2, 1과 같이 줄을 서는 방법은 다음과 같이 16가지가 있다.
<입력값>
첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 다음과 같이 두 줄로 이루어져 있다. 첫째 줄에는 줄의 수 k가 주어진다. 둘째 줄에는 가장 뒷 줄부터 앞 줄까지 몇 명의 사람이 줄을 서야 하는지가 공백으로 구분되어 주어진다. (n1, n2, ..., nk)
k는 5보다 작거나 같은 자연수이고, 전체 학생의 수는 30보다 작거나 같다.
<출력값>
각 테스트 케이스에 대해, 한 줄에 하나씩 사진 찍는 대형의 수를 출력한다. 이 값은 4294967295보다 작거나 같다.

<문제 2765>
대부분의 자전거 속도계는 앞 포크에 설치된 홀 효과 센서로 동작한다. 자석이 앞 바퀴의 포크중 하나에 부착되어, 홀 효과를 이용해 속도계가 바퀴의 회전수를 측정한다. 따라서 바퀴의 지름을 안다면 회전수를 통해 이동 거리를 측정할 수 있다. 또한 바퀴가 회전하는 동안 걸린 시간을 안다면 평균 속도 역시 알 수 있다.
바퀴의 지름, 회전수, 걸린 시간이 주어졌을 때, 총 이동 거리와 평균 속도를 계산하여라. 앞바퀴는 땅에서 떨어지거나 미끄러지거나 공전하지 않았다고 가정한다.
이동 거리의 단위는 miles이고, 평균 속도의 단위는 miles/hour 이다.
<입력값>
입력은 여러 줄의 데이터로 구성된다. 각 데이터는 지름, 회전수, 시간이 공백으로 구분되어 주어진다. 지름은 inch단위의 실수이며, 회전수는 정수이다. 시간은 초단위의 실수로 주어진다. 입력은 회전수가 0이면 끝난다. 실수는 소수점 셋째자리이하까지 주어진다.
<출력값>
각각의 데이터에 대해 다음을 출력한다
Trip #N: distance MPH
N은 각각의 데이터 번호를 출력해야 하며, distance는 총 거리(Miles)를 소수 둘째 자리까지 반올림하여 나타내며, MPH는 평균 속도(miles per hour)를 소수 둘째 자리까지 반올림하여 나타낸다. 회전수가 0인 데이터에 대해서는 출력하지 않는다.

<문제 2766>
학생들이 선생님을 중심으로 서로 마주보며 둥글게 앉아있다. 학생들은 각각 짝수개의 사탕을 가지고 있다. 선생님이 호루라기를 부는 순간 학생들은 자신의 오른쪽 학생에게 사탕의 반을 준다. 이때 학생들 중 홀수개의 사탕을 가지게 되는 학생들은 선생님으로부터 하나의 사탕을 더 받게 된다. 모든 학생들의 사탕의 개수가 같아지면 게임은 끝나게 된다.

	선생님이 호루라기를 부는 횟수와 게임이 끝났을 때 한 학생이 받는 사탕의 개수를 구해보자.
<입력값>
입력은 여러개의 게임으로 이루어져 있다. 각 게임의 첫 번째 줄에는 학생들의 수 N이 주어지며, 다음 N개에 줄에 시계방향 순으로 각 학생들이 가지고 있는 사탕의 개수가 한 줄에 하나씩 주어진다. 학생의 수 N이 0일 때 프로그램을 종료한다. N은 10만보다 작거나 같은 자연수이다.
<출력값>
각 게임이 끝났을 때 라운드 수와 학생들이 가지고 있게 되는 사탕의 수를 공백으로 구분하여 출력한다.

<문제 2768>
칼리가 살던 곳의 문명은 우리의 문명과는 다르지만 그 곳도 정부, 기업, 기술을 가지고 있었다. 가장 큰 차이는 세율의 결정 방법이었다. 그들은 흥정하는 것을 좋아했기 때문에 세율도 흥정으로 결정하였다. 
세금 계약을 작성할 때, 정부 관료들과 흥정하기 위해 수도로 가야한다. 계약에는 시작일, 만기일, 세율에 관한 내용이 있다. (부기 때문에 만기일은 항상 마지막달의 15일이다.) 계약 마지막 달과 새 계약이 시작하기 전 동안의 짧은 세금이 없는 기간을 즐기는 것은 칼리 가족의 전통이다. 이 기간 역시 흥정을 할 때이기도 하다.
칼리가 살던 곳은 매우 번영하고 인구가 많아서 정부 관료들은 업무가 매우 많았다. 세금 흥정 거래가 성사되면 관료들은 속기로 써서 일이 진행될 수 있도록 전달한다. 이 속기 노트를 컴퓨터로 입력하려면 XML 형식으로 전환되어야 한다. 때때로 노트가 완성된 게 아니라 세금 계약을 하러 다시 수도로 사람이 불려오기도 했다. 이 일련의 과정은 굉장히 비효율적이지만 이 방식은 이 곳 사람들이 하던 방식이고, 그 방법을 바꿀 생각이 없다.
노트를 XML 형식으로 바꾸는 프로그램을 작성하시오.
<입력값>
입력은 여러개의 데이터 세트로 구성되어 있으며, 각 세트는 한 줄로 구성되어 있다.
각 줄은 3개의 정보로 구성되어 있다.

세율
	
세율은 숫자 뒤에 %가 붙어있다. (예 5%)
소수점이 없다.
세율은 분수가 될 수 있지만 분모는 2,4,8 중에 하나이다.
세율은 분자가 분모보다 작다.


계약 종료 날짜
	
계약이 끝나는 달과 연도의 두자리로 들어온다. 두 숫자는 붙어서 들어오거나 하이픈으로 연결되어 있다. 예를 들어, 12-05 또는 1205는 05년 12월 15일을 뜻한다.


계약 시작 날짜
	
종료 날짜와 마찬가지 형식이며, 현재 날짜보다 이후로 간주한다.



3개의 정보는 0개 이상의 공백으로 구분되어 있다.
달력은 우리와 같이 12개의 달로 구성되어 있지만, 모든 달은 31일까지 있다.
최고 세율은 99.875%이다.
<출력값>
각 데이터 세트에 대해 들여쓰기를 올바르게 한 XML을 출력한다. (들여쓰기 하나는 4개의 공백)

<Kalii Index=N>
    <startdate><start date)</startdate>
    <rate>(tax rate)</rate>
    <enddate>(end date)</enddate>
</Kalii>
N은 데이터 세트 번호이며, (start date)는 시작일, (tax rate)는 세율, (end date)는 종료일을 뜻한다.
데이터가 잘못되었거나 모호하여 출력할 수 없으면
<Kalii Index=N>BAD INPUT</Kalii> 라고 출력한다. (N은 데이터 세트 번호)
시작일은 DDMMMYY 형태이며, 종료일은 15MMMYY이다.
DD는 01-31, MMM은 JAN,FEB,MAR,APR,MAY,JUN,JUL,AUG,SEP,OCT,NOV,DEC로 구성되어 있다. YY는 00-99로 구성되어 있다.
세율은 소수점 3자리까지 정확해야 한다.

<문제 2769>
두 논리식이 주어졌을 때, 두 논리식이 논리적으로 같은지 아닌지를 판별하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 같은지 비교해야 할 두 논리식이 주어진다. 입력으로 주어지는 식은 26개의 변수 a-z, 이항 연산자 |, &, ^,(OR, AND, XOR), 단항 연산자 ~(NOT), 괄호로 이루어져 있다. 

	이외의 다른 문자는 무시해야 하고, C언어 연산자 우선순위를 따른다. 두 입력식은 구분되어 있지 않다. 두 논리식을 구분하는 것도 구현해야 한다.

	이러한 문제를 풀 때는 보통 각 식을 정규화 한 뒤, 두 정규화 식이 같은지 판별하는 방법을 사용한다. 각각의 논리식은 10개 이하의 변수, 100개 이하의 연산자로 이루어져 있다.
<출력값>
각각의 테스트 케이스에 대해서, 두 논리식이 같다면,

	Data set N: Equivalent

	다르다면

	Data set N: Different

	를 출력한다. N은 테스트 케이스 번호이고, 1번부터 시작한다.

<문제 2772>
양의 정수 n이 주어질 때 N을 1부터 n까지의 정수의 집합이라 하자. N의 부분집합의 수열 A1, …, Ak이 아래의 성질을 만족할 때 완전히 다양화되었다고 한다.
a. 각각의 부분집합 Ai가 짝수 개의 원소로 이루어졌다.
b. 임의의 N의 원소 m에 대해 m을 원소로 갖는 Ai가 m개 존재한다.
예를 들어 {1, 2, 3}의 부분집합으로 이뤄진 수열 {1, 3}, {2, 3}, {2, 3}은 완전히 다양화된 수열이다. (수열의 항은 같을 수 있다)
N의 부분집합의 수열 중 완전히 다양화된 수열은 여러 개가 존재하는데, 그 중 가장 짧은 것을 최소라 한다. 위의 예에서는 3이 세 개의 다른 집합에 나타나야 하므로, 위 수열이 최소이다.
정수 n이 주어졌을 때, 완전히 다양화된 수열이 있는가를 판별하고, 있다면 최소의 다양화된 수열을 찾아라.
<입력값>
양의 정수 n(≤ 100)이 한 줄에 하나씩 입력된다. 0이 입력되면 입력을 종료한다.
<출력값>
집합 N에 대해 완전히 다양화된 수열이 없다면 0을 출력하고 다음 줄에 빈 줄을 출력한다.
완전히 다양화된 수열이 있다면, 수열의 길이를 출력하고 다음 줄에 집합을 출력한 뒤 다음 줄에 빈 줄을 출력한다.
각각의 원소는 오름차순으로 출력하여야 하며, 원소들 사이에는 빈 칸을 하나씩 출력한다. 수열의 집합은 사전순으로 출력하여야 한다. 각각의 문제에 대해 답은 여러 개가 있을 수 있다.

<문제 2773>
삼각형 ABC가 주어졌을 때, 이 삼각형의 바깥 삼각형은 다음과 같이 만들 수 있다.
ABC의 각 변에서 다음과 같은 정사각형(ABDE, BCHJ, ACFG)을 만든다. 인접한 정사각형의 꼭짓점을 아래와 같이 연결하면 세 개의 바깥 삼각형(AGD, BEJ, CFH)을 만들 수 있다.
삼각형 ABC의 바깥 중선이란, 각 바깥 삼각형의 중선 중 ABC의 꼭짓점을 통과하는 중선을 ABC 내부까지 연장한 선이다. (아래 그림에서 LAO, MBO, NCO)
바깥 삼각형의 중심이란 삼각형 ABC의 바깥 중선이 교차하는 점(그림에서 점 O)이다.
삼각형이 주어졌을 때, 바깥 삼각형의 중심을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 삼각형 ABC의 세 점의 좌표로 이루어져 있고, 한 줄에 한 점의 정보가 주어진다. 겹치는 점이나, 삼각형을 만들지 못하는 경우는 없다.
<출력값>
각 테스트 케이스에 대해서 바깥 삼각형의 중심의 x좌표와 y좌표를 소수 넷째자리까지 출력한다.

<문제 2774>
윤정이는 뭐든지 아름다운 것이 좋다고 생각한다. 그래서 윤정이는 사물을 볼 때 자신이 정한 방법으로 아름다운 정도를 평가한다. 윤정이는 수를 볼 때도 이런 아름다운 수의 정도를 따지는데, 윤정이에게 있어서 아름다운 수의 정도는 그 수를 이루고 있는 10진수의 중복되지 않은 숫자의 개수를 의미한다.  예를 들어 122이라는 수는 1과 2 라는 2개의 숫자로 이루어져 있으므로 아름다운 정도가 2가 된다. 윤정이의 방법으로 여러 수들의 아름다운 정도를 알아보자.
<입력값>
첫째 줄에는 테스트 케이스의 개수 T가 주어진다. 다음 줄부터는 아름다운 정도를 알고 싶은 수 X(1 ≤ X ≤ 1000000000)가 주어진다.
<출력값>
각각의 테스트 케이스마다 X의 아름다운 정도를 한 줄에 하나씩 입력으로 주어진 순서대로 출력한다.

<문제 2775>
평소 반상회에 참석하는 것을 좋아하는 주희는 이번 기회에 부녀회장이 되고 싶어 각 층의 사람들을 불러 모아 반상회를 주최하려고 한다.
이 아파트에 거주를 하려면 조건이 있는데, “a층의 b호에 살려면 자신의 아래(a-1)층의 1호부터 b호까지 사람들의 수의 합만큼 사람들을 데려와 살아야 한다” 는 계약 조항을 꼭 지키고 들어와야 한다.
아파트에 비어있는 집은 없고 모든 거주민들이 이 계약 조건을 지키고 왔다고 가정했을 때, 주어지는 양의 정수 k와 n에 대해 k층에 n호에는 몇 명이 살고 있는지 출력하라. 단, 아파트에는 0층부터 있고 각층에는 1호부터 있으며, 0층의 i호에는 i명이 산다.
<입력값>
첫 번째 줄에 Test case의 수 T가 주어진다. 그리고 각각의 케이스마다 입력으로 첫 번째 줄에 정수 k, 두 번째 줄에 정수 n이 주어진다
<출력값>
각각의 Test case에 대해서 해당 집에 거주민 수를 출력하라.

<문제 2776>
연종이는 엄청난 기억력을 가지고 있다. 그래서 하루 동안 본 정수들을 모두 기억 할 수 있다. 하지만 이를 믿을 수 없는 동규는 그의 기억력을 시험해 보기로 한다. 동규는 연종을 따라 다니며, 연종이 하루 동안 본 정수들을 모두 ‘수첩1’에 적어 놓았다. 그것을 바탕으로 그가 진짜 암기왕인지 알아보기 위해, 동규는 연종에게 M개의 질문을 던졌다. 질문의 내용은 “X라는 정수를 오늘 본 적이 있는가?” 이다. 연종은 막힘없이 모두 대답을 했고, 동규는 연종이 봤다고 주장하는 수 들을 ‘수첩2’에 적어 두었다. 집에 돌아온 동규는 답이 맞는지 확인하려 하지만, 연종을 따라다니느라 너무 힘들어서 여러분에게 도움을 요청했다. 동규를 도와주기 위해 ‘수첩2’에 적혀있는 순서대로, 각각의 수에 대하여, ‘수첩1’에 있으면 1을, 없으면 0을 출력하는 프로그램을 작성해보자.
<입력값>
첫째 줄에 테스트케이스의 개수 T가 들어온다. 다음 줄에는 ‘수첩 1’에 적어 놓은 정수의 개수 N(1 ≤ N ≤ 1,000,000)이 입력으로 들어온다. 그 다음 줄에  ‘수첩 1’에 적혀 있는 정수들이 N개 들어온다. 그 다음 줄에는 ‘수첩 2’에 적어 놓은 정수의 개수 M(1 ≤ M ≤ 1,000,000) 이 주어지고, 다음 줄에 ‘수첩 2’에 적어 놓은 정수들이 입력으로 M개 들어온다. 모든 정수들의 범위는 int 로 한다.
<출력값>
‘수첩2’에 적혀있는 M개의 숫자 순서대로, ‘수첩1’에 있으면 1을, 없으면 0을 출력한다.

<문제 2777>
학교에서 공부를 하고 있던 승환이는 갑자기 숫자 하나를 보고 그 숫자의 특징에 대해 생각했다. 승환이가 본 숫자는 10이다. 10은 2*5로 나타낼 수 있고 이를 조금 더 생각해서 25라는 수의 각 자릿수를 곱하면 10이 된다는 것을 알아냈다. 이를 일반적인 문제로 바꾸면 다음과 같다. 
“양의 정수 N( 1 <= N <= 1,000,000,000 )이 있을 때 모든 자릿수의 곱이 정확히 N이 되는 가장 작은 양의 정수 X를 찾아라. ”
모든 자릿수의 곱이 20인 수들을 예를 들면, 522 보다는 225가 작고 225 보다는 45가 작다.
승환이는 자신이 만든 문제를 수업 시간 전에 칠판에 써 놓았다. 그것을 본 당신은 호기심이 생겨서 그 문제를 풀어보고 싶어한다. N이 주어졌을 때 위 조건을 만족하는 가장 작은 양의 정수 X가 몇 자리 수인지 구하여라.
<입력값>
첫 번째 줄에 Test case의 수 T가 주어진다. 그리고 각각의 케이스마다 입력으로 첫 번째 줄에 양의 정수 N이 주어진다. (1 <= N <= 1,000,000,000)
<출력값>
각각의 Test case에 대해서 조건을 만족하는 가장 작은 X가 몇 자리 수인지 출력하라. 만약 그러한 X가 존재하지 않는다면 -1을 출력하라.

<문제 2778>
측량사 지윤이는 삼각형을 너무 좋아해서 하루에 하나씩 삼각형을 그린다. 그런데 어느 날 밤에 삼각형을 그리려고 하는데, 작업실이 정전 되고 말았다. 그래도 지윤이는 감으로 직선 3개를 그리고 그 직선으로 만들어지는 삼각형의 넓이를 구해 보려 한다. 보이지 않는 상태로 그렸지만, 지윤이는 자신이 그린 직선 3개의 방정식은 알고 있다. 하지만 넓이를 계산하기에는 머리가 너무 아픈 지윤이는, 당신에게 넓이 계산을 부탁했다. 직선의 방정식은 3개 주어지고, 각각 ax + by + c = 0와 같이 표현될 때( a,b,c는 정수),  만들어지는 삼각형의 넓이를 구해보자. 만약 삼각형이 만들어지지 않는다면 0 을 출력하라.
<입력값>
첫 번째 줄에 Test case의 수 T가 주어진다. 그리고 각각의 케이스마다 입력으로 첫 번째 줄부터 연속해서 3개의 줄에 각각 직선을 뜻하는 정수 a, b, c가 차례대로 주어진다. (-1,000 <= a, b, c <= 1,000)
<출력값>
각각의 Test case에 대해서 한 줄씩, 3개의 직선으로 만들어지는 삼각형의 넓이를 소수점 아래 5자리에서 반올림 하여 출력하라. 만약 삼각형을 만들 수 없다면 0.0000을 출력해주면 된다.

<문제 2779>
규현이와 진우는 둘만의 비밀이 있다. 그 비밀은 절대로 둘 외에는 알아서는 안되기 때문에 무조건 말이 아닌 글로 대화하기로 했다. 그리고 그것도 모자라서 둘은 자신들만의 비밀 어를 만들기로 결심했다. 그리고 비밀 어는 비용을 들여서 단어 내의 글자 위치를 바꿀 수 있다. 단어를 바꾸는 비용은 기존 단어와 바꾼 단어에서 글자가 다른 위치의 수이다. 
만약 abc라는 비밀 단어가 있다고 하자. 그렇다면 비용을 들여서 다음과 같은 단어를 비밀 어로 사용할 수 있다.

비용 0 : abc
비용 2 : acb, cba, bac
비용 3 : cab, bca


비밀 어와 비밀 어의 합은 비밀 문장이 될 수 있다.  예를 들어 ab와 dc라는 비밀 어가 있을 경우 abdc라는 비밀 문장이 만들어 질 수 있다. 만약 하나의 비밀 어가 문장에 여러 번 등장할 경우 각각은 다르게 변형되어 사용 될 수 있다. 즉, 주어진 단어가 위처럼 되어 있을때 abcacb라는 문장을 만들 수 있다는 것이다. ( 비용을 들이지 않고 abc단어를 사용하고 비용 2를 들여 acb단어를 사용하여 이 문장을 만들 수 있다. 이때 총 비용은 2이다.)
이렇게 비밀 어에서는 특정 문장을 만들기 위해 주어진 비밀 어를 비용을 들여서 글자 위치를 바꾼 후 접합 시킬 수 있다. 이는 하나의 문장을 만드는 방법이 여러 개가 있을 수 있음을 의미한다.  우리는 규현이와 진우의 비밀 문장 하나를 얻었다. 주어진 비밀 어들을 이용하여 비밀 문장을 만들기 위해 필요한 최소의 비용을 구해보자. 만약 문장을 만들 수 없다면 -1을 출력하라.
<입력값>
첫 번째 줄에 Test case의 수 T가 주어진다. 그리고 각각의 케이스마다 입력으로 첫 번째 줄에  우리가 만들어야하는 비밀문장 하나가 주어진다. 이 비밀문장은 ‘a’~’z’까지의 문자만 사용하여 만들어져있으며 길이는 1~50글자이다. 둘째 줄에 비밀어에서 사용하는 단어의 개수 N이 주어진다. (N은 1 <= N <= 50 인 자연수) 다음줄부터 N개의 줄만큼 비밀 어가 각각의 줄에 하나씩 주어진다.
<출력값>
각각의 Test case에 대해서 주어진 비밀 문장을 만드는데 필요한 최소의 비용을 출력하라. 만약 만들 수 없다면 -1을 출력하라.

<문제 2780>
석원이는 자신의 현관문에 비밀번호 기계를 설치했다. 그 기계의 모양은 다음과 같다.

지나가던 석원이 친구 주희는 단순한 호기심에 저 비밀번호를 풀고 싶어한다. 이때 주희는 바닥에 떨어져 있는 힌트 종이를 줍게 된다. 이 종이에는 석원이가 비밀번호를 만들 때 사용했던 조건이 적혀 있다. 이제 주희는 이 조건을 가지고, 석원이 집의 가능한 비밀번호의 전체 개수를 알고 싶어 한다. 현재 컴퓨터를 사용할 수 없는 주희는 당신에게 이 문제를 부탁했다. 석원이의 힌트 종이는 다음과 같다.

비밀번호의 길이는 N이다.
비밀번호는 위 그림에 나온 번호들을 눌러서 만든다.
비밀번호에서 인접한 수는 실제 위 기계의 번호에서도 인접해야 한다.

(ex. 15 라는 비밀번호는 불가능하다. (1과 5는 인접하지 않는다. ) 하지만 1236이라는 비밀번호는 가능하다.)
<입력값>
첫 번째 줄에 Test case의 수 T가 주어진다. 그리고 각각의 케이스마다 입력으로 첫 번째 줄에 비밀번호의 길이 N이 주어진다.( 1 <= N <= 1,000 )
<출력값>
각각의 Test case에 대해서 조건을 만족하는 비밀번호의 개수를 출력하라. 단, 수가 매우 커질 수 있으므로 비밀번호의 개수를 1,234,567으로 나눈 나머지를 출력하라.

<문제 2781>
새로 생긴 놀이 동산에 놀러간 해인이는 잠시 한눈을 판 사이에 친구들을 놓쳤다. 준비성이 철저한 해인이는 미리 자신이 길을 잃을 것을 대비해서 약속 장소를 친구들에게 알려주었기 때문에 그 장소로 가능한 한 빨리 가려고 한다. 놀이동산은  N*M의 격자로 이루어져 있고 각각의 격자를 모두 독특한 행사를 하고 있기 때문에 지나가는데 드는 비용이 다르다. 맨 왼쪽 위의 격자는 (1,1)이고 가장 오른쪽 아래 격자는 (N,M)이다. 그리고 각 격자를 지나가는데 걸리는 비용을 나타난 행렬을 C라고 하면 Cij는 (i,j)번 격자를 지나가려면 1/Cij의 비용이 든다는 것을 의미한다. 
해인이는 격자위의 특정 지점에 있을때 그 지점의 위, 아래, 왼쪽, 오른쪽으로 순식간에 이동할 수 있다.(즉, 시간이 들지 않는다) 
그리고 시간은 0분~1분, 1분~2분, 2분~3분, … 같은 구간으로 나누어 볼 수 있으며 이때 격자를 이동하는데에 한가지 조건이 생긴다. 각 시간 구간에서 거쳤던 격자의 총 비용이 1이하여야 한다.
해인이가 현재 있는 위치 (Sx, Sy)와 약속장소 (Dx, Dy)가 주어지고 행렬 C가 주어진다고 할때 해인이의 현재 위치에서 약속 장소까지 가는데 걸리는 최소의 시간을 구하라.
다음의 예제를 생각해보자. N=1, M=5이고 C = {22334}, Sx = 1, Sy = 1, Dx = 1, Dy = 5라면 놀이동산은 다음과 같은 그림이라고 할 수 있다.

이때 첫 번째 시간 구간 (0분~1분) 에서 위치를 (1,2)까지 갈 수 있다. 왜냐하면 이 구간에 있었던 격자의 총 비용이 ½ + ½ <= 1이기 때문이다. 하지만, (1,3)까지는 ½ + ½ + ⅓ > 1이기 때문에 가지 못한다.

(1분~2분)에서는 (1,3)까지 갈 수 있다. 하지만, (1,4)까지는 갈 수 없다. ½ + ⅓ + ⅓ > 1.

(2분~3분)에서는 (1,5)까지 갈 수 있다. ⅓ + ⅓ + ¼ <= 1
결국 필요한 최소의 시간은 3분이다.
<입력값>
첫 번째 줄에 Test case의 수 T가 주어진다. 그리고 각각의 케이스마다 입력으로 첫 번째 줄에 놀이동산의 크기 정수 N, M이 주어진다. ( 1<= N , M <= 50 인 ). 두 번째 줄에는 N개의 줄에 걸쳐서 행렬 C가 주어진다. N+2 번째 줄에는 정수 Sx, Sy, Dx, Dy가 주어진다. ( 1 <= Sx, Dx <= N,  1 <=Sy, Dy <= M ).
<출력값>
각각의 Test case에 대해서 해인이의 현재 위치에서 목표 위치까지 가는데 필요한 최소 시간을 출력하라. 목표 위치까지 갈 수 없는 경우에는 -1을 출력한다.

<문제 2782>
옛날에 왕비를 매우 사랑하는 왕이 살았다. 하루는 왕비를 기쁘게 해주고 싶은 왕은 왕비를 위해 깜짝 파티를 해주기로 했다. 왕비 몰래 파티 준비를 하던 왕은 파티가 시작되기 몇 시간을 앞두고 자신이 왕비에게 줄 선물을 깜빡 했다는 사실을 깨달았다. 왕은 절망했지만 다행히 왕과 왕비가 사는 주변에는 선물 나무라는 것이 자라서 선물을 구할 수 있다는 사실이 떠올랐다. 왕비를 사랑하는 왕은 선물을 가능한 많이 따다 주고 싶었지만, 왕은 운동을 전혀 하지 않는 사람이라 선물을 많이 딸 수록 발걸음이 느려진다. 주어진 왕이 왕비에게 줄 수 있는 최대 선물의 개수를 알아 보자.(왕은 시작한 곳에서 왕비가 있는 곳까지 주어진 시간 이내 반드시 가야 한다. 또한 왕은 기본적으로 1시간에 한 칸씩 이동하는데, 선물 q개를 가지고는 한 칸에 (q+1)시간이 걸린다. 선물을 가지러 갈 때 왕비를 지나쳐도 괜찮다.)
<입력값>
첫째 줄에 test case T가 주어진다. 둘째 줄부터 도시 지도의 세로, 가로 크기와 주어진 시간이 주어진다. 그 다음 줄에는 도시의 지도가 주어진다. Q는 왕비가 있는 성이고, K은 지금 왕이 있는 위치이다. G는 선물 나무의 위치이고 .은 그냥 길, #은 가지 못하는 길이다.  이 도시의 크기는 가로, 세로 최소 1부터 최대 50까지 가능하다. 선물 나무 G는 한 도시에 0~16개까지 자랄 수 있다. 항상 왕비가 있는 곳으로 갈 수 있는 경우만 입력으로 주어진다.
<출력값>
왕이 가지고 올 수 있는 최대의 선물 개수를 출력한다.

<문제 2783>
유명 편의점 체인점 세븐25는 삼각 김밥을 전국에서 가장 싸게 판매하고 있다. 
이 회사의 직원들은 삼각 김밥의 가격을 전국 최저가를 유지하기 위해 매일 근처의 편의점을 방문한다. 그리고 나서 세븐25의 삼각 김밥보다 싼 가격을 발견하면, 삼각 김밥의 가격을 그 가격으로 바꿔 최저가를 유지한다.
매일 아침, 점심, 저녁으로 삼각 김밥을 먹는 상근이와 정인이는 정말 세븐25가 제일 싼지 궁금해졌다. 
이들은 학교 근처에 있는 세븐 25와 세븐 25를 제외한 서로 다른 N개의 편의점 체인을 방문 할 것이다. 이 편의점을 방문하면서 세븐25보다 싼 삼각김밥을 찾을 것이다. 또, 전체 편의점에서 가장 싼 삼각 김밥은 어디인지 찾을 것이다.
어느 편의점의 삼각 김밥이 제일 싼지 고객들이 쉽게 알지 못하기 하기 위해서, 모든 편의점은 삼각 김밥의 가격을 다음과 같이 표시한다. "삼각 김밥 Y그램 당 X원"
상근이와 정인이는 삼각 김밥을 1,000그램 살 것이다.
세븐 25의 삼각 김밥 가격과, 다른 N개 편의점의 삼각 김밥 가격이 주어졌을 때, 1,000그램의 삼각 김밥을 가장 싸게 사려면 얼마면 되는지 구하는 프로그램을 작성하시오.
삼각 김밥은 여러 군데에서 돌아가면서 사도 되고, 세븐 25와 N개 편의점 이외의 다른 곳에서는 살 수 없다.
<입력값>
첫째 줄에 세븐25의 삼각 김밥 가격 정보 X와 Y가 주어진다. (Y그램 당 X원) (1 ≤ X ≤ 100, 1 ≤ Y ≤ 1,000)
둘째 줄에는 세븐25를 제외한 편의점의 개수 N이 주어진다. (1 ≤ N ≤ 100)
다음 N개의 줄에는 i번째 편의점의 삼각 김밥 가격 정보 Xi와 Yi가 주어진다. (Yi그램 당 Xi원) (1 ≤ Xi ≤ 100, 1 ≤ Yi ≤ 1,000)
<출력값>
첫째 줄에 삼각 김밥 1,000그램 가격의 최저가를 출력한다. 정답과의 오차는 0.01까지 허용한다.

<문제 2784>
아래와 같은 가로 세로 퍼즐을 풀어보자.

가로줄

device used to cool a PC
solid water
to obtain

세로줄

small, soft, sweet fruit
strong playing card
fisherman's tool

6개의 단어가 주어졌을 때, 이를 가지고 가로 세로 퍼즐을 만드는 프로그램을 작성하시오. 단어 3개는 가로줄, 3개는 세로줄로 배치해야한다.
<입력값>
6개의 줄에 알파벳 대문자로 이루어진 단어가 주어진다. 이 단어는 사전순으로 정렬되어 있다.
<출력값>
6개 단어를 3*3 가로 세로 퍼즐에 놓을 수 없다면 0을 출력한다. 그렇지 않다면, 3개 줄에 퍼즐을 출력한다. 만약 가능한 답이 여러개라면 사전순으로 앞서는 것을 출력한다. 사전순으로 비교를 할 때는, 모두 한 줄로 이어붙인 9개의 단어를 생각하면 된다.

<문제 2785>
희원이는 그의 다락방에서 N개의 체인을 찾았다. 각각의 체인은 몇 개의 고리로 연결되어 있는데, 각각의 고리는 최대 두 개의 인접한 고리를 가질 수 있다. 각각의 고리는 열고 닫을 수 있다. 그래서, 체인을 분리하거나 두 체인을 연결하여 하나의 긴 체인으로 만들 수 있다. 희원이는 가능한 한 적은 고리를 열고 닫아서, 모든 체인을 하나의 긴 체인으로 연결하려고 한다.
예를 들어, 희원이가 세 개의 체인을 가지고 있고, 각 체인이 고리 하나로만 이루어져 있다면, 그 중 하나를 열어서 나머지 두 개를 연결하고 닫으면 된다.

체인의 개수와 각각의 체인의 길이가 주어지면, 하나의 긴 체인으로 모든 체인을 묶기 위해 희원이가 열고 닫아야할 최소한의 고리 수를 찾아라.
<입력값>
첫 번째 줄에는 체인의 개수를 나타내는 양의 정수 N (2 ≤ N ≤ 500000)이 주어진다. 두 번째 줄에는 각각의 체인의 길이를 나타내는 N개의 양의 정수 Li(1 ≤ Li ≤ 1000000)가 주어진다.
<출력값>
첫째 줄에 필요한 고리의 최소 개수를 출력한다.

<문제 2786>
상근이는 도서관에서 번 돈으로 서강대 곤자가 플라자에 레스토랑을 하나 열었다. 이 레스토랑에는 음식을 N종류 팔고 있고, 손님은 서로 다른 음식을 여러개 시킬 수 있다. 이때, 음식을 시키는 순서가 중요하다. 그 이유는 각 음식을 첫 번째로 시킬 때의 가격과 아닐 때의 가격이 다르기 때문이다. 즉, 모든 음식 i의 가격은 첫 번째로 시킬 때의 가격 Ai와 아닐 때의 가격 Bi 두가지가 있다.
배가 고픈 창영이는 상근이네 레스토랑에서 음식을 시켜먹으려고 한다. 이때, 1개, 2개, ..., N개 시킬 때 필요한 최소 가격을 각각 구하는 프로그램을 작성하시오. 같은 종류 음식을 여러 번 중복해서 주문할 수 없다.
<입력값>
첫째 줄에 상근이네 레스토랑의 음식의 개수 N(2 ≤ N ≤ 500,000)이 주어진다. 다음 N개의 줄에는 각 음식의 가격 Ai와 Bi가 주어진다. (0 ≤ Ai, Bi ≤ 1,000,000,000)
<출력값>
출력은 총 N개로 이루어져 있다. i번째 줄에는 음식을 i개 시킬 때 필요한 최소 가격을 출력한다.

<문제 2787>
수업시간이 너무나 지루했던 태석이는 종이에 길이가 N인 수열 A를 적었다. 이 수열은 1보다 크거나 같고, N보다 작거나 같은 양의 정수로 이루어져 있고, 각 숫자는 정확히 한 번씩 등장한다.
그런 다음 태석이는 다른 종이에 수열 A에 대한 설명을 M개 적었다.
각 설명은 다음과 같은 형태로 되어있다.

1 x y v - x번째 수부터, y번째 수 중 제일 큰 값은 v
2 x y v - x번째 수부터, y번째 수 중 제일 작은 값은 v

태석이는 설명만 적은 종이를 보성이에게 주었다. 보성이는 M개의 설명만 가지고 태석이가 원래 적은 수열을 맞추어보려고 한다.
M개의 설명이 주어졌을 때, 태석이가 원래 적은 수열을 구해 출력하는 프로그램을 작성하시오. 수열은 여러개 존재할 수 있다.
<입력값>
첫째 줄에 수열의 크기 N과 설명의 개수 M이 주어진다. (1<=N<=200, 0<=M<=40,000) 둘째 줄부터 M개의 줄에는 태석이의 설명이 문제 설명과 같은 형식으로 주어진다.
<출력값>
첫째 줄에 태석이가 원래 적은 수 N개를 공백으로 구분하여 출력한다. 만약 태석이의 설명과 일치하는 수열이 없다면 -1을 출력한다.

<문제 2788>
요즘 한국에는 스타트업 열풍이 불고 있다. 상근이는 스타트업에게 사무실을 빌려주는 스타트업을 시작했다. 사무실은 총 N개가 있다. 가장 왼쪽에 있는 사무실은 1번, 가장 오른쪽은 N번이며, 그 사이 사무실은 순서대로 번호가 매겨져 있다. 
처음에 사무실은 모두 비어있다. 사무실에 회사가 입주할 때, 회사는 상근이에게 다음과 같은 네 가지 정보를 알려주어야 한다.

T: 입주일 (상근이가 스타트업을 시작한 날이 1일이다)
K: 사무실 번호
Z: 하루 수익 (회사가 손해를 보고있다면 음수일 수도 있다)
S: 입주일 당시에 그 회사가 가지고 있는 금액

만약 입주하려고 하는 사무실 K에 이미 회사가 있다면, K에 있던 회사는 짐을 싸서 사무실을 비워야 한다. 또, 입주하는 날은 하루종일 이사를 해야 하기 때문에, 일을 하지 않아서 수익을 올리지 않는다.
놀랍게도 이 사무실에 입주한 회사는 매일 매일 Z만큼 수익을 올리며, 이 금액은 늘어나지도, 줄어들지도 않는다.
가끔 상근이는 가장 부유한 회사가 어디인지 알아본다. 항상 연속으로 붙어있는 사무실을 조사하며, 다음과 같이 나타낼 수 있다.

T: 조사하는 날 (상근이가 스타트업을 시작한 날이 1일)
A와 B: A번 사무실부터 B번까지 조사

상근이는 항상 입주한 회사의 모든 업무가 끝난 다음에 조사를 한다. (사무실에서 밤 8시가 넘었는데 일을 할 수 없다) 따라서, 각 회사가 하루에 버는 수익은 항상 입주할 때 보고한 금액이다.
이벤트의 정보가 주어졌을 때, 조사에 대한 답을 구하는 프로그램을 작성하시오. 회사가 입주하는 정보와 상근이가 조사하는 정보를 합쳐서 이벤트라고 한다.
<입력값>
첫째 줄에 사무실의 개수 N과 이벤트의 개수 M이 주어진다. (1 ≤ N ≤ 100,000, 1 ≤ M ≤ 300,000)
다음 M개 줄에는 이벤트의 정보가 주어진다. 회사의 입주는 "1 T K Z S"와 같이 주어지며, 상근이의 조사는 "2 T A B"로 주어진다.
모든 이벤트는 일어난 순서대로 주어진며, 하루에 일어나는 이벤트는 최대 한 개 이다. 따라서, T가 항상 증가하는 순서로 주어진다. 마지막 이벤트가 일어난 날은 106보다 작으며, Z와 S의 절댓값도 106보다 작다.
<출력값>
상근이의 질문에 대한 답(주어진 구간에 포함 되는 가장 부유한 회사가 가지고 있는 금액)을 한 줄에 하나씩 출력한다. 만약, 그 구간에 있는 회사가 하나도 없다면, "nema"를 출력한다.

<문제 2789>
아주 멀리 떨어져 있는 작은 나라가 있다. 이 나라에서 가장 공부를 잘하는 학생들은 모두 다른 나라로 유학을 간다. 정부는 최고의 학생들이 자꾸 유학을 가는 이유를 찾으려고 했다. 하지만, 학생들의 이유가 모두 달랐기 때문에 정확한 이유를 찾을 수 없었다. 정부의 고위직은 뛰어난 학생들이 자꾸 유학을 가는 현상을 매우 불쾌해 했다.

	가장 많은 학생들이 유학을 가는 대학교는 영국의 캠브리지 대학교이다. 정부는 인터넷 검열을 통해서 해외로 나가는 이메일의 내용 중 일부를 삭제하기로 했다. 이메일의 각 단어 중에서 CAMBRIDGE에 포함된 알파벳은 모두 지우기로 했다. 즉, 어떤 이메일에 LOVA란 단어가 있다면, A는 CAMBRIDGE에 포함된 알파벳이기 때문에, 받아보는 사람은 LOV로 받는다.

	이렇게, 어떤 단어가 주어졌을 때, 검열을 거친 후에는 어떤 단어가 되는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 알파벳 대문자로 이루어진 단어가 주어진다. 이 단어는 적어도 3글자이며, 많아야 100글자이다.
<출력값>
입력으로 주어진 단어를 정부가 검열을 하면 어떻게 변하는지를 출력한다. 즉, 단어에서 CAMBRIDGE에 포함된 알파벳을 모두 지운 뒤 출력한다. 항상 정답의 길이는 0보다 크다.

<문제 2790>
권위를 자랑하는 레이싱 대회 F7이 열릴 예정이다. F7은 드라이버의 순위가 자주 바뀌기 때문에 사람들에게 인기가 아주 많다. 상근이는 F7 레이싱의 엄청난 팬이지만, 마지막 레이싱과 중간고사가 겹쳐서 갈 수 없게 되었다.
지금은 마지막 레이싱을 제외한 나머지 레이싱이 모두 종료된 상황이다. 상근이는 우승을 할 수 있는 사람의 수를 알아보려고 한다. F7의 우승자는 각 레이싱을 통해서 얻은 점수의 합이며, 점수가 가장 높은 사람이 우승을 하게 된다.
마지막 레이싱에서 1등을 한 사람은 N점을 얻게 되고, 2등은 N-1점, ..., 꼴등은 1점을 얻게 된다. 각 레이싱에서 두 드라이버의 등수가 같은 경우는 없다.
마지막 레이싱을 하기 바로 전에 각 드라이버의 점수가 주어졌을 때, 우승을 할 가능성이 있는 사람의 수를 구하는 프로그램을 작성하시오. 만약 점수의 합이 가장 큰 사람이 여러 명이라면, 여러명 다 우승자이다.
<입력값>
첫째 줄에 F7에 참가하는 드라이버의 수 N (3 ≤ N ≤ 300,000)이 주어진다.
다음 N개 줄에는 각 드라이버가 마지막 레이싱을 하기 전까지 얻은 점수 Bi가 주어진다. (0 ≤ Bi ≤ 2,000,000, i = 1, ..., N)
<출력값>
첫째 줄에 F7을 우승할 가능성이 있는 사람의 수를 출력한다.

<문제 2792>
보석 공장에서 보석 상자를 유치원에 기증했다. 각각의 보석은 M가지 서로 다른 색상 중 한 색상이다. 원장 선생님은 모든 보석을 N명의 학생들에게 나누어 주려고 한다. 이때, 보석을 받지 못하는 학생이 있어도 된다. 하지만, 학생은 항상 같은 색상의 보석만 가져간다.

	한 아이가 너무 많은 보석을 가져가게 되면, 다른 아이들이 질투를 한다. 원장 선생님은 이런 질투심을 수치화하는데 성공했는데, 질투심은 가장 많은 보석을 가져간 학생이 가지고 있는 보석의 개수이다. 원장 선생님은 질투심이 최소가 되게 보석을 나누어 주려고 한다.

	상자에 빨간 보석이 4개 (RRRR), 파란 보석이 7개 (BBBBBBB) 있었고, 이 보석을 5명의 아이들에게 나누어 주는 경우를 생각해보자. RR, RR, BB, BB, BBB로 보석을 나누어주면 질투심은 3이 되고, 이 값보다 작게 나누어 줄 수 없다.

	상자 안의 보석 정보와 학생의 수가 주어졌을 때, 질투심이 최소가 되게 보석을 나누어주는 방법을 알아내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 아이들의 수 N과 색상의 수 M이 주어진다. (1 ≤ N ≤ 109, 1 ≤ M ≤ 300,000, M ≤ N)

	다음 M개 줄에는 구간 [1, 109]에 포함되는 양의 정수가 하나씩 주어진다. K번째 줄에 주어지는 숫자는 K번 색상 보석의 개수이다.
<출력값>
첫째 줄에 질투심의 최솟값을 출력한다.

<문제 2793>
양의 정수 N이 있을 때, N을 나눌 수 없는 가장 작은 수 A를 찾을 수 있다. 예를 들어, 6은 4로 나누어 떨어지지 않으므로, A는 4가 된다.

	이렇게 A를 찾은 다음, 그 수를 다시 N이라고 하고, 나눌 수 없는 가장 작은 수 A를 찾는 것을 계속해서 한다면, 결국에는 A는 2가 된다.

	N이 2가 된다면, 더이상 찾지 않고 여기서 그만한다.

	우리는 이런 성질을 이용해서 strength(N)을 위의 방법에서 나온 N의 수열의 길이로 정의할 수 있다.

	예를 들어, N=6이라면 6, 4, 3, 2를 얻을 수 있으므로, strength(6) = 4가 된다.

	두 양의 정수 A < B가 주어졌을 때, A와 B를 포함하여 그 사이에 있는 숫자의 힘의 합을 구하는 프로그램을 작성하시오.

	strength(A) + strength(A+1) + ... + strength(B)
<입력값>
첫째 줄에 두 정수 A와 B가 주어진다. (3 <= A < B < 1017)
<출력값>
첫째 줄에 A와 B를 포함하여 그 사이에 있는 숫자의 합을 출력한다.

<문제 2794>
과학자들은 화성에서 특이한 박테리아를 발견했고, 열심히 조사하고 있다. 그들은 박테리아의 개수가 2의 제곱수인 것을 알아챘다. 그것은 이들이 1개의 박테리아에서 시작되고, 각 박테리아는 매 세대 2개의 박테리아로 분열하기 때문이다(원래의 박테리아는 없어지는 꼴이다).
즉, 1세대는 하나의 박테리아, 2세대는 첫 세대의 박테리아가 둘로 나누어진 두 박테리아, 3세대는 또 그것이 나누어진 네 개의 박테리아, 4세대는 여덟 개, 이런 식으로 K+1세대에는 2k개의 박테리아가 있는 것을 알게 되었다.
과학자들은 그들이 찾아낸 박테리아를 1부터 2K까지 다음과 같이 번호 붙였다.

이전의 K세대의 박테리아들의 후손은: {1, 2}, {3, 4}, {5, 6}, ..., {2K-1, 2K}
더욱 전의 (K-1)세대의 박테리아들의 후손은: {1, 2, 3, 4}, {5, 6, 7, 8}, ..., {2K-3, 2K-2, 2K-1, 2K}
훨씬 더욱 전의 (K-2)세대의 박테리아들의 후손은: {1, 2, 3, 4, 5, 6, 7, 8}, ..., {2K-7, 2K-6, 2K-5, 2K-4, 2K-3, 2K-2, 2K-1, 2K}
...
2세대의 두 박테리아의 후손은: {1, 2, ..., 2K-1}와 {2K-1 + 1, 2K-1 + 2, ..., 2K}

중괄호는 이들이 한 박테리아의 후손들이라는 뜻이다. 즉 어떤 조상 박테리아의 후손도 연속된 번호를 가지고 있도록 번호붙여졌다.
이때 박테리아의 순서를 바꾸더라도 여전히 위의 규칙을 만족하게 할 수 있는데, 과학자들은 그런 순서들 중 '순열의 길이'를 최소화하는 규칙을 찾으려 한다. '순열의 길이'는 이웃한 박테리아 사이의 거리를 모두 합한 것으로 정의된다.
정확히는, 모든 두 박테리아 사이에는 반발력이 존재하는데, 이 반발력은 수치로 나타내어진다. 두 박테리아 사이의 반발력은 두 박테리아가 서로 이웃해 있을 때 떨어져야 하는 최소 길이이다(두 박테리아가 이웃하지 않는다면 반발력은 아무 효과도 미치지 않는다). 모든 박테리아 쌍들의 반발력이 주어질 때, 이들을 앞서 말한 규칙을 지키면서 나열할 수 있는 최소의 길이를 구하시오.
<입력값>
입력의 첫 줄에는 문제에서 언급한 양수 K가 주어진다(1 ≤ K ≤ 9).
그 후의 2K개의 줄에는 [0, 106] 범위에 있는 2K개의 자연수가 주어진다. 2K × 2K개의 숫자는 박테리아 쌍들 사이의 반발력을 뜻한다: 여기서 (m, n)에 있는 숫자는 박테리아 m과 n 사이의 반발력을 뜻한다. (m, n)과 (n, m)에는 같은 숫자가 들어가고, m = n일 때는 0이다.
<출력값>
조건을 만족하면서 박테리아를 나열하는 최소의 길이만을 출력하라.

<문제 2795>
성공한 벤쳐회사 "봉씨"의 사장 연종이는 사업을 미국으로 확장하기로 결정했다.

	봉씨는 LA에 있는 투자자들을 만나기 위해 미국으로 출발했다. 하지만, 비행기를 내리고 보니 그곳은 LA가 아니었다. 연종이의 비서는 아는 미국 도시가 뉴욕밖에 없었기 때문에, 당연히 사장의 항공편을 뉴욕행으로 예약한 것이다.

	연종이는 LA까지 가는 비용을 최대한 줄이려고 한다. 따라서, 그는 비행기를 타는 대신에 차를 빌려서 이동할 것이다.

	미국에는 N개의 도시가 있고, 각 도시는 1번부터 N번까지 번호가 매겨져 있다. 또, M개의 도로가 있다. 도로는 두 도시를 연결하며, 한 방향으로만 움직일 수 있다.

	뉴욕의 도시 번호는 1번이고, LA의 번호는 2번이다. 

	연종이의 회사는 구글을 넘는 가치를 지니고 있기 때문에, 연종이가 방문하는 도시에 경호원을 고용하려고 한다. 이때, 고용해야하는 경호원의 수를 최소화하는 프로그램을 작성하시오. 어떤 도시에서 경호원을 고용하면, 몇 번을 방문하더라도 재고용하지 않아도 된다. 연종이는 뉴욕에서 출발해서 LA를 방문했다가 다시 뉴욕으로 돌아온다.
<입력값>
첫째 줄에는 N과 M이 주어진다. (2 ≤ N ≤ 100, 2 ≤ M ≤ 200)

	다음 M개의 줄에는 서로 다른 정수 A와 B가 주어진다. (1 ≤ A, B ≤ N) 이 두 숫자는 도로에 대한 정보이고, A에서 B로 가는 도로라는 뜻이다. 같은 도로가 두 번이상 주어지는 경우는 없지만, 반대 방향 도로(B -> A)가 주어질 수는 있다.
<출력값>
첫째 줄에 뉴욕에서 LA로 갔다가, 다시 뉴욕으로 돌아오는 경로 중 고용해야하는 경호원의 수의 최솟값을 출력한다. 항상 답이 존재하는 경우만 입력으로 주어진다.

<문제 2796>
올해 여름에 종혁이는 친구들과 함께 락 페스티벌에 가려고 한다. 종혁이는 친구들의 티켓도 자신이 직접 구매했고, 이제 티켓을 친구들에게 배달하러 가려고 한다.
종혁이와 친구들이 살고 있는 마을은 이차원 평면으로 나타낼 수 있다. 종혁이는 정수 좌표 위에만 서 있을 수 있다. 종혁이가 현재 있는 좌표에서 인접한 여덟 개의 좌표 중 하나로 한 걸음에 이동할 수 있다. (위, 아래, 왼쪽, 오른쪽, 대각선)
종혁이의 친구는 티켓을 받으러 자신의 집에서 조금 걸어 나올 수 있다. 즉, 친구가 살고 있는 집의 좌표가 (x, y)이면, 집에서 P걸음 떨어진 곳까지 종혁이를 마중나올 수 있다. P는 각각의 친구에 따라서 다르다.
티켓을 모두 배달한 후에 종혁이는 배달한 순서를 다시 생각해 보았다. 이때, 종혁이가 걸었던 걸음의 최솟값을 구하는 프로그램을 작성하시오. 종혁이가 배달을 시작한 위치와 끝마친 위치의 좌표는 알 수 없다.
<입력값>
첫째 줄에 친구의 수 N이 주어진다. (2 ≤ N ≤ 200,000)
다음 N개 줄에는 집의 위치 x, y와 P가 주어진다. (0 ≤ x, y, P ≤ 200,000)
종혁이가 티켓을 배달한 순서대로 입력이 주어진다.
<출력값>
첫째 줄에 종혁이가 티켓을 배달하는데 필요한 걸음 수의 최솟값을 출력한다.

<문제 2797>
과외맨은 배트맨, 스파이더맨, 슈퍼맨과 같은 슈퍼 히어로를 따라하는 한국의 대표 영웅이다. 오늘은 스파이더맨을 따라해보려고 한다. 과외맨은 고층 건물의 옥상을 점프하면서 돌아다니려고 한다.
고층 건물은 총 N개가 있고, 왼쪽에서 오른쪽으로 1번부터 N번까지 번호가 매겨져 있다. 지금 과외맨은 K번 건물 위에 있다. 과외맨은 아직 힘이 많이 부족한다. 따라서, 현재 있는 건물의 왼쪽 또는 오른쪽 건물로만 점프해서 이동할 수 있다. 또, 지금 자신이 있는 건물의 높이보다 높지 않은 빌딩으로만 이동할 수 있다.
이런 과외맨을 도와주고 위해서 상근이는 일부 건물의 옥상에 트램폴린을 설치해 놓았다. 과외맨이 트램폴린을 이용해 점프를 한다면 다른 모든 건물로 이동할 수 있고, 건물의 높이와 상관없이 이동할 수 있다.
과외맨이 방문할 수 있는 서로 다른 건물의 개수의 최댓값을 구하는 프로그램을 작성하시오. 과외맨은 점프를 K번 빌딩에서 시작한다. 같은 건물을 여러 번 방문할 때도, 방문한 건물의 개수는 한 개로 센다.
<입력값>
첫째 줄에 건물의 수 N과 점프를 시작하는 건물의 번호 K가 주어진다. (3 ≤ N ≤ 300,000, 1 ≤ K ≤ N)
둘째 줄에는 106보다 작은 N개의 정수가 주어진다. 이 정수는 건물의 높이이며, 1번 건물부터 순서대로 주어진다.
셋째 줄에는 '.' 또는 'T'로 이루어진 N개의 문자가 주어진다. i번째 문자가 'T'인 경우에는 i번 건물의 옥상에 트램폴린이 설치되어 있는 것이다.
<출력값>
첫째 줄에 과외맨이 방문할 수 있는 서로 다른 건물 개수의 최댓값을 출력한다.

<문제 2798>
카지노에서 제일 인기 있는 게임 블랙잭의 규칙은 상당히 쉽다. 카드의 합이 21을 넘지 않는 한도 내에서, 카드의 합을 최대한 크게 만드는 게임이다. 블랙잭은 카지노마다 다양한 규정이 있다.
한국 최고의 블랙잭 고수 김정인은 새로운 블랙잭 규칙을 만들어 상근, 창영이와 게임하려고 한다.
김정인 버전의 블랙잭에서 각 카드에는 양의 정수가 쓰여 있다. 그 다음, 딜러는 N장의 카드를 모두 숫자가 보이도록 바닥에 놓는다. 그런 후에 딜러는 숫자 M을 크게 외친다.
이제 플레이어는 제한된 시간 안에 N장의 카드 중에서 3장의 카드를 골라야 한다. 블랙잭 변형 게임이기 때문에, 플레이어가 고른 카드의 합은 M을 넘지 않으면서 M과 최대한 가깝게 만들어야 한다.
N장의 카드에 써져 있는 숫자가 주어졌을 때, M을 넘지 않으면서 M에 최대한 가까운 카드 3장의 합을 구해 출력하시오.
<입력값>
첫째 줄에 카드의 개수 N(3 ≤ N ≤ 100)과 M(10 ≤ M ≤ 300,000)이 주어진다. 둘째 줄에는 카드에 쓰여 있는 수가 주어지며, 이 값은 100,000을 넘지 않는 양의 정수이다.
합이 M을 넘지 않는 카드 3장을 찾을 수 있는 경우만 입력으로 주어진다.
<출력값>
첫째 줄에 M을 넘지 않으면서 M에 최대한 가까운 카드 3장의 합을 출력한다.

<문제 2799>
봄이 오고 있다. 해는 높이 떠서 환하게 빛나고 있다. 사람들은 햇볕을 가리기 위해 블라인드를 내린다.
상근이는 이웃들이 무엇을 하는지를 염탐하고, 이것에 대해서 뒷담화를 하는 주부이다. 올해는 건너편 아파트에 사는 사람들이 블라인드를 얼마나 내리는지를 조사하려고 한다. 
모든 창문은 4*4 그리드로 나타낼 수 있고, *를 이용해서 블라인드를 나타낸다. 상근이가 볼 수 있는 창문은 다음 5가지 상태 중 하나이다.

건너편 아파트의 한 층에는 N개의 창문이 있고, 총 M층 건물이다. 현재 건너편 아파트의 창문 상태가 주어졌을 때, 위의 5가지 상태가 각각 몇 번 나오는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 M과 N이 공백으로 구분해서 주어진다. (1 ≤ M, N ≤ 100)
다음 줄에는 현재 건너편 아파트의 상태가 주어진다. 모든 창문은 문제 설명에 나온 것 처럼 4*4 그리드로 주어진다. 또, 창문과 창문은 '#'를 이용해서 구분한다. 예제 입력 형식을 참고하면 좋다. 아파트의 정보는 5M+1줄, 각 줄은 5N+1개 글자로 이루어져 있다.
<출력값>
출력은 총 5개 숫자이다. 문제 설명에 나온 순서대로 각 블라인드 타입이 몇 개 있는지를 출력한다. 숫자를 모두 합하면 M*N이 되어야 한다.

<문제 2800>
어떤 수식이 주어졌을 때, 괄호를 제거해서 나올 수 있는 서로 다른 식의 개수를 계산하는 프로그램을 작성하시오.

	이 수식은 괄호가 올바르게 쳐져 있다. 예를 들면, 1+2, (3+4), (3+4*(5+6))와 같은 식은 괄호가 서로 쌍이 맞으므로 올바른 식이다.

	하지만, 1+(2*3, ((2+3)*4 와 같은 식은 쌍이 맞지 않는 괄호가 있으므로 올바른 식이 아니다.

	괄호를 제거할 때는, 항상 쌍이 되는 괄호끼리 제거해야 한다.

	예를들어 (2+(2*2)+2)에서 괄호를 제거하면, (2+2*2+2), 2+(2*2)+2, 2+2*2+2를 만들 수 있다. 하지만, (2+2*2)+2와 2+(2*2+2)는 만들 수 없다. 그 이유는 쌍이 되지 않는 괄호를 제거했기 때문이다.

	어떤 식을 여러 쌍의 괄호가 감쌀 수 있다.
<입력값>
첫째 줄에 음이 아닌 정수로 이루어진 수식이 주어진다. 이 수식은 괄호가 올바르게 쳐져있다. 숫자, '+', '*', '-', '/', '(', ')'로만 이루어져 있다. 수식의 길이는 최대 200이고, 괄호 쌍은 적어도 1개, 많아야 10개이다.
<출력값>
올바른 괄호 쌍을 제거해서 나올 수 있는 서로 다른 식을 사전 순으로 출력한다.

<문제 2802>
창영이는 생일 선물로 크레용 N개를 받았다. 각 크레용의 색은 빨강, 초록, 파랑이 혼합으로 나타낼 수 있다. i번 크레용의 색은 빨강 성분 Ri, 초록 성분 Gi, 파랑 성분 Bi로 나타낼 수 있다.
i번 크레용과 j번 크레용의 거리는 max(|Ri - Rj|, |Gi - Gj|, |Bi - Bj|) 이다. 크레용 여러 개의 채도는 두 크레용의 거리 중 가장 큰 값이다.
창영이는 가지고 있는 크레용 중에서 채도가 가장 작게 되는 크레용 K개를 고르려고 한다. 이때, 어떻게 고르면 채도가 최소가 되는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N과 K가 주어진다. (2 ≤ K ≤ N ≤ 100,000)
다음 N개 줄에는 각 크레용의 색상 성분 Ri, Gi, Bi가 주어진다. (0 ≤ Ri, Gi, Bi ≤ 255)
<출력값>
첫째 줄에 K개를 골랐을 때, 가장 작은 채도를 출력한다. 다음 K개 줄에는 고른 크레용의 R, G, B 성분을 한 줄에 하나씩 출력한다.

<문제 2803>
어젯밤에 나는 어렸을 때 가지고 놀던 장난감 상자 N개를 창고에서 발견했다. 상자를 좀 뒤적여보니 나는 M종류의 장난감을 가지고 있었다. 오랫동안 기억 속에서 잊혀졌던 장난감을 보니, 내가 어렸을 때, 붙여 주었던 이름이 생각난다. 하지만, 그 이름이 모두 기억나지 않는다. 장난감 마다 숫자를 붙여주어야 겠다. 같은 종류 장난감은 모두 같은 번호를 붙이기로 했다. 상자를 살펴보면서 1번부터 M번까지 번호를 붙여주었다.
어렸을적부터 정리정돈의 귀재였던 나는 항상 한 박스에는 한 종류의 장난감을 넣었다. 하지만, 이 상자는 내가 정리한 것이 아닌가보다. 장난감들이 뒤죽박죽 들어가있다. 심지어는 같은 종류의 장난감인데도 여러 상자에 나누어져있는 경우도 있다.
이렇게 어렸을 적 추억에 젖어있다보니 지금 내가 얼머나 순수함을 잃었는지를 생각하게 된다. 장난감을 항상 내 곁에 두어 절대 어렸을 적의 순수함을 잃지 않아야겠다.
내 방은 좁다. 박스를 놓기에는 너무나도 좁다. 일부 박스만 선택해서 내 곁에 두어야 겠다. 하지만, 모든 종류의 장난감이 있어야 나는 순수함을 잃지 않을 것 같다.
모든 종류의 장난감이 선택한 박스 안에 들어있게 박스를 선택하는 방법은 총 몇 가지나 있을까?
<입력값>
첫째 줄에 N과 M이 주어진다. (1 ≤ N ≤ 1,000,000, 1 ≤ M ≤ 20)
다음 N개 줄에는 각 박스에 들어있는 장난감의 종류의 수 Ki와 어떤 종류가 들어있는지 주어진다. 첫 번째 수는 Ki이고, 다음 숫자 Ki개는 장난감 종류이다. (0 ≤ Ki ≤ M)
<출력값>
첫째 줄에 모든 종류의 장난감이 들어있게 박스를 고르는 방법의 수를 1,000,000,007로 나눈 나머지를 출력한다.

<문제 2804>
창영이는 크로스워드 퍼즐을 만들려고 한다.
두 단어 A와 B가 주어진다. A는 가로로 놓여야 하고, B는 세로로 놓여야 한다. 또, 두 단어는 서로 교차해야 한다. (정확히 한 글자를 공유해야 한다) 공유하는 글자는 A와 B에 동시에 포함되어 있는 글자여야 하고, 그런 글자가 여럿인 경우 A에서 제일 먼저 등장하는 글자를 선택한다. 마찬가지로 이 글자가 B에서도 여러 번 등장하면 B에서 제일 처음 나오는 것을 선택한다. 예를 들어, A = "ABBA"이고, B = "CCBB"라면, 아래와 같이 만들 수 있다.

.C..
.C..
ABBA
.B..
<입력값>
첫째 줄에 두 단어 A와 B가 주어진다. 두 단어는 30글자 이내이고, 공백으로 구분되어져 있다. 또, 대문자로만 이루어져 있고, 적어도 한 글자는 두 단어에 포함되어 있다.
<출력값>
A의 길이를 N, B의 길이를 M이라고 했을 때, 출력은 총 M줄이고, 각 줄에는 N개 문자가 있어야 한다. 문제 설명에 나온 것 같이 두 단어가 교차된 형태로 출력되어야 한다. 나머지 글자는 '.'로 출력한다.

<문제 2805>
상근이는 나무 M미터가 필요하다. 근처에 나무를 구입할 곳이 모두 망해버렸기 때문에, 정부에 벌목 허가를 요청했다. 정부는 상근이네 집 근처의 나무 한 줄에 대한 벌목 허가를 내주었고, 상근이는 새로 구입한 목재절단기를 이용해서 나무를 구할것이다.
목재절단기는 다음과 같이 동작한다. 먼저, 상근이는 절단기에 높이 H를 지정해야 한다. 높이를 지정하면 톱날이 땅으로부터 H미터 위로 올라간다. 그 다음, 한 줄에 연속해있는 나무를 모두 절단해버린다. 따라서, 높이가 H보다 큰 나무는 H 위의 부분이 잘릴 것이고, 낮은 나무는 잘리지 않을 것이다. 예를 들어, 한 줄에 연속해있는 나무의 높이가 20, 15, 10, 17이라고 하자. 상근이가 높이를 15로 지정했다면, 나무를 자른 뒤의 높이는 15, 15, 10, 15가 될 것이고, 상근이는 길이가 5인 나무와 2인 나무를 들고 집에 갈 것이다. (총 7미터를 집에 들고 간다) 절단기에 설정할 수 있는 높이는 양의 정수 또는 0이다.
상근이는 환경에 매우 관심이 많기 때문에, 나무를 필요한 만큼만 집으로 가져가려고 한다. 이때, 적어도 M미터의 나무를 집에 가져가기 위해서 절단기에 설정할 수 있는 높이의 최댓값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 나무의 수 N과 상근이가 집으로 가져가려고 하는 나무의 길이 M이 주어진다. (1 ≤ N ≤ 1,000,000, 1 ≤ M ≤ 2,000,000,000)
둘째 줄에는 나무의 높이가 주어진다. 나무의 높이의 합은 항상 M보다 크거나 같기 때문에, 상근이는 집에 필요한 나무를 항상 가져갈 수 있다. 높이는 1,000,000,000보다 작거나 같은 양의 정수 또는 0이다.
<출력값>
적어도 M미터의 나무를 집에 가져가기 위해서 절단기에 설정할 수 있는 높이의 최댓값을 출력한다.

<문제 2806>
국내 생물학자들은 기존에 보지 못했던 신기한 DNA 분자를 발견했다. 이 분자는 A와 B로만 이루어진 N글자로 나타낼 수 있다. 이 분자는 계속해서 돌연변이를 한 다음에, A로만 된 분자로 변한다.

	어느 날, 이 분자를 연구하던 학자들은 두 종류의 돌연변이를 일으킨다는 사실을 알아내었다. 첫 번째 돌연변이는 분자의 한 글자가 다른 글자로 바뀌는 것이다. (A -> B 또는 B -> A) 두 번째 돌연변이는 첫 K개 글자를 모두 다른 글자로 바꾸는 것이다

	DNA 분자가 주어졌을 때, 돌연변이를 최소 몇 번 일으키면, 전부 A로 된 분자가 되는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 분자의 길이 N이 주어진다. (1 ≤ N ≤ 1,000,000)

	둘째 줄에는 분자를 이루는 N글자가 주어진다.
<출력값>
첫째 줄에 최소 몇 번 돌연변이를 일으키면 A로만 된 분자가 되는지 출력한다.

<문제 2807>
상근이는 전 세계에 존재하는 모든 크로스워드 퍼즐을 풀었다. 더 이상 풀 퍼즐이 없기 때문에, 새로운 퍼즐을 만들려고 한다.
단어의 길이가 같은 네 단어를 이용해서 정사각형 모양의 크로스워드 퍼즐을 만들 수 있다. 가로로 놓인 단어는 왼쪽부터 오른쪽으로 읽고, 세로로 놓은 단어는 위에서 아래로 읽는다. 아래 그림은 "HLAD", "NIVA", "HSIN", "DEDA"를 이용해서 만든 크로스워드 퍼즐의 한 예이다.

길이가 모두 같은 단어가 여러개 주어졌을 때, 서로 다른 정사각형 모양의 크로스워드 퍼즐을 몇 개나 만들 수 있는지 구하는 프로그램을 작성하시오. 한 단어는 꼭 한 번만 사용해야 한다. 두 정사각형이 적어도 한 위치에서 문자가 다르다면, 두 크로스워드퍼즐은 다른 퍼즐이다.
<입력값>
첫째 줄에 단어의 개수 N이 주어진다. (4 ≤ N ≤ 100,000) 다음 N개 줄에는 알파벳 대문자로만 이루어진 단어가 주어진다. 단어의 길이는 모두 같으며, 10글자 이내이다. 입력 되는 모든 단어들은 서로 다르다.
<출력값>
첫째 줄에 입력으로 주어진 단어를 이용해서 서로 다른 크로스워드 퍼즐을 몇 개나 만들 수 있는지 출력한다.

<문제 2808>
질량이 mi, 길이가 2, 높이가 h인 직사각형이 N개가 있다. 이 직사각형은 2차원 평면에 다음과 같이 쌓여져 있다.

직사각형의 변은 모두 축에 평행하다.
직사각형 아랫변의 y좌표는 모두 다르고, 다음이 0, h, 2h, 3h, ..., (N-1)h값을 갖는다.
가장 아래에 있는 직사각형의 왼쪽 아래 좌표는 (-2,0)이고, 오른쪽 아래의 좌표는 (0,0)이다.


직사각형의 x중심은 아랫변의 중점이다.
하나 또는 그 이상 직사각형의 무게중심은 직사각형의 x좌표와 무게를 이용해서 아래와 같이 계산할 수 있다.

각 직사각형 A보다 위에 있는 직사각형의 무게중심과 A의 x중심의 거리가 많아야 1이 되도록 직사각형을 쌓는다면, 안정한 쌓기라고 한다.
직사각형을 안정하게 쌓는다면, 직사각형은 무너지지 않을 것이다. 왼쪽 그림은 안정한 배치가 아니다. 그 이유는 가장 위의 두 직사각형의 무게중심과 바로 아래있는 직사각형의 x중심의 거리가 1을 넘기 때문이다. 오른족 그림은 안정한 쌓기이다.
모든 직사각형의 질량이 주어졌을 때, 모든 직사각형의 꼭짓점 중 가장 오른쪽에 있는 꼭짓점이 크게 쌓는 방법을 구하는 프로그램을 작성하시오. 이때, 직사각형은 안정한 쌓기이어야 하고, 입력으로 주어진 순서대로 쌓아야 한다.
<입력값>
첫째 줄에 직사각형의 개수 N이 주어진다. (2 ≤ N ≤ 300,000)
다음 N개 줄에는 직사각형의 질량이 아래 직사각형부터 위 직사각형까지 순서대로 주어진다. 질량은 10,000보다 작거나 같은 양의 정수이다.
<출력값>
첫째 줄에 안정하게 쌓는 방법 중에서 가장 오른쪽 꼭짓점이 클 때의 오른쪽 꼭짓점의 x좌표를 출력한다. 정답과의 오차는 0.000001까지 허용한다.

<문제 2809>
상근이네 집 앞의 아스키 거리는 알파벳 소문자가 적혀 있는 타일 N개로 이루어져 있다. 정부는 알 수 없는 이유 때문에 거리의 타일을 자주 바꾼다. 하지만, 글자가 적혀있는 타일은 공급이 수요를 따라갈 수 없기 때문에 정부는 M종류의 묶음 타일만 사용할 수 있다.
i번째 묶음 타일은 Li개의 글자로 이루어져 있다. 묶음 타일은 회전하거나 조각으로 나눌 수 없다. 또, 거리와 연속해서 글자가 모두 일치하는 경우에만 그 묶음을 사용해서 타일을 교체할 수 있다. 타일은 겹쳐도 상관없고, 한 묶음을 여러 번 사용해도 된다.
현재 거리에 쓰여 있는 타일과 묶음 타일의 정보가 주어졌을 때, 그 어떤 타일로도 바꿀 수 없는 칸의 수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 거리의 길이 N이 주어진다. 다음 줄에는 거리에 원래 적혀져있는 알파벳이 주어진다. 셋째 줄에는 묶음 타일의 종류의 개수 M이 주어진다. 다음 M개 줄에는 각 묶음 타일에 적혀져있는 알파벳이 주어진다. (1 ≤ N ≤ 300,000, 1 ≤ M ≤ 5000, 1 ≤ 각 묶음 타일의 길이 ≤ 5000)
<출력값>
첫째 줄에 그 어떤 묶음 타일로도 바꿀 수 없는 타일의 개수를 출력한다.

<문제 2810>
십년이면 강산이 변한다.
강산이네 동네에 드디어 극장이 생겼고, 강산이는 극장에 놀러갔다. 매점에서 콜라를 산 뒤, 자리에 앉은 강산이는 큰 혼란에 빠졌다. 양쪽 컵홀더를 이미 옆 사람들이 차지했기 때문에 콜라를 꽂을 컵 홀더가 없었기 때문이다. 영화를 보는 내내 콜라를 손에 들고 있던 강산이는 극장에 다시 왔을 때는 꼭 콜라를 컵 홀더에 놓겠다는 다짐을 한 후 집에 돌아갔다.
극장의 한 줄에는 자리가 N개가 있다. 서로 인접한 좌석 사이에는 컵홀더가 하나씩 있고, 양 끝 좌석에는 컵홀더가 하나씩 더 있다. 또, 이 극장에는 커플석이 있다. 커플석 사이에는 컵홀더가 없다.
극장의 한 줄의 정보가 주어진다. 이때, 이 줄에 사람들이 모두 앉았을 때, 컵홀더에 컵을 꽂을 수 있는 최대 사람의 수를 구하는 프로그램을 작성하시오. 모든 사람은 컵을 한 개만 들고 있고, 자신의 좌석의 양 옆에 있는 컵홀더에만 컵을 꽂을 수 있다.
S는 일반 좌석, L은 커플석을 의미하며, L은 항상 두개씩 쌍으로 주어진다.
어떤 좌석의 배치가 SLLLLSSLL일때, 컵홀더를 *로 표시하면 아래와 같다.

*S*LL*LL*S*S*LL*
위의 예에서 적어도 두 명은 컵홀더를 사용할 수 없다.
<입력값>
첫째 줄에 좌석의 수 N이 주어진다. (1 ≤ N ≤ 50) 둘째 줄에는 좌석의 정보가 주어진다.
<출력값>
컵을 컵홀더에 놓을 수 있는 최대 사람의 수를 출력한다.

<문제 2811>
민균이와 상범이는 오래된 연인이다.
요즘따라 냉랭해진 상범이의 태도를 본 민균이는 상범이의 기분을 예측한 다음, 상범이가 우울해지기 전에 꽃을 선물함으로써 그의 기분을 상큼하게 만들어주려고 한다.
상범이의 기분은 하루씩 정수로 표현되는데, 기분이 좋은 날은 양수로 표현되고 우울한 날은 음수로 표현된다. (따라서 음수만 나타나는 연속적인 구간을 '우울한 기간' 또는 '우울 기간'이라고 한다)
한편, 상범이의 우울 기간의 길이가 T일 땐, 구간의 시작으로부터 2T일 전부터 구간의 시작 바로 전날까지 꽃을 선물해야 그의 우울함을 덜어줄 수 있다. 주의해야 할 점은 길이가 가장 긴 우울 구간의 경우에는 2T일 이전이 아닌 3T일 이전부터 꽃을 선물해야 한다는 점이다. 현재부터 가장 빠른 상범이의 우울기간을 T_f 라고 하자. 만약 현재부터 계속해서 꽃을 선물해도 가장 빠른 상범이의 우울기간까지 2 * T_f 만큼 꽃을 선물할 수 없다고 하더라고 줄 수 있는만큼 꽃을 줘야 한다. (단, 이런 최장 우울 구간이 여러 개인 경우에는 그중 한 구간만 이렇게 하면 되고, 나머지 구간은 2T로 적용하면 된다)
민균이가 예측한 앞으로 N일간의 상범이의 기분이 주어졌을 때, 이 N일 중 그가 상범이에게 꽃을 줘야하는 날의 수(사야 하는 꽃의 개수)의 최댓값을 구해보자.
<입력값>
첫 번째 줄에는 예측한 날의 수 N (1 ≤ N ≤ 100,000)이 주어진다.
두 번째 줄에는 상범이의 기분을 나타내는 N개의 정수(|기분| ≤ 100)가 주어진다.
<출력값>
민균이가 상범이에게 꽃을 주어야하는 날의 최댓값을 출력한다.

<문제 2812>
N자리 숫자가 주어졌을 때, 여기서 숫자 K개를 지워서 얻을 수 있는 가장 큰 수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N과 K가 주어진다. (1 ≤ K < N ≤ 500,000)

	둘째 줄에 N자리 숫자가 주어진다. 이 수는 0으로 시작하지 않는다.
<출력값>
입력으로 주어진 숫자에서 K개를 지웠을 때 얻을 수 있는 가장 큰 수를 출력한다.

<문제 2813>
상근이네 마을의 울타리는 모두 높이가 다른 N개의 판자로 만든다. 상근이는 아직 울타리를 가지고 있지 않았기 때문에, 이번 기회에 만들기로 했다.
나무 판자는 109보다 작은 양의 정수로 나타낼 수 있다. 이 정수는 판자의 높이를 나타낸다.
울타리의 매력도는 인접한 판자의 높이 차이의 합이다.
상근이는 이미 나무 판자를 상점에서 사왔다. 하지만, 어떠한 순서로 울타리를 만들어야 하는지 결정하지 못했다. 결국 상근이는 동규의 울타리와 비슷하게 울타리를 만들려고 한다. 그러면서 매력도를 가능한 크게 만들려고 한다.
인접한 두 나무 판자의 높이의 대소관계가 일치한다면, 두 울타리가 비슷하다고 한다. 즉, 두 울타리 모두 i번 판자가 (i+1)번 판자보다 커야(작아야) 한다.
동규의 울타리의 높이와 상근이가 구매한 나무 판자의 높이가 주어졌을 때, 동규의 울타리와 비슷하면서 매력도가 가장 큰 울타리를 만드는 프로그램을 작성하시오.
상근이의 울타리의 높이가 모두 각각 다르고, 동규의 울타리의 높이가 모두 각각 다르다.
<입력값>
첫째 줄에 N이 주어진다. (2 ≤ N ≤ 300,000)
둘째 줄에 동규의 울타리를 구성하는 판자의 높이가 주어진다.
셋째 줄에 상근이가 구매한 판자의 높이가 주어진다.
<출력값>
첫째 줄에 상근이의 울타리의 매력도를 출력한다.
둘째 줄에 상근이의 울타리를 구성하는 나무 판자의 높이를 공백으로 구분해 출력한다.

<문제 2814>
가장 작은 소인수가 P인 숫자 중에서 N번째 작은 수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N과 P가 주어진다. (1 ≤ N, P ≤ 109) P는 항상 소수이다.
<출력값>
첫째 줄에 가장 작은 소인수가 P인 숫자 중 N번째로 작은 수를 출력한다. 만약, 그러한 수가 109를 넘을 경우에는 0을 출력한다.

<문제 2815>
민균이와 준민이는 상범이를 사이에 둔 치밀한 삼각관계이다. 민균이는 감성적인 남자라 상범이에게 자주 영어로 편지를 쓰곤 한다. 이 사실을 안 준민이는 몹시 화가 나, 편지를 가로채 내용을 확인하려는 계획을 짰다. 다행히 계획대로 편지를 가로챘지만, 편지의 내용은 암호화가 되어있어 해독을 해야했다.
창영이는 준민이에게 그 암호화된 편지의 문장(여러개의 단어로 구성) 중 일부만 진짜 편지의 문장임을 알려주었다. 즉, 암호화된 편지에는 진짜 편지의 문장이 있을수도 있고 실제 없지만 꾸며낸 문장이 있을 수도 있다는 것이다. 준민이는 이제 그 암호화된 편지 중에 진짜 편지 문장의 위치를 찾으려고 한다.
편지의 암호화 규칙은 다음과 같다.
진짜 편지에 있는 단어는 항상 어떤 단어로 대체된다.(같은 단어로도 대체 가능하다.) 예를 들어, 진짜 편지 문장이 "doo doom chit doo doom chat"이면, 단어 "doo", "doom", "chit", "chat"이 어떤 단어로 대체되어야 한다는 것이다. 만약 "doo" -> a, "doom" -> b, "chit" -> c, "chat" -> d로 대체되었다면, 진짜 편지 문장은 암호화된 편지에서 "a b c a b d"로 나타날 것이다. 또한, 서로 다른 두 단어는 같은 단어로 대체될 수 없다.
단어들은 항상 소문자이며, 띄어쓰기로 구분되어 있다. 문장은 앞에서 말했듯이, 여러 단어의 연속이다.
준민이를 도와 진짜 편지의 한 문장이 입력으로 주어질 때, 암호화된 편지에서 그 문장이 가장 먼저 나타날 수 있는 위치를 출력하는 프로그램을 작성하자.
<입력값>
첫 줄은 암호화된 편지가 주어진다. 편지의 길이는 10^6을 넘지 않으며, 편지의 끝에는 \$라고 표시되어 있다. 당연히 \$는 편지의 일부로 보지 않는다.
다음 줄에는 진짜 편지의 문장이 주어지는데, 우리는 암호화된 편지에서 이 문장이 제일 먼저 어디서 나타나는 지를 알아내야한다. 이 문장 길이 역시 10^6을 넘지 않으며, 암호화된 편지와 같은 형식을 가진다.
<출력값>
입력으로 주어진 진짜 편지의 문장이, 주어진 암호화된 편지에서 가장 먼저 나타날 수 있는 위치(문장에서 맨 앞 단어의 위치)를 출력한다.
암호화된 편지에서 첫 단어의 위치는1, 다음 단어의 위치는 2, ... 이며 답은 항상 존재한다고 가정해도 좋다.
또한, 답이 여러개일 경우, 가장 작은 위치를 출력한다.

<문제 2816>
2012년 12월 31일 새벽 4시부터 지상파 아날로그 TV방송이 종료되었다. TV를 자주보는 할머니를 위해서, 상근이네 집도 디지털 수신기를 구입했다.
원래 상근이네 집에는 KBS1과 KBS2만 나왔다. 할머니는 두 방송만 시청한다. 이제 디지털 수신기와 함께 엄청난 양의 채널을 볼 수 있게 되었다.  하지만, 할머니는 오직 KBS1과 KBS2만 보려고 한다. 따라서, 상근이는 채널 리스트를 조절해 KBS1을 첫 번째로, KBS2를 두 번째로 만들려고 한다.
티비를 켜면 디지털 수신기는 시청 가능한 채널 리스트를 보여준다. 모든 채널의 이름은 서로 다르고, 항상 KBS1과 KBS2를 포함하고 있다. 상근이는 이 리모콘을 이용해서 리스트의 순서를 바꾸는 법을 알아냈다. 리스트의 왼편에는 작은 화살표가 있고, 이 화살표는 현재 선택한 채널을 나타낸다. 가장 처음에 화살표는 제일 첫 번째 채널을 가리키고 있다.
다음과 같은 네 가지 버튼을 이용해서 리스트의 순서를 바꿀 수 있다. 각각은 1번부터 4번까지 번호가 적혀져있는 버튼이다.

화살표를 한 칸 아래로 내린다. (채널 i에서 i+1로)
화살표를 위로 한 칸 올린다. (채널 i에서 i-1로)
현재 선택한 채널을 한 칸 아래로 내린다. (채널 i와 i+1의 위치를 바꾼다. 화살표는 i+1을 가리키고 있는다)
현재 선택한 채널을 위로 한 칸 올린다. (채널 i와 i-1의 위치를 바꾼다. 화살표는 i-1을 가리키고 있다)

화살표가 채널 리스트의 범위를 넘어간다면, 그 명령은 무시한다.
현재 채널 리스트의 순서가 주어졌을 때, KBS1를 첫 번째로, KBS2를 두 번째로 순서를 바꾸는 방법을 구하는 프로그램을 작성하시오. 방법의 길이는 500보다 작아야 한다. 두 채널을 제외한 나머지 채널의 순서는 상관없다.
<입력값>
첫째 줄에 채널의 수 N이 주어진다. (2 ≤ N ≤ 100)
다음 N개 줄에는 채널의 이름이 한 줄에 하나씩 주어진다. 채널의 이름은 최대 10글자이고, 알파벳 대문자와 숫자로만 이루어져 있다.
이미 KBS1이 첫 번째에, KBS2가 두 번째에 있는 입력은 주어지지 않는다.
<출력값>
상근이가 눌러야 하는 버튼을 순서대로 공백없이 출력한다.

<문제 2817>
전대프연(전국 대학생 프로그래밍 대회 동아리 연합)에서는 매년 프로그래밍 대회를 연다. 올해도 무사히 대회를 개최한 전대프연 회장 성진은 수고해준 스태프들에게 수고비를 주기로 하였다. 하지만 몇몇 스태프는 일을 열심히하지 않았기 때문에 성진은 일을 열심히 한 사람에게만 주기로했다. 하지만 일을 무진장 열심히 한 사람과 덜 열심히 한 사람에게 수고비를 똑같이 주는 것은 불공평하다.
고민을 한 성진은 수고비를 받을 사람을 선출하는 방식으로 ALPS(Allegro Leader Picking System) 을 사용하기로 결심했다. ALPS는 이름에서 보이듯이, 아주 유쾌하고 빠르게 사람들을 선별하는 방법이다. 
우선 대회 참가자들은  "수고비를 받을 가치가 있는 스태프" 한 명을 선택해 투표를 한다. (참가자가 투표를 하지 않을 수도 있다.) 이 투표결과, 전체 대회 참가자의 5% 미만의 득표를 얻은 사람은 열심히 일을 하지 않은 스태프이므로 후보에서 제외해버린다. 이제 남은 스태프마다, 받은 득표수를 1로 나눈 값, 2로 나눈 값... 14로 나눈 값을 구한다. 이렇게 구한 14개의 실수가 그 스태프의 '점수'들이 된다.
이렇게 14 * (후보 스태프의 명수) 개의 실수를 가진 점수집합을 얻을 수 있다.  이 점수집합에서의 값에 따라 각 스태프들에게 14개의 칩을 나눠주는데,  집합 내에서 가장 큰 점수를 가진 후보 스태프에게 1개의 칩을 주고, 집합 내에서 두 번째로 점수가 큰 후보 스태프에게 1개의 칩을, ... 14번째로 점수가 큰 후보 스태프에게 1개의 칩을 준다. 최종적으로 스태프마다 득표수에 따라 칩의 개수가 다르게 지급될 것이다. 이것이 바로 ALPS식 투표이다. 성진은 스태프가 가진 칩의 개수에 비례해서 수고비를 지급하기로 했다. 신비롭게도, 점수집합에 있는 실수들은 항상 서로 다르도록 투표결과가 나온다고 한다.
우리는 각 스태프마다 몇개의 표를 얻었는지를 알고있다. 이 득표수를 토대로, ALPS식 투표를 수행하게 된 후, 각 스태프가 받을 칩의 개수를 구하는 프로그램을 작성하시오.
<입력값>
첫 번째 줄에는 전대프연 대회에 참가한 참가자들의 수 X( 1 ≤ X ≤ 2,500,000) 이 주어진다. 두 번째 줄에는 전대프연에 참가한 스태프의 수 N (0 ≤ N ≤ 10) 이 주어진다.
다음 N개의 줄에 걸쳐 각 스태프의 정보 -스태프의 이름(항상 대문자 알파벳이다.)과 그 스태프가 받은 득표수- 가 공백을 사이에 두고 주어진다.
<출력값>
득표율이 전체의 5% 이상인 스태프에 대해, 스태프의 이름과 그 스태프가 받은 칩의 개수를 한줄에 하나씩 출력한다. 출력하는 순서는 스태프 이름의 사전순이여야한다.

<문제 2818>
상근이는 숙제가 너무 하기 싫어서, 숙제 한 달치를 걸고 창영이와 게임을 하기로 했다. 진 사람은 한 달동안 숙제 두 명분을 해야 한다. 상근이는 영리하게 자신이 어렸을 때, 하던 게임을 하자고 했다. 창영이는 흔쾌히 수락했다.

이 게임을 하기 위해서는 주사위가 필요하다. 주사위는 왼쪽 그림과 같이 생겼다. 마주보는 면에 쓰여 있는 숫자의 합은 항상 7이다. 즉, 6은 1, 5는 2, 4는 3은 마주보는 면이다.

	그 다음, 한 칸의 크기가 주사위의 한 면과 같은 표를 그린다. 이 표의 크기는 R행 C열이다. 주사위는 가장 처음에 왼쪽 위 칸에 있다. 윗 면에는 숫자 1이 있고, 오른쪽 면에는 숫자 3이 있다. 이제 다음과 같이 주사위를 굴린다.

	1. 주사위를 마지막 열에 도착하기 전까지 오른쪽으로 굴린다.

	2. 주사위를 아래줄로 한 칸 굴린다.

	3. 주사위를 첫 번째 열에 도착하기 전까지 왼쪽으로 굴린다.

	4. 2단계와 비슷하게 주사위를 한 칸 아래로 굴린다.

	상근이는 위와 같은 단계를 할 수 있을 때 까지, 즉, 마지막 줄까지 반복한다. 주사위가 어떤 칸에 도착하면, 창영이는 주사위 윗 면의 숫자를 적는다. 마지막에, 지금까지 적은 숫자를 모두 더한 다음, 상근이에게 물어본다.

	상근이는 정답을 말할 것이고, 이 숫자가 창영이가 더한 합과 같다면 상근이가 이긴다. 상근이는 잠시 머뭇거리다가 정답을 말했다. 이제 창영이는 이 정답이 맞는지 확인해야 한다. R과 C가 주어졌을 때, 윗 면의 합을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 R과 C가 주어진다. (1 ≤ R, C ≤ 100,000)
<출력값>
첫째 줄에 정답을 출력한다.

<문제 2819>
상근이는 새로운 로봇을 만들었다. 이 로봇의 성능을 시험하기 위해서 테스트 트랙 위에서 테스트하기로 했다. 테스트 트랙은 2차원 평면이다. 가장 처음에 로봇은 (0,0)에서 시작한다. 상근이는 로봇에게 S, J, I, Z중 하나의 명령을 보낸다. 이 명령은 로봇이 움직여야 하는 방향을 나타낸다.

	로봇이 현재 (x,y)에 있다고 하자. S(north)는 (x, y+1)로, J(south)는 (x,y-1)로, I(east)는 (x+1,y)로, Z(west)는 (x-1,y)로 이동하라는 의미이다.

	상근이는 로봇이 올바르게 움직이는지 확인하기 위해서 테스트 트랙 위에 N개의 고정된 조사점을 설치했다. 로봇은 명령을 수행할 때마다, 각 조사점과의 거리의 합을 상근이에게 전송한다. 이때, 거리는 맨해튼 거리이다.

	로봇이 상근이에게 전송한 값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 조사점의 수 N과 명령의 수 M이 주어진다. (1 ≤ N ≤ 100,000, 1 ≤ M ≤ 300,000)

	다음 N개 줄에는 조사점의 x좌표와 y좌표가 주어진다. 모든 좌표의 절댓값은 백만보다 작거나 같은 정수이다. 같은 좌표를 가지는 조사점이 여러 개 있을 수도 있다. 이때는, 각각의 거리를 따로 계산해서 합해야 한다.

	마지막 줄에는 상근이가 로봇에게 전송한 명령이 순서대로 주어진다.
<출력값>
출력은 총 M줄이다. i번째 줄에는, i번째 명령을 수행하고 난 후에 상근이에게 전송한 값을 출력한다.

<문제 2820>
상근이는 자동차를 매우 좋아한다. 자동차 공장에 취직한 상근이는 계속된 승진 끝에 드디어 사장이 되었다. 공장에는 총 N명의 직원이 있다. 상근이를 제외한 모든 직원은 한 명의 상사가 있다. (상근이는 모든 사람의 상사이다) 상근이의 번호는 1번이고, 나머지 직원의 번호는 2부터 N이다.
모든 직원은 자신의 모든 부하 직원(직속 부하와 부하의 부하등등을 모두 포함)의 월급을 인상하거나 삭감할 수 있다. 상근이는 권력 남용을 막기 위해 직원의 월급을 모니터링 하려고 한다.
월급의 변화를 모니터링하는 프로그램을 작성하시오.
모든 직원의 월급은 항상 양의 정수이고 231-1 이하이다.
<입력값>
첫째 줄에 직원의 수 N과 월급 변화와 조사 쿼리의 수 M이 주어진다. (1 ≤ N, M ≤ 500,000)
다음 N개 줄의 i번째 줄에는 직원 i의 초기 월급과 상사의 번호가 주어진다. (상근이는 상사가 없기 때문에, 초기 월급만 주어진다)
다음 M개 줄에는 월급 변화와 조사 쿼리가 주어진다.

p a x가 주어진 경우 a의 모든 부하의 월급을 x만큼 증가시킨다. (-10,000 ≤ x ≤ 10,000)
u a가 주어진 경우에는 a의 월급을 출력한다.
<출력값>
입력으로 u가 주어질 때마다 해당하는 직원의 월급을 출력한다.

<문제 2821>
상근이네 자동차 공장에는 직원이 N명 있다. 이 공장은 자동차를 컨베이어 벨트에 올려놓고 차를 만든다. 직원은 1번부터 N번까지 번호가 매겨져 있다. 직원 1은 컨베이어 벨트의 가장 왼쪽에 있고, N은 오른쪽에 있다. 각 직원이 하는 일은 모두 다르다.
차 한 대를 만들려면, 직원 1(상근)이부터 작업을 시작한다. 상근이가 작업을 끝내면 직원 2가 작업을 시작하고, 직원 2가 작업을 끝내면 직원 3이 작업을 시작한다. 그리고 직원 N이 작업을 끝내면 그 때 차가 완성되는 것이다. 차 M대를 만들려면, 1부터 M번까지 순서대로 차를 만들어야 한다.
각 직원 i가 자신의 일을 끝내는데 필요한 시간은 Ti이다. 또, 각 자동차 j의 복잡도는 Fj이다. 직원 i가 자동차 j의 작업을 완료하는데 필요한 시간은 Ti*Fj가 된다.
어떤 직원이 자신의 작업을 끝낸다면, 그 차는 즉시 다음 직원에게 넘겨진다. 따라서, 그 때, 다음 직원이 일을 하고 있으면 안 된다.
모든 일은 상근이가 시작한다. 상근이는 위와 같이 어떤 직원이 작업을 끝내고 다음 직원에게 차를 넘겼는데, 다음 직원이 일을 하고 있는 상황이 발생하지 않게 하려고 한다. 그렇게 하기 위해서 상근이는 작업을 하지 않고 기다려야 하는 시간이 있다. 이때, 이 시간을 최소로 하려고 한다.
모든 직원이 자신의 일을 끝내는데 필요한 시간과 모든 자동차의 복잡도가 주어진다. 이때, 차를 모두 만들기 위해서 필요한 시간을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N과 M이 주어진다. (1 ≤ N, M ≤ 100,000)
다음 N개 줄에는 직원 i의 작업 시간 Ti가 주어진다. (1 ≤ Ti ≤ 10,000)
다음 M개 줄에는 자동차 j의 복잡도 Fj가 주어진다. (1 ≤ Fj ≤ 10,000)
<출력값>
첫째 줄에 자동차를 모두 만들기 위해 필요한 최소 시간을 출력한다.

<문제 2822>
상근이는 퀴즈쇼의 PD이다. 이 퀴즈쇼의 참가자는 총 8개 문제를 푼다. 참가자는 각 문제를 풀고, 그 문제를 풀었을 때 얻는 점수는 문제를 풀기 시작한 시간부터 경과한 시간과 난이도로 결정한다. 문제를 풀지 못한 경우에는 0점을 받는다. 참가자의 총 점수는 가장 높은 점수 5개의 합이다. 
상근이는 잠시 여자친구와 전화 통화를 하느라 참가자의 점수를 계산하지 않고 있었다. 참가자의 8개 문제 점수가 주어졌을 때, 총 점수를 구하는 프로그램을 작성하시오.
<입력값>
8개 줄에 걸쳐서 각 문제에 대한 참가자의 점수가 주어진다. 점수는 0보다 크거나 같고, 150보다 작거나 같다. 모든 문제에 대한 점수는 서로 다르다. 입력으로 주어지는 순서대로 1번 문제, 2번 문제, ... 8번 문제이다.
<출력값>
첫째 줄에 참가자의 총점을 출력한다. 둘째 줄에는 어떤 문제가 최종 점수에 포함되는지를 공백으로 구분하여 출력한다. 출력은 문제 번호가 증가하는 순서이어야 한다.

<문제 2823>
상근이는 여자친구와의 드라이브를 위해서 운전을 배우고 있다. 도로 연수를 10년쯤 하다 보니 운전은 그럭저럭 잘하게 되었다. 하지만, 그는 유턴을 하지 못한다. 10년동안 도로 연수를 받았지만 유턴을 하지 못한다. 밥먹고 유턴만 연습했지만, 결국 유턴은 하지 못했다.
상근이는 유턴을 연습하기 위해서 시간을 투자하는 대신에 유턴을 할 필요가 없고, 유턴이 금지된 마을로 이사가려고 한다.

상근이가 이사가려고 하는 마을은 막다른 길이 있으면 안 된다. 막다른 길은 유턴을 하지 않고는 빠져나올 수 없기 때문이다. 어떤 마을의 지도가 주어졌을 때, 유턴을 하지 않고 마을의 모든 구역을 돌아다닐 수 있는지 없는지(막다른 길이 있는지 없는지)를 구하는 프로그램을 작성하시오. 
마을의 지도는 R × C 칸으로 이루어진 표로 생각할 수 있다. 각 칸에 빌딩이 있다면 'X'로 표시하고, 길이라면 '.'으로 표시한다. 모든 칸은 빌딩 또는 길이다. 상근이가 어떤 길 위에 있다면, 근처 네 방향(위,아래,오른쪽,왼쪽)의 길로 이동할 수 있다. 빌딩으로는 이동할 수 없다.
이 마을에 막다른 길이 없다면, 상근이는 임의의 한 길에서 시작해서, 갈 수 있는 어떤 방향으로 움직이더라도, 유턴을 하지 않고 그 위치로 돌아올 수 있어야 한다.
유턴은 방금 이동한 방향의 반대 방향으로 이동하는 것을 말한다.
<입력값>
첫째 줄에 마을의 크기 R과 C가 주어진다. (3 ≤ R, C ≤ 10)
다음 R개 줄에는 마을의 지도가 주어진다. 모든 길은 서로 연결되어 있다. 또, 마을에는 적어도 두 개의 길이 있다.
<출력값>
첫째 줄에 마을에 막다른 길이 없다면 0을, 그렇지 않다면 1을 출력한다.

<문제 2824>
상근이는 학생들에게 두 양의 정수 A와 B의 최대공약수를 계산하는 문제를 내주었다. 그런데, 상근이는 학생들을 골탕먹이기 위해 매우 큰 A와 B를 주었다.
상근이는 N개의 수와 M개의 수를 주었고, N개의 수를 모두 곱하면 A, M개의 수를 모두 곱하면 B가 된다.
이 수가 주어졌을 때, 최대공약수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N이 주어진다.(1 ≤ N ≤ 1000) 둘째 줄에는 N개의 정수가 공백으로 구분되어 주어진다. 이 수는 모두 1,000,000,000보다 작고, N개의 수를 곱하면 A가 된다.
셋째 줄에 M이 주어진다.(1 ≤ M ≤ 1000) 넷째 줄에는 M개의 정수가 공백으로 구분되어 주어진다. 이 수는 모두 1,000,000,000보다 작고, M개의 수를 곱하면 B가 된다.
<출력값>
두 수의 최대공약수를 출력한다. 만약, 9자리보다 길다면, 마지막 9자리만 출력한다. (최대 공약수가 1000012028인 경우에는 000012028을 출력해야 한다)

<문제 2825>
상근이는 데이터베이스 수업 시간에 교수님 몰래 교실을 나갔다. 결국 교수님에게 불려가게 되었고, 교수님은 다음과 같은 수학 숙제를 내주었다.
정수 N개가 주어진다. 이때, 친구의 개수를 구하라.
상근이는 이 문제를 받고 친구가 무엇인지 궁금해졌다. 데이터베이스 조교 동규는 두 수를 이루는 숫자가 적어도 하나 겹치는 쌍을 친구라고 한다고 했다. (겹치는 위치는 달라도 된다)
상근이의 숙제를 하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 수의 개수 N이 주어진다. (1 ≤ N ≤ 1,000,000)
다음 N개 줄에는 [1, 1018] 범위 안에 있는 양의 정수가 주어진다. 이 수가 교수님이 상근이에게 숙제로 전달한 수이다. 같은 수가 두 번 이상 주어지지 않는다.
<출력값>
첫째 줄에 친구의 개수를 출력한다.

<문제 2826>
창영이는 다음과 같은 함수를 작성했다.

int fun() {
    int ret = 0;
    for (int a = X1; a <= Y1; ++a)
        for (int b = X2; b <= Y2; ++b)
        ...
            for (int <n-th> = XN; <n-th> <= YN; ++<n-th>)
                ret = (ret + 1)  % 1000000007;
    return ret;
}

<N-th>는 영어 알파벳의 N번째 소문자이다. Xi와 Yi는 100,000보다 작거나 같은 양의 정수 또는 해당 루프 바깥 쪽에서 등장한 변수가 될 수 있다.
예를 들어, X3은 a, b, 또는 숫자가 될 수 있다. Xi와 Yi중 적어도 하나는 변수 이름이 아닌 숫자이며, 이는 모든 i에 해당된다.
Xi, Yi의 값이 주어졌을 때, 함수의 리턴값을 출력하는 프로그램을 작성하시오.
만약 (X1, Y1) = (1, 2), (X2, Y2) = (a, 3), (X3, Y3) = (1, b)라면, 함수는 다음과 같다.

int fun() {
    int ret = 0;
    for (int a = 1; a <= 2; ++a)
        for (int b = a; b <= 3; ++b)
            for (int c = 1; c <= b; ++c)
                ret = (ret + 1)  % 1000000007;
    return ret;
}
<입력값>
첫째 줄에 양의 정수 N(1 ≤ N ≤ 26)이 주어진다. 다음 N개의 줄에는 Xi와 Yi가 X1 Y1부터 차례대로 주어진다. 만약 Xi와 Yi가 모두 숫자라면 Xi <= Yi이다.
<출력값>
첫째 줄에 함수의 리턴값을 출력한다.

<문제 2827>
현주는 안암에서 피자가게를 하고 있다. 이 피자 가게는 환상적인 맛으로 대전에서 엄청난 인기를 끌었고, 대전에 사는 모든 사람들은 점심으로 현주네 피자가게를 이용한다. 현주네 피자가게에서 배달부로 일하는 현정이는 전국 스쿠터 배달 대회 1등 출신이다. 1등 출신 답게 그가 피자를 배달하는데 걸리는 시간은 0에 매우 가깝기 때문에 무시할 수 있다.
배달은 현정이를 통해서 해결하면 되지만, 문제는 피자를 만드는데 시간이 오래걸린다는 것이다. 사람들이 가장 좋아하는 피자의 토핑 조합은 사람마다 다르다. 또, 현주네 가게에 있는 오븐은 매우 작아서 한번에 피자 하나만 구울 수 있다. 따라서, 피자를 굽는 일정을 정하기 위해서 요즘 동혁이를 영입하였다.
동혁이는 날이 시작하기 전에 피자를 만드는 일정을 작성해야 한다.
대전에는 총 N명이 살고 있다. 현주는 모든 사람들에게 고유 번호를 붙여주었고, 번호는 1부터 N까지이다. 동혁이는 일을 시작하기 전에 미리 i가 좋아하는 피자를 만드는데 걸리는 시간(Ti)을 조사했고, 점심을 먹기 원하는 시간(Li)를 조사했다. 만약 피자를 Li보다 K분 빠른 시간에 배달한다면, 현정이는 팁으로 K원을 받게 된다. 또, K분 늦게 배달한다면, 현정이는 K원을 뺏기게 된다. 피자가 정확한 시간에 도착한다면, 팁도 받을 수 없고, 뺏기는 돈도 없다.
동혁이는 학비를 내느라 고생하는 현정이를 위해서, 현정이가 팁을 가능한 많이 받게 일정을 작성하려고 한다. 물론, 현정이가 받는 팁은 음수일 수도 있다. 이러한 경우는 피자를 늦게 배달해서 벌금으로 내는 돈이 더 많을 때이다.
그런데, 가끔 변화를 주기 위해서 좋아하는 피자를 바꾸는 사람도 있다. 이렇게 좋아하는 피자가 바뀔 때는, 원하는 점심 시간이 변할 수도 있다. 이렇게 시키려는 피자를 바꾸려면, 시간이 0일 때 현주네 피자가게로 전화를 해야 한다.
시간이 0인 시간은 피자를 굽기 시작하기 전까지 무한히 지속된다고 한다. 또, 모든 전화는 시간이 0인 동안 온다.
가장 먼저 원래 사람들이 시키려고 한 피자의 정보로 일정을 구한다. 그 다음에, 좋아하는 피자를 바꾸는 전화가 올 때 마다, 일정을 다시 구하는 프로그램을 작성하시오. 동혁이는 현정이가 받는 팁이 가장 커지게 일정을 작성해야 한다.
<입력값>
첫째 줄에 사람의 수 N과 현주가 받은 전화의 수 C가 주어진다. (1 ≤ N,C ≤ 200,000)
둘째 줄부터 N개의 줄에는 i가 점심을 먹는 시간 Li와 그가 좋아하는 피자를 굽는데 드는 시간 Ti가 주어진다.
다음 C개 줄에는 세 정수 R(전화를 건 사람의 번호), L(R이 점심을 먹을 새로운 시간), T(R이 좋아하는 피자를 굽는데 드는 시간)이 전화가 온 순서대로 주어진다.
0 ≤ Li, L ≤ 100,000
1 ≤ Ti, T ≤ 100,000
1 ≤ R ≤ N
<출력값>
첫째 줄에 아무 전화도 받지 않았을 때, 현정이가 받게되는 최대 팁을 출력한다.
다음 줄부터 C개 줄에는, 각 전화에 의해서 변경되는 일정에서 현정이가 받게되는 최대 팁을 출력한다.

<문제 2828>
상근이는 오락실에서 바구니를 옮기는 오래된 게임을 한다. 스크린은 N칸으로 나누어져 있다. 스크린의 아래쪽에는 M칸을 차지하는 바구니가 있다. (M<N) 플레이어는 게임을 하는 중에 바구니를 왼쪽이나 오른쪽으로 이동할 수 있다. 하지만, 바구니는 스크린의 경계를 넘어가면 안 된다. 가장 처음에 바구니는 왼쪽 M칸을 차지하고 있다.
스크린의 위에서 사과 여러 개가 떨어진다. 각 사과는 N칸중 한 칸의 상단에서 떨어지기 시작하며, 스크린의 바닥에 닿을때까지 직선으로 떨어진다. 한 사과가 바닥에 닿는 즉시, 다른 사과가 떨어지기 시작한다.
바구니가 사과가 떨어지는 칸을 차지하고 있다면, 바구니는 그 사과가 바닥에 닿을 때, 사과를 담을 수 있다. 상근이는 사과를 모두 담으려고 한다. 이때, 바구니의 이동 거리의 최솟값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N과 M이 주어진다. (1 ≤ M < N ≤ 10) 둘째 줄에 떨어지는 사과의 개수 J가 주어진다. (1 ≤ J ≤ 20) 다음 J개 줄에는 사과가 떨어지는 위치가 순서대로 주어진다.
<출력값>
모든 사과를 담기 위해서 바구니가 이동해야 하는 거리의 최솟값을 출력한다.

<문제 2829>
상근이는 이상하게 정사각행렬을 아름답다고 생각한다. 상근이는 행렬이 얼마나 아름다운지를 수치로 나타낸다.
A를 행렬의 주 대각선 성분의 합이라고 하자. 또, B는 또다른 대각선 성분의 합이라고 하자. 이때, 행렬의 아름다운 정도는 A-B가 된다.
N×N크기의 행렬이 주어졌을 때, 아름다운 정도가 가장 큰 부분 행렬을 구하는 프로그램을 작성하시오.
주 대각선은 행렬의 가장 왼쪽 위에서 시작하는 대각선이다.
<입력값>
첫째 줄에 행렬의 크기 N이 주어진다. (2 ≤ N ≤ 400) 다음 N개의 줄에는 행렬의 성분이 공백으로 구분되어 주어진다. 각 성분은 [-1000,1000] 범위 안에 들어있다.
<출력값>
첫째 줄에 입력으로 주어진 행렬의 부분 행렬 중 아름다운 정도가 가장 큰 것의 아름다운 정도를 출력한다.

<문제 2830>
상근이는 초등학교 졸업 여행으로 외계 행성 X3에 방문했었다. 이 행성에 사는 사람들의 이름은 모두 자연수이다. 행성의 거주민은 모두 서로를 알고 있다. 두 X3인은 그들의 친밀도를 자신의 이름을 이진수로 바꾸어서 계산한다. 두 이름을 이진수로 바꾸고, 자리수가 짧은 쪽을 기준으로 정렬한다. 이때, 두 이진수의 각 자리 아래에 두 자리가 같으면 0을, 다르면 1을 적는다. 이 결과 이진수를 다시 10진수로 바꾸면 그들의 친밀도가 된다.

	예를 들어, 10과 19의 친밀도는 25이다.



	행성의 가치는 이 섬에 있는 모든 친밀도의 합이다. 행성 거주민들의 이름이 주어졌을 때, 행성의 가치를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 X3 거주민의 수 N이 주어진다. (1 ≤ N ≤ 1,000,000) 다음 N개의 줄에는 거주민의 이름이 주어진다. 이름은 1,000,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 행성 X3의 가치를 출력한다.

<문제 2831>
남자 N명과 여자 N명이 상근이가 주최한 댄스 파티에 왔다. 상근이는 모든 사람의 키를 알고있다. 각 남자는 모두 여자와 춤을 출 수 있고, 여자는 남자와 춤을 출 수 있다. 모든 사람은 많아야 한 사람과 춤을 출 수 있다.
모든 남자는 자신이 선호하는 여자와 춤을 추려고 한다. 각 남자가 선호하는 여자는 두 가지 유형이 있는데, 한 유형은 자신보다 키가 큰 여자이고, 다른 유형은 자신보다 키가 작은 유형이다. 여자도 남자와 마찬가지로 자신이 선호하는 남자와 춤을 추려고 한다. 각 여자가 선호하는 남자도 남자와 비슷하게 두 유형이 있다. (자신보다 키가 큰 남자, 작은 남자) 키가 같은 남자와 여자가 춤을 추는 일은 일어나지 않는다.
이때, 상근이는 각 사람의 키와 선호하는 이성 유형을 알고 있다. 이런 조건을 가지고 춤을 출 쌍을 만들어 주려고 한다. 상근이는 최대 몇 쌍을 만들 수 있을까?
<입력값>
첫째 줄에 N이 주어진다. (1 ≤ N ≤ 100,000)
둘째 줄에는 남자의 키가 밀리미터 단위로 주어진다. 키는 절댓값이 1500보다 크거나 같고, 2500보다 작거나 같은 정수이다. 사람의 키는 주어지는 값의 절댓값이다. 키가 양수인 경우에는 자신보다 키가 큰 여자와 춤을 추기를 원하는 남자이고, 음수인 경우에는 키가 작은 사람과 춤을 추기를 원하는 남자이다.
셋째 줄에는 여자의 키가 밀리미터 단위로 주어진다. 키의 범위나 의미 역시 남자와 동일하다.
<출력값>
첫째 줄에 상근이가 만들어 줄 수 있는 쌍의 최댓값을 출력한다.

<문제 2832>
상근이는 다음과 같은 정렬 알고리즘을 만들었다.

reverse-sort(sequence a)
    while (A is not in nondecreasing order)
        partition a into the minimum number of slopes
        for every slope with length greater than one
            reverse(slope)

	여기서 slope란 감소하는 a의 연속 부분 수열이다. reverse는 그 구간의 순서를 뒤집는다.

	1부터 N으로 이루어진 길이가 N인 순열이 주어진다. 처음에 순열의 slope의 길이는 모두 짝수이다. reverse를 몇 번 호출하는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N이 주어진다. (2 ≤ N ≤ 100,000) 둘째 줄에는 정렬해야 하는 순열이 주어진다.
<출력값>
첫째 줄에 reverse를 몇 번 호출하는지 출력한다.

<문제 2833>
"나이트"는 한국에서 엄청나게 유행하는 새 게임이다. 강산이와 창영이는 대세에 뒤쳐지지 않기 위해서 이 게임을 플레이하려고 한다. 강산이는 체스에서 사용하는 나이트 말을 N*N 체스판 위에 놓는다. 그 다음에, 창영이는 눈가리개를 하고, 강산이는 1초에 한 번씩 나이트를 T번 움직인다. 이렇게 움직인 이후에, 창영이가 나이트의 최종 위치를 맞추면 이기는 게임이다.
이 게임에서 사용하는 체스판은 보통 체스판이 아니다. 각 칸에는 숫자가 하나씩 쓰여 있다. 어떤 칸에 쓰여 있는 수를 K라고 한다면, 시작한지 0, K, 2K, 3k, ...초 이었을 때만 나이트가 이동할 수 있는 칸이다. 
게임은 0초일 때 시작된다. 강산이는 나이트를 움직일 수 있는 8개 칸 중 한 칸으로 반드시 이동시켜야 한다. 나이트가 그 자리에 있는 시간 동안 (i초 일 때, 나이트를 움직였다면 i+1초) 그 칸은 나이트가 이동할 수 있는 칸이어야 한다.
창영이를 도와서 T번 움직인 이후에 나이트가 있을 수 있는 곳의 위치를 모두 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 체스판의 크기 N과 강산이가 나이트를 움직이는 횟수 T가 주어진다. (3 ≤ N ≤ 30, 1 ≤ T ≤ 1,000,000)
둘째 줄에는 나이트의 시작 위치 X와 Y가 주어진다. (1 ≤ X, Y ≤ N)
다음 N개 줄에는 체스판에 쓰여 있는 숫자가 주어진다. 이 값은 109보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 T번 움직인 이후에 나이트가 있을 수 있는 곳의 위치의 수 M을 출력한다.
다음 M개 줄에는 그 위치를 한 줄에 하나씩 행이 증가하는 순서로, 행이 같다면 열이 증가하는 순서로 출력한다.

<문제 2834>
상근이는 박스 N개를 로봇을 이용해서 정렬하려고 한다. 박스에는 1부터 N까지 숫자가 겹치지 않게 쓰여 있고, 이 수가 오름차순을 이루도록 박스를 정렬하려고 한다.
상근이가 가지고 있는 로봇에 수열을 입력하면, 위치에 해당하는 박스를 교환하게 된다. 수열에는 같은 위치가 두 번 이상 주어지면 안 된다.
예를 들어, 박스가 지금 [4, 1, 5, 2, 3] 순서로 놓여져 있고, 로봇에 [2, 1, 3] 명령을 내렸다고 해보자. 그럼 두 번째 위치에 있는 박스를 위치 1로 옮기고, 첫 번째 박스는 위치 3으로, 세 번째 박스는 위치 2로 이동하게 된다. 박스의 순서는 [1, 5, 4, 2, 3]이 된다.
명령을 가장 적게 이용해서 박스를 정렬하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 박스의 수 N이 주어진다. (2 ≤ N ≤ 1000)
다음 줄에는 박스에 붙어있는 숫자가 순서대로 주어진다. 같은 숫자가 두 번 이상 주어지지 않는다.
<출력값>
첫째 줄에 정렬하는데 사용한 명령의 수 X를 출력한다.
그 다음 X개 줄에는 로봇에게 내린 명령을 순서대로 출력한다. 가장 첫 숫자는 수열의 길이이며, 그 다음에 콜론(:)과 공백을 출력하고, 수열의 각 원소를 출력한다.

<문제 2835>
최근에 상근이가 살고 있는 나라에서는 인구 조사가 있었다. 사실 이번 인구 조사의 진짜 이유는 바로 텔레비전 인기도 조사이다.
각 사람이 텔레비전을 시청한 시간은 아래와 같은 형식이다.
HH:MM:SS - HH:NN:SS
앞 시간은 그 사람이 텔레비전을 시청하기 시작한 시간이며, 다음 시간은 시청을 마친 시간이다. 사람들은 그 구간의 가장 처음과 마지막 초에도 텔레비전을 시청한다. 만약, 어떤 사람이 자정이 넘기 전(23:45:30) 에 텔레비전을 시작했다면, 다음날 텔레비전 시청을 종료한다. (01:15:00)
모든 데이터를 수집했고, 이제 이 데이터를 분석하려고 한다.
어떤 초의 인기도는 그 초에 티비를 보고 있던 사람의 수로 나타낼 수 있다. 또, 구간의 인기도는 구간에 포함되는 초의 인기도의 합을 그 구간의 길이로 나눈 값이다.
Q개의 구간이 주어졌을 때, 그 구간의 인기도를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 상근이가 살고 있는 나라의 국민의 수 N이 주어진다. (N ≤ 100,000)
다음 N개 줄에는 각 사람이 티비를 시청한 구간이 문제에서 설명한 대로 주어진다. (0 ≤ HH ≤ 23, 0 ≤ MM ≤ 59, 0 ≤ SS ≤ 59)
다음 줄에는 인기도를 조사하려고 하는 구간의 수 Q가 주어진다. (Q ≤ 100,000)
다음 Q개 줄에는 인기도를 구하려고 하는 구간이 같은 형식으로 주어진다.
<출력값>
총 Q개의 구간에 대해서 각 구간의 인기도를 출력한다. 정답과의 오차는 최대 10-6까지 허용한다.

<문제 2836>
상근이가 살고 있는 도시에는 큰 강이 흐르고 있고, 모든 사람의 집은 이 강 근처에 있다. 집은 0번부터 M번까지 강을 따라서 번호가 매겨져 있고, 인접한 집 사이의 거리는 모두 1 킬로미터이다.
상근이는 0번 집에 살고 있고, 보트를 이용해서 사람들을 운송하는 일을 하고 있다.
오늘은 저녁때까지 M번 집으로 가야한다. 상근이는 M번 집으로 가는 길에 사람들을 태워주려고 한다.
오늘 상근이의 수상 택시를 타려고 하는 사람은 총 N명이다. 상근이는 각 사람들이 탑승할 위치와 목적지를 알고 있다. 상근이의 보트는 매우 커서 N명 모두 보트에 태울 수 있다.
예를 들어, 사람 A가 2번 집에서 8번으로 가려고 하고, B가 6에서 4로 가려고 하는 경우를 생각해보자. 상근이는 0번 집에서 시작해서, 2번에서 A를 태우고, 6번에서 B를 태울 것이다. 그 다음 4로 돌아가 B를 내려주고, 8번에서 A를 내려다준다. 그 다음에 원래 상근이가 가려고 했던 M번 집으로 가면 된다.
상근이가 모든 사람을 데려다주고, M번 집으로 가기 위해서 이동해야 하는 거리의 최솟값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N과 M이 주어진다. (N ≤ 300,000, 3 ≤ M ≤ 109)
다음 N개 줄에는 각 사람이 상근이의 수상 택시를 타는 위치와 목적지가 주어진다. 모든 숫자는 0과 M 사이이다.
<출력값>
첫째 줄에 상근이의 이동 거리의 최솟값을 출력한다.

<문제 2837>
상근이는 도시를 오고가며 짐을 실고 내리는 트럭 운전사이다. 상근이의 트럭은 매우 커서, 짐을 무제한으로 담을 수 있다. 상근이는 대학시절 배운 프로그래밍을 이용해서 자동으로 짐을 실고 내릴 수 있는 기능을 트럭에 추가했다. 유난히도 스택을 좋아하는 상근이는 스택을 이 기능에 이용했다. 따라서, 마지막으로 실은 짐만 내릴 수 있다.
상근이는 짐을 26가지 종류로 구분했다. 이러한 짐은 알파벳으로 나타낼 수 있다. (대소문자는 구분하지 않는다)
도시의 도로는 모두 일방통행이고, 길이는 모두 1 킬로미터이다. 또, 도로는 모두 세 종류로 나눌 수 있다. 이 도로는 1번 도로, 2번 도로, 3번 도로라고 한다.
1번 도로를 지날 때는 그 도로에 해당하는 짐을 하나 실어야 하고, 2번 도로는 짐을 하나 내려야 한다. 3번 도로는 짐을 실거나 내리지 않고 지나가야 한다.
도시는 N개, 도로는 E개가 있다 상근이는 1번 도시에서 출발해서 N번 도시에 도착해야 한다. N번 도시에 도착했을 때, 트럭은 비어있어도 되고, 안 비어있어도 된다.
상근이가 N번 도시로 도착하는 방법의 수를 계산하는 프로그램을 작성하시오. 단, 상근이는 최대 K 킬로미터만 이동할 수 있다.
<입력값>
첫째 줄에 도시의 수 N, 도로의 수 E, 이동할 수 있는 최대 거리 K가 주어진다. (2 ≤ N ≤ 50, 1 ≤ E ≤ 2450, 1 ≤ K ≤ 50)
다음 E개 줄에는 도로의 정보가 주어진다. 각 도로의 종류에 따라 다른 형식으로 주어진다.
1번 도로: "x y C" x에서 y로 향하는 도로이다. 이 도로를 지날 때, C(대문자)에 해당하는 짐을 실어야 한다.
2번 도로: "x y c" x에서 y로 향하는 도로이다. 이 도로를 지날 때, c(소문자)에 해당하는 짐을 내려야 한다.
3번 도로: "x y" x에서 y로 향하는 도로이며, 그 어
두 도시를 연결하는 도로의 수가 두 개 이상인 경우는 없다. (단, 방향이 다를 수는 있다) 또, x와 y가 같은 경우도 없다.
<출력값>
첫째 줄에 상근이가 1번 도시에서 출발해서 N번 도시로 도착하는 방법의 수를 출력한다. 수가 매우 커질 수 있기 때문에 10007로 나눈 나머지를 출력해야 한다.

<문제 2838>
선영이는 문제를 풀 때 종이에 낙서를 한다. 오늘은 2×N by 2×N 크기의 체스판을 그렸다.
오늘은 아래 설명과 같은 게임을 할 것이다.
먼저 각 칸에 정수를 써 놓는다. 먼저, 첫 번째 행의 중간(N열, N+1열)에 비숍 두 개를 놓는다. 그 다음에 선영이는 비숍의 시야를 표시한다.
비숍의 시야란 비숍이 이동할 수 있는 칸이다.
예를 들어, N이 3일 때, 두 비숍의 시야는 아래 그림과 같다. 비숍은 L로 표시하고, 시야는 X로 표시한다.

OOLLOO
OXXXXO
XXOOXX
XOOOOX
OOOOOO
OOOOOO

선영이가 비숍을 움직일 수 있는 횟수는 제한이 있다. 따라서, 아래와 같은 전략으로 최대 점수를 얻으려고 한다.
1. 비숍을 움직이기 전에, 비숍의 시야에 들어있는 칸에 쓰여 있는 숫자의 합을 계산한다. 이 합이 초기 점수이다.
2. 각 턴을 수행할 때, 선영이는 두 비숍중 하나를 고르고, 그 시야에 있는 칸 중 하나로 이동한다.
3. 비숍을 새 위치로 이동시키면, 이전에는 볼 수 없었던 새로운 칸을 볼 수 있다. 자 이제 게임을 시작하고 단 한 번도 비숍의 시야에 들어온 적이 없지만, 이번 이동으로 새로이 비숍의 시야에 들어온 칸에 쓰여 있는 숫자의 합을 구한다. 이 합을 점수에 추가한다.
선영이가 턴을 K번 수행했을 때 얻을 수 있는 최대 점수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 두 정수 N과 K가 주어진다. (1 ≤ N ≤ 10, 0 ≤ K ≤ 100)
다음 2×N개 줄에는 해당하는 행에 쓰여 있는 숫자 2×N개가 주어진다. 각 숫자는 -1,000,000보다 크거나 같고, 1,000,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 선영이가 얻을 수 있는 최대 점수를 출력한다.

<문제 2839>
상근이는 요즘 설탕공장에서 설탕을 배달하고 있다. 상근이는 지금 사탕가게에 설탕을 정확하게 N킬로그램을 배달해야 한다. 설탕공장에서 만드는 설탕은 봉지에 담겨져 있다. 봉지는 3킬로그램 봉지와 5킬로그램 봉지가 있다.
상근이는 귀찮기 때문에, 최대한 적은 봉지를 들고 가려고 한다. 예를 들어, 18킬로그램 설탕을 배달해야 할 때, 3킬로그램 봉지 6개를 가져가도 되지만, 5킬로그램 3개와 3킬로그램 1개를 배달하면, 더 적은 개수의 봉지를 배달할 수 있다.
상근이가 설탕을 정확하게 N킬로그램 배달해야 할 때, 봉지 몇 개를 가져가면 되는지 그 수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N이 주어진다. (3 ≤ N ≤ 5000)
<출력값>
상근이가 배달하는 봉지의 최소 개수를 출력한다. 만약, 정확하게 N킬로그램을 만들 수 없다면 -1을 출력한다.

<문제 2840>
상덕이는 최근에 행운의 바퀴를 구매했다. 상덕이는 바퀴의 각 칸에 알파벳 대문자를 아래 그림과 같이 적었다.

바퀴에 같은 글자는 두 번 이상 등장하지 않는다. 또, 바퀴는 시계방향으로만 돌아간다. 바퀴 옆에는 화살표가 있는데, 이 화살표는 항상 한 곳을 가리키고 있으며, 돌아가는 동안 가리키는 글자는 바뀌게 된다. 위의 그림에서는 H를 가리키고 있다.
상덕이는 바퀴를 연속해서 K번 돌릴 것이다. 매번 바퀴를 돌릴 때 마다, 상덕이는 화살표가 가리키는 글자가 변하는 횟수와 어떤 글자에서 회전을 멈추었는지를 종이에 적는다.
희원이는 상덕이가 적어놓은 종이를 발견했다. 그 종이를 바탕으로 상덕이가 바퀴에 적은 알파벳을 알아내려고 한다.
상덕이가 종이에 적어놓은 내용과 바퀴의 칸의 수가 주어졌을 때, 바퀴에 적어놓은 알파벳을 알아내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 바퀴의 칸의 수 N과 상덕이가 바퀴를 돌리는 횟수 K가 주어진다. (2 ≤ N ≤ 25, 1 ≤ K ≤ 100)
다음 줄부터 K줄에는 바퀴를 회전시켰을 때 화살표가 가리키는 글자가 몇 번 바뀌었는지를 나타내는 S와 회전을 멈추었을 때 가리키던 글자가 주어진다. (1 ≤ S ≤ 100)
<출력값>
첫째 줄에 마지막 회전에서 화살표가 가리키는 문자부터 시계방향으로 바퀴에 적어놓은 알파벳을 출력한다. 이때, 어떤 글자인지 결정하지 못하는 칸은 '?'를 출력한다. 만약, 상덕이가 적어놓은 종이에 해당하는 행운의 바퀴가 없다면 "!"를 출력한다.

<문제 2841>
상근이의 상상의 친구 외계인은 손가락을 수십억개 가지고 있다. 어느 날 외계인은 기타가 치고 싶었고, 인터넷에서 간단한 멜로디를 검색했다. 이제 이 기타를 치려고 한다.
보통 기타는 1번 줄부터 6번 줄까지 총 6개의 줄이 있고, 각 줄은 P개의 프렛으로 나누어져 있다. 프렛의 번호도 1번부터 P번까지 나누어져 있다.
멜로디는 음의 연속이고, 각 음은 줄에서 해당하는 프렛을 누르고 줄을 튕기면 연주할 수 있다. 예를 들면, 4번 줄의 8번 프렛을 누르고 튕길 수 있다. 만약, 어떤 줄의 프렛을 여러 개 누르고 있다면, 가장 높은 프렛의 음이 발생한다.
예를 들어, 3번 줄의 5번 프렛을 이미 누르고 있다고 하자. 이때, 7번 프렛을 누른 음을 연주하려면, 5번 프렛을 누르는 손을 떼지 않고 다른 손가락으로 7번 프렛을 누르고 줄을 튕기면 된다. 여기서 2번 프렛의 음을 연주하려고 한다면, 5번과 7번을 누르던 손가락을 뗀 다음에 2번 프렛을 누르고 연주해야 한다.
이렇게 손가락으로 프렛을 한 번 누르거나 떼는 것을 손가락을 한 번 움직였다고 한다. 어떤 멜로디가 주어졌을 때, 손가락의 가장 적게 움직이는 회수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 멜로디에 포함되어 있는 음의 수 N과 한 줄에 있는 프렛의 수 P가 주어진다. (N ≤ 500,000, 2 ≤ P ≤ 300,000)
다음 N개 줄에는 멜로디의 한 음을 나타내는 두 정수가 주어진다. 첫 번째 정수는 줄의 번호이고 두 번째 정수는 그 줄에서 눌러야 하는 프렛의 번호이다. 입력으로 주어진 음의 순서대로 기타를 연주해야 한다.
<출력값>
첫째 줄에 멜로디를 연주하는데 필요한 최소 손가락 움직임을 출력한다.

<문제 2842>
상덕이는 언덕 위에 있는 마을의 우체국에 직업을 얻었다. 마을은 N×N 행렬로 나타낼 수 있다. 행렬로 나뉘어진 각 지역은 우체국은 'P', 집은 'K', 목초지는 '.' 중 하나로 나타낼 수 있다. 또, 각 지역의 고도도 알고 있다.
매일 아침 상덕이는 마을의 모든 집에 우편을 배달해야 한다. 배달은 마을에 하나밖에 없는 우체국 'P'가 있는 곳에서 시작한다. 상덕이는 현재 있는 칸과 수평, 수직, 대각선으로 인접한 칸으로 이동할 수 있다. 마지막 편지를 배달하고 난 이후에는 다시 우체국으로 돌아와야 한다.
상덕이는 이렇게 매일 아침 배달을 하는 것이 얼마나 힘든지 궁금해졌다. 상덕이가 배달하면서 방문한 칸 중 가장 높은 곳과 낮은 곳의 고도 차이를 피로도라고 하자. 이때, 가장 작은 피로도로 모든 집에 배달을 하려면 어떻게 해야 하는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N이 주어진다. (2 ≤ N ≤ 50)
다음 N개 줄에는 마을을 나타내는 행렬이 주어진다. 'P'는 한 번만 주어지며, 'K'는 적어도 한 번 주어진다.
다음 N개 줄에는 행렬로 나뉘어진 지역의 고도가 행렬 형태로 주어진다. 고도는 1,000,000보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 가장 작은 피로도를 출력한다.

<문제 2843>
민혁이는 매주 금요일마다 지수와 함께 논다. 이번 주 금요일은 지수와 민혁이가 친구가 된지 십 년이 되는 날이다. 따라서, 둘은 엄청난 게임을 하기로 결정했다. 민혁이는 바닥이 흙인 운동장을 예약했고, 지수는 조약돌 한 개를 들고 왔다.
먼저 민혁이는 운동장 바닥에 나뭇가지로 방향 그래프를 그린다. 이 그래프에서 모든 정점은 많아야 한 개의 나가는 간선(outgoing edge)를 가질 수 있다. 그 다음 민혁이는 조약돌을 한 정점 위에 올려 놓는다. 만약, 조약돌이 있는 정점에 나가는 간선이 있다면, 조약돌은 그 간선을 통해서 이동할 수 없을 때까지 계속해서 이동한다. 더 이상 이동할 수 있는 정점이 없다면, 조약돌은 그 자리에서 멈춘다. 조약돌은 그래프를 무한히 이동할 수도 있고, 방문하지 않는 정점이 있을 수도 있다.
민혁이는 지수가 게임의 규칙을 확실하게 이해했는지 알기 위해서 다음과 같은 두 가지 질문을 하려고 한다.

1 X - 조약돌을 정점 X에 놓았을 때, 조약돌이 무한히 움직이지 않는다면 조약돌이 멈추는 정점의 번호는 몇 번인가?
2 X - 정점 X에서 나가는 간선을 지운다. (항상 나가는 간선이 있는 정점만 주어진다)

민혁이의 질문이 주어졌을 때, 지수의 답변을 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 그래프의 정점의 개수 N이 주어진다. (1 ≤ N ≤ 300,000)
둘째 줄에는 각 정점의 나가는 간선이 공백으로 구분되어서 주어진다. 정점의 번호는 1부터 시작하며, 나가는 간선이 없는 경우에는 0이 주어진다.
셋째 줄에는 민혁이의 질문의 수 Q가 주어진다. (1 ≤ Q ≤ 300,000)
넷째 줄부터 Q개 줄에는 문제 설명에 나온 질문 형식대로 민혁이의 질문이 주어진다.
<출력값>
1로 시작하는 쿼리가 주어질때 마다, 조약돌이 멈추는 정점의 번호를 한 줄에 하나씩 출력한다. 만약, 어떤 정점에 멈추지 않고 무한히 이동한다면, CIKLUS를 출력한다.

<문제 2844>
택희는 자료구조 수업시간에 다음과 같은 자료구조를 만들었다. 이 자료구조는 택희가 좋아하는 숫자 N개로 이루어진 수열에 아래와 같은 연산을 수행하는 것이다.



연산 형식
설명
예제




1 A B X
A번째부터 B번째까지 수를 X로 바꾼다.
(9,8,7,6,5,4,3,2,1) → 1 3 5 0 → (9,8,0,0,0,4,3,2,1)


2 A B X
A번째 수에는 X를, A+1번째 수에는 2×X를, ..., B번째 수에는 (B-A+1)×X를 더한다.
(9,8,7,6,5,4,3,2,1) → 2 3 5 2 → (9,8,9,10,11,4,3,2,1)


3 C X
C번째 숫자 바로 앞에 X를 삽입한다.
(9,8,7,6,5,4,3,2,1) → 3 4 100 → (9,8,7,100,6,5,4,3,2,1)


4 A B
A번째 수부터 B번째 수를 더해서 출력한다.
(2,18,7,6,1,4,7,7,2) → 4 6 7 → 결과: 11



택희가 좋아하는 숫자 N개로 이루어진 수열과 택희가 수행한 연산 목록이 주어졌을 때, 4번이 나올때 마다 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N과 Q가 주어진다. (1 ≤ N, Q ≤ 100,000) N은 처음 수열의 크기이고, Q는 택희가 수행한 연산의 개수이다.
둘째 줄에는 처음 수열이 주어진다. 수열의 수는 100,000을 넘지않는 음이 아닌 정수이며, 공백으로 구분되어져 있다.
셋째 줄부터 Q개의 줄에는 택희가 수행한 연산이 차례대로 주어진다. 0 ≤ X ≤ 100, 1 ≤ A ≤ B ≤ 현재 수열의 크기, 1 ≤ C ≤ 현재 수열의 크기+1
<출력값>
4번 연산이 나올때 마다 합을 출력한다. 합이 32비트 정수를 넘어갈 수 있다.

<문제 2845>
파티가 끝나고 나면, 사람들은 누가 파티에 왔는지와 얼마나 많은 사람들이 왔는지를 궁금해한다. 보통 파티는 매우 크게 열리기 때문에, 정확하게 몇 명이 참가했는지 알 수가 없다.

	지난주 토요일에 상근이는 자신의 3학년 진학을 기념하면서 매우 성대한 파티를 열었다. 그리고, 상근이는 1m2당 몇 명의 사람이 있었는지 알고있다.

	상근이의 파티는 정말 엄청난 규모였기 때문에, 대부분의 신문에도 기사가 실렸다. 상근이는 서로 다른 5개의 신문을 보면서 그 기사에 적혀져있는 참가자의 수를 적었다.

	상근이는 자신이 알고있는 참가자의 수가 정확하다고 생각한다. 각 신문 기사에 실려있는 참가자의 수가 몇 명 만큼 잘못되어있는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 1m2당 사람의 수 L (1 ≤ L ≤ 10)과 파티가 열렸던 곳의 넓이 P (1 ≤ P ≤ 1000)가 주어진다.

	둘째 줄에는 각 기사에 실려있는 참가자의 수가 주어진다. 106보다 작은 양의 정수 5개가 주어진다.
<출력값>
출력은 첫째 줄에 다섯 개의 숫자를 출력해야 한다. 이 숫자는 상근이가 계산한 참가자의 수와  각 기사에 적혀있는 참가자의 수의 차이이다.

<문제 2846>
상근이는 자전거를 타고 등교한다. 자전거 길은 오르막길, 내리막길, 평지로 이루어져 있다. 상근이는 개강 첫 날 자전거를 타고 가면서 일정 거리마다 높이를 측정했다. 상근이는 가장 큰 오르막길의 크기를 구하려고 한다.
측정한 높이는 길이가 N인 수열로 나타낼 수 있다. 여기서 오르막길은 적어도 2개의 수로 이루어진 높이가 증가하는 부분 수열이다. 오르막길의 크기는 부분 수열의 첫 번째 숫자와 마지막 숫자의 차이이다.
예를 들어, 높이가 다음과 같은 길이 있다고 하자. 12 3 5 7 10 6 1 11. 이 길에는 2 개의 오르막길이 있다. 밑 줄로 표시된 부분 수열이 오르막길이다. 첫 번째 오르막길의 크기는 7이고, 두 번째 오르막길의 크기는 10이다. 높이가 12와 6인 곳은 오르막길에 속하지 않는다.
가장 큰 오르막길을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 상근이가 측정한 높이의 수이자 수열의 크기인 N(1 ≤ N ≤ 1000)이 주어진다. 둘째 줄에는 N개의 양의 정수 Pi(1 ≤ Pi ≤ 1000)가 주어진다. 각 숫자는 상근이가 측정한 높이이다.
<출력값>
첫째 줄에 가장 큰 오르막길의 크기를 출력한다. 만약 오르막길이 없는 경우에는 0을 출력한다.

<문제 2847>
학교에서 그래픽스 수업을 들은 동준이는 수업시간에 들은 내용을 바탕으로 스마트폰 게임을 만들었다. 게임에는 총 N개의 레벨이 있고, 각 레벨을 클리어할 때 마다 점수가 주어진다. 플레이어의 점수는 레벨을 클리어하면서 얻은 점수의 합으로, 이 점수를 바탕으로 온라인 순위를 매긴다. 동준이는 레벨을 난이도 순으로 배치했다. 하지만, 실수로 쉬운 레벨이 어려운 레벨보다 점수를 많이 받는 경우를 만들었다.
이 문제를 해결하기 위해 동준이는 특정 레벨의 점수를 감소시키려고 한다. 이렇게해서 각 레벨을 클리어할 때 주는 점수가 증가하게 만들려고 한다.
각 레벨을 클리어할 때 얻는 점수가 주어졌을 때, 몇 번 감소시키면 되는지 구하는 프로그램을 작성하시오. 점수는 항상 양수이어야 하고, 1만큼 감소시키는 것이 1번이다. 항상 답이 존재하는 경우만 주어진다. 정답이 여러 가지인 경우에는 점수를 내리는 것을 최소한으로 하는 방법을 찾아야 한다.
<입력값>
첫째 줄에 레벨의 수 N이 주어진다. (1 ≤ N ≤ 100) 다음 N개 줄에는 각 레벨을 클리어하면 얻는 점수가 첫 번째 레벨부터 마지막 레벨까지 순서대로 주어진다. 점수는 20,000보다 작은 양의 정수이다.
<출력값>
첫째 줄에 점수를 몇 번 감소시키면 되는지 출력한다.

<문제 2848>
알고스팟어는 알고스팟 커뮤니티에서 사용하는 언어다. 이 언어는 영어 알파벳을 사용하지만, 영어와 알파벳 순서는 다르다.
알고스팟어의 알파벳 사전 순으로 정렬되어 있는 단어의 목록이 주어졌을 때, 알고스팟어의 알파벳 순서를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 단어의 개수 N (N ≤ 100)이 주어진다. 다음 N개 줄에는 알고스팟어 단어가 하나씩 주어진다. 단어의 길이는 최대 10이며, 소문자로만 이루어져 있다.
<출력값>
첫째 줄에 알고스팟어의 알파벳 순서를 출력한다. 만약, 올바른 순서가 없다면 "!"를, 가능한 순서가 한 개 이상이라면 "?"를 출력한다.

<문제 2849>
창영이와 현우는 탭댄스 학원을 다니고 있다. 탭댄스는 밑창에 탭(tap)이라는 쇠붙이를 붙인 구두를 신고 리듬감 있게 플로어를 쳐서 경쾌한 소리를 내며 추는 춤이다. 알고보니 창영이와 현우는 춤에 소질이 있었고, 이제 그들만의 안무를 만들려고 한다.
탭댄스의 안무는 L과 R로 이루어진 수열로 묘사할 수 있다. L은 왼쪽 발로, R은 오른쪽 발로 바닥을 탭하는 것이다. 창영이는 같은 발을 두 번 연속해서 사용하지 않을 때, 탭댄스의 진가가 나타난다고 생각한다. 따라서, 창영이는 안무의 점수를 만들었다. 안무의 점수는 L과 R이 두 번 연속해서 나오지 않는 연속된 원소들로 이루어진 가장 긴 부분 수열의 길이이다.
안무를 만드는 것은 매우 어려운 일이다. 현우는 창영이의 춤을 본 뒤, 안무에서 수정할 부분을 알려주었다. 창영이는 매번 수정할 때 마다 안무의 점수를 구하려고 한다. 안무의 수정은 하나의 L을 R로 또는 R을 L로 바꾸는 것이다.
가장 처음에 창영이가 만든 안무에는 L만 포함하고 있다.
<입력값>
첫째 줄에 창영이의 안무의 길이 N(1≤ N ≤ 200,000)과 현우가 안무를 수정한 횟수 Q(1≤ Q ≤ 200,000)가 주어진다.
다음 Q개 줄에는 현우가 안무의 몇 번째를 수정했는지가 순서대로 주어진다.
<출력값>
출력은 Q개의 정수로 이루어져 있다. 현우가 창영이의 안무를 수정할 때마다 안무의 점수를 한 줄에 하나씩 출력한다.

<문제 2850>
선영이는 도시의 두 지점을 연결하는 수도관을 설치하려고 한다.
도시는 R × S로 나타낼 수 있다. 어떤 칸은 수도관을 놓을 수 없는 칸이다.
선영이는 가장 왼쪽 위칸의 바로 위과 가장 오른쪽 아래 칸의 바로 아래를 연결하는 수도관을 설치하려고 한다.
수도관을 놓을 수 있는 칸은 빈 상태로 두거나, 아래 6가지 타입 중 하나를 설치할 수 있다.

수도관을 놓는 방법의 수를 구하는 프로그램을 작성하시오. 설치한 파이프는 모두 사용해야 한다. 또, 물이 새면 안 된다.
<입력값>
첫째 줄에 도시의 크기 R과 S가 주어진다. (2 ≤ R, S ≤ 10) 다음 R개 줄에는 수도관을 놓을 수 있는 칸의 정보가 주어진다. '.'인 경우에는 수도관을 놓을 수 있는 곳이고, '#'인 경우에는 놓을 수 없는 곳이다.
<출력값>
첫째 줄에 도시에 수도관을 설치하는 방법의 수를 10007로 나눈 나머지를 출력한다.

<문제 2851>
슈퍼 마리오 앞에 10개의 버섯이 일렬로 놓여져 있다. 이 버섯을 먹으면 점수를 받는다.
슈퍼 마리오는 버섯을 처음부터 나온 순서대로 집으려고 한다. 하지만, 모든 버섯을 집을 필요는 없고 중간에 중단할 수 있다. 중간에 버섯을 먹는 것을 중단했다면, 그 이후에 나온 버섯은 모두 먹을 수 없다. 따라서 첫 버섯을 먹지 않았다면, 그 이후 버섯도 모두 먹을 수 없다.
마리오는 받은 점수의 합을 최대한 100에 가깝게 만들려고 한다.
버섯의 점수가 주어졌을 때, 마리오가 받는 점수를 출력하는 프로그램을 작성하시오.
<입력값>
총 10개의 줄에 각각의 버섯의 점수가 주어진다. 이 값은 100보다 작거나 같은 양의 정수이다. 버섯이 나온 순서대로 점수가 주어진다.
<출력값>
첫째 줄에 마리오가 받는 점수를 출력한다. 만약 100에 가까운 수가 2개라면 (예: 98, 102) 마리오는 큰 값을 선택한다.

<문제 2852>
동혁이는 NBA 농구 경기를 즐겨 본다. 동혁이는 골이 들어갈 때 마다 골이 들어간 시간과 팀을 적는 이상한 취미를 가지고 있다.
농구 경기는 정확히 48분동안 진행된다. 각 팀이 몇 분동안 이기고 있었는지 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 골이 들어간 횟수 N(1<=N<=100)이 주어진다. 둘째 줄부터 N개의 줄에 득점 정보가 주어진다. 득점 정보는 득점한 팀의 번호와 득점한 시간으로 이루어져 있다. 팀 번호는 1 또는 2이다. 득점한 시간은 MM:SS(분:초) 형식이며, 분과 초가 한자리 일 경우 첫째자리가 0이다. 분은 0보다 크거나 같고, 47보다 작거나 같으며, 초는 0보다 크거나 같고, 59보다 작거나 같다. 득점 시간이 겹치는 경우는 없다.
<출력값>
첫째 줄에 1번 팀이 이기고 있던 시간, 둘째 줄에 2번 팀이 이기고 있던 시간을 출력한다. 시간은 입력과 같은 형식(MM:SS)으로 출력한다.

<문제 2853>
해빈이는 배가 한 척이라도 올까 말까 한 작은 항구 마을에 산다. 그런데 어느 날, 마을을 방문한 적이 있는 모든 배가 한꺼번에 마을을 방문한 날이 있었다. 해빈이는 이 날을 기념해 1일로 센다. 그리고 배가 한 척이라도 마을에 온 날을 신나는 날이라고 하고 특별히 리스트에 기록해두었다.
해빈이는 마을에 방문하는 배들을 관찰한 결과, 이들이 일정한 날자 간격을 두고 주기적으로 항구를 방문한다는 사실을 알아차렸다. 예를 들어, 간격이 3인 배는 1일, 4일, 7일, 10일 등에 해빈이의 마을에 온다.
오늘은 신나는 날이다. 오늘을 포함해서 해빈이의 신나는 날 리스트가 주어질 때, 방문한 배의 최소 수를 구하라. (해빈이는 모든 신나는 날을 리스트에 정확히 적어두었다. 따라서 항상 답이 존재한다.)
<입력값>
입력의 첫 줄에 정수 신나는 날의 개수 N (2 ≤ N ≤ 5000)이 주어진다.
다음 N줄에는 신나는 날의 번호가 오름차순으로 한 줄에 하나 씩 주어진다. 첫 번째 수와 마지막 수는 각각 해빈이가 관찰을 시작한 날, 그리고 해빈이가 매긴 오늘의 번호이다. 즉, 첫 번째 줄은 항상 1이다. 마지막 수(오늘의 번호)는 10^9보다 작다.
<출력값>
가능한 배의 최소 수를 출력한다.

<문제 2854>
상근이는 서강 프로그래밍 대회의 문제를 준비해야 한다.

	모든 문제의 난이도는 1과 N사이의 자연수로 표현할 수 있다. 하지만, 어떤 문제는 난이도를 정확하게 결정할 수 없는 경우도 있다. 따라서, 상근이는 문제의 난이도를 숫자 하나 또는 연속한 두 수로 표현하기로 했다. 예를 들어, 어떤 문제의 난이도는 3 또는 4가 될 수 있다.

	올해 대회는 총 N문제가 필요하다. 상근이는 각 난이도에 해당하는 문제를 한 문제씩 내기로 했다. 당연하겠지만 같은 문제를 두 번 낼 수는 없다.

	이때, 문제를 고르는 경우의 수를 구하는 프로그램을 작성하시오. 어떤 난이도에 해당하는 문제가 다른 경우에 두 방법이 서로 다른 경우이다.

	정답이 매우 커질 수 있으므로 경우의 수를 1,000,000,007로 나눈다.
<입력값>
첫째 줄에 N (2 ≤ N ≤ 100,000)이 주어진다.

	둘째 줄에는 109를 넘지 않는 N개의 정수가 주어진다. i번째 수는 난이도가 i인 문제의 개수이다.

	셋째 줄에는 109를 넘지않는 N-1개의 정수가 주어진다. i번째 수는 난이도가 i 또는 i+1인 문제의 개수이다.
<출력값>
첫째 줄에 문제를 고를 수 있는 방법의 수를 1,000,000,007로 나눈 나머지를 출력한다.

<문제 2855>
2*K개로 이루어진 수열이 있을 때, 처음 K개의 원소의 합과 마지막 K개의 원소의 합이 S를 넘지 않을 때, 이 수열을 흥미로운 수열이라고 한다.
크기가 N인 수열이 주어졌을 때, 각각의 수열의 원소에서 시작하는 부분 연속 수열 중 가장 긴 흥미로운 수열의 길이를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N과 S가 주어진다. (2 ≤N ≤ 100,000, 1 ≤ S ≤ 2×109)
둘째 줄부터 N개의 줄에 수열 A의 원소가 한 줄에 하나씩 주어진다. 이 수는 양수이며, 수열 A의 모든 원소의 합은 2×109를 넘지 않는다.
<출력값>
출력은 총 N개의 줄로 이루어져 있다. i번째 줄에는 i번째 원소에서 시작하는 가장 긴 흥미로운 수열의 길이를 출력한다. 만약 흥미로운 수열이 없을 때는 0을 출력한다.

<문제 2856>
동규는 이번에 새로 나온 그림판 프로그램을 설치했다. 이 프로그램에서 지원하는 색상의 개수는 K개이며, 각 색상은 1부터 K까지 번호가 매겨져 있다. 그림을 그릴 수 있는 캔버스의 크기는 N*N이다. 가장 처음에 모든 칸은 흰색 (1번 색상)으로 칠해져 있다. 이 그림판은 마우스를 이용해서 그림을 그릴 수 없고 키보드로 명령어를 입력해야 한다.
캔버스의 가장 왼쪽 위 칸의 좌표는 (0, 0)이다. 첫 번째 좌표는 x로 행을 나타내고, 두 번째 좌표는 y로 열을 나타낸다.
동규가 가장 좋아하는 그림판 명령어는 PAINT c x1 y1 x2 y2이다. 이 명령어는 선택한 직사각형을 체스판 패턴으로 칠한다. 여기서 c는 색칠할 색상이고, (x1, y1), (x2, y2)는 색칠할 직사각형의 왼쪽 위와 오른쪽 아래 좌표이다.
가장 왼쪽 위 칸의 색상은 명령어에서 고른 색상 c가 된다. 나머지 칸의 색은 체스판 패턴에 의해서 결정된다. 이때, 색칠되지 않는 칸의 색상은 원래 색상을 그대로 유지한다. 아래 그림은 흰색 캔버스에 빨간 체스판 패턴을 칠했을 때의 모습이다.

그림판에는 두 가지 명령어가 더 있다. 첫 번째는 SAVE로 현재 캔버스를 저장하는 명령이다. 두 번째 명령은 LOAD x로 x번째 저장한 캔버스를 불러오는 명령이다.
하루종일 그림을 그리던 동규는 실수로 저장을 하지 않고 프로그램을 종료했다. 하지만, 이 프로그램은 사용자가 입력한 명령을 순서대로 저장하고 있다. 동규가 입력한 명령을 수행했을 때, 각 칸에 색칠되어 있는 색상을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N(1 ≤ N ≤ 1000), K(2 ≤ K ≤ 100,000), M(1 ≤ M ≤ 100,000, M은 명령의 개수)이 주어진다.
다음 M개의 줄에는 문제에서 설명한 세 가지 명령어중 하나가 주어진다. 올바르지 않은 명령이 주어지는 경우는 없다.
<출력값>
N개 줄에 각 칸의 색상을 나타내는 N개의 숫자를 출력한다.

<문제 2857>
5명의 요원 중 FBI 요원을 찾는 프로그램을 작성하시오.
FBI요원은 요원의 첩보원명에 FBI가 들어있다.
<입력값>
5개 줄에 요원의 첩보원명이 주어진다. 첩보원명은 알파벳 대문자, 숫자 0~9, 대시 (-)로만 이루어져 있으며, 최대 10글자이다.
<출력값>
첫째 줄에 FBI 요원을 출력한다. 이때, 해당하는 요원이 몇 번째 입력인지를 공백으로 구분하여 출력해야 하며, 오름차순으로 출력해야 한다. 만약 FBI 요원이 없다면 "HE GOT AWAY!"를 출력한다.

<문제 2858>
상근이는 기숙사 생활을 한다. 상근이의 방의 크기는 L*W 이다.
수업시간에 타일 채우기 경우의 수를 계산하던 상근이는 자신의 방도 1*1크기 타일로 채우려고 한다. 이때, 가장자리는 빨간색으로, 나머지는 갈색으로 채우려고 한다.
아래 그림은 상근이의 방의 크기가 4*3일 때 이다.

어느 날 상근이네 방에 하근이가 놀러왔다. 하근이는 아름다운 타일 배치에 감동받았다. 다시 방으로 돌아온 하근이는 빨간색과 갈색 타일의 개수는 기억했지만, 방의 크기는 기억해내지 못했다.
빨간색과 갈색 타일의 개수가 주어졌을 때, 상근이 방의 크기를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 빨간색 타일의 수 R과 갈색 타일의 수 B가 주어진다. (8 ≤ R ≤ 5000, 1 ≤ B ≤ 2,000,000)
<출력값>
첫째 줄에 상근이네 방의 크기 L과 W을 공백으로 구분하여 출력한다. 만약, 두 수가 다르다면, 큰 수가 L이 되고 작은 수가 W이 된다. 항상 정답이 유일한 경우만 입력으로 주어진다.

<문제 2859>
상근이와 중근이는 천문학 수업을 듣고 있다. 이번 주 과제는 흔치 않은 별 두 개를 관찰하는 것이다. 두 사람은 별을 관찰하면서 반짝이는 시간을 적어놓았다. 관찰한 결과를 살펴보니 두 별은 주기적으로 반짝인다는 사실을 알게되었다. 어느 날 두 별이 처음으로 반짝인 시간과 반짝이는 주기가 주어졌을 때, 언제 동시에 반짝이는지 구하는 프로그램을 작성하시오.

	예를 들어, 첫 번째 별이 오늘(토요일) 02:20, 두 번째 별이 13:00에 반짝였고, 첫 번째 별이 반짝이는 주기는 05:50 (5시간 50분), 두 번째 별은 01:00 (1시간) 이라고 하자. 그러면, 첫 번째 별은 08:10, 14:00에 반짝일 것이고, 두 번째 별은 14:00에 반짝일 것이다. 따라서, 두 별은 오늘 14:00에 동시에 반짝인다.

	00:00 (자정)은 그 날의 첫 시간이다.
<입력값>
네 줄 걸쳐에 HH:MM (시:분) 형식의 시간이 주어진다. (00 ≤ HH ≤ 23, 00 ≤ MM ≤ 59)

	첫째 줄의 시간은 첫 번째 별이 반짝인 시간, 둘째 줄은 두 번째 별이 반짝인 시간, 세 번째 줄은 첫 번째 별이 반짝이는 주기, 네 번째 줄은 두 번째 줄이 반짝이는 주기이다.

	처음 두 시간은 항상 다르며, 오늘은 토요일(Saturday)이다. 반짝이는 주기는 00:00이 아니다.
<출력값>
만약, 두 별이 동시에 반짝이지 않는다면 "Never"를 출력한다.

	첫째 줄에 두 별이 동시에 반짝이는 날의 요일을 출력한다. (Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday)

	둘째 줄에는 동시에 반짝인 시간을 HH:MM형식으로 출력한다.

<문제 2860>
상근이는 종이에 숫자를 쓰려고 한다. 종이에는 1~5 사이의 숫자를 1개만 쓸 수 있고, 상근이는 종이를 무한개 가지고 있다.
열심히 종이에 숫자를 쓴 다음에, 종이에 쓴 숫자의 평균을 P와 같게 만들려고 한다.
이때, 사용한 종이의 개수를 최소로 하려고 한다. P가 주어졌을 때, 각 숫자를 총 몇 번 쓰는지 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 P가 주어진다. P는 1보다 크거나 같고, 5보다 작거나 같으며 소수점 1자리 ~ 9자리이다.
<출력값>
첫째 줄에 5개의 음이 아닌 정수를 출력한다. 첫 번째 숫자는 1의 개수, 두 번째 숫자는 2의 개수, ..., 마지막 숫자는 5의 개수이다. 가능한 방법이 여러개라면 아무거나 출력한다.

<문제 2861>
원섭시에는 N명의 시민들이 살고 있다. 이 마을에 살고있는 모든 시민은 각각 다른 시민 1명에게 돈을 빌렸다. 이제 모든 빚을 갚아야하는 시간이다. 그런데, 큰 문제가 생겨서 모든 사람들이 돈을 갚을 수 없게 되었다. 그 이유는 각자 가지고 있는 돈을 모두 써버렸기 때문이다.

	원섭시의 시장 고원섭은 이런 악순환을 해결하고자 마을에서 일부 사람들에게 돈을 주기로 했다. 이렇게 일부 사람들이 돈을 받게 되면, 그 돈으로 돈을 갚고, 또 받은 사람은 돈을 갚을 수 있게 된다. 예를 들어, A가 마을에서 돈을 받았다고 하자. 그럼 A는 B에게 돈을 갚을 수 있고, B는 C에게 돈을 갚을 수 있다. 만약, B가 빚을 갚을 수 있는 충분한 돈이 없다면, 충분한 돈이 생길 때 까지 기다리면 된다. 또, B가 돈을 더 가지고 있다면, B는 그 돈을 가지면 된다.

	다른 예로, 이 마을에 두 사람이 살고 있고, 두 사람이 서로에게 100원을 빌린 경우를 생각해보자. 이 경우에 마을에서 두 사람 중 한 사람에게 100원을 주면, 서로 빚을 갚을 수 있게 된다.

	원섭시의 모든 시민들의 채무 관계가 주어졌을 때, 마을의 악순환을 해결하기 위해 필요한 금액의 최솟값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 시민의 수 N (2 ≤ N ≤ 200,000)이 주어진다. 각 사람의 번호는 1번부터 N번이다.

	다음 N개의 줄에는 공백으로 구분되어져 있는 두 정수 Ai와 Bi가 주어진다. Ai는 i번 사람이 돈을 빌린 사람의 번호이고, Bi는 갚아야 하는 금액이다. (1 ≤ Ai ≤ N, Ai ≠ i, 1 ≤ Bi ≤ 10,000)
<출력값>
첫째 줄에 시민들의 빚을 해결하기 위해 필요한 최소 금액을 출력한다.

<문제 2862>
상덕이와 희원이는 동전 게임을 하면서 시간을 보낸다. 동전 게임은 동전 N개를 가지고 하는 게임이고, 규칙은 다음과 같다.

상덕이가 먼저 게임을 하고, 그 다음엔 희원이, 그 다음에 상덕이, 희원이 순서대로 게임을 한다. 순서대로 첫 번째 턴, 두 번째 턴, 세 번째 턴, ...
상덕이는 첫 번째 턴에서 가져갈 수 있는 동전의 개수는 1보다 크거나 같고, N보다 작거나 같다.
그 다음 턴부터는 동전을 이전 턴에서 그 사람이 가져간 동전 개수의 최대 2배만큼 가져갈 수 있다. (동전을 적어도 1개는 가져가야 한다)
이렇게 플레이를 하다가 마지막 동전을 가져가는 사람이 이긴다.

상덕이와 희원이가 항상 최적의 방법으로 게임을 한다. 이 말은 어떤 상황에서 플레이어 A가 B를 항상 이길 수 있다면, A가 항상 이긴다는 것이다.)
이때, 상덕이가 이기기 위해서는 첫 번째 턴에서 동전을 몇 개 가져가야 하는지를 구하는 프로그램을 작성하면 된다. 이러한 동전의 개수가 여러 개 나올 수 있는데, 그 때는 가장 적은 개수를 출력하면 된다.
<입력값>
첫째 줄에 동전의 개수 N이 주어진다. (2 ≤ N ≤ 1015)
<출력값>
첫째 줄에 상덕이가 이기기 위해서 가져가야 하는 동전 개수의 최솟값을 출력한다.

<문제 2863>
상근이는 덧셈과 나눗셈을 엄청나게 못한다. 이런 상근이를 위해 정인이는 상근이에게 다음과 같은 문제를 냈다.

	정인이는 양의 정수 A,B,C,D로 이루어진 2*2 표를 그렸다.




				A

				B



				C

				D




	위와 같은 표가 있을 때, 표의 값은 A/C + B/D 이다.

	상근이는 표를 몇 번 돌리면 표의 값이 최대가 되는지 궁금해졌다.

	표는 90도 시계방향으로 돌릴 수 있다.

	문제 상단의 표를 1번 회전 시키면 다음과 같다.




				C

				A



				D

				B




	2번 회전 시키면 다음과 같이 된다.




				D

				C



				B

				A




	표에 쓰여 있는 A,B,C,D가 주어졌을 때, 표를 몇 번 회전시켜야 표의 값이 최대가 되는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 A와 B가 공백으로 구분되어 주어진다. 둘째 줄에 C와 D가 공백으로 구분되어 주어진다. 모든 수는 100보다 작거나 같은 양의 정수이다.
<출력값>
첫째 줄에 표를 몇 번 돌려야 표의 값이 최대가 되는지 출력한다. 만약, 그러한 값이 여러개라면 가장 작은 값을 출력한다.

<문제 2864>
상근이는 2863번에서 표를 너무 열심히 돌린 나머지 5와 6을 헷갈리기 시작했다.
상근이가 숫자 5를 볼 때, 5로 볼 때도 있지만, 6으로 잘못 볼 수도 있고, 6을 볼 때는, 6으로 볼 때도 있지만, 5로 잘못 볼 수도 있다.
두 수 A와 B가 주어졌을 때, 상근이는 이 두 수를 더하려고 한다. 이때, 상근이가 구할 수 있는 두 수의 가능한 합 중, 최솟값과 최댓값을 구해 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 두 정수 A와 B가 주어진다. (1 <= A,B <= 1,000,000)
<출력값>
첫째 줄에 상근이가 구할 수 있는 두 수의 합 중 최솟값과 최댓값을 출력한다.

<문제 2865>
상근이는 한국 최고의 가수를 뽑는 "나는 위대한 슈퍼스타K"의 감독이다. 상근이는 다음과 같이 참가자를 선발하려고 한다.
"나는 위대한 슈퍼스타K"의 예선에는 N명이 참가했고, 서로 다른 M개 장르에 대한 오디션을 보았다. 심사위원은 모든 참가자의 각 장르에 대한 능력을 점수로 매겼다. 이 점수는 실수로 나타낸다.
본선에는 총 K명이 나갈 수 있다. 각 참가자는 본선에서 단 하나의 장르만 부를 수 있고, 이 장르는 상근이가 정해준다. 한 사람이 여러 장르를 부를 수는 없지만, 여러 사람이 같은 장르를 부를 수는 있다.
모든 참가자의 각 장르에 대한 능력이 주어진다. 이때, 능력의 합이 최대가 되도록 참가자와 장르를 선택하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N, M, K가 주어진다. (1 ≤ M ≤ 100, 1 ≤ K ≤ N ≤ 100)
다음 M개의 줄은 각 장르에 대한 참가자의 능력이 주어진다. 이 줄에는 N개의 (i, s)쌍이 주어진다. 여기서 i는 참가자의 번호, s는 그 참가자의 장르에 대한 능력이다. 이 쌍은 능력이 감소하는 순서대로 주어진다. 참가자의 번호는 1부터 N까지 이다.
각 줄에 모든 학생은 한 번씩 등장한다.
<출력값>
첫째 줄에 본선 참가자의 능력의 합을 소수점 첫째자리까지 반올림해 출력한다.

<문제 2866>
R개의 행과 C개의 열로 이루어진 테이블이 입력으로 들어오게 됩니다. 이 테이블의 원소는 알파벳 소문자로 주어집니다.
각 테이블의 열을 위에서 아래로 읽어서 하나의 문자열을 만들 수 있습니다. 예제 입력에서
dobarz
adatak
이 주어지는 경우 "da", "od", "ba", "at", "ra", "zk"와 같이 6개의 문자열들이 만들어지게 됩니다.
만약 가장 위의 행을 지워도 테이블의 열을 읽어서 문자열이 중복되지 않는다면, 가장 위의 행을 지워주고, count의 개수를 1 증가시키고, 이 과정을 반복합니다. 만약 동일한 문자열이 발견되는 경우, 반복을 멈추고 count의 개수를 출력 후 프로그램을 종료하면 됩니다. (가장 처음에 주어지는 테이블에는 열을 읽어서 문자열을 만들 때, 동일한 문자열이 존재하지 않음이 보장됩니다.)
테이블이 주어질 경우 count의 값을 구해주시면 됩니다.
<입력값>
첫 번째 줄에는 테이블의 행의 개수와 열의 개수인 R과 C가 주어집니다. (2 ≤ R, C ≤ 1000)
이후 R줄에 걸쳐서 C개의 알파벳 소문자가 주어집니다. (가장 처음에 주어지는 테이블에는 열을 읽어서 문자열을 만들 때, 동일한 문자열이 존재하지 않음이 보장됩니다.)
<출력값>
위의 설명과 같이 count의 값을 출력하시면 됩니다.

<문제 2867>
수열의 값이란 수열에서 가장 큰 원소와 가장 작은 원소의 차이이다.
예를 들어, (3, 1, 7, 2)는 수열의 값이 6이고, (42, 42)는 0이다.
수열이 주어졌을 때, 모든 부분 수열의 값의 합을 출력하는 프로그램을 작성하시오 .
(3, 1, 7, 2)의 부분 수열은 총 10개 (3), (1), (7), (2), (3,1), (1,7), (7,2), (3,1,7), (1,7,2), (3,1,7,2) 가 있고, 각각의 수열의 값을 구한뒤 이를 합하면 31이 된다.
<입력값>
첫째 줄에 수열의 크기 N(2<=N<=300,000)이 주어진다. 둘째 줄부터 N개의 줄에는 수열의 원소가 한 줄에 하나씩 주어진다. 원소는 100,000,000보다 크지 않은 양의 정수이다.
<출력값>
첫째 줄에 입력으로 주어진 수열의 부분 수열의 값의 합을 출력한다.

<문제 2868>
Mirko soon realised that number sequences are not the best career choice, and went right back to letter-table business.
Mirko’s table has R rows and C columns and consists of lowercase letters. 
Each cell of the table is a square of equal size. We assign coordinates to vertices of those squares, so that upper-left corner of the table has coordinates (0, 0), upper-right (C,0), lower-left (0, R), and lower-right (C, R).
We say that polygon within the table is monoliteral if the following holds: 

its vertices are from the described set of cell-square vertices, 
its edges are parallel to coordinate axes, 
all letters inside the polygon are equal. 

A simple polygon for which first two conditions are true (third one may or may not be true) is given. Mirko would like to know the number of monoliteral polygons that can be obtained by moving the given one up, down, left, or right or any combination thereof, but not rotating.
<입력값>
The first line of input contains two space seperated integers R and C (1 ≤ R, C ≤ 500). 
Each of the next R lines contains exactly C lowercase letters, this is Mirko’s table. 
The following line contains integer V (4 ≤ V ≤ 500), number of vertices of given polygon. 
Each of the next V lines contains two integers X, Y (0 ≤ X ≤ C, 0 ≤ Y ≤ R). These are the coordinates of the vertices of the given polygon. Vertices are given in clockwise order. 
The given polygon will satisfy conditions 1 and 2 from above.
<출력값>
In the first and only line of output, print expected number of polygons.

<문제 2869>
땅 위에 달팽이가 있다. 이 달팽이는 높이가 V미터인 나무 막대를 올라갈 것이다.
달팽이는 낮에 A미터 올라갈 수 있다. 하지만, 밤에 잠을 자는 동안 B미터 미끄러진다. 또, 정상에 올라간 후에는 미끄러지지 않는다.
달팽이가 나무 막대를 모두 올라가려면, 며칠이 걸리는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 세 정수 A, B, V가 공백으로 구분되어서 주어진다. (1 ≤ B < A ≤ V ≤ 1,000,000,000)
<출력값>
첫째 줄에 달팽이가 나무 막대를 모두 올라가는데 며칠이 걸리는지 출력한다.

<문제 2870>
상근이는 수학시간에 딴 짓을 하다가 선생님께 걸렸다. 선생님은 상근이에게 이번 주말동안 반성하라며 엄청난 숙제를 내주었다.
선생님이 상근이에게 준 종이에는 숫자와 알파벳 소문자로 되어있는 글자가 N줄있다. 상근이는 여기서 숫자를 모두 찾은 뒤, 이 숫자를 비내림차순으로 정리해야한다. 숫자의 앞에 0이 있는 경우에는 정리하면서 생략할 수 있다.
글자를 살펴보다가 숫자가 나오는 경우에는, 가능한 가장 큰 숫자를 찾아야 한다. 즉, 모든 숫자의 앞과 뒤에 문자가 있거나, 줄의 시작 또는 끝이어야 한다.
예를 들어, 01a2b3456cde478에서 숫자를 찾으면 1, 2, 3456, 478이다.
선생님이 준 종이의 내용이 주어졌을 때, 상근이의 숙제를 대신하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 종이의 줄의 개수 N이 주어진다. (1 ≤ N ≤ 100)
다음 N개의 줄에는 각 줄의 내용이 주어진다. 각 줄은 최대 100글자이고, 항상 알파벳 소문자와 숫자로만 이루어져 있다.
<출력값>
종이에서 찾은 숫자의 개수를 M이라고 하면, 출력은 M줄로 이루어져야 한다. 각 줄에는 종이에서 찾은 숫자를 하나씩 출력해야 한다. 이때, 비내림차순으로 출력해야 한다. 비내림차순은 내림차순의 반대인 경우인데, 다음 수가 앞의 수보다 크거나 같은 경우를 말한다.

<문제 2871>
상근이는 희원이와 놀기 위해 집에서 게임을 준비해 왔다. 한 종이에 한 글자씩 쓰여 있고, 이러한 종이 N개가 한 줄로 놓여져 있다. 두 사람 각각은 이 종이를 모아서 단어를 만들려고 한다. 각 사람은 턴을 번갈아가면서 종이 한 장을 가져가고 자기 단어의 뒤쪽에 붙인다. 상근이가 게임을 먼저 하고, 더 이상 가져갈 종이가 없으면 게임을 종료한다.
두 단어 A와 B가 있을때, A가 B보다 사전순으로 앞선다면, A는 B보다 아름답다. 두 사람이 각자 만든 단어 중에서 더 아름다운 단어를 만든 사람이 게임을 이긴다. 만약 두 사람이 같은 단어를 만들었다면 둘 다 진다.
상근이는 이 게임을 엄청나게 잘하지만, 희원이는 아직 규칙도 헷갈리는 상황이다. 따라서, 상근이는 희원이를 위해 조금 다르게 게임을 하려고 한다. 상근이는 항상 가장 오른쪽에 있는 종이를 집어간다. 희원이가 이 사실을 알고 있을 때, 희원이가 상근이를 이길 수 있는지 구하고, 만들 수 있는 가장 아름다운 단어를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 짝수 N이 주어진다. (2 ≤ N ≤ 100 000)
둘째 줄에 종이에 적혀 있는 글자가 순서대로 주어진다. 글자는 모두 알파벳 소문자이다.
<출력값>
만약, 희원이가 이길 수 있다면 첫째 줄에 "DA"를, 없다면 "NE"를 출력한다. 둘째 줄에는 희원이가 만들 수 있는 가장 아름다운 단어를 출력한다.

<문제 2872>
상근이는 컴퓨터 공학의 일인자가 되기 위해 책을 매우 많이 구매했다. 하지만, 집에 책장이 없어서 책을 탑처럼 쌓아놓고 있다.
오늘은 오랜만에 상근이가 집에서 휴식을 취하는 날이다. 상근이는 책을 알파벳 순서대로 정렬하려고 한다. 사전 순으로 가장 앞서는 책은 가장 위에 놓고, 가장 뒤에 있는 책은 가장 밑에 놓아야 한다. 책을 정렬할 때 사용할 수 있는 방법은 책 하나를 뺀 다음, 가장 위에 놓는 것이다.
책은 1부터 N까지 번호가 책 이름의 사전 순으로 매겨져 있다. 1은 사전 순으로 가장 앞서는 책이다. 따라서, 위에서부터 책의 번호를 읽으면 (1, 2, ..., N)이 되어야 한다. 예를 들어, 책이 3권있고 처음에 (3, 2, 1)로 쌓여있을 때, 2번 만에 사전순으로 책을 쌓을 수 있다. 가장 먼저, 2번 책을 뺀 다음에 가장 위에 놓는다. 그렇게 되면 (2, 3, 1)이 된다. 마지막으로, 1을 뺀 다음 가장 위에 놓으면 (1, 2, 3)이 된다.
현재 책이 어떻게 쌓여있는지가 주어졌을 때, 몇 번만에 사전 순으로 쌓을 수 있는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 책의 개수 N이 주어진다. (N ≤ 300,000)
다음 N개 줄에는 가장 위에 있는 책부터 아래에 있는 책까지 순서대로 주어진다.
<출력값>
첫째 줄에 몇 번만에 책을 정렬할 수 있는지 출력한다.

<문제 2873>
상근이는 우리나라에서 가장 유명한 놀이 공원을 운영하고 있다. 이 놀이 공원은 야외에 있고, 다양한 롤러코스터가 많이 있다.
어느 날 벤치에 앉아있던 상근이는 커다란 황금을 발견한 기분이 들었다. 자신의 눈 앞에 보이는 이 부지를 구매해서 롤러코스터를 만든다면, 세상에서 가장 재미있는 롤러코스터를 만들 수 있다고 생각했다.
이 부지는 직사각형 모양이고, 상근이는 R행 C열의 표 모양으로 나누었다. 롤러코스터는 가장 왼쪽 위 칸에서 시작할 것이고, 가장 오른쪽 아래 칸에서 도착할 것이다. 롤러코스터는 현재 있는 칸과 위, 아래, 왼쪽, 오른쪽으로 인접한 칸으로 이동할 수 있다. 각 칸은 한 번 방문할 수 있고, 방문하지 않은 칸이 있어도 된다.
각 칸에는 그 칸을 지나갈 때, 탑승자가 얻을 수 있는 기쁨을 나타낸 숫자가 적혀있다. 롤러코스터를 탄 사람이 얻을 수 있는 기쁨은 지나간 칸의 기쁨의 합이다. 가장 큰 기쁨을 주는 롤러코스터는 어떻게 움직여야 하는지를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 R과 C가 주어진다. (2 ≤ R, C ≤ 1000) 둘째 줄부터 R개 줄에는 각 칸을 지나갈 때 얻을 수 있는 기쁨이 주어진다. 이 값은 1000보다 작은 양의 정수이다.
<출력값>
첫째 줄에 가장 가장 큰 기쁨을 주는 롤러코스터는 가장 왼쪽 위 칸부터 가장 오른쪽 아래 칸으로 어떻게 움직이면 되는지를 출력한다. 위는 U, 오른쪽은 R, 왼쪽은 L, 아래는 D로 출력한다. 정답은 여러 가지 일 수도 있다.

<문제 2874>
상근이는 N행 N열로 이루어진 모눈종이를 구매했다. 모눈종이는 가장 처음에 모든 칸이 흰 색이다. 상근이는 이 칸 중 일부를 검정색으로 칠하려고 한다.
모눈종이의 경계선을 따라서 붙어있는 칸을 선택한다면, 직사각형을 만들 수 있다. 그리고 그 직사각형 내부의 색이 모두 검정색이고, 크기가 두 칸 이상이라면, 이 직사각형을 검정 직사각형이라고 한다.

왼쪽에서 선택한 직사각형은 모두 검정 직사각형이 아니다. 1번 직사각형은 내부의 색 중 한 칸이 흰색이고, 2번은 한 칸이기 때문에 검정 직사각형이 아니다. 오른쪽 그림에서 선택한 세 개 직사각형은 모두 검정 직사각형이다.
이렇게 상근이가 적절히 색칠한 모눈종이가 주어졌을 때, 겹치는 칸이 없게 검정 직사각형 두 개를 선택하는 방법의 수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N이 주어진다. (2 ≤ N ≤ 1000) 다음 줄부터 N개 줄에는 각 모눈종이 칸의 색이 주어진다. C는 검정색, B는 흰색을 의미한다.
<출력값>
첫째 줄에 겹치는 칸이 없게 두 검정 직사각형을 선택하는 방법의 수를 10007로 나눈 나머지 값을 출력한다.

<문제 2875>
백준대학교에서는 대회에 나갈 때 2명의 여학생과 1명의 남학생이 팀을 결성해서 나가는 것이 원칙이다. (왜인지는 총장님께 여쭈어보는 것이 좋겠다.)
백준대학교는 뛰어난 인재들이 많아 올해에도 N명의 여학생과 M명의 남학생이 팀원을 찾고 있다. 대회에 참여하려는 학생들 중 K명은 반드시 인턴쉽 프로그램에 참여해야 한다. 인턴쉽에 참여하는 학생은 대회에 참여하지 못한다.
백준대학교에서는 뛰어난 인재들이 많기 때문에, 많은 팀을 만드는 것이 최선이다.
여러분은 여학생의 수 N, 남학생의 수 M, 인턴쉽에 참여해야하는 인원 K가 주어질 때 만들 수 있는 최대의 팀 수를 구하면 된다.
<입력값>
첫째 줄에 N, M, K가 순서대로 주어진다. (0 ≤ M ≤ 100, 0 ≤ N ≤ 100, 0 ≤ K ≤ M+N),
<출력값>
만들 수 있는 팀의 최대 개수을 출력하면 된다.

<문제 2876>
오늘은 기초컴퓨터그래픽스의 퀴즈가 있는 날이다. 기다란 교실 안에는 N개의 책상이 한 줄로 늘어서 있는데, 각 책상당 두 명의 학생이 앉도록 되어있다.
모든 학생들은 그래픽스를  열심히 공부했지만, 말도 안되는 난이도에 질려 포기하고 말았다. 한편 교수님은 각 학생들의 얼굴만 보고도 이 학생이 받아야 할 그레이드를 정확히 알아낼 수 있다.
교수님은 그래픽스 과목을 가르치는 만큼 자신의 미적 감각을 살리기 위해 각 그레이드를 다른 색을 이용해서 표시한다(예를 들어 A를 빨강으로 칠하면, B,C,D는 빨강으로 표시하지 않는다).
또, 퀴즈의 방식은 교수님이 수업이 시작할 때 어떤 두 책상을 선택하고, 두 책상과 그 사이에 있는 모든 책상에서 각각 한 명씩 지목해서 질문을 하고, 학생의 대답을 듣는 것이다.
오늘 교수님은 바쁜 나머지 한 가지 색의 색연필만 가지고 왔고, 결국 자신의 미학을 지키기 위해 퀴즈에서 지목한 모두에게 같은 그레이드를 주려고 한다. 교수님이 채점할 수 있는 학생의 수는 최대 몇 명일까?
<입력값>
입력의 첫 번째 줄에는 정수 N이 주어진다(1 ≤ N ≤ 100,000).
다음 N개의 줄에는 i번째 책상에 앉은 두 학생이 받아야 할 그레이드 Ai와 Bi(1 ≤ Ai, Bi ≤ 5)가 주어진다.
<출력값>
교수님이 한 가지 색만을 이용해 채점할 수 있는 최대 학생 수와 그때의 그레이드를 출력한다.
만약 답이 여러 가지라면, 가장 작은 그레이드를 출력한다.

<문제 2877>
창영이는 4와 7로 이루어진 수를 좋아한다. 창영이가 좋아하는 수 중에 K번째 작은 수를 구해 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 K(1 ≤ K ≤ 109)가 주어진다.
<출력값>
첫째 줄에 창영이가 좋아하는 숫자 중 K번째 작은 수를 출력한다.

<문제 2878>
오늘 사탕 M개를 가득 담은 박스가 택배로 택희네 집에 도착했다. 택희는 이 사탕을 N명의 친구들에게 나누어 주려고 한다.
택희의 친구들은 문자로 사탕을 몇 개 받고 싶은지 보냈다. 만약 받고 싶은 개수만큼 사탕을 받지 못한다면, 그 친구는 분노하게 되고, 못 받는 개수가 많아질 수록 더욱 분노하게 된다.
놀랍게도 택희는 친구들의 분노를 수치화 할 수 있는데, 이것은 못 받는 사탕 개수의 제곱이다.
예를 들어, 택희의 친구 백준이가 받고 싶은 사탕의 개수가 32개였을 때, 사탕을 29개 받아 3개를 받지 못한다면, 그의 분노는 3의 제곱 9가 된다.
택희가 받은 사탕의 개수와 친구의 수, 그리고 그 친구들이 받고 싶어하는 사탕의 개수가 주어졌을 때, 사탕을 적절히 나누어 주어 친구들의 분노의 합을 최소화해 그 값을 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 M(1 ≤ M ≤ 2×109)와 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N개의 줄에는 각 친구들이 받고 싶어하는 사탕의 개수가 주어진다. 이 개수는 2×109보다 작으며, 친구들이 받고 싶어하는 사탕의 개수의 합은 항상 M을 넘는다.
<출력값>
첫째 줄에 택희 친구들의 분노의 합의 최솟값을 264로 나눈 나머지를 출력한다.

<문제 2879>
백준이는 한 작은 회사에 취직했다. 이 회사에서 백준이는 소스 코드의 뒤죽박죽인 인덴트를 고치고 있다. 인덴트는 각 줄을 탭 키를 이용해 들여 쓰는 것을 말한다. 다행히 백준이가 사용하는 편집기는 연속된 줄을 그룹으로 선택하고, 여기에서 각 줄의 앞에 탭을 추가하거나, 삭제할 수 있다. 백준이를 도와 코드의 뒤죽박죽인 인덴트를 예쁘게 고치는 방법을 생각해보자.
줄의 개수 N과 각 줄의 앞에 있는 탭의 개수와 올바른 탭의 개수가 주어진다. 이때, 한 번 편집을 할 때, 다음과 같은 명령을 수행할 수 있다.

연속된 줄을 그룹으로 선택한다.
선택된 줄의 앞에 탭 1개를 추가하거나 삭제한다.

위의 두 명령을 모두 수행하는 것이 하나의 편집이며, 선택된 줄의 개수와는 상관이 없다. 만약, 선택한 줄 중에 단 한 줄이라도 탭이 없을 경우에는, 탭을 삭제하는 명령을 수행할 수 없다.
백준이가 몇 번 편집 만에 코드의 인덴트를 올바르게 고칠 수 있는지 구하는 프로그램을 작성하시오. 이때, 편집 회수의 최솟값을 구해야 한다.
<입력값>
첫째 줄에 줄의 개수 N(1 ≤ N ≤ 1,000)이 주어진다. 둘째 줄에는 현재 줄에 있는 탭의 개수가 주어지며, 1번째 줄부터 순서대로 주어진다. 탭의 개수는 0보다 크거나 같고, 80보다 작거나 같은 정수이다. 셋째 줄에는 각 줄의 올바른 탭의 개수가 주어진다. 1번째 줄부터 순서대로 주어지며, 이 값도 0보다 크거나 같고, 80보다 작거나 같은 정수이다.
<출력값>
첫째 줄에 코드의 인덴트를 올바르게 고치는 편집 회수의 최솟값을 출력한다.

<문제 2881>
정부는 오크 나무 숲을 통과하는 산책길를 만들려고 한다. 숲을 평면으로 나타낼 수 있고, 나무 N개는 평면위의 격자점으로 나타낼 수 있다.
산책길은 축에 평행한 직사각형으로 나타낸다. 산책길의 변 위에 있는 나무는 베어내야 한다. 산책길 내부에 있는 나무는 문제가 되지 않으며, 베어내지 않아도 된다.
산림청에서는 산책길 계획을 공모전으로 열었고, 총 P개의 산책길가 접수되었다. 각각의 접수된 산책길에 대해서, 그 산책길를 만들려면 나무를 몇 개나 잘라내야하는지 구하는 프로그램을 작성하시오. 나무는 변 위에 있는 나무만 베어야한다.
<입력값>
첫째 줄에 나무의 수 N이 주어진다. (1 ≤ N ≤ 300,000)
다음 N개 줄에는 나무의 좌표 X와 Y가 한 줄에 하나씩 주어진다. 한 점위에 나무가 두 개 이상 있는 경우는 없다. (1 ≤ X, Y ≤ 109)
다음 줄에는 접수된 산책로 계획의 수 P (1 ≤ P ≤ 100,000)가 주어진다.
다음 P개 줄에는 X1, Y1, X2, Y2 (1 ≤ X1 < X2 ≤ 109, 1 ≤ Y1 < Y2 ≤ 109)가 주어진다. (X1, Y1)은 직사각형의 왼쪽 아래 좌표, (X2, Y2)는 오른쪽 위 좌표를 나타낸다.
<출력값>
총 P개의 줄에 각 산책로를 건설하려면 나무를 몇 개나 베어야 하는지 출력한다. 입력으로 주어진 순서를 지켜 출력한다.

<문제 2882>
상근이와 친구들이 술자리에서 하는 게임은 소수 사이클 게임이다. 각 사람은 1번부터 N번으로 나타낸다.
게임을 시작하기에 앞서 동그란 의자 N-1개와 네모난 의자 1개를 준비한다. 의자는 원을 이루어서 배치한다. 먼저, 1번이 네모난 의자에 앉고, 다음 2번부터는 반시계방향으로 차례대로 의자에 앉는다. 모든 사람은 원의 중심을 바라보고 있다.
게임은 총 K개 라운드로 이루어져 있다. i번째 라운드 시작되면 네모에 앉은 사람이 자리에서 일어나서 "내가 네모야!"라고 외친다. 그 다음, 오른쪽에 있는 사람과 자리를 총 Pi번 바꾸게 된다. Pi는 i번째 작은 소수이다.
아래는 N=5, K=3인 예이다.

N, K, A가 주어졌을 때, 게임이 끝난 후에 A의 이웃을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N, K, A가 주어진다. (3 ≤ N ≤ 5,000,000, 1 ≤ K ≤ 500,000, 1 ≤ A ≤ N)
<출력값>
게임이 끝난 후에 A의 오른쪽에 있는 사람과 왼쪽에 있는 사람을 출력한다.

<문제 2883>
얼마전 남극 연구 탐사진들은 새로운 종을 발견하였다. 연구진은 테스트를 하기 위해 샘플을 하나 추출해 연구실로 보냈다.
이번에 발견된 새로운 종은 짧은 주기를 갖고 번식한다. 번식할 때 부모는 하나만 있으면 된다. 한 부모는 두 번 번식할 수 있으며, 그 이후에는 더 이상 번식할 수 없다.
따라서, 연구실에 있는 표본의 수는 급속도로 늘어났고, 가계도가 필요한 시점이 되었다.
연구진은 간단한 텍스트 에디터를 이용해 가계도를 그리려고 한다. 가계도는 다음과 같은 규칙을 지켜야 한다.
표번의 이름은 '-', '|', 'o'로 이루어진 박스로 둘러쌓여져 있어야 한다. 윗 변과 아랫 변의 중앙에는 '+' 마크가 있어야 한다. 변의 길이가 짝수인 경우에는 두 중앙 중 왼쪽 중앙에 '+'를 표시한다.

박스를 링크를 이용해 연결해야 한다. 한 링크는 두 개 또는 그 이상의 박스를 연결할 수 있으며, '+'와 연결되어 있어야 한다. 부모 박스가 위에, 자식 박스가 아래에 있어야 한다. 박스와 링크는 겹칠 수 없다.

자식의 수가 1개인 경우에는 가장 왼쪽 그림에 나와있는 링크를 사용한다. 둘 이상의 자식을 가지는 경우에는 중간에 갈라진 링크를 사용해야 하며, 왼쪽에는 나이가 많은 자식, 오른쪽에는 적은 자식이 있어야 한다.
링크는 수평방향으로 늘어날 수 있으며, 좌우의 '-'의 개수는 같아야 한다. 링크는 수직방향으로 늘어날 수는 없다.
각 표본의 정보가 주어졌을 때, 가계도를 그리는데 필요한 문자의 개수를 구하는 프로그램을 작성하시오. 단, 공백의 개수는 세지 않으며, '-', '|', '+', 'o', 이름만 센다.
<입력값>
첫째 줄에 실험실에 있는 표본의 수 N (1 ≤ N ≤ 300,000)이 주어진다. 각 표본은 1번부터 N번까지 태어난 순서대로 번호가 매겨져 있다. 즉, 가장 나이가 많은 표본은 1, 어린 표본은 N이다.
다음 N개 줄에는 각 표본의 이름과 부모의 번호가 주어진다. (첫 번째 표본의 부모는 알 수 없다) 이름은 알파벳 소문자로만 이루어진 문자열로 길이는 20을 넘지 않는다.
<출력값>
첫째 줄에 가계도를 그리는데 필요한 글자의 수를 출력한다.

<문제 2884>
상근이는 매일 아침 알람을 듣고 일어난다. 알람을 듣고 바로 일어나면 다행이겠지만, 항상 조금만 더 자려는 마음 때문에 매일 학교를 지각하고 있다.
상근이는 모든 방법을 동원해보았지만, 조금만 더 자려는 마음은 그 어떤 것도 없앨 수가 없었다.
이런 상근이를 불쌍하게 보던, 창영이는 자신이 사용하는 방법을 추천해 주었다.
바로 "45분 일찍 알람 설정하기"이다.
이 방법은 단순하다. 원래 설정되어 있는 알람을 45분 앞서는 시간으로 바꾸는 것이다. 어차피 알람 소리를 들으면, 알람을 끄고 조금 더 잘 것이기 때문이다. 이 방법을 사용하면, 매일 아침 더 잤다는 기분을 느낄 수 있고, 학교도 지각하지 않게 된다.
현재 상근이가 설정한 알람 시각이 주어졌을 때, 창영이의 방법을 사용한다면, 이를 언제로 고쳐야 하는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 두 정수 H와 M이 주어진다. (0 ≤ H ≤ 23, 0 ≤ M ≤ 59) 그리고 이것은 현재 상근이가 설정한 놓은 알람 시간 H시 M분을 의미한다.
입력 시간은 24시간 표현을 사용한다. 24시간 표현에서 하루의 시작은 0:0(자정)이고, 끝은 23:59(다음날 자정 1분 전)이다. 시간을 나타낼 때, 불필요한 0은 사용하지 않는다.
<출력값>
첫째 줄에 상근이가 창영이의 방법을 사용할 때, 설정해야 하는 알람 시간을 출력한다. (입력과 같은 형태로 출력하면 된다.)

<문제 2885>
학교 근처 편의점에 새 초콜릿이 들어왔다. 이 초콜릿은 막대 모양이고, 각 막대는 정사각형 N개로 이루어져 있다. 초콜릿의 크기(정사각형의 개수)는 항상 2의 제곱 형태이다. 즉, 1, 2, 4, 8, 16, ...개의 정사각형으로 이루어져 있다.
상근이는 점심식사로 초콜릿을 먹는다. 이때, 적어도 K개 정사각형을 먹어야 남은 수업을 졸지 않고 버틸 수 있다. 상근이의 친구 선영이도 초콜릿을 좋아한다. 선영이는 초콜릿은 돈을 주고 사기 아깝다고 생각하기 때문에, 상근이가 주는 초콜릿만 먹는다.
상근이는 막대 초콜릿를 하나 산 다음에, 정확하게 K개 정사각형이 되도록 초콜릿을 쪼갠다. K개는 자신이 먹고 남는 것은 선영이에게 준다.
막대 초콜릿은 나누기 조금 어렵게 되어 있어서, 항상 가운데로만 쪼개진다. 즉, 정사각형이 D개 있는 막대는 D/2개 막대 두 조각으로 쪼개진다.
K개 정사각형을 만들기 위해서, 최소 몇 번 초콜릿을 쪼개야 하는지와 사야하는 가장 작은 초콜릿의 크기를 구하는 프로그램을 작성하시오. 상근이는 초콜릿을 하나만 살 수 있다. 꼭 한 조각이 K개일 필요는 없고, 여러 조각에 있는 정사각형을 합쳤을 때 K개이면 된다.
<입력값>
첫째 줄에 K가 주어진다. (1 ≤ K ≤ 1,000,000)
<출력값>
첫째 줄에는 상근이가 구매해야하는 가장 작은 초콜릿의 크기와 최소 몇 번 쪼개야 하는지를 출력한다.

<문제 2886>
R x C의 형태를 지닌 전차 안에는 의자와 사람들의 정보들이 주어진다. 사람들은 다리가 아픈 것을 매우 싫어하기 때문에 빈 의자가 보이면 무조건 앉으려고 한다.
하지만 나보다 의자에 가까이 있는 사람이 보이면, 그 사람이 먼저 앉는다는 것을 알기 때문에 양보할 수밖에 없다.
만약, 나보다 의자에 가까이 있는 사람은 없지만, 같은 거리에 있는 사람이 있으면 서로 자리를 차지하려고 할 것이므로, 그 자리는 전쟁터가 될 것이다. (심지어 모든 사람들은 싸움에 자신있기 때문에, 이러한 전쟁터를 거부하지 않는다(!) )

여러분들은 이 전차의 정보가 주어질 때, 전쟁터가 될 자리의 수를 세어주면 된다.
A행 B열에서 C행 D열과의 떨어진 거리 Dist는 다음과 같은 유클리드 거리로 계산된다.
Dist² = (A-C)² + (B-D)²
(번역 주 : 수식을 못넣어서 이렇게 표현합니다. ㅜㅜ)
<입력값>
첫 줄에는 R과 C가 입력된다. (1 ≤ R ≤ 100) and (1 ≤ C ≤ 100)
이후 R개의 줄에 걸쳐 문자가 C개씩 주어진다. 이 문자는 '.' (빈 공간), 'X' (사람), 'L' (좌석) 만 주어지는 것이 보장된다.
'X'와 'L' 문자는 적어도 하나 이상이 주어짐이 보장되고, 하나의 'X' 문자와 같은 거리에 떨어진 'L'은 2개 이상 존재하지 않음이 보장된다.
<출력값>
전쟁터의 수를 출력하면 된다.

<문제 2887>
때는 2040년, 이민혁은 우주에 자신만의 왕국을 만들었다. 왕국은 N개의 행성으로 이루어져 있다. 민혁이는 이 행성을 효율적으로 지배하기 위해서 행성을 연결하는 터널을 만들려고 한다.

	행성은 3차원 좌표위의 한 점으로 생각하면 된다. 두 행성 A(xA, yA, zA)와 B(xB, yB, zB)를 터널로 연결할 때 드는 비용은 min(|xA-xB|, |yA-yB|, |zA-zB|)이다.

	민혁이는 터널을 총 N-1개 건설해서 모든 행성이 서로 연결되게 하려고 한다. 이때, 모든 행성을 터널로 연결하는데 필요한 최소 비용을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 행성의 개수 N이 주어진다. (1 ≤ N ≤ 100,000) 다음 N개 줄에는 각 행성의 x, y, z좌표가 주어진다. 좌표는 -109보다 크거나 같고, 109보다 작거나 같은 정수이다. 한 위치에 행성이 두 개 이상 있는 경우는 없다.
<출력값>
첫째 줄에 모든 행성을 터널로 연결하는데 필요한 최소 비용을 출력한다.

<문제 2888>
상범이와 영훈이는 체스를 변형한 새롭고 참신하며 혁신적인 게임을 개발했다. 이 게임은 R행 C열의 체스판에서 플레이되는 게임이다. 각 플레이어는 몇개의 체스 킹 말을 가지고 시작한다. 체스 킹은 상하좌우 대각선 총 8방향으로 한 칸씩 이동할 수 있다.
이 게임의 가장 독특한 점은 점수 계산 방법이다. 상범이가 만든 게임인지라 역시 기괴함을 자랑하는데, 각 플레이어의 모든 두 킹 간의 최단 거리의 합이 점수가 된다. 이때 두 말 사이의 최단 거리는 한 킹이 다른 킹의 위치까지 이동하기 위해 필요한 이동의 횟수이다. 이때, 이러한 이동 경로 위에 다른 말이 있어도 무시하고 최단 거리를 계산해야 한다.
현재 게임 판의 상태가 주어졌을 때, 상범이와 영훈이의 점수를 구해보자.
<입력값>
첫 번째 줄에는 행의 수 R과 열의 수 C가 주어진다(1 ≤ R, C ≤ 1,000).
다음 R개의 줄에는 C개의 문자가 주어지는데, 'M'은 상범이의 킹, 'S'는 영훈이의 킹, 그리고 '.'은 빈 칸을 이야기한다.
체스판에는 상범이와 영훈이의 말이 최소한 하나씩은 존재한다.
<출력값>
첫 번째 줄에 상범이와 영훈이의 점수를 공백으로 구분하여 출력한다.

<문제 2889>
도시 N개와 도로를 연결하는 양방향 고속도로 E개로 이루어진 나라가 있다. 이 나라의 거대한 두 레스토랑 체인점은 서로 공평하게 시장을 점유하기로 결정했다. 도로의 각 중앙에는 한 레스토랑만 만들 수 있다.
두 레스토랑은 공평하게 시장을 점유하기로 결정했기 때문에, 각 도시와 연결된 도로에는 두 레스토랑이 적어도 하나씩 있어야 한다. 하지만, 도시와 연결된 도로가 하나이거나 없는 경우에는 두 체인점이 인접하는 것은 불가능하다. 이러한 경우에는 한 체인점만 이용하거나, 다른 곳으로 멀리 여행을 가면 되기 때문에 신경쓰지 않아도 된다.
위의 조건을 만족하면서 각 도로에 어떤 레스토랑 체인점을 세워야 하는지를 결정하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 도시의 수 N과 도로의 수 E가 주어진다. (1 ≤ N, E ≤ 100,000)
다음 E개 줄에는 도로의 정보 Ai와 Bi가 주어진다. 도시 Ai와 Bi를 연결하는 도로라는 뜻이며, Ai와 Bi는 같지 않다. 또, 두 도시를 연결하는 도로가 둘 이상인 경우는 없다.
<출력값>
출력은 총 E줄을 해야 한다. i번째 줄에는 입력으로 주어진 i번째 도로에 1번 레스토랑을 놓을 것이면 1을, 2번을 놓을 것이면 2를 출력한다. 만약, 문제의 조건을 만족시키게 레스토랑을 배치할 수 없다면 0을 출력한다.

<문제 2890>
상근이는 카약 대회를 개최했다. 대회는 전세계에 생중계되고, 위성이 경기장 전체를 촬영하고 있다. 상근이는 위성 사진을 바탕으로 실시간 순위를 계산하는 프로그램을 만들려고 한다.
위성 사진은 R행 C열이다. 모든 줄의 첫 번째 글자는 'S'이고 출발선을 의미한다. 또, 마지막 글자는 'F'이고 이것은 결승선을 의미한다. 대회에 참가한 팀은 총 9팀이고, 각 팀은 1부터 9까지 번호가 매겨져 있다. 카약은 항상 열에 대해 연속하는 세 칸을 차지하며, 카약 번호로 표시한다. 마지막으로 물은 '.'로 나타나 있다.
팀의 순위는 결승선으로부터 떨어진 거리로 측정한다. 가까울수록 순위가 높다. 만약, 두 팀이 결승선과 떨어진 거리가 같다면, 같은 등수이다.
<입력값>
첫째 줄에 R과 C가 주어진다. 다음 R개 줄에는 '.', 'S', 'F', '1'~'9'로 이루어진 위성 지도가 주어진다. 한 줄에는 최대 한 개의 카약만 있고, 위성 사진에 있는 카약은 항상 9개이다. (10 ≤ R, C ≤ 50)
<출력값>
출력은 총 9줄을 해야 한다. i번째 줄에는 i번 팀의 등수를 출력한다. (i=1~9)

<문제 2891>
2890번을 보면 알겠지만, 상근이는 카약 대회를 개최했다. 그런데, 갑자기 엄청난 강풍이 경기장에 불었고, 일부 카약이 부서졌다. 경기는 5분 안에 시작해야 하는 상황이다.
다행히 일부 팀은 혹시 모를 사태에 대비해서 카약을 하나 더 경기장에 들고 왔다. 카약은 매우 무겁고 운반하기 어렵다. 따라서, 자신의 바로 다음이나 전에 경기하는 팀에게만 카약을 빌려주려고 한다. 즉, 팀 4는 여분의 카약을 3이나 5에게만 빌려줄 수 있다. 또, 카약을 하나 더 가져온 팀의 카약이 손상되었다면, 여분의 카약으로 경기에 출전하게되고, 이 카약은 다른 팀에게 빌려줄 수 없다.
카약이 부서진 팀과 하나 더 가져온 팀이 주어진다. 카약을 적절히 빌렸을 때 출발하지 못하는 팀의 최솟값은 몇 팀인지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 팀의 수 N, 카약이 손상된 팀의 수 S, 카약을 하나 더 가져온 팀의 수 R이 주어진다. (2 ≤ N ≤ 10, 1 ≤ S, R ≤ N)
둘째 줄에는 카약이 손상된 팀의 번호가 주어진다. 팀 번호는 중복되지 않는다.
셋째 줄에는 카약을 하나 더 가져온 팀의 번호가 주어진다. 팀 번호는 중복되지 않는다.
<출력값>
첫째 줄에 출발을 할 수 없는 팀의 최솟값을 출력한다.

<문제 2892>
해빈이는 준규에게 메세지를 받았다. 준규는 세계 최고 수준의 암호학자이기 때문에 해빈이에게 암호로 메세지를 보낸다. 이번에 준규는 One Time Pad(OTP) 암호화 방식을 사용하기로 했다. 준규는 OTP방식을 제대로 적용하면 절대 해독할 수 없다는 것을 알기 때문에, 해빈이가 해석할 수 있도록 몇 가지 힌트를 같이 보내기로 했다.
준규는 메세지에 항상 영소문자, 온점('.'), 공백 (' ', ASCII코드 32)만 쓴다. 그리고 key값으로는 항상 '0'부터 '9'까지의 숫자만 쓴다. 이 사실을 알고 있는 해빈이는 이를 이용해 메세지에 있는 온점과 공백의 위치를 알 수 있다는 것을 깨닫고, 당신에게 프로그램으로 만들어달라고 부탁했다.
준규가 이런 메세지를 보낸 게 한두 번이 아니기 때문에 해빈이는 OTP 암호화 방식을 알고 있다. 예를 들어 "0120123"을 key로 사용해서 "abc efg"라는 문자열을 암호화하면 아래와 같다.



abc efg
			0120123
61 62 63 20 65 66 67
			30 31 32 30 31 32 33
51 53 51 10 54 54 54




Start
ASCII hexadecimal
excrypted message



먼저 key와 메세지 원문을 ASCII 인코딩을 사용해 16진수로 변환한다. 그리고 변환한 key와 원문을 각각 차례대로 XOR 연산한다. 그 결과가 암호화 된 메세지이다.
<입력값>
입력에 첫 줄에는 암호화 된 메세지의 길이인 정수 N (1 ≤ N ≤ 1000)이 주어진다.
다음 줄에는 암호화 된 메세지가 N개의 16진수 정수로 주어진다. 이 수는 0(10진수) 이상 127(10진수) 이하이다.
<출력값>
N개의 문자를 한 줄에 출력한다. 만약 i번째 글자가 문자라면 '-'를, 아니라면 '.'을 출력한다.

<문제 2893>
동혁이는 스케치북에 직각 이등변 삼각형 N개를 그리려고 한다. 동혁이가 가지고 있는 크레파스는 흰색과 검정색이다.

	동혁이가 삼각형을 그릴때마다, 삼각형 내부의 색을 모두 반전시킨다. 즉, 흰색은 검정색으로, 검정색은 흰색으로 칠한다.



	이때, 검정색의 면적을 구하는 프로그램을 작성하시오. 가장 처음에 스케치북은 흰색으로 칠해져 있다.
<입력값>
첫째 줄에 삼각형의 개수 N(1 ≤ N ≤ 10)이 주어진다. 다음 N개의 줄에는 직각 이등변 삼각형의 정보 X, Y, R(1 ≤ X, Y, R ≤ 106)이 주어진다. (X,Y)는 삼각형의 왼쪽 아래 꼭짓점의 좌표이고, R는 삼각형 두 변의 길이이다.
<출력값>
첫째 줄에, 검정색으로 칠해진 영역의 면적을 소수점 첫째자리까지 출력한다.

<문제 2894>
안녕 친구들? 내 이름은 홍즈. 세계에서 제일 유명한 탐정이지. 요즘 내가 가는 곳마다 살인 사건이 끊이질 않아서 고민이야(웃음)! 서로에게 상처밖에 주지 못하는 불쌍한 사람들... 어쨋든 오늘도 나는 살인 사건을 찾아 헤매이고 있지. 돈을 벌어야 하니까.
나는 지금까지 탐정을 하면서 얻은 경험으로 사람이 일으키는 사건의 인과관계를 간단하게 압축할 수 있었어. 예를 들어 사건 A가 일어났다면 무조건 사건 B가 일어나야 한다는 것을 알고 있어. 이런 관계를 A → B라고 나타내자. 사건이 여러개 이어져서 A → B → C와 같은 관계가 있을 수도 있어, 하지만 A → B → C → ... → A 같은식으로 순환하는 관계는 없어. 그리고 만약 A → C이고 B → C라고 하고 사건 C가 일어났다고 하자. 이런 경우에는 사건 A나 사건 B중 하나는 일어났을거라는 사실을 알 수 있어.
오늘도 오늘의 살인 사건이 일어났군. 지금 증거들을 수집했어, 이걸로 나는 총 N개의 사건이 일어났다는 것을 알 수 있었어. 이것으로 나는 무조건 일어났을 다른 사건들이 더 있다는 사실을 알게 되었어. 나는 지성과 경험을 모두 겸비한 탐정이니까. 당신도 과연 알 수 있을까?
<입력값>
첫 번째 줄에 일어날 수 있는 사건의 개수 D (1 ≤ D ≤ 1000), 사건들 간의 관계의 개수 M (1 ≤ M ≤ 100000), 그리고 일어난 사건의 개수 N (1 ≤ N ≤ D)이 공백으로 구분되어 주어진다.
다음 M개의 줄에는 두 정수 A와 B(1 ≤ A, B ≤ D)가 주어지는데 이는 사건 A,B가  A → B인 관계에 있음을 나타낸다.
마지막으로 다음 N개의 줄에는 일어난 사건을 나타내는 정수 X (1 ≤ X ≤ D)가 주어진다.
<출력값>
무조건 일어나야 하는 사건을 한 줄에 공백으로 구분하여 출력한다. 순서는 상관없다.

<문제 2895>
그렘린은 작고, 재미있고, 털이 보송보송한 상상 속의 요정이다. 그렘린의 종류는 N가지이며, 편의상 종류별로 1번 부터 N번까지 차례대로 번호가 매겨져있다.
T년 전 한 연구소에서 폭발이 일어나 N 종류의 그렘린이 한 마리씩 생겨났다. 그렘린은 두 단계의 성장 과정(알 → 성장기)을 지나 완전히 자란다.
종류가 i인 그렘린은 알에서 부화하고 Yi년 동안 성장기를 지난다. 성장을 완전히 마친 그렘린은 완전한 성장 직후 Ki개의 알을 낳는다. 각 알 별로 태어나는 그렘린 종류가 다를 수 있고, 알이 부화하는데 걸리는 시간도 다를 수 있다. 안타깝게도 그렘린은 알을 다 낳고 죽는다.
폭발이 일어나고 T년이 지난 현재, 과학자들은 여태까지 존재했던 그렘린 중에 조상이 가장 많은 그렘린이 궁금해졌다. 다만 과학자들은 아직 부화하지 않은 그렘린은 고려하지 않는다. 여기서 조상이란, 부모, 부모의 부모, 부모의 부모의 부모, ... 만 고려한다. 올해 부화 예정인 알들은 모두 부화되었다고 봐도 무방하다.
과학자들을 도와 가장 조상이 많은 그렘린의 조상수를 구하는 프로그램을 작성하시오.
<입력값>
첫 줄에 그렘린 종류의 수 N과 폭발이 일어난 뒤 지난 년 수 T가 주어진다. (1 ≤ N ≤ 100, 1 ≤ T ≤ 1015)
다음 3N개의 줄에 그렘린 종류에 대한 입력이 주어진다.

첫 줄에는 자연수 Ki와 Yi가 주어진다. (1 ≤ Ki ≤ 1000, 1 ≤ Yi ≤ 1000) Ki는 부화하는 알의 개수이고, Yi는 i번 종류의 그렘린이 부화한 뒤 성장기를 거치는 기간을 의미한다.
둘째 줄에는 각 알이 부화되고 나오는 그렘린의 종류를 나타내는 Ki개의 자연수가 주어진다.
셋째 줄에는 각 알이 부화하는데 걸리는 년 수가 주어진다. 이는 1이상 1000 이하의 값이다.
<출력값>
첫 줄에 가장 조상이 많은 그렘린의 조상의 수를 출력한다.

<문제 2896>
상근이와 지수는 마트에서 오렌지 주스, 사과 주스, 파인애플 주스를 구매했다. 그들은 인터넷에서 찾은 방법으로 무알콜 칵테일을 만들어 학교에서 팔려고 한다. 하지만, 칵테일을 만드는 방법을 찾기 전에 주스를 구매했기 때문에, 주스가 남을 수도 있다.
무알콜 칵테일을 만드는데 필요한 오렌지, 사과, 파인애플 주스의 비율과 구매한 주스의 양이 주어진다. 칵테일을 최대한 많이 만들었을 때, 각 주스가 얼만큼 남는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 구매한 오렌지, 사과, 파인애플 주스의 양 A, B, C가 주어진다. (1 ≤ A, B, C ≤ 500)
둘째 줄에 칵테일을 만드는데 필요한 각 주스의 비율 I, J, K가 주어진다. (1 ≤ I, J, K ≤ 50)
<출력값>
첫째 줄에 칵테일을 최대한 많이 만들었을 때, 각 주스가 얼만큼 남는지를 공백으로 구분하여 출력한다. 정답과의 오차는 10-4까지 허용한다.

<문제 2897>
해빈이가 드디어 면허를 땄다! 해빈이의 부모님은 기뻐하며 해빈이에게 첫 차로 몬스터 트럭을 사 주셨다. 해빈이는 자신의 첫 차가 강남 대로의 모든 차를 부수면서 러시 아워조차 자신을 막을 수 없다는 것을 깨닫고 기뻐했지만, 차가 다른 차들의 네 배 크기이기 때문에 주차하는 데 애를 먹고 있었다.
그걸 본 준규는 마침 강남에서 공영 주차장 아르바이트를 하고 있기 때문에 정기적으로 해빈이에게 강남 주차장 지도를 보내주기로 했다. 지도는 R행 C열의 표로 이뤄져 있다. 표의 각 칸은 빌딩('#'), 주차 된 차('X'), 또는 빈 주차 공간('.')이다. 해빈이의 차는 꽤 커서 정확히 2행 2열의 칸을 차지한다.
해빈이를 도와 가능한 주차 공간을 해빈이가 부숴야 하는 차의 수대로 모아서 보여주자. 이때 주차하기 위해 부숴야 하는 차만 고려한다. (주차 하러 가는 길에 부수는 차는 신경쓰지 않는다.) 단, 아무리 몬스터 트럭이라도 빌딩을 부술 수는 없기 때문에 빌딩이 있는 자리에는 주차를 할 수 없다.
<입력값>
입력의 첫 줄에 두 정수 R과 C(2 ≤ R, C ≤ 50)가 주어진다. R은 행의 개수, C는 열의 개수이다.
두 번째 줄에는 R개의 줄에 각각 C개의 문자가 주어진다. 이 문자는 '#', 'X', '.'로만 이뤄져 있다. 'X'는 항상 영대문자이다.
<출력값>
출력은 다섯 줄이다. 첫째 줄에는 해빈이가 아무 차도 부수지 않으면서 주차할 수 있는 공간의 개수, 둘째 줄은 차 한 대를 부수고 주차할 수 있는 공간의 개수, 셋째 줄은 차 두 대, 넷째 줄은 차 세 대, 다섯째 줄은 차 네 대를 부수고 주차할 수 있는 공간의 개수이다.

<문제 2898>
한중혁은 자신의 몬스터 트럭으로 도시의 절반을 날려버린 대가로 유명한 고고학자의 조수로 일하게 되었다. 그의 임무 중 하나는 고대 문서 상자의 열쇠를 만드는 일이다.
고대 문서 상자는 흥미로운 자물쇠가 달린 정교한 매커니즘으로 구성되어있다. 각각의 자물쇠는 너비 W cm, 높이 L cm 이며 상단부, 하단부, 그리고 이 둘 사이의 빈 공간으로 구성되어있다. 상단부와 하단부는 음이아닌 정수의 수열 r1, r2, r3, ..., rL로 나타내진다.
각 자물쇠에 맞는 열쇠는 가장자리 사이의 공간에 완벽하게 맞는 작은 점토 탭으로 되어있다. 아래 그림은 7cm X 8cm 형태의 자물쇠와 이에 맞는 열쇠를 나타낸다. 상단부를 나타내는 수열은 {2, 1, 3, 2, 3, 2, 3}이며 하단부를 나타내는 수열은 {3, 4, 2, 3, 2, 3, 4}이다.

한중혁은 하나의 열쇠가 두 개 이상의 자물쇠를 열 수도 있다는 것을 발견했다. 열쇠를 만드는 작업은 매우 힘들기 때문에 최소한의 열쇠로 모든 자물쇠를 열고자 한다. 한중혁의 작업을 덜어주기 위해, 최소 몇 개의 열쇠를 만들어야 하는지 알려주자.
<입력값>
입력의 첫 번째 줄에는 자물쇠의 너비 W (1 ≤ W ≤ 108), 자물쇠의 길이 L (1 ≤ L ≤ 1000), 그리고 자물쇠의 개수 N (1 ≤ N ≤ 100)이 주어진다.
다음 2N개의 줄은 자물쇠의 정보를 나타낸다. 각 줄은 W보다 작은 L개의 수로 구성되어 있으며 상단부를 나타내는 수열과 하단부를 나타내는 수열이 주어진다. 모든 자물쇠는 상단부와 하단부 사이에 적어도 1cm의 빈 공간이 존재한다.
<출력값>
한중혁이 만들어야 할 열쇠의 최소 개수를 출력한다.

<문제 2899>
홍준이의 눈 앞에 N개의 색칠된 구슬이 놓여있다. 구슬의 색은 서로 다를 수 있다. 만약 같은 색의 구슬들이 K개 이상 연속되어 있으면 그 구슬들을 없앨 수 있다. 또한 구슬들을 없애는 작업을 미뤘다가 나중에 할 수도 있다. 운이 좋게도 홍준이에게는 구슬이 많이 있어 구슬들 사이에 원하는 색의 구슬을 끼워 넣을 수 있다. 물론, 맨 앞과 맨 뒤에도 놓을 수 있다.
홍준이를 도와 최소 개수의 구슬을 새로 끼워 넣어 모든 구슬을 없애는 프로그램을 작성하시오.
<입력값>
첫 줄에 N과 K가 주어진다. (1 ≤ N ≤ 100, 2 ≤ K ≤ 5)
그리고 다음 줄에 놓여져 있는 구슬의 색이 차례대로 주어진다. 구슬의 색은 1이상 100이하의 자연수로 표현된다.
<출력값>
놓여져 있는 구슬을 모두 없애기 위해 새로 끼워 넣어야되는 구슬의 최소 개수를 출력한다.

<문제 2900>
창영이가 에러를 찾기 위해서 디버깅을 하고 있다. 이 프로그램은 크기가 N이고 0으로 채워져있는 배열을 a를 만들고, 아래 something 함수를 호출한다.

void something(int jump) {
    int i = 0;
    while (i < N) {
        a[i] = a[i] + 1;
        i = i + jump;
    }
}
창영이는 함수를 K번 호출하려고 한다. 각각 호출할 때, 인자로 넘기는 jump의 값은 X1, X2, X3, ... Xk 순서이다.
이렇게 호출한 뒤에는 배열의 값이 정상적으로 들어갔는지를 확인하려고 한다. 확인은 총 Q번 하고, 매번 확인을 할 때마다 L과 R(L ≤ R)을 정한뒤, 그 구간의 배열의 합을 구한다. 즉, a[L] + a[L+1] + ... + a[R]을 구한다.
함수를 호출할 때 필요한 X의 값과 창영이가 확인한 횟수 Q가 주어졌을 때, 확인한 결과(배열의 합)을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 배열의 크기 N과 함수의 호출 횟수 K가 주어진다. (1 ≤ N, K ≤ 106)
둘째 줄에 함수를 호출할 때 사용하는 인자의 값 X1, X2..., Xk가 공백으로 구분되어 주어진다. (1 ≤ Xi < N)
셋째 줄에는 확인하는 횟수 Q가 주어진다. (1 ≤ Q ≤ 106)
넷째 줄부터 Q개 줄에는 각 확인에 사용하는 L과 R이 주어진다. (0 ≤ L ≤ R < N)
<출력값>
출력은 총 Q줄이다. 창영이가 확인하는데 사용한 L과 R이 주어졌을 때, a[L] + a[L+1] + a[L+2] ... + a[R]을 출력한다.

<문제 2901>
You are given an matrix of R rows and C columns. All elements of the matrix are by their absolute value smaller than or equal to 104.
You may perform the following operations:



Operation
Notation
Example




Rotate i-th row of he matrix k elements right
rotR i k
rotR 3 1
			\(\begin{pmatrix} 1 & 2 & 3 \\ 4 & 5 & 6 \\ 7 & 8 & 9 \\ 10 & 11 & 12 \end{pmatrix}\rightarrow \begin{pmatrix} 1&2&3 \\ 4&5&6 \\ 9&7&8\\10&11&12 \end{pmatrix} \)


Rotate j-th column of the matrix k elements down
rotS j k
rotS 3 2
			\(\begin{pmatrix} 1 & 2 & 3 \\ 4 & 5 & 6 \\ 7 & 8 & 9 \\ 10 & 11 & 12 \end{pmatrix}\rightarrow \begin{pmatrix} 1&2&9 \\ 4&5&12 \\ 7&8&3\\10&11&6 \end{pmatrix} \)


Multiply all elements in the i-th row by -1, if and only if none of them were multiplied before.
negR i
negR 2
			\(\begin{pmatrix} 1 & 2 & 3 \\ 4 & 5 & 6 \\ 7 & 8 & 9 \\ 10 & 11 & 12 \end{pmatrix}\rightarrow \begin{pmatrix} 1 & 2 & 3 \\ -4 & -5 & -6 \\ 7 & 8 & 9 \\ 10 & 11 & 12 \end{pmatrix}\)


Multiply all elements in the j-th column by -1, if and only if none of them were multiplied before.
negS j
negS 1
			\(\begin{pmatrix} 1 & 2 & 3 \\ 0&0&0 \\ 7 & 8 & 9 \\ 10 & 11 & 12 \end{pmatrix}\rightarrow \begin{pmatrix} -1 & 2 & 3 \\ 0 & 0 & 0\\ -7 & 8 & 9 \\ -10 & 11 & 12 \end{pmatrix}\)



Using limited number of these operations, you need to maximize the sum of all the elements of the matrix.
<입력값>
The first line of input contains two integers R and C (1 ≤ R, C ≤ 100), number of rows and columns.
The next R lines contain C integers each. All integers are by their absolute value smaller than 104.
<출력값>
The first line of output should contain two integers, the maximal sum obtainable and the number of operations used. We shall call this number T. The next T lines should contain any sequence of operations leading to the sum. Each operation should follow the notation defined in the table below. For details look at sample test cases.

If the obtained sum is not maximal, one of the elements was multiplied more than once or the sequence of operations printed does not lead to the sum, 0 points are awarded.
Otherwise, the number of points depends on the number of operations used
	
For T≤5×R×C, you are awarded 100% of points allocated to that test case
For T>5×R×C,  you are awarded 0 points for that test case

<문제 2902>
KMP 알고리즘이 KMP인 이유는 이를 만든 사람의 성이 Knuth, Morris, Prett이기 때문이다. 이렇게 알고리즘에는 발견한 사람의 성을 따서 이름을 붙이는 경우가 많다.
또 다른 예로, 유명한 비대칭 암호화 알고리즘 RSA는 이를 만든 사람의 이름이 Rivest, Shamir, Adleman이다.
사람들은 이렇게 사람 성이 들어간 알고리즘을 두 가지 형태로 부른다.

첫 번째는 성을 모두 쓰고, 이를 하이픈(-)으로 이어 붙인 것이다. 예를 들면, Knuth-Morris-Pratt이다. 이것을 긴 형태라고 부른다.
두 번째로 짧은 형태는 만든 사람의 성의 첫 글자만 따서 부르는 것이다. 예를 들면, KMP이다.

동혁이는 매일매일 자신이 한 일을 모두 메모장에 적어놓는다. 잠을 자기 전에, 오늘 하루 무엇을 했는지 되새겨 보는 것으로 하루를 마감한다.
하루는 이 메모를 보던 중, 지금까지 긴 형태와 짧은 형태를 섞어서 적어 놓은 것을 발견했다.
이렇게 긴 형태로 하루 일을 기록하다가는 메모장 가격이 부담되어 파산될 것이 뻔하기 때문에, 앞으로는 짧은 형태로 기록하려고 한다.
긴 형태의 알고리즘 이름이 주어졌을 때, 이를 짧은 형태로 바꾸어 출력하는 프로그램을 작성하시오.
<입력값>
입력은 한 줄로 이루어져 있고, 최대 100글자의 영어 알파벳 대문자, 소문자, 그리고 하이픈 ('-', 아스키코드 45)로만 이루어져 있다. 첫 번째 글자는 항상 대문자이다. 그리고, 하이픈 뒤에는 반드시 대문자이다. 그 외의 모든 문자는 모두 소문자이다.
<출력값>
첫 줄에 짧은 형태 이름을 출력한다.

<문제 2903>
상근이는 친구들과 함께 SF영화를 찍으려고 한다. 이 영화는 외계 지형이 필요하다. 실제로 우주선을 타고 외계 행성에 가서 촬영을 할 수 없기 때문에, 컴퓨터 그래픽으로 CG처리를 하려고 한다.
외계 지형은 중앙 이동 알고리즘을 이용해서 만들려고 한다.
알고리즘을 시작하면서 상근이는 정사각형을 이루는 점 4개를 고른다. 그 후에는 다음과 같은 과정을 거쳐서 지형을 만든다.

정사각형의 각 변의 중앙에 점을 하나 추가한다.
정사각형의 중심에 점을 하나 추가한다.

첫 단계에서 위와 같은 과정을 한 번 거치면 총 4개의 정사각형이 새로 생긴다. 이와 같은 과정을 상근이가 만족할 때 까지 계속한다.
아래 그림은 과정을 총 2번 거쳤을 때 까지의 모습이다.

상근이는 어떤 점은 한 개 보다 많은 정사각형에 포함될 수 있다는 사실을 알았다. 메모리 소모량을 줄이기 위해서 중복하는 점을 한 번만 저장하려고 한다. N 단계를 거친 후 점 몇 개를 저장해야 하는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N이 주어진다. (1 ≤ N ≤ 15)
<출력값>
첫째 줄에 N 단계를 거친 후에 점의 수를 출력한다.

<문제 2904>
상근이의 할머니는 매우 유명한 수학자이다. 할머니는 매일 수학 문제로 상근이를 힘들게 한다. 할머니는 종이 N장에 숫자를 하나씩 쓴 다음 상근이에게 준다. 그 다음 상근이는 다음과 같이 문제를 풀어야 한다.

	두 수 A와 B를 고르고, A를 나눌 수 있는 소수 X를 고른다. 그 다음, A를 지우고 A/X를 쓰고, B를 지우고 B×X를 쓴다.

	상근이는 위의 행동을 무한히 반복할 수 있다. 할머니는 상근이가 만든 수를 보고 점수를 계산한다. 점수가 높을수록 할머니는 상근이에게 사탕을 많이 준다. 점수는 종이에 적혀있는 모든 수의 최대공약수이다.

	상근이가 얻을 수 있는 가장 높은 점수를 구하는 프로그램을 작성하시오. 또, 그 점수를 얻으려면 최소 몇 번 해야 하는지도 구한다.
<입력값>
첫째 줄에 N이 주어진다. (1 ≤ N ≤ 100) 둘째 줄에는 종이에 적혀있는 수 N개가 주어진다. 수는 모두 1,000,000보다 작거나 같은 양의 정수이다.
<출력값>
첫째 줄에 상근이가 얻을 수 있는 가장 큰 점수와 최소 몇 번 만에 그 점수를 얻을 수 있는지를 출력한다.

<문제 2905>
홍준이는 오래된 울타리를 색칠해야한다. 이 울타리는 너비가 1cm이고 높이가 여러 가지인 널빤지 N개로 만들어졌다. 색칠을 빨리 하기 위해, 홍준이는 롤러 Super Paint Roller Deluxe를 샀다. 이 롤러의 폭은 X cm이다. 홍준이는 색칠을 할 때, 롤러의 모든 부분이 널빤지를 벗어나지않게 해야한다. 그렇지 않으면 페인트가 흘러서 주위를 얼룩지게 할 수 있다. 또한, 색칠 중에 롤러는 언제나 땅과 평행해야한다. 즉, 홍준이가 롤러를 안전하게 쓰기 위해서는, X개의 연속된 널빤지를 선택해서 맨 밑에서부터 X개의 널빤지 중 가장 높이가 낮은 널빤지 전체를 색칠할 때까지, 한 번에 색칠해야한다. 그 다음 다른 X개의 널빤지를 선택해서, 같은 방법으로 칠하는 작업을 반복한다.
이렇게 색칠하면 널빤지의 몇 부분이 색칠되지 않으므로, 홍준이는 그 부분을 칫솔로 페인트칠 해야한다. 이건 누구나 알다시피 지루한 작업이기 때문에, 홍준이는 여러분에게 Super Paint Roller Deluxe를 이용해서 가장 많은 영역을 색칠할 수 있도록 도움을 요청했다. 이러한 방법이 여러 가지 있다면, 홍준이는 최소한의 롤러질 횟수로 색칠하려고한다. 홍준이를 도와, 칫솔로 칠해야 할 널빤지의 최소 넓이와 최소 롤러질 횟수를 구하는 프로그램을 작성하시오.
<입력값>
첫 번째 줄에 널빤지의 수 N (1 ≤ N ≤ 1 000 000), Super Paint Roller Deluxe의 너비 X (1 ≤ X ≤ 100 000, X ≤ N)가 주어진다.
두 번째 줄에 널빤지들의 높이를 의미하는 1 000 000 이하의 자연수 N개가 주어진다.
<출력값>
첫 번째 줄에 홍준이가 칫솔로 칠해야하는 널빤지 넓이의 최솟값을 출력한다.
두 번째 줄에 이때 필요한 최소한의 롤러질 횟수를 출력한다.

<문제 2906>
준규는 화학과 대학원생이다. 준규의 랩에서는 최근 흥미로운 테입을 발견했다. 이 테입은 N개의 서로 같은 길이의 조각으로 이뤄져 있는데, 두 조각 사이는 쉽게 구부러지지만 정확히 180도로만 구부러진다.
테입의 한 면은 매우 불안정한 휘발성 화학물질로 코팅되어 있다. 만약 이 코팅된 면끼리 닿는다면 엄청난 폭발이 일어날 것이다.
테입의 다른 한 면은 아직 다 코팅이 끝나지 않아서, 테입의 처음 A개 조각과 끝의 B개 조각만 코팅이 되어 있다. 물론 이 면의 코팅도 같은 화학물질로 코팅되어 있기 때문에 서로 닿으면 폭발한다.
준규는 이 테입이 폭발하지 않도록 구부릴 수 있는 방법의 수를 알고싶어 한다. 이 테입은 한 번 이상 구부릴 수 있으며, 두 조각 사이를 구부린 방법이 하나라도 다르면 다른 방법으로 센다.
답이 매우 커질 수 있기 때문에 방법의 수를 10301로 나눈 나머지를 출력한다.
아래 예시는 N=4, A=1, B=1일 때 가능한 방법의 수를 나타낸 것이다. 단, 아래 그림에서는 편의를 위해 90도 구부린 것으로 그려져 있지만 실제 준규는 이 테입을 180도로 구부린다.
<입력값>
입력의 첫 줄에 자연수 N, A, B(A>0, B>0, A+B ≤ N ≤ 1000)가 주어진다. N은 조각의 수, A는 테입의 왼쪽에 코팅된 조각의 수, B는 테잎의 오른쪽에 코팅된 조각의 수이다.
<출력값>
가능한 방법의 수를 10301로 나눈 나머지를 출력한다.

<문제 2907>
세상에서 제일 바쁜 동혁이는 팬케익을 좋아한다. 오늘은 집에서 팬케익을 만들어 먹기로 결심했다. 주방을 뒤져 열심히 팬케익을 만들 재료 4가지 밀가루, 우유, 계란, 잼을 찾았지만, 집에는 재료가 하나도 없었다. 그는 주변의 상점을 돌아다니면서 재료를 사오려고 한다.
동혁이네 동네에는 교차로가 N개 있고, 1번부터 N번까지 번호가 매겨져 있다. 그리고 도로는 총 R개가 있고, 교차로와 교차로를 잇는다.
동혁이는 지금 1번 교차로에 있다. 각 도로에는 상점이 항상 1개가 있고, 상점에서는 4개 재료 중 일부만 팔 수도 있고, 모두 팔 수도 있다. 상점을 방문하지 않고 도로를 지나는데 걸리는 시간은 1분이고, 상점을 방문해 재료를 구매하고 지나면 2분이 걸린다.
동혁이는 모든 재료를 구한 뒤, 1번 교차로로 다시 돌아오려고 한다. 그는 재료를 모두 구했다고 하더라도 상점간의 가격 비교를 위해서 상점을 방문할 수 있다.
아래와 같이 교차로 5개, 도로 7개인 경우를 살펴보자. (밀가루: B, 계란: J, 우유: M, 잼: P)

위와 같은 경우라면, 7분안에 모든 재료를 구하는 서로 다른 방법은 아래와 같이 5가지가 있다.



1분
2분
3분
4분
5분
6분
7분




1→3
3->상점->4
4→상점→1
 
 


1→상점→2
2→상점→4
4→상점→1
 


1→상점→3
3→상점→4
4→상점→1
 


1→상점→3
3→상점→4
4→5
4→상점→1


1→3
3→상점→4
4→상점→5
5→상점→1



동혁이가 1번 교차로에서 출발서 모든 재료를 구한 뒤 다시 1번 교차로로 K분안에 돌아오는 서로 다른 방법의 수를 구하는 프로그램을 작성하시오.
이 숫자는 매우 커질 수 있으므로 5557로 나눈 나머지를 출력한다.
<입력값>
첫째 줄에 N과 R이 주어진다. (1<=N<=25, 1<=R<=500)
둘째 줄부터 R개의 줄에는 도로의 정보가 주어진다. 도로의 정보는 서로 다른 정수 u, v와 문자열 s가 공백으로 구분되어 있다. u와 v를 잇는 도로가 있고, 여기에 있는 상점에서 파는 재료는 s라는 의미이며, s는 1글자~4글자 알파벳 대문자이며, 밀가루는 B, 달걀은 J, 우유는 M, 잼은 P이다. 두 교차로 사이에는 도로가 최대 2개까지 있을 수 있으며, 2개인 경우에는 방향이 서로 달라야 한다. (u->v와 v->u)
마지막 줄에는 동혁이가 모든 재료를 구하고 다시 돌아 와야 하는 시간 제한 K(1<=K<=1,000,000,000)가 주어진다.
<출력값>
첫째 줄에 동혁이가 K분 안에 모든 재료를 구하고 다시 1번 교차로로 돌아오는 서로 다른 방법의 수를 5557로 나눈 나머지를 출력한다.

<문제 2908>
상근이의 동생 상수는 수학을 정말 못한다. 상수는 숫자를 읽는데 문제가 있다. 이렇게 수학을 못하는 상수를 위해서 상근이는 수의 크기를 비교하는 문제를 내주었다. 상근이는 세 자리 수 두 개를 칠판에 써주었다. 그 다음에 크기가 큰 수를 말해보라고 했다.
상수는 수를 다른 사람과 다르게 거꾸로 읽는다. 예를 들어, 734와 893을 칠판에 적었다면, 상수는 이 수를 437과 398로 읽는다. 따라서, 상수는 두 수중 큰 수인 437을 큰 수라고 말할 것이다.
두 수가 주어졌을 때, 상수의 대답을 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 상근이가 칠판에 적은 두 수 A와 B가 주어진다. 두 수는 같지 않은 세 자리 수이며, 0이 포함되어 있지 않다.
<출력값>
첫째 줄에 상수의 대답을 출력한다.

<문제 2909>
오늘은 화이트데이이다. 상근이는 여자친구를 위해서 사탕을 사려고 한다. 하지만, 상근이는 독특한 성격을 가지고 있어서, 특정 액면가의 지폐만 가지고 있는다. 또, 거스름돈은 받지 않는다. 따라서, 사탕 가게의 사장과 상근이는 다음과 같은 합의를 했다. 상근이는 사장에게 자신이 가지고 있는 지폐의 액면가를 말해준다. 그럼 사장은 상근이가 지불할 수 있는 가장 가까운 금액으로 사탕의 가격을 반올림해준다.
예를 들어, 상근이가 가지고 있는 지폐의 액면가가 100원이라고 하자. 만약 상근이가 고른 사탕의 가격이 150원이라면, 사장은 가격을 200원으로 반올림해서 상근이가 낼 수 있도록 해준다. 또, 가격이 149원이라면, 사장은 가격을 100원으로 반올림해서 상근이가 지불할 수 있도록 해준다.
상근이가 가지고 있는 지폐의 액면가는 항상 1, 10, 100, 1000, ..., 1,000,000,000 중 하나이다. 또, 지폐를 무한개 가지고 있다.
사탕 가격과 상근이가 가지고 있는 지폐의 액면가가 주어졌을 때, 사장은 가격을 얼마로 바꿔줄 것인지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 사탕의 가격 C와 상근이가 가지고 있는 지폐의 액면가에 적혀있는 0의 개수 K가 주어진다. (0 ≤ C ≤ 1,000,000,000, 0 ≤ K ≤ 9)
<출력값>
첫째 줄에 상근이가 내야하는 가격을 출력한다.

<문제 2910>
위대한 해커 창영이는 모든 암호를 깨는 방법을 발견했다. 그 방법은 빈도를 조사하는 것이다.
창영이는 말할 수 없는 방법을 이용해서 현우가 강산이에게 보내는 메시지를 획득했다. 이 메시지는 숫자 N개로 이루어진 수열이고, 숫자는 모두 C보다 작거나 같다. 창영이는 이 숫자를 자주 등장하는 빈도순대로 정렬하려고 한다.
만약, 수열의 두 수 X와 Y가 있을 때, X가 Y보다 수열에서 많이 등장하는 경우에는 X가 Y보다 앞에 있어야 한다. 만약, 등장하는 횟수가 같다면, 먼저 나온 것이 앞에 있어야 한다.
이렇게 정렬하는 방법을 빈도 정렬이라고 한다.
수열이 주어졌을 때, 빈도 정렬을 하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 메시지의 길이 N과 C가 주어진다. (1 ≤ N ≤ 1,000, 1 ≤ C ≤ 1,000,000,000)
둘째 줄에 메시지 수열이 주어진다.
<출력값>
첫째 줄에 입력으로 주어진 수열을 빈도 정렬한 다음 출력한다.

<문제 2911>
민혁이는 한 도시의 시장으로 취임했다. 민혁이는 제일 먼저 사람들이 전화를 몇 통하는지 알아보려고 한다.
이 도시에는 동서를 잇는 긴 도로가 하나 있고, 그 도로를 따라서 집이 M개 있다. 가장 서쪽에 있는 집의 번호는 1이고, 이 순서대로 진행한다.
전화 감지기는 두 집 사이에 설치할 수 있다. 감지기는 감지기가 설치된 위치로부터 동쪽에 있는 집과 서쪽에 있는 집이 서로 통화하는것을 감지할 수 있다.
하루가 지나고, 민혁이는 감지기를 모두 회수했다. 이제 하루동안 이 도시에 전화가 몇 통있었는지 알아보려고 한다. 감지기가 설치되었던 위치와 각 감지기엔 감지된 전화 통화의 수가 주어졌을 때, 이 마을에서 전화가 적어도 몇 통 있었는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 감지기의 수 N과 집의 수 M이 주어진다. (1 ≤ N ≤ 100,000, N < M ≤ 1,000,000,000)
다음 N개 줄에는 두 수 Pi와 Ci가 주어진다. Pi는 감지기가 설치된 위치이고, Ci는 감지된 전화의 수이다. (1 ≤ Pi < M, 1 ≤ Ci ≤ 1,000,000,000) 감지기가 설치된 위치가 Pi라는 뜻은, Pi와 Pi+1 에 위치한 두 집 사이에 설치되었다는 뜻이다. 같은 장소에 감지기가 여러 개 설치되어 있는 경우는 없다.
<출력값>
첫째 줄에 이 마을에서 하루 동안 전화가 적어도 몇 통 있었는지 출력한다.

<문제 2912>
백설 공주와 난쟁이 N명과 함께 숲 속에 살고 있다. 난쟁이는 매일 광산에 일하러가고, 백설 공주는 그동안 페이스북을 하고 있다.
매일 아침 난쟁이는 한 줄로 휘파람을 불면서 광산으로 출근을 한다. 백설 공주는 그 주변을 돌아다니면서 난쟁이들 사진을 찍는다.
난쟁이가 광산에 들어가면, 백설 공주는 다시 집으로 돌아간다. 집으로 돌아가면서 찍은 사진 중에 페이스북에 올릴 예쁜 사진을 고른다. 각 난쟁이는 모두 모자를 쓰고 있다. 모자의 색상은 총 C가지가 있다. 사진에 찍힌 난쟁이가 쓰고 있는 모자의 색상 중 절반보다 많은 색이 같은 색이라면 예쁜 사진이다. 즉, 사진에 난쟁이가 K명 찍혀있고, K/2보다 많은 난쟁이의 모자 색이 같다면 예쁜 사진이다.
백설공주가 찍은 사진 M개와 각 사진에 찍힌 난쟁이가 주어졌을 때, 예쁜 사진인지 아닌지를 알아내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 난쟁이의 수 N과 모자 색상의 수 C가 주어진다. (3 ≤ N ≤ 300,000, 1 ≤ C ≤ 10,000)
둘째 줄에는 각 난쟁이가 쓰고 있는 모자의 색상이 줄을 서 있는 순서대로 주어진다.
셋째 줄에는 사진의 수 M이 주어진다. (1 ≤ M ≤ 10,000)
다음 M개 줄에는 두 정수 A와 B가 주어진다. (1 ≤ A ≤ B ≤ N) 이 줄은 사진의 정보를 의미하고, A번째 난쟁이부터 B번째 난쟁이까지 사진에 찍혔다는 뜻이다.
<출력값>
출력은 총 M 줄이다. 각 사진이 예쁘지 않다면 "no"를 출력하고, 예쁘다면 "yes X"를 출력한다. 예쁜 사진인 경우에 X는 사진에 절반이 넘는 모자의 색상이다.

<문제 2913>
동혁 천문 관측소에서는 망원경 N개로 서로 다른 행성을 관측하고 있다. 관측소에서는 행성에서 발생하는 사건을 M가지 종류로 구분해 놓았다. 모든 행성에서 하루에 발생하는 사건은 한 종류이다. 모든 사건은 적어도 하루동안 지속되며, 많아야 365일동안 지속된다. 사건은 발생했다면, 항상 하루 종일 발생한다. 즉, 첫 날 지속되고, 둘째 날의 중간에 사건이 그만 발생하는 경우는 없다. 둘째 날에도 사건이 발생했다면, 둘째 날이 끝날 때 까지 사건이 발생한다. 각 사건은 항상 같은 기간 동안 발생한다. 즉, 어떤 행성이서 발생하느냐에 상관 없이 사건의 종류가 같다면 일어나는 기간도 같다.

	이제 몇 년 동안 관측한 데이터를 분석하려고 한다. 망원경은 모든 관측을 기록해두었다. 하지만, 기록한 연도를 적지 않았다. 각 망원경이 기록한 내용은 기록을 시작한 날짜와, 끝낸 날짜, 그리고 각 사건이 몇 종류 발생했는지 기록되어 있다. 이때, 각 사건이 발생하는 기간을 구하는 프로그램을 작성하시오.

	일년은 365일이고, 윤년은 없다.
<입력값>
첫째 줄에 망원경의 수 N과 종류의 수 M이 주어진다. (1 ≤ N, M ≤ 200)

	다음 N개 줄에는 아래 형식과 같은 M+4개의 숫자가 주어진다.

	D1D1 M1M1 D2D2 M2M2 F1 F2 ... FM

	여기서 D1D1 M1M1 (01 ≤ DD ≤ 31, 01 ≤ MM ≤ 12)은 관측을 시작한 날짜이고, D2D2 M2M2는 끝난 날짜이다. 그리고, Fi (0 ≤ Fi ≤ 200)는 사건 i가 발생한 횟수이다.
<출력값>
출력은 총 M개 숫자이고, 각 사건이 발생한 기간이다. 만약, 가능한 정답이 여러 가지라면 아무거나 출력한다. 또, 정답이 없는 경우에는 -1을 출력한다.

<문제 2914>
창영이는 노래 여러 개를 이어서 부르는 가수이다. 유명한 노래의 비슷한 멜로디를 이어서 부르면서 언제 곡이 넘어갔는지 모르게 만드는 것이 창영이 노래의 특징이다. 이런 노래로 상업적으로 엄청난 성공을 거둔 창영이에게 큰 시련이 찾아왔다. 그것은 바로 저작권이었다.
창영이의 노래에 포함되어 있는 멜로디는 모두 저작권이 다른 사람에게 있는 노래이다. 따라서, 이 음악으로 상업적인 활동을 했기 때문에, 저작권 협회에 저작권료를 내야한다.
창영이는 자신의 앨범에 포함되어있는 저작권이 있는 멜로디의 평균값을 구해보기로 했다. 이 값은 아래와 같이 구할 수 있다.
(창영이 앨범에 수록된 곡에 포함되어 있는 저작권이 있는 멜로디의 개수) / (앨범에 수록된 곡의 개수)
이때, 평균값은 항상 올림을 해서 정수로 만들어야 한다. 예를 들어, 창영이의 1집 앨범 "영창에서 영원히 영창피아노를 친다"에 총 38개 곡이 수록되어 있고, 이 앨범에 저작권이 있는 멜로디가 894개가 있다면, 평균값은 23.53이 되고 올림해서 24가 된다.
매니저 강산이는 얼마나 많은 사람에게 저작권료를 주어야 하는지 궁금해졌다. 강산이가 알고 있는 정보는 앨범에 수록되어 있는 곡의 개수와 위에서 구한 평균값이다. 이때, 적어도 몇 곡이 저작권이 있는 멜로디인지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 앨범에 수록된 곡의 개수 A와 평균값 I가 주어진다. (1 ≤ A, I ≤ 100)
<출력값>
첫째 줄에 적어도 몇 곡이 저작권이 있는 멜로디인지 출력한다.

<문제 2915>
1, 2, 3, 4, 5, 6, 7, 8, 9를 로마 숫자로 바꾼다면 I, II, III, IV, V, VI, VII, VIII, IX가 된다.

	10, 20, 30, 40, 50, 60, 70, 80, 90은 X, XX, XXX, XL, L, LX, LXX, LXXX, XC가 된다.

	100보다 작은 수를 로마 숫자로 바꾸려면, 십의 자리와 일의 자리를 따로따로 위의 방법을 이용해서 로마 숫자로 바꾼 다음, 하나로 이어 붙이면 된다.

	예를 들어, 48은 XLVIII이다. 그 이유는 40을 XL로 바꾸고, 8을 VIII로 바꾼 다음, 둘을 이어 붙이면 XLVIII이기 때문이다.

	로마 숫자가 주어졌을 때, 문자를 재배치했을 때 나올 수 있는 숫자 중, 가장 작은 수를 구하여 로마 숫자로 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 1보다 크거나 같고, 100보다 작은 정수 B가 로마 숫자로 주어진다.
<출력값>
첫째 줄에, 로마 숫자 B의 문자를 재배치했을 때, 나올 수 있는 숫자 중, 가장 작은 수를 로마 숫자로 출력한다.

<문제 2916>
창영이는 방 청소를 하다가 자와 각도기를 발견했다. 다음날 창영이는 학교에 자와 각도기를 들고 갔고, 현우와 "작도 대결"을 하려고 한다.
창영이는 각도기와 자를 이용해서 만들 수 있는 각을 알고 있고, 두 각을 합하거나 빼서 새로운 각을 만드는 방법을 알고 있다. 현우가 어떤 각도를 외치면, 창영이는 자와 각도기를 이용해서 현우가 외친 각도를 작도해야 한다. 작도할 때는 새로운 각을 이용해서 또다른 새로운 각을 만드는 것도 가능하다.
현우가 외치는 각도를 창영이가 만들 수 있는지 없는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 창영이가 만드는 방법을 알고 있는 각의 수 N과 현우가 외친 각의 개수 K가 주어진다. (1 ≤ N, K ≤ 10)
둘째 줄에는 창영이가 만들 수 있는 각이 주어진다. 모든 각도는 360보다 작다.
셋째 줄에는 현우가 외친 각이 주어진다. 이 각도 360보다 작다.
<출력값>
현우가 외친 각도를 창영이가 만들 수 있다면 YES를, 없다면 NO를 입력으로 주어진 순서대로 한 줄에 하나씩 출력한다.

<문제 2917>
늑대 현우는 피에 굶주린 사냥꾼들에게 벗어나려고 도망치고 있다. 사냥꾼은 매우 똑똑해서 나무 뒤에 숨어있다. 현우도 이 사실을 알고있다. 하지만, 어떤 나무 뒤에 사냥꾼들이 숨어있는지 알지 못한다. 현우는 사냥꾼에게 잡히지 않기 위해서 숲의 한 오두막으로 대피하려고 한다. 현우는 나무와 거리가 최대한 떨어지는 경로로 대피하려고 한다.

	숲은 N×M 크기의 그리드로 나타낼 수 있다. 각 칸이 빈 목초지라면 '.', 나무가 있다면 '+', 현재 현우의 위치는 'V', 오두막의 위치는 'J'로 나타나있다. 현우는 현재 있는 위치에서 동서남북으로 인접한 칸으로 이동할 수 있고, 나무가 있는 칸으로도 이동할 수 있다.

	만약 현우가 지금 R행 C열에 있고, 나무가 A행 B열에 있다면, 현우와 나무의 거리는 |R-A| + |C-B|이다.

	현우는 오두막으로 도망치는 가장 안전한 길로 이동하려고 한다. 가장 안전한 길이란 현우가 이동하는 모든 칸에서 나무와 거리의 최솟값이 가장 큰 경로이다. 또, 오두막이 있는 칸도 경로의 일부이기 때문에 나무와 거리를 계산해야 한다.

	숲의 지도가 주어졌을 때, 가장 안전한 길을 찾는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N과 M (1 ≤ N, M ≤ 500)이 주어진다. 둘째 줄부터 N개 줄에는 숲의 지도가 주어진다. 지도에 'V'와 'J'는 딱 하나만 있고, 적어도 하나의 '+'가 있다.
<출력값>
첫째 줄에 가장 안전한 경로에서 나무와 현우와 거리의 최솟값을 출력한다.

<문제 2918>
어랜지는 창영이가 즐겨하는 플래시 게임이다. 이 게임은 1부터 N까지 숫자로 이루어진 순열이 주어졌을 때, 숫자의 위치를 적절히 바꿔서 1,2,3,...,N 순서로 만드는 게임이다.

	하지만, 모든 숫자의 위치를 바꿀 수 있는 것은 아니다. 플레이어는 미리 정해져있는 교환만 사용할 수 있다.

	창영이는 최고 기록을 깨려고 한다. 따라서, 교환을 되도록 적게 사용하려고 한다.

	순열의 순서와 사용할 수 있는 교환의 위치가 주어졌을 때, 교환을 되도록 적게 사용해서 오름차순으로 만드는 프로그램을 작성하시오.
<입력값>
첫째 줄에 순열의 길이 N과 사용할 수 있는 교환의 수 M이 주어진다. (1 ≤ N ≤ 12, 1 ≤ M ≤ N*(N-1)/2)

	둘째 줄에는 1부터 N까지 숫자로 이루어져 있는 순열이 주어진다.

	셋째 줄부터 M개 줄에는 사용할 수 있는 교환의 방법이 주어진다. 방법은 두 숫자 A와 B로 이루어져 있고, A번째 위치와 B번째 위치의 수를 서로 바꾸는 교환을 사용할 수 있다는 뜻이다. 동일한 교환이 두 개 이상 주어지지 않는다.
<출력값>
첫째 줄에 사용한 교환의 수 X를 출력한다. 다음 줄부터 사용한 교환 번호를 한 줄에 하나씩 출력한다. 입력의 첫 번째로 주어지는 교환이 1번이고, 나머지는 순서대로 증가한다. 항상 답이 존재하는 경우만 입력으로 주어지며, 방법이 여러 가지일 때는 아무거나 출력하면 된다.

<문제 2920>
다장조는 c d e f g a b C, 총 8개 음으로 이루어져있다. 이 문제에서 8개 음은 다음과 같이 숫자로 바꾸어 표현한다. c는 1로, d는 2로, ..., C를 8로 바꾼다.
1부터 8까지 차례대로 연주한다면 ascending, 8부터 1까지 차례대로 연주한다면 descending, 둘 다 아니라면 mixed 이다.
연주한 순서가 주어졌을 때, 이것이 ascending인지, descending인지, 아니면 mixed인지 판별하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 8개 숫자가 주어진다. 이 숫자는 문제 설명에서 설명한 음이며, 1부터 8까지 숫자가 한 번씩 등장한다.
<출력값>
첫째 줄에 ascending, descending, mixed 중 하나를 출력한다.

<문제 2921>
도미노는 여러 종류의 타일 게임에서 사용하는 조각이다. 도미노 조각은 두 칸으로 이루어져 있다. 각 칸에는 점이 찍혀있는데, 점이 안 찍혀져 있을 수도 있다. 점의 개수는 세트의 크기에 의해서 결정된다. 세트의 크기가 N인 도미노 세트에서 점의 개수는 0보다 크거나 같고, N보다 작거나 같다. 두 도미노에 찍혀잇는 점의 개수가 같다면, 두 도미노는 동일한 것이다. 예를 들어, 점이 2개와 8개 찍혀있는 도미노는 8개와 2개 찍혀있는 도미노와 같은 도미노이다.
크기가 N인 도미노 세트는 N 또는 그보다 작거나 같은 점을 포함하는 가능한 도미노를 모두 포함하고 있고, 각 도미노는 중복되지 않는다. 다음은 크기가 2인 도미노 세트이다.

N을 입력받은 뒤, 크기가 N인 도미노 세트에는 점이 몇 개 찍혀 있는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 도미노 세트의 크기 N (1 ≤ N ≤ 1000)이 주어진다.
<출력값>
크기가 N인 도미노 세트에 찍혀 있는 점의 개수를 출력한다.

<문제 2922>
상근이는 자신이 다니는 학교에서 영어단어를 가장 많이 외우고 있다. 그 비법은 바로 조기교육이었다. 상근이는 젖병을 물기도 전에 영어 단어를 외웠다. 따라서, 지금은 자리에 앉으면 사전을 만들 수 있을 정도로 많이 외우게 되었다.

	더 이상 외울 단어가 없어진 상근이는 이제 단어를 만들기로 결심했다.

	상근이는 단어는 두 종류, 즐거운 단어와 즐겁지 않은 단어로 분류할 수 있다고 생각한다. 새로운 단어를 만들기 위해 즐겁지 않은 단어를 공책에 적는다. 그 다음, 보기 싫은 알파벳을 지우개로 지우고 그 자리에 밑 줄(_)을 적는다. 이렇게 보기 싫은 단어를 모두 지운 다음에는 즐거운 단어를 만들 수 있도록 밑 줄에 알파벳을 적는다.

	상근이에게 즐거운 단어란, 모음(A,E,I,O,U)이 연속해서 3번, 자음(모음을 제외한 나머지 알파벳)이 연속해서 3번 나오지 않아야 한다. 또, L을 반드시 포함해야 한다.

	상근이게 보기 싫은 알파벳을 지운 단어가 주어졌을 때, 즐거운 단어를 만들 수 있는 경우의 수를 세는 프로그램을 작성하시오.
<입력값>
첫째 줄에 상근이가 공책에 적은 단어가 주어진다. 단어의 길이는 최대 100이고, 알파벳 대문자와 밑 줄(_)로만 이루어져 있다. 단어에 포함된 밑 줄의 개수는 최대 10이다.
<출력값>
첫째 줄에, 밑 줄을 알파벳으로 바꿔 즐거운 단어를 만들 수 있는 경우의 수를 출력한다.

<문제 2923>
창영이와 현우는 새로운 게임을 하고 있다. 이 게임은 여러 라운드로 이루어져 있다. 매 라운드가 시작할 때, 현우는 창영이에게 100보다 작은 두 숫자 A와 B를 말해준다. 그러고 난 뒤, 창영이는 다음과 같은 문제를 풀어야 한다. 

	지금까지 현우가 말한 모든 A와 모든 B를 짝짓는다. 이때, 각 쌍의 합 중에서 가장 큰 값을 작게 만들어라.

	즉, 현재 라운드가 N 라운드이라고 하면, 현우가 창영이에게 말한 숫자는 a1, a2, ..., an 과 b1, b2, ..., bn이라고 할 수 있다. 이때, 각 숫자를 한 번씩 사용하여 (ai, bj)쌍을 n개 만들 수 있다. 이렇게 쌍을 모두 만들었을 때, ai+bj의 합 중 가장 큰 값을 가능한 작게 만들어야 한다.
<입력값>
첫째 줄에 라운드의 수 N이 주어진다. (1 ≤ N ≤ 100000) 다음 N개의 줄에는 각 라운드에서 현우가 말한 숫자 A와 B가 주어진다. (1 ≤ A, B ≤ 100)
<출력값>
출력은 N줄이다. 각 줄은 해당하는 라운드에서 창영이가 말해야하는 값 (모든 쌍의 합의 최댓값의 최솟값) 이다.

<문제 2924>
준규는 천재다. 하지만 준규의 발명품은 용도가 좀 애매하다. 준규의 최신 발명품인 'Shuffle-o-matic 3175' 역시 좀 애매하다. Shuffle-o-matic은 아주 특별한 방식으로 사용된다. 먼저 1부터 N까지의 수가 적힌 N개의 카드를 이 기계에 위에 놓는다. 그 다음 셔플 수열을 입력하고 작동 버튼을 누르면, 기계가 자동으로 카드의 숫자를 읽어서 그 수열을 테입에 출력한다. 그 후 기계는 셔플 수열대로 카드를 섞은 후 카드의 숫자를 읽어 테입의 다음 줄에 출력한다. 같은 방식으로 한 번 더 셔플 수열대로 카드를 섞고 다시 카드의 수를 테입의 다음 줄에 출력한다. 테입이 다 떨어질 때 까지 이 과정을 반복한다.
준규는 자신의 발명품을 테스트 해 본 후 좀 쉬기로 했다. 그러다 출력 테입의 한 조각을 발견했다. 그리고 모든 줄은 앞에서부터 C개의 수와 뒤에서부터 D개의 수가 지워져 있었다.
준규는 섞기 전의 수열을 1번째 수열이라고 했을때, A번째 수열에서 B번째 수열까지의 수열 중 맨 처음 섞기 전의 순서와 적힌 부분이 모두 일치하는 수열이 몇 개인지 궁금해졌다. 이를 계산하는 프로그램을 작성하시오.
<입력값>
입력의 첫째 줄에는 정수 N, A, B, C, D (1 ≤ N ≤ 500 000, A ≤ B ≤ 10^12, 0 ≤ C, D ≤ N, C + D < N)가 차례로 주어진다.
둘째 줄에는 셔플 수열이 주어진다. 이 수열에는 1부터 N까지의 수가 한 번씩 등장한다. 만약 수열의 k번째 숫자가 x라면, 이는 카드를 섞을 때 k번째 수를 x번째로 옮긴다는 의미이다.
<출력값>
준규가 찾는 수열의 개수를 출력한다.

<문제 2925>
어느 날, 상근이는 길을 걷던 중에 신기한 물체를 발견했다. 외계의 것으로 추정되는 이 물체의 왼편에는 빈 박스가 N개 있었다. 기계의 사용방법을 알아내기 위해서 하루종일 기계를 더듬거렸고, 마침내 상근이는 이 기계를 어떻게 사용하는지를 알게되었다.
기계는 정수 4개 L, R, A, B를 입력으로 받는다. 크고 빨갛게 빛나는 실행버튼을 누르면 기계는 다음과 같은 움직인다.
먼저, L번 박스에 들어 있는 돌의 개수를 A mod B개로 만든다. 그 다음 L+1번 박스에 들어 있는 돌을 (2*A) mod B개로 만든다. 마찬가지로, L+2번 박스에 들어 있는 돌을 (3*A ) mod B개로 만든다. 즉, L번과 R번 사이의 X번 박스에 들어 있는 돌의 개수를 ((X-L+1)*A) mod B개로 만드는 것이다. R번 박스까지 돌을 채우고나면, 기계는 다음 명령을 기다린다.
기계에 여러 가지 명령을 내리던 중에, 상근이는 어떤 박스의 구간에 들어있는 돌의 개수가 궁금해졌다.
상근이가 기계에 입력한 명령이 주어졌을 때, 이 기계를 시뮬레이팅 하면서, 상근이의 궁금증도 해결해주는 프로그램을 작성하시오.
<입력값>
첫째 줄에 박스의 수 N과 쿼리의 수 Q가 주어진다. (1 ≤ N ≤ 1,000,000,000, 1 ≤ Q ≤ 50,000)
다음 Q개 줄에는 시뮬레이션에 관한 정보가 주어진다.
만약, 정보가 1로 시작한다면, 형식은 "1 L R A B" (1 ≤ L ≤ R ≤ N, 1 ≤ A, B ≤ 1,000,000)가 된다. 이 뜻은 상근이가 기계에 L, R, A, B를 입력했다는 뜻이다.
정보가 2로 시작한다면, 형식은 "2 L R"이 된다. (1 ≤ L ≤ R ≤ N) 이 뜻은 상근이가 L과 R번 박스 사이에 들어있는 돌의 개수를 궁금했다는 뜻이고, 개수를 구한뒤, 출력해야 한다. L과 R도 범위에 포함된다.
<출력값>
2로 시작하는 명령이 들어올 때 마다, 그 구간에 들어있는 돌의 개수를 출력한다.

<문제 2926>
오늘은 국회의원을 뽑는 날이다.
총 V명이 투표를 했으며, 각 사람은 정당 N개 중 하나에 표를 던졌다. 이 중 M명이 국회에 진출하게 된다.
D'Hondt 방법을 이용해 의석 배정을 하며, 한계치는 5%이다. 각 정당은 1번부터 N번까지 번호가 매겨져 있고, 받은 표의 개수는 V1, V2, ..., VN이다. 의석 배정은 다음과 같이 이루어진다.

총득표수(V)의 5%보다 표를 적게 받은 정당은 정당 목록에서 지운다.
처음에 모든 정당에 할당된 의석은 0이다.
각각의 정당 P에 대해서, 몫 QP = VP/(SP+1)을 구한다. VP는 정당 P가 받은 표의 개수이고, SP는 그때 까지 정당 P에 할당된 의석의 수이다.
가장 큰 QP를 갖는 정당이 의석 하나를 갖게 된다. 그런 경우가 여러개라면 번호가 가장 작은 정당이 의석을 하나 갖게 된다.
모든 의석이 할당될 때 까지 3번과 4번을 반복한다.

현재 개표가 진행중이며, 일부만 개표된 상황이다. 각 정당의 득표수는 모두 알려져 있다. 
일부만 개표된 결과가 주어졌을 때, 각 정당이 받을 수 있는 최대 의석 수와 최소 의석 수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 V, N, M이 주어진다. (1 ≤ V ≤ 10,000,000, 1 ≤ N ≤ 100, 1 ≤ M ≤ 200)
둘째 줄에 각 정당이 받은 표의 수가 주어진다. 합은 V를 넘지 않는다.
<출력값>
첫째 줄에 각 정당의 가능한 최대 의석 수, 둘째 줄에 최소 의석 수를 출력한다.

<문제 2927>
상근이는 "얼음을 꿈꾸다" 여행사의 사장이다. 이 여행사는 남극 근처의 섬 N개를 구매해 당일치기 여행을 제공하고 있다. 관광객들에게 가장 인기 있는 동물은 황제 펭귄으로 섬에서 쉽게 찾을 수 있다.
여행사는 점점 인기를 얻게 되었고, 이제 보트를 이용하는 것이 효율적이지 않은 상황까지 이르렀다. 상근이는 섬 사이에 다리를 건설해 관광객을 버스로 이동시키려고 한다. 상근이는 컴퓨터 프로그램을 이용해서 다리를 건설하는 과정을 관리하려고 한다.
섬은 1번부터 N번까지 번호가 매겨져 있다. 가장 처음에는 아무 다리도 없으며, 각 섬에 펭귄이 몇 마리 살고있는지는 모두 알고있다. 펭귄의 수는 변할 수 있다. 하지만, 항상 0보다 크거나 같고, 1000보다 작거나 같다.
상근이의 프로그램은 다음과 같은 세 가지 명령을 수행할 수 있어야 한다.

"bridge A B" - 섬 A와 B사이에 다리를 건설하는 명령이다. (A와 B는 다르다) 이전까지 지어진 다리를 이용해서 이동할 수 없는 경우에만 다리를 지어야 한다. 다리를 지어야 하면 "yes", 지을 필요가 없이 이미 이동할 수 있으면 "no"를 출력한다.
"penguins A X" - 섬 A에 살고있는 펭귄의 수를 다시 세보니 X마리가 되었다는 명령이다. 아무것도 출력할 필요가 없다.
"excursion A B" - 관광객들이 섬 A에서 시작해 B에서 끝나는 여행 경로를 이용하는 명령이다. A에서 B로 갈 수 있는 경우에는 이동하는 섬에 있는 모든 펭귄의 수를 구해 출력한다. (A와 B 포함) 이동할 수 없는 경우에는 "impossible"를 출력한다.

상근이의 프로그램을 작성하시오.
<입력값>
첫째 줄에 섬의 수 N (1 ≤ N ≤ 30,000)이 주어진다.
둘째 줄에는 각 섬에 있는 펭귄의 수가 주어진다.
셋째 줄에는 명령의 개수 Q (1 ≤ Q ≤ 300,000)가 주어진다.
다음 Q개 줄에는 문제에서 주어진 명령 중 하나가 주어진다.
<출력값>
"bridge"나 "excursion" 명령이 주어질 때 마다 출력한다.

<문제 2928>
일요일을 맞이해 창영이는 집안의 모든 침대 시트를 빨고, 집 앞 잔디밭에서 말리고 있다. 갑자기, 엄청난 강풍이 몰아쳤고 모든 침대 시트는 땅바닥에 떨어지게 되었다.
잔디밭은 크기가 무한대인 정사각형 격자로 나타낼 수 있고, 각 단위 정사각형은 좌표 쌍으로 나타낼 수 있다. 침대 시트는 직사각형이며, 축에 평행하다. 시트는 서로 겹칠 수도 있다.
다시 빨래줄에 시트를 걸어놓기 위해 창영이는 막대를 (0,0)에 꽂았다. 그런데 갑자기 땅에서 기름이 나오기 시작했다. 창영이는 이런 예상하지 못한 상황에 당황하였고 결국 기절했다. 창영이가 기절한 사이에 기름은 퍼져나갔다.
시간은 기름이 퍼지기 시작한 순간부터 측정하기 시작한다. 가장 처음에는 단위 정사각형 (0,0)만 기름이 있다. 기름은 아래 그림에 나와있는 것 같이 1초에 한 정사각형씩 여덟 방향으로 이동한다. 기름이 단위 정사각형에 들어가게 되면, 즉시 그 정사각형을 가득 채우게 되고, 그 부분에 속해있는 시트에도 기름이 스며들게 된다.

시간 0, 1, 2초의 모습이다.
입력으로 주어지는 시간이 지난 후에 기름이 물들은 시트의 면적을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 침대 시트의 수 N (1 ≤ N ≤ 100,000)이 주어진다.
다음 N개 줄에는 침대 시트를 나타내는 좌표 x1, y1, x2, y2 (−1,000,000 ≤ x1 ≤ x2 ≤ 1,000,000, −1,000,000 ≤ y1 ≤ y2 ≤ 1,000,000)가 주어진다. (x1, y1), (x2, y2)는 침대 시트의 양 끝 대각선 좌표이다. 이 좌표는 좌표평면 위의 점이 아닌 각 단위 정사각형을 나타낸다. (0, 0)을 포함하는 침대 시트는 없다.
다음 줄에는 시간의 개수 M (1 ≤ M ≤ 100,000)이 주어진다.
다음 M개 줄에는 시간이 주어진다. 이 정수는 0과 1,000,000 사이의 정수이다. 오름차순으로 주어지며, 중복된 시간은 주어지지 않는다.
<출력값>
각각의 시간에 대해서, 기름에 물들은 침대 시트 영역의 크기를 출력한다.

<문제 2929>
종수는 새 마이크로프로세서를 구매했다. 새 프로세서에 예전 프로세서에서 작동하던 프로그램을 실행시키니 실행이 되지 않았다.
며칠동안 두 프로세서의 기술 문서를 살펴본 결과, 그 결과를 알게 되었다. 새 프로세서의 실행 속도를 향상시키기 위해서 프로그램 머신 코드에 제한이 새로 생겼다. 예전 프로세서에서는 제한이 없었다.
프로세서의 머신 코드는 명령을 실행할 순서대로 나열한 것이다. 각 명령은 메모리를 1바이트 사용한다. 또, 명령은 0개 또는 그 이상의 파라미터를 가질 수 있으며, 각 파라미터도 1바이트씩 메모리를 차지한다. 머신 코드에서 파라미터는 명령의 바로 뒤에 따라 나온다.
머신 코드를 명령은 대문자, 파라미터는 소문자로 나타낼 수 있다.

위의 프로그램은 명령 4개로 이루어져 있다. 첫 번째 명령은 파라미터 3개, 두 번째는 2개, 세 번째는 파라미터가 없고, 네 번째는 4개이다. 이 프로그램은 메모리를 13바이트 사용한다.
새 프로세서는 메모리를 4바이트 단위로 가져온다. 즉, 명령은 반드시 4로 나누어지는 위치에서 시작해야 한다. (메모리의 첫 바이트가 주소 0) 따라서, 새로운 명령 NOP(no operation)를 추가해 모든 명령이 시작하는 위치를 4로 나누어지는 곳으로 맞춰야 한다. 위의 프로그램을 새 프로세서용으로 변환한 머신 코드는 아래와 같다.

명령 A, B, C, D의 시작 위치는 0, 4, 8, 12로 모두 4로 나누어 떨어진다.
예전 프로세서의 머신 코드가 주어졌을 때, 새 프로세서에서 실행시키기 위해 삽입해야 하는 NOP 개수의 최솟값을 구하는 프로그램을 작성하시오.
<입력값>
예전 프로세서용 머신 코드 프로그램이 주어진다. 프로그램은 최대 200글자로 이루어져 있다.
프로그램은 항상 명령으로 시작한다. (첫 글자가 대문자) 한 명령이 머신 코드에서 여러 번 나오는 경우에, 항상 같은 개수의 파라미터를 갖는다.
<출력값>
삽입해야하는 NOP 개수의 최솟값을 출력한다.

<문제 2930>
가위 바위 보는 두 사람이 즐기는 유명한 게임이다. 각 플레이어는 자신의 손을 이용해서 가위, 바위, 보 중 한 모양을 만들어야 한다. 두 플레이어가 같은 모양을 만든 경우에는 비기게 된다. 가위는 보를 이기고, 보는 바위, 바위는 가위를 이긴다.
상근이는 사람들의 심리를 수십년동안 연구한 결과 가위 바위 보를 한국에서 가장 잘 하는 사람이 되었다. 상근이는 일대일 가위 바위 보를 절대로 지지 않는다.
한국에 적수가 없다고 판단한 상근이는 세계 대회에 나가기로 했다. 요즘 상근이는 세계 대회를 대비해 훈련중이다. 훈련은 친구 N명과 동시에 한다. 가위바위보는 총 R개의 라운드로 이루어져 있고, 각 라운드마다 상근이와 친구들은 세 모양중 하나를 만들어야 한다.
각 라운드의 점수 계산은 상근이와 친구 개개인을 독립적으로 비교한다. 상근이가 이기면 2점, 비기면 1점, 지면 0점이다. 
상근이와 친구들이 각 라운드에 낸 모양이 주어졌을 때, 게임이 끝나고 난 후 상근이의 점수를 구한다. 그 다음, 상근이가 친구들이 무엇을 낼지 미리 알고있었다고 가정할 때, 상근이가 얻을 수 있는 최고 점수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 라운드 수 R (1 ≤ R ≤ 50)이 주어진다.
둘째 줄에는 상근이가 각 라운드에 낸 모양이 주어진다. S는 가위, P는 보, R은 바위이다.
셋째 줄에는 친구의 수 N (1 ≤ N ≤ 50)이 주어진다.
다음 N개 줄에는 상근이의 친구들이 각 라운드에 낸 모양이 주어지며, 한 줄에 한 명씩 주어진다.
<출력값>
첫째 줄에 상근이의 점수를 출력한다.
둘째 줄에는 상근이가 얻을 수 있는 최대 점수를 출력한다.

<문제 2931>
러시아 가스를 크로아티아로 운반하기 위해 자그레브와 모스코바는 파이프라인을 디자인하고 있다. 두 사람은 실제 디자인을 하기 전에 파이프 매니아 게임을 이용해서 설계를 해보려고 한다.
이 게임에서 유럽은 R행 C열로 나누어져 있다. 각 칸은 비어있거나, 아래 그림과 같은 일곱가지 기본 블록으로 이루어져 있다.

가스는 모스크바에서 자그레브로 흐른다. 가스는 블록을 통해 양방향으로 흐를 수 있다. '+'는 특별한 블록으로, 아래 예시처럼 두 방향 (수직, 수평)으로 흘러야 한다.

파이프 라인의 설계를 마친 후 두 사람은 잠시 저녁을 먹으러 갔다. 그 사이 해커가 침임해 블록 하나를 지웠다. 지운 블록은 빈 칸이 되어있다.
해커가 어떤 칸을 지웠고, 그 칸에는 원래 어떤 블록이 있었는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 유럽의 크기 R과 C가 주어진다. (1 ≤ R, C ≤ 25)
다음 R개 줄에는 C개 글자가 주어지며, 다음과 같은 글자로 이루어져 있다.

빈칸을 나타내는 '.'
블록을 나타내는 '|'(아스키 124), '-','+','1','2','3','4'
모스크바의 위치를 나타내는 'M'과 자그레브를 나타내는 'Z'. 두 글자는 한 번만 주어진다.

항상 답이 존재하고, 가스의 흐름이 유일한 경우만 입력으로 주어진다, 또, 모스크바와 자그레브가 하나의 블록과 인접해 있는 입력만 주어진다. 또, 불필요한 블록이 존재하지 않는다. 즉, 없어진 블록을 추가하면, 모든 블록에 가스가 흐르게 된다.
<출력값>
지워진 블록의 행과 열 위치를 출력하고, 어떤 블록이었는지를 출력한다.

<문제 2932>
상근이는 N×N 표를 만들었다. 표에는 1부터 N2까지의 수가 행 우선 순서(row-major order)에 따라 쓰여져 있다. 표가 수행할 수 있는 연산은 아래와 같이 두 가지이다.

행을 회전시킨다 - 한 행을 골라 오른쪽으로 한 칸 회전시킨다. 마지막 열에 있던 수가 가장 첫 열에 오게 된다.
열을 회전시킨다 - 한 열을 골라 아래로 한 칸 회전시킨다. 마지막 행에 있던 수가 갖아 첫 행에 오게 된다.

상근이는 수 X를 (R,C)로 이동시키려고 한다. 이때, 상근이는 다음과 같은 과정을 거쳐서 수를 찾는다.

X의 위치가 C열이 될 때 까지, X가 있는 행을 회전 시킨다.
X의 위치가 R행이 될 때 까지, X가 있는 열을 회전시킨다.

아래 그림은 6을 (3,4)에 이동시키는 방법이다.

상근이는 숫자 K개를 이동시키려고 한다. 한 숫자를 이동시키고 난 후에, 바로 그 다음 숫자를 이동시키며, 다음 숫자를 이동시킬 때, 표에 들어있는 수를 처음 상태로 되돌리지 않는다. 숫자 K개를 이동시키는데 필요한 회전의 수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 표의 크기 N(2 ≤ N ≤ 10000)과 이동시키려고 하는 숫자의 수 K(1 ≤ K ≤ 1000)이 주어진다.
다음 K개 줄에는 이동시키려고 하는 숫자 X와 위치 R, C가 주어진다. (1 ≤ X ≤ N2, 1 ≤ R,C ≤ N)
항상 입력으로 주어진 순서대로 하나씩 이동시켜야 한다.
<출력값>
총 K개 줄에 각각의 숫자를 이동시키는데 필요한 회전의 수를 출력한다.

<문제 2933>
창영과 상근은 한 동굴을 놓고 소유권을 주장하고 있다. 두 사람은 막대기를 서로에게 던지는 방법을 이용해 누구의 소유인지를 결정하기로 했다. 싸움은 동굴에서 벌어진다. 동굴에는 미네랄이 저장되어 있으며, 던진 막대기가 미네랄을 파괴할 수도 있다.
동굴은 R행 C열로 나타낼 수 있으며, R×C칸으로 이루어져 있다. 각 칸은 비어있거나 미네랄을 포함하고 있으며, 네 방향 중 하나로 인접한 미네랄이 포함된 두 칸은 같은 클러스터이다.
창영은 동굴의 왼쪽에 서있고, 상근은 오른쪽에 서있다. 두 사람은 턴을 번갈아가며 막대기를 던진다. 막대를 던지기 전에 던질 높이를 정해야 한다. 막대는 땅과 수평을 이루며 날아간다.
막대가 날아가다가 미네랄을 만나면, 그 칸에 있는 미네랄은 모두 파괴되고 막대는 그 자리에서 이동을 멈춘다.
미네랄이 파괴된 이후에 남은 클러스터가 분리될 수도 있다. 새롭게 생성된 클러스터가 떠 있는 경우에는 중력에 의해서 바닥으로 떨어지게 된다. 떨어지는 동안 클러스터의 모양은 변하지 않는다. 클러스터는 다른 클러스터나 땅을 만나기 전까지 게속해서 떨어진다. 클러스터는 다른 클러스터 위에 떨어질 수 있고, 그 이후에는 합쳐지게 된다.
동굴에 있는 미네랄의 모양과 두 사람이 던진 막대의 높이가 주어진다. 모든 막대를 던지고 난 이후에 미네랄 모양을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 동굴의 크기 R과 C가 주어진다. (1 ≤ R,C ≤ 100)
다음 R개 줄에는 C개의 문자가 주어지며, '.'는 빈 칸, 'x'는 미네랄을 나타낸다.
다음 줄에는 막대를 던진 횟수 N이 주어진다. (1 ≤ N ≤ 100)
마지막 줄에는 막대를 던진 높이가 주어지며, 공백으로 구분되어져 있다. 모든 높이는 1과 R사이이며, 높이 1은 행렬의 가장 바닥, R은 가장 위를 의미한다. 첫 번째 막대는 왼쪽에서 오른쪽으로 던졌으며, 두 번째는 오른쪽에서 왼쪽으로, 이와 같은 식으로 번갈아가며 던진다.
공중에 떠 있는 미네랄 클러스터는 없으며, 두 개 또는 그 이상의 클러스터가 동시에 떨어지는 경우도 없다. 클러스터가 떨어질 때, 그 클러스터 각 열의 맨 아래 부분 중 하나가 바닥 또는 미네랄 위로 떨어지는 입력만 주어진다.
<출력값>
입력 형식과 같은 형식으로 미네랄 모양을 출력한다.

<문제 2934>
상근이는 유전자 조작을 통해 줄기 두 개로 이루어진 식물을 만들었다. 이 식물은 줄기의 x좌표 L, R과 높이 H로 나타낼 수 있다. 아래 그림은 L=2, R=5, H=4인 식물이다.

상근이는 매일 매일 화단에 식물을 하나씩 심는다. 첫 번째 날에 심은 식물의 높이는 1이고, 그 다음날에 심은 식물은 전날에 심은 식물의 높이보다 1 크다.
새 식물의 줄기가 다른 식물의 수평 선분과 교차하는 경우가 있다. 이러한 경우에 그 위치에는 꽃이 하나 피게 된다. (이미 꽃이 있는 경우에는 꽃이 더 피지 않는다) 점에서 접하는 경우에는 꽃이 피지 않는다.
아래 그림은 예제를 나타낸 것이다.

모든 식물의 좌표가 주어졌을 때, 매일 매일 피는 꽃의 개수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 식물을 심은 날의 수 N (1 ≤ N ≤ 100,000)이 주어진다.
다음 N개 줄에는 매일 매일 심은 식물의 두 줄기 좌표 L과 R이 주어진다. (1 ≤ L < R ≤ 100,000)
<출력값>
총 N개의 줄에 매일 매일 핀 꽃의 수를 출력한다.

<문제 2935>
수업 시간에 떠드는 두 학생이 있다. 두 학생은 수업에 집중하는 대신에 글로벌 경제 위기에 대해서 토론하고 있었다. 토론이 점점 과열되면서 두 학생은 목소리를 높였고, 결국 선생님은 크게 분노하였다.
이렇게 학생들이 수업 시간에 떠드는 문제는 어떻게 해결해야 할까?
얼마전에 초등학교 선생님으로 취직한 상근이는 이 문제를 수학 문제로 해결한다. 학생들을 진정시키기 위해 칠판에 수학 문제를 써주고, 아이들에게 조용히 이 문제를 풀게 한다. 학생들이 문제를 금방 풀고 다시 떠드는 것을 방지하기 위해서, 숫자를 매우 크게 한다.
아직 초등학교이기 때문에, 학생들은 덧셈과 곱셈만 배웠다. 또, 아직 10의 제곱꼴을 제외한 다른 수는 학교에서 배우지 않았기 때문에, 선생님이 써주는 수는 모두 10의 제곱 형태이다.
쉬는 시간까지 문제를 푸는 것을 막기 위해서, 선생님이 써주는 숫자는 최대 100자리이다.
칠판에 쓰여 있는 문제가 주어졌을 때, 결과를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 양의 정수 A가 주어진다.
둘째 줄에 연산자 + 또는 *가 주어진다.
셋째 줄에 양의 정수 B가 주어진다.
A와 B는 모두 10의 제곱 형태이고, 길이는 최대 100자리이다.
<출력값>
첫째 줄에 결과를 출력한다. 결과는 A+B 또는 A*B이며, 입력에서 주어지는 연산자에 의해 결정된다.

<문제 2936>
상범이는 저번 주말에 수영장을 만들었다.

	수영장은 직각 이등변 삼각형이고, 두 변의 길이가 250이다.



	사실 상범이가 수영장을 만든 이유는 파티였다. 파티에는 많은 여학생들이 왔고, DJ도 왔다. 또, 고기는 매우 맛있게 구워지고 있었다.

	하지만, 그들이 예상하지 못한 문제가 생겼다. 이 파티에 놀러왔던 친구들 중에 준민이는 채식주의자였기 때문에 고기를 먹지 않는다. 반면에, 고기가 없는 파티는 파티라고 생각하지 않는다. 따라서, 상범이는 수영장을 두 부분으로 나누기로 했다.

	수영장은 위에 그림에서 보이듯이 좌표 평면 위에 있다. 그리고, 두 끝점이 삼각형의 변 위에 있는 선분을 이용해서 두 구역으로 나눌 것이다. 두 구역은 넓이가 같아야 한다.

	삼각형을 이등분하는 선분의 한 끝점이 주어진다. 이때, 다른 한 끝점을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 선분의 한 끝점이 주어진다. 이 점은 항상 삼각형의 변 위에 있다.
<출력값>
첫째 줄에 다른 끝점을 소수점 둘째 자리까지 출력한다. 이때, 셋째 자리에서 반올림하면 된다.

<문제 2937>
민혁 유치원에서는 아이들의 창의력과 인내력, 근력과 지구력, 잉여력과 탄성력, 판단력과 노력, 기력과 활동력, 활력과 달력, 내구력과 변형력, 응집력과 무력, 지력과 매력, 미력과 담력, 능력과 실력, 압력과 협력, 체력과 경력, 폭력과 세력, 양력과 음력, 입력과 출력, 권력과 주력, 병력과 전력, 마찰력과 동력, 전기력과 효력, 내력과 국력, 자기력과 중력, 화력과 수력, 원자력과 영향력, 이력과 경쟁력, 경제력과 설득력, 공권력과 원동력, 정치력과 집중력, 추진력과 연기력, 잠재력과 정신력, 부력과 재력, 마력과 유력, 조력과 여력, 초능력과 예지력, 표현력과 기억력, 무기력과 창조력, 순발력과 저항력, 호소력과 관찰력, 구속력과 풍력, 청력과 시력, 학력과 필력, 완력과 사력, 수사력과 자생력, 고학력과 번식력, 자금력과 포용력, 정력과 편력, 속력과 피력, 지도력과 통제력, 기동력과 사고력, 무중력과 결정력, 이해력과 친화력, 결단력과 태양력, 공격력과 방어력, 돌파력과 장악력, 전속력과 흡인력, 괴력과 극력, 독력과 경기력, 기획력과 득점력, 적응력과 파괴력, 행정력과 구매력, 도약력과 반발력, 진력과 금력, 강력과 약력, 정치권력과 분석력, 세정력과 자제력, 반작용력과 만유인력, 근지구력과 진심전력, 불가항력과 청천벽력, 폭발력과 형성력, 견제력과 장력, 각력과 감항능력, 겸인지력과 결심육력, 고광지력과 구사력, 단결력과 생활력, 수비력과 운동력, 교정시력과 공력, 어휘력과 군책군력, 구태양력과 조직력, 가창력과 문장력, 발표력과 교력, 궁력과 동심합력, 방위력과 소비력, 연출력과 자본력, 주도력과 그레고리력, 율리우스력과 마호메트력, 무능력과 작용력, 주동력과 가로복원력, 강제통영력과 게이지압력, 경제잠재력과 분투노력, 공소의효력과 불유여력, 직감력과 직관력, 추리력과 충격력, 횡압력과 감별력, 결합력과 기술력, 미적판단력과 발전소출력, 사회적압력과 신통력, 동원력과 가호력, 다력과 대력, 감각력과 감득력, 자기세력과 일심협력, 이집트력과 정지마찰력, 잠재구매력과 최대마찰력, 감상력과 개괄력, 개발력과 개념력, 도력과 구상력, 관통력과 물력, 기조력과 기전력, 담세력과 독서력, 독창력과 법력, 강한핵력과 약한핵력을 기르기 위해 재미있는 게임을 만들었다.
이 게임을 하려면 한 변의 길이가 N인 정사각형 보드가 필요하다. 이 보드는 변의 길이가 1인 정사각형 N*N개로 나누어져 있다. 또, 변의 길이가 1인 정육면체 블록도 여러 개 있다. 아이들은 이 블록을 보드 위의 한 정사각형 위에 올려놓거나, 다른 블록 위에 올려 놓는다. 항상 블록은 정사각형 하나를 가득 채우게 놓아야 한다.
아이들은 이 놀이를 하고 난 다음에 반드시 뒷정리를 하고 집에 가야 한다. 만약, 뒷정리를 하지 않을 경우에는 민혁 선생님과 력으로 끝나는 단어 외우기를 해야 한다.
선생님은 아이들에게 직사각형을 가르쳐 주기 위해서, 블록을 직사각형 모양으로 배열하라고 했다. 이때, 한 블록 위에 다른 블록이 있으면 안 된다.
지금 블록의 상태가 주어졌을 때, 이 블록이 놓인 모습이 직사각형이 되게 하기 위해서 블록을 최소 몇 개 움직여야 하는지 구하는 프로그램을 작성하시오. 한 칸의 가장 위에 있는 블록을 다른 칸의 가장 위에 올려놓는 이동만 할 수 있다.
<입력값>
첫째 줄에 보드판의 한 변의 길이 N과 그 위의 블록의 개수 M이 주어진다. (1 ≤ N ≤ 100, 1 ≤ M ≤ N2)
다음 M개 줄에는 블록이 있는 위치(좌표) R과 C가 주어진다. (1 ≤ R, C ≤ N)
<출력값>
첫째 줄에 블록을 최소 몇 개 이동시키면 직사각형을 만들 수 있는지 출력한다. 항상 직사각형을 만들 수 있는 경우만 입력으로 주어진다.

<문제 2938>
자연수로 이루어진 배열이 주어졌을 때, 수의 순서를 적절히 바꿔서 인접한 두 수의 합이 3으로 나누어 떨어지지 않는 배열을 만드는 프로그램을 작성하시오.
<입력값>
첫째 줄에 배열의 크기 N이 주어진다. (1 ≤ N ≤ 10000)

	둘째 줄에는 배열에 들어있는 수가 공백으로 구분되어 주어진다. 수는 1,000,000보다 작거나 같은 자연수이다.
<출력값>
만약, 3으로 나누어 떨어지지 않게 배열을 만들 수 있다면 첫째 줄에 출력한다. 불가능하다면 -1을 출력한다.

<문제 2939>
상근이는 데이트 비용을 마련하기 위해 빠름택배에서 택배를 배달하는 직업을 가졌다.
매일 빠름택배에 출근하면, 상근이는 그날 배달해야 하는 위치가 적힌 종이를 받는다. 또, 이 위치에 적혀져있는 순서대로 배달해야 한다.
도시는 R*C칸으로 나누어져 있다. 각 행은 1번부터 R번까지 번호가 매겨져 있고, 열도 1번부터 C번까지 번호가 매겨져 있다.
상근이는 각 칸에서, 왼쪽 또는 오른쪽으로 이동할 수 있다. 하지만, 위나 아래로 이동하려면 꼭 첫 번째나 마지막 열(1과 C)로 가야 한다.
빠름택배는 가장 왼쪽 위 칸인 (1,1)에 있다. 이곳이 상근이가 배달을 시작하는 곳이다. 상근이는 출발할 때 모든 물품을 들고 출발하고, 자신의 오토바이를 이용하여 배달하기 때문에, 배달하는 중 또는 배달을 마치고 다시 빠름택배로 돌아오지 않는다.
각 칸을 통과하는데 드는 시간이 주어진다. 이때, 모든 택배를 배달하는데 걸리는 최소 시간을 계산하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 도시의 크기 R과 C가 주어진다. (1 ≤ R ≤ 2000, 1 ≤ C ≤ 200)
다음 R개 줄에는, 각 칸을 통과하는데 드는 시간이 주어진다. 이 시간은 0보다 크거나 같고, 5000보다 작거나 같은 자연수이다.
다음 줄에는 배달해야 하는 물품의 수 D (1 ≤ D ≤ 200000)가 주어진다. 다음 D개 줄에는 물품을 배달해야 하는 곳의 위치의 좌표가 배달해야 하는 순서대로 주어진다. 같은 곳이 여러 번 주어질 수는 있다. 하지만, 연속해서 같은 곳을 배달해야 하는 경우는 없다.
<출력값>
모든 택배를 배달하는데 가장 빠른 시간을 출력한다.

<문제 2941>
예전에는 운영체제에서 크로아티아 알파벳을 입력할 수가 없었다. 따라서, 다음과 같이 크로아티아 알파벳을 변경해서 입력했다.



크로아티아 알파벳
변경




č
c=


ć
c-


dž
dz=


đ
d-


lj
lj


nj
nj


š
s=


ž
z=



예를 들어, ljes=njak은 크로아티아 알파벳 6개(lj, e, š, nj, a, k)로 이루어져 있다. 단어가 주어졌을 때, 몇 개의 크로아티아 알파벳으로 이루어져 있는지 출력한다.
dž는 무조건 하나의 알파벳으로 쓰이고, d와 ž가 분리된 것으로 보지 않는다. lj와 nj도 마찬가지이다. 위 목록에 없는 알파벳은 한 글자씩 센다.
<입력값>
첫째 줄에 최대 100글자의 단어가 주어진다. 알파벳 소문자와 '-', '='로만 이루어져 있다.
단어는 크로아티아 알파벳으로 이루어져 있다. 문제 설명의 표에 나와있는 알파벳은 변경된 형태로 입력된다.
<출력값>
입력으로 주어진 단어가 몇 개의 크로아티아 알파벳으로 이루어져 있는지 출력한다.

<문제 2942>
맨체스터 유나이티드의 감독 퍼거슨은 빨간 사과를 R개, 초록 사과를 G개 가지고 있다. 훈련장에 있는 선수들 중 몇 명에게 나누어 주려고 한다. 단, 선수들이 서로 같은 개수의 사과를 받지 못하면 경기력 저하가 나타날 수 있으므로 모든 선수에게 같은 개수를 주려고 한다. 퍼거슨 감독은 사과를 싫어한다. 따라서 사과가 남으면 안 된다.
예를 들어, 퍼거슨이 빨간 사과를 4개, 초록 사과를 8개 가지고 있다면, 다음과 같이 세가지 방법으로 나누어 줄 수 있다.

선수 1명에게 빨간 사과 4개와 초록 사과 8개를 줄 수 있다.
선수 2명에게 빨간 사과 2개와 초록 사과 4개를 각각 줄 수 있다.
선수 4명에게 빨간 사과 1개와 초록 사과 2개를 각각 줄 수 있다.

퍼거슨이 사과를 나누어 주는 방법을 구하는 프로그램을 작성하시오. 훈련장에 선수는 무한히 많다.
<입력값>
첫째 줄에 R과 G가 주어진다. (1 ≤ R, G ≤ 1,000,000,000)
<출력값>
퍼거슨이 사과를 나누어 주는 방법을 출력한다. 방법을 출력할 때는 사과를 받게되는 선수의 수 N과 나누어 주는 빨간 사과의 수 X와 초록 사과의 수 Y를 출력한다.
각 방법은 한 번만 출력해야 한다. 나누어 주는 방법은 아무 순서로 출력해도 된다.

<문제 2943>
상근이는 토끼 N마리를 키우고 있다. 그는 매일 매일 토끼에게 다양한 야채와 과일을 먹이로 주고 있었다. 그러나, 상근이의 토끼는 딸기를 가장 좋아한다. 하지만 겨울에는 딸기를 구하기가 매우 어렵고, 가격도 비싸다. 따라서 상근이는 일부 토끼에게만 딸기를 주기로 했다.
상근이 토끼의 이름은 숫자이고, 1번부터 N번이다. 상근이는 각 토끼가 먹는 딸기의 양을 기록을 하기 위해서 다음과 같은 방법을 이용한다.
매일 상근이는 딸기 S개를 구매한다. 그러고 난 뒤, A번 토끼에게 첫 번째 딸기를, A+1번 토끼에게 두 번째 딸기를, A+2번 토끼에게 세 번째 딸기를,.... 준다.
모든 토끼는 비어있는 성냥갑을 가지고 있고, 이 성냥갑은 한 줄로 놓여져 있다.
K·K ≤ N을 만족하는 가장 큰 K를 고른다. 그 다음 첫 성냥갑부터 K개씩 그룹을 지어준다. 각 성냥갑의 앞에는 컵을 하나씩 놓는다. 이렇게 연속하는 K개 성냥갑과 컵을 블록이라고 한다.
토끼에게 딸기를 준 다음에, 상근이는 딸기를 받은 토끼의 성냥갑에 성냥을 넣는다. 이때, 어떤 블록에 모든 성냥갑에 성냥을 넣어야된다면, 성냥갑 대신에 컵에 성냥을 넣는다. 
위의 방법을 사용하면, 각 토끼가 지금까지 먹은 딸기의 수는 성냥갑과 컵에 들어있는 성냥의 수가 된다.

예를 들어, 위와 같이 토끼가 11마리 있다고하자. 그럼 N = 11이 된다. 이때, K를 구하면 K = 3이 된다. 따라서, 총 네 개의 블록이 있을 것이고, 마지막 블록에는 성냥갑이 2개만 있을 것이다. 만약, 상근이가 딸기를 6개 사왔고, 5번 토끼부터 딸기를 준다면, 성냥갑과 컵에 들어있는 성냥은 아래와 같이 된다.

토끼의 수 N이 주어지고, M일동안 구매한 딸기의 수와 토끼에게 준 방법이 주어진다. 이때, 상근이가 그날 성냥을 넣은 성냥갑과 컵에 들어있는 성냥의 수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N과 M이 공백으로 구분되어 주어진다. (1 ≤ N, M ≤ 100000)
다음 M개 줄에는 각 날 상근이가 구매한 딸기의 수 S와 딸기를 주기 시작하는 토끼의 번호 A가 주어진다. (1 ≤ A ≤ N, 1 ≤ A+S–1 ≤ N)
<출력값>
출력은 총 M개의 숫자를 출력해야 한다. k번째 줄에는 k번째 날에 성냥을 넣은 성냥갑과 컵에 들어있는 성냥의 수를 출력해야 한다.

<문제 2944>
상근이는 고등학교에 다닐 때, 친구들과 함께 아이폰으로 페이스북 게임을 했다. 그 당시에 가장 인기 있던 게임은 TGN에서 만든 수박 던지기이다.
선생님 몰래 게임을 하다가 걸리면 아이폰을 뺏길 수 있기 때문에, 그들은 수업이 시작하는 종이 치면 바로 게임을 한다. (게임을 하는데 드는 시간과 아이폰을 꺼내는 시간, 앱을 실행시키는 시간과 같은 시간은 모두 없다)
게임은 항상 상근이가 시작한다. 일교시가 시작할 때, 상근이는 그들의 친구에게 모두 수박을 하나씩 던진다. 이교시부터 다음 교시가 시작할 때는 다음과 같은 과정을 거치게 된다.
만약, 어떤 학생이 이전 교시에 맞은 수박의 수가 홀수라면, 그는 모든 친구에게 수박을 하나씩 던진다. 이와 반대로 짝수개인 경우(0도 짝수)에는 수박을 두 개씩 던진다.
상근이네 반의 모든 학생들은 1번부터 N번까지 번호가 매겨져 있다. 상근이는 1번이다.
학생들의 친구 관계가 주어졌을 때, H교시가 끝난 이후에 수박이 총 몇 번 던져졌는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 학생의 수 N과 교시의 수 H가 주어진다. (1 ≤ N ≤ 20, 1 ≤ H ≤ 1,000,000,000)
다음 N개 줄에는 학생들의 친구관계가 행렬 형식으로 주어진다. A번째 행의 B번째 열의 수가 1인 경우에는 A와 B가 친구이고, 0인 경우에는 친구가 아니다.
자기 자신과 친구인 경우는 없고, 행렬은 항상 대칭이다.
<출력값>
첫째 줄에 H교시가 끝난 이후에 학생들이 그때까지 던진 수박의 수를 출력한다.

<문제 2945>
상근이는 작은 마을에 살고 있다. 이 마을에서 가장 큰 거리에는 사과 나무가 한 줄로 있다. 상근이는 사과에 번호를 붙였다. 제일 처음 나무는 1번이고, 순서대로 번호를 붙였다.

	이 거리를 매일 지나다니는 상근이는 각 나무가 가지고 있는 사과의 개수는 나무의 번호와 깊은 관계가 있다는 사실을 알게 되었다.

	각 나무의 번호에 있는 연속되는 숫자의 그룹을 찾는다. 연속되는 숫자의 그룹은 같은 숫자로 되어 있는 연속하는 구간이다. 사과의 개수는 각 그룹의 길이의 제곱과 연속하는 숫자의 곱을 모두 더하면 된다.

	예를 들어, 나무의 번호가 77744007이라면, 연속되는 숫자의 그룹은 777, 44, 00, 7이다. 이 나무가 가지고 있는 사과의 개수는 7·32 + 4·22 + 0·22 + 7·12 = 86가 된다.

	상근이는 A번부터 B번나무에 있는 사과를 모두 수확하려고 한다. 상근이가 수확하는 사과의 개수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 A와 B가 주어진다. (1 ≤ A ≤ B ≤ 1015)
<출력값>
A번 부터 B번 나무에 있는 사과의 개수를 출력한다. (A와 B번도 포함 한다)

<문제 2946>
알라딘은 궁전에서 지루한 삶에 싫증을 느꼈다. 항상 변함없이 똑같은 일과 부인 자스민과 아이들은 알라딘에게 더 이상 큰 흥미를 가져다주지 못했다. 그는, 더 이상 궁전에서 지루한 삶을 살 수 없다고 생각했고 모험을 떠나기로 했다.

	알라딘이 살고있는 나라에는 요정이 나타나는 램프가 묻혀있다는 전설이 있다. 이 램프는 지금까지 그 누구도 찾지 못했던 램프이다. 알라딘은 이 램프를 찾기로 했다.

	예로부터 내려오는 전설에 의하면 램프는 사막에 묻혀있다. 사막은 N*N 칸이 그리드형태로 배열되어 있는 모습으로 나타낼 수 있다. 행과 열은 위에서 부터 아래로, 왼쪽부터 오른쪽으로 1번부터 N번까지 번호가 매겨져 있다. 어떤 칸에는 마법사가 살고 있고, 마법사는 알라딘에게 가야할 방향을 알려준다.

	알라딘은 사막의 가장 왼쪽 위 칸에서 모험을 시작한다. 이 날은 월요일이며, 알라딘은 오른쪽을 보고 있다. 알라딘은 아래 세 단계를 거쳐서 다음 칸으로 이동하게 된다.

	1. 알라딘이 있는 칸에 마법사가 깨어있다면, 알라딘은 마법사가 말해주는 방향으로 방향을 바꾼다. 이때, 마법사가 말하는 방향은 90도 왼쪽 방향과 오른족 방향 둘 중 하나이다.

	2. 알라딘이 한 칸 전진했을 때, 사막읙 경계를 벗어난다면, 그는 180도 방향을 바꾼다.

	3. 알라딘은 한 칸 전진하고, 이것은 정확하게 하루가 걸린다. (1, 2단계에 걸리는 시간은 없다)

	모든 마법사가 말해주는 방향은 요일에 따라서 다르고, 길이가 7인 문자열로 나타낼 수 있다. 문자열은 'L', 'R', 'S'로 이루어져 있으며, 각 문자는 어떤 요일에 무슨 방향을 말해주는지를 나타낸다. 첫 번째 문자는 월요일, 두 번째 문자는 화요일, ... 이며, 'L'은 왼쪽으로, 'R'은 오른쪽으로 방향을 바꾸라는 의미이다. 'S'는 그 날은 마법사가 잠을 잔다는 뜻이다.

	알라딘은 모험을 떠나기전에 유명한 예언가는 알라딘이 방향을 K번 바꾼다면 (1단계와 2단계) 램프를 발견한다고 말했다. 이 예언대로라면 알라딘은 며칠 만에 램프를 발견하는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 사막의 크기 N과 예언가의 예언 K가 주어진다. (2 ≤ N ≤ 200, 1 ≤ K ≤ 1,000,000,000)

	둘째 줄에는 마법사의 수 M이 주어진다. (0 ≤ M ≤ 10000)

	다음 M개 줄에는 마법사의 위치 R, C와 스케쥴을 나타내는 문자열이 주어진다. R은 마법사가 있는 행의 번호, C는 열의 번호이다.

	한 칸에 두 명 이상의 마법사가 있는 경우는 없으며, 항상 (1, 1)에는 마법사가 없다.
<출력값>
첫째 줄에 램프를 발견하는데 총 며칠이 걸리는지 출력한다.

<문제 2947>
동혁이는 나무 조각을 5개 가지고 있다. 나무 조각에는 1부터 5까지 숫자 중 하나가 쓰여져 있다. 또, 모든 숫자는 다섯 조각 중 하나에만 쓰여 있다.
동혁이는 나무 조각을 다음과 같은 과정을 거쳐서 1, 2, 3, 4, 5 순서로 만들려고 한다.

첫 번째 조각의 수가 두 번째 수보다 크다면, 둘의 위치를 서로 바꾼다.
두 번째 조각의 수가 세 번째 수보다 크다면, 둘의 위치를 서로 바꾼다.
세 번째 조각의 수가 네 번째 수보다 크다면, 둘의 위치를 서로 바꾼다.
네 번째 조각의 수가 다섯 번째 수보다 크다면, 둘의 위치를 서로 바꾼다.
만약 순서가 1, 2, 3, 4, 5 순서가 아니라면 1 단계로 다시 간다.

처음 조각의 순서가 주어졌을 때, 위치를 바꿀 때 마다 조각의 순서를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 조각에 쓰여 있는 수가 순서대로 주어진다. 숫자는 1보다 크거나 같고, 5보다 작거나 같으며, 중복되지 않는다. 처음 순서는 1, 2, 3, 4, 5가 아니다.
<출력값>
두 조각의 순서가 바뀔때 마다 조각의 순서를 출력한다.

<문제 2948>
2009년 날짜가 주어졌을 때, 무슨 요일인지 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 D와 M이 주어진다. M월 D일이다.
<출력값>
2009년 M월 D일의 요일을 영어로 출력한다. 출력은 다음 중 하나이다. "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday".

<문제 2949>
동혁이는 회전을 좋아한다. 동혁이는 표에 글자를 채워넣은 다음에 이를 회전시키려고 한다.
먼저 A4용지에 R*C크기의 표를 그리고, 각 칸에 알파벳 소문자를 채워 넣는다.
그 다음 45의 배수인 K를 고른 뒤에, 그 각도만큼 시계방향으로 회전 시킨다.
이때, 동혁이가 보는 표의 모습을 출력하는 것이다. (동혁이는 마법을 부려 알파벳은 종이를 돌려도 항상 제모습 유지하도록 만들었다)
<입력값>
첫째 줄에 R과 C가 공백으로 구분되어 주어진다. 그 다음 R개의 줄에는 동혁이가 그린 표에 적혀있는 알파벳이 주어진다. (1 ≤ R ≤ 10, 1 ≤ C ≤ 10)
마지막 줄에는 K가 주어진다. 이 수는 0보다 크거나 같고, 360보다 작거나 같은 45의 배수이다.
<출력값>
예제와 같은 형태로 회전 시켰을 때의 모습을 출력하면 된다. 회전 시켰을 때,  다양한 경우가 나올 수 있는데, 이럴 때는 줄의 수가 가장 작은 것을 출력하면 된다. 어떤 줄은 공백으로 시작할 수도 있고, 공백으로 끝날 수도 있다. 이때, 공백으로 시작하는 경우에는 공백을 모두 출력해야 하지만, 공백으로 끝나는 경우에는 공백을 출력하지 않고 무시한다. (모든 줄은 알파벳 소문자로 끝나야 한다.)

<문제 2951>
상근이는 금고 대여 사업을 시작했다. 금고가 모여있는 곳은 이차원 평면, 금고는 평면위의 한 점으로 생각할 수 있다. 상근이는 금고를 총 L*(A+1+B)개 가지고 있고, 금고는 (1, -A), (L, B)를 꼭짓점으로 하는 직사각형 안의 정수 좌표에 해당한다.

	금고는 두 명의 경비원이 지키고 있다. 한 경비원은 (0, -A)에, 다른 경비원은 (0, B)에 서있다. 경비원은 금고와 경비원을 연결하는 선분 사이에 금고가 하나도 없다면 그 금고를 볼 수 있다.

	두 경비원이 모두 보지 못하는 금고는 안전하지 않은 금고이고, 한 명만 볼 수 있는 금고는 안전한 금고이다. 마지막으로, 두 경비원이 모두 볼 수 있는 금고는 매우 안전한 금고이다.

	A, B, L이 주어졌을 때, 안전하지 않은 금고, 안전한 금고, 매우 안전한 금고의 수를 세는 프로그램을 작성하시오.
<입력값>
첫째 줄에 A와 B가, 둘째 줄에 L이 주어진다. (1 ≤ A, B ≤ 2000, 1 ≤ L ≤ 1,000,000,000)
<출력값>
첫째 줄에 안전하지 않은 금고의 수, 둘째 줄에 안전한 금고의 수, 셋째 줄에 매우 안전한 금고의 수를 출력한다.

<문제 2952>
동혁이는 화학 시간에 벽에 걸려있는 주기율표를 보다가 잠이 들었다. 동혁이는 꿈에서 신기하게 생긴 주기율표를 보았다.

	꿈에서 본 주기율표는 N열로 이루어져 있다. 각 열은 높이가 있고, 아래 그림처럼 정렬되어 있다. 주기율표에는 아직 아무 원소도 쓰여져 있지 않다. 동혁이는 원소를 채워넣으려고 한다.

	동혁이는 비활성 기체 K개를 채워넣으려고 한다. 또, 비활성 기체를 서로 가까이 있지 않게 채우려고 한다.

	두 정사각형이 서로 가까이 있으려면, 같은 행이나 열에 있어야 한다. 또, 중간에 비어있는 사각형이 있으면 안 된다. 아래 그림에서 'a'는 가까이 있는 것이 아니지만, 'b'는 가까이 있는 것이다.



	N과 K, 그리고 N열의 높이가 주어졌을 때, 동혁이가 비활성 기체를 채우는 방법의 수를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에는 N과 K가 주어진다. (1 ≤ N ≤ 500, 1 ≤ K ≤ 500)

	다음 줄에는 각 칸의 높이가 공백으로 구분되어서 주어진다. 높이는 최대 1,000,000이다. 높이는 왼쪽 칸부터 오른쪽까지 순서대로 주어진다.
<출력값>
동혁이의 주기율표에 비활성 기체를 채우는 방법의 수를 1,000,000,007로 나눈 나머지를 출력한다.

<문제 2953>
"나는 요리사다"는 다섯 참가자들이 서로의 요리 실력을 뽐내는 티비 프로이다. 각 참가자는 자신있는 음식을 하나씩 만들어오고, 서로 다른 사람의 음식을 점수로 평가해준다. 점수는 1점부터 5점까지 있다.

	각 참가자가 얻은 점수는 다른 사람이 평가해 준 점수의 합이다. 이 쇼의 우승자는 가장 많은 점수를 얻은 사람이 된다.

	각 참가자가 얻은 평가 점수가 주어졌을 때, 우승자와 그의 점수를 구하는 프로그램을 작성하시오.
<입력값>
총 다섯 개 줄에 각 참가자가 얻은 네 개의 평가 점수가 공백으로 구분되어 주어진다. 첫 번째 참가자부터 다섯 번째 참가자까지 순서대로 주어진다. 항상 우승자가 유일한 경우만 입력으로 주어진다.
<출력값>
첫째 줄에 우승자의 번호와 그가 얻은 점수를 출력한다.

<문제 2954>
창영이는 매일 밤 하루동안 일어난 일을 일기장에 남긴다. 일기장을 쓰면서 영어 공부도 같이 하기 위해서 영어로 일기를 쓴다. 또, 남들이 자신의 일기장을 보는 것을 막기 위해서 모음('a','e','i','o','u')의 다음에 'p'를 하나 쓰고,  그 모음을 하나 더 쓴다.
예를 들어, "kemija" 는 "kepemipijapa"가 되고, "paprika"는 "papapripikapa"가 된다.
창영이가 일기장에 작성한 문장이 하나 주어졌을 때, 원래 문장은 무엇인지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 알파벳 소문자와 공백으로만 이루어진 문장이 하나 주어진다. 모든 단어는 공백 하나로 구분되어져 있다. 문장의 길이는 최대 100이다.
<출력값>
첫째 줄에 창영이가 일기장에 작성한 문장을 원래 문장으로 바꾸어 출력한다.

<문제 2955>
스도쿠는 가로 9칸, 세로 9칸으로 이루어져 있는 표에 1부터 9까지의 숫자를 채워 넣는 퍼즐이다. 퍼즐을 푸는 방법은 각 가로줄과 세로줄에 1에서 9까지의 숫자를 한 번만 넣고, 3*3칸의 작은 격자에도 1에서 9까지의 숫자를 겹치지 않게 넣어야 한다.

	스도쿠를 푸는 방법에는 여러 가지 방법이 있다. 그 중 한가지 방법은 Cross-hatching이다.

	Cross-hatching방법을 이용할 때는, 먼저 숫자를 하나 골라야 한다. 그런 뒤에, 그 숫자가 등장하는 가로줄이나 세로줄 또는 3*3 박스에 선을 긋는다. 이렇게 선을 그었을 때, 3*3박스에 고른 숫자가 들어갈 수 있는 칸이 한 칸일 때, 그 숫자를 채우는 것이다.

	아래 그림 중 왼쪽 그림은 매우 조금만 숫자가 채워진 스도쿠이고, 오른쪽 그림은 cross-hatching 방법을 이용해서 4가 들어갈 수 있는 곳을 찾은 한가지 예이다.



	부분적으로 숫자가 채워진 스도쿠 퍼즐이 주어졌을 때, cross-hatching방법만을 이용해서 스도쿠를 푸는 프로그램을 작성하시오. 더이상 이 방법을 이용해서 풀 수 없을 때 까지 스도쿠를 풀어야 한다. 다른 방법을 이용하면 안 된다.

	입력으로 주어지는 스도쿠 퍼즐이 규칙을 지키지 않는 경우가 입력으로 주어질 수 있다. (예, 한 가로줄에 1이 2개 있는 경우, 숫자 1이 어떤 가로줄, 3*3박스, 세로줄에 있을 수 있는 곳이 전혀 없는 경우) 이런 경우도 판별해야 한다.
<입력값>
입력은 9개줄로 이루어지며, 각 줄은 9개 문자로 이루어져 있다. 문자는 1~9 숫자 또는 '.'이다. 마침표는 빈 칸을 나타낸다.
<출력값>
올바른 스도쿠 퍼즐이고, 모순이 일어나지 않는다면, 입력과 같은 형식으로 cross-hatching만을 이용해서 푼 결과를 출력한다. 그렇지 않다면 "ERROR"를 출력한다. (쌍따옴표는 출력하지 않는다)

<문제 2956>
행렬은 글자로 채워져 있는 직사각형 표이다. 정사각형 행렬은 열의 수와 행의 수가 같을 때이다. 정사각형 행렬 M이 대칭이라면, 모든 i,j쌍에 대해서 Mij = Mji를 만족할 때이다.
아래 두 행렬은 대칭인 경우이다.

AAB        AAA
ACC        ABA
BCC        AAA
아래 두 행렬은 대칭이 아닌 경우이다.

ABCD        AAB
ABCD        ACA
ABCD        DAA
ABCD
사용할 수 있는 문자가 주어졌을 때, 이 문자를 모두 사용해서 만들 수 있는 대칭행렬 중에서, 사전순으로 앞서는 행렬의 열의 부분집합을 출력하는 프로그램을 작성하시오.
어떤 행렬의 열의 부분집합이란 특정 열을 제외하고는 모두 지워버린 행렬이다. 아래와 같은 행렬을 살펴보자.

AAB
ACC
BCC
위 행렬의 1,3열의 부분집합은 다음과 같다. (2열에 등장하는 문자를 모두 지워버리면 된다.)

AB
AC
BC
두 행렬 A와 B를 사전순으로 비교하려면, 각 행렬을 행을 순서대로 모두 이어붙여 긴 문자열로 만든 뒤 문자열 비교를 한다고 생각하면 된다.
<입력값>
첫째 줄에 두 정수 N과 K가 주어진다. N은 행렬의 크기이고, K는 사용할 수 있는 서로 다른 문자의 개수이다. (1 ≤ N ≤ 30000, 1 ≤ K ≤ 26)
다음 K개 줄에는 사용할 수 있는 문자와 그 개수가 공백으로 구분되어 주어진다. 문자는 모두 알파벳 대문자이다. 예를 들어, "A 3"은 A를 3번 사용할 수 있다는 뜻이다.
사용할 수 있는 문자의 개수는 정확히 N2개이다.
다음 줄에는 열의 부분집합의 크기 P가 주어진다. (1 ≤ P ≤ 50)
마지막 줄에는, P개의 숫자가 주어지고, 열의 부분집합의 내용이다. 각 숫자는 1보다 크거나 같고, N보다 작거나 같으며, 오름차순으로 정렬되어 있고, 중복되지 않는다.
<출력값>
주어진 문자로 대칭행렬을 만드는 것이 가능하다면, 행렬의 열의 부분집합을 출력한다. 만약, 불가능하다면 "IMPOSSIBLE"을 출력한다. (따옴표는 출력하지 않는다)

<문제 2957>
이진 탐색 트리는 모든 노드가 많아야 2개의 자식 노드를 가지고 있는 트리이고, 각 노드에는 수가 하나씩 쓰여있다. 만약 어떤 노드에 쓰여 있는 수가 X라면, 그 노드의 왼쪽 서브트리에는 X보다 작은 수, 오른쪽 서브트리에는 X보다 큰 수만 저장되어 있어야 한다.
1보다 크거나 같고, N보다 작거나 같은 수 N개가 한 번씩 등장하는 수열이 입력으로 주어진다. 이 수열을 이용해서 이진 탐색 트리를 만들려고 한다. 이제 배열의 첫 번째 수를 루트 노드로 놓고, 다른 나머지 수들을 순서대로 삽입하면서 이진 탐색 트리를 만들려고 한다. 즉, 첫 번째 수를 제외한 모든 수에 대해서 insert(X,root)를 실행하는 것과 같다. 그 함수는 다음과 같다. 
이진 탐색 트리에 삽입하는 함수는 다음과 같다.

insert(number X, node N)
    카운터 C값을 1 증가시킨다
    if X가 노드 N에 있는 수보다 작다면
        if N의 왼쪽 자식이 없다면
            X를 포함하는 새 노드를 만든 뒤, N의 왼쪽 자식으로 만든다
        else
            insert(X, N의 왼쪽 자식)
    else (X가 노드 N에 있는 수보다 크다면)
        if N의 오른쪽 자식이 없다면
            X를 포함하는 새 노드를 만든 뒤, N의 오른쪽 자식으로 만들기
        else
            insert(X, N의 오른쪽 자식)
각 수를 삽입한 후에 C의 값을 출력하는 프로그램을 작성하시오. 카운터 C의 값은 0으로 초기화되어 있다.
<입력값>
첫째 줄에 수열의 크기 N이 주어진다. (1 ≤ N ≤ 300,000)
다음 N개의 줄에는 수열의 수가 차례대로 주어진다. 수는 구간 [1, N]에 포함된 정수이고, 중복되지 않는다.
<출력값>
N개의 줄에 각 수가 트리에 삽입된 후에 카운터 C값을 한 줄에 하나씩 출력한다.

<문제 2958>
도시 N개와 일방통행 도로 M개로 이루어진 도로 네트워크가 있다. 도시는 1번부터 N번까지 번호가 매겨져 있다. 또, 각 도로의 출발 도시와 도착 도시, 그리고 길이를 알고 있다.
도로 E의 도착 도시와 도로 F의 시작 도시가 같다면, 도로 F를 도로 E의 연장선이라고 한다. A에서 B로 가는 경로란 첫 도로의 시작 도시가 A이고 마지막 도로의 도착 도시가 B이면서 각 도로가 이전 도로의 연장선인 도로의 연속이다. 경로의 길이는 경로에 포함된 도로의 길이의 합이다.
A에서 B로 가는 최단 경로는 A에서 B로 가는 경로 중에서 길이가 가장 짧은 것을 말한다.
각각의 도로에 대해서, 그 도로를 포함하는 최단 경로가 몇 개 있는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 도시의 수 N과 도로의 수 M이 주어진다. (2 ≤ N ≤ 1500, 1 ≤ M ≤ 5000)
다음 M개 줄에는 도로의 정보를 나타내는 세 정수 O, D, L이 주어진다. 도로의 시작 도시가 O이고, 도착 도시가 D이면서 길이가 L인 도로라는 의미이다. O와 D는 다르고, L은  10,000보다 작거나 같은 자연수이다.
<출력값>
총 M개 도로에 대해서 그 도로를 포함하는 최단 경로의 개수를 1,000,000,007로 나눈 나머지를 한 줄에 하나씩 출력한다. 출력은 입력으로 주어진 도로 순서대로 해야 한다.

<문제 2959>
거북이는 이제 어떤 것에도 흥미를 느끼지 않는다. 그 이유는 거북이가 300년동안 살았고, 그 동안 모든 것들을 다 해보았기 때문이다. 거북이는 시간을 떼우는 무엇인가를 하려고 한다. 이번 주말에 거북이는 거북이 세계에서 매우 유명한 게임인 "가장 큰 직사각형 만들기"를 해보려고 한다.
이 게임을 시작하기 전에 거북이는 양의 정수 네 개를 머릿 속에 생각해야 한다. 한 방향으로 움직이기 시작하고 90도 회전한 뒤에 새로운 방향으로 움직인다. 이런 식으로 세 번 90도 회전을 하고, 네 번 앞으로 움직여서 선분 네 개를 만들어야 한다.
거북이가 선분을 그릴 때 움직여야 하는 걸음의 수는 생각해 놓은 네 정수중 하나이다. 이때, 한 정수를 각각 한 번씩 사용해야 한다. 거북이가 정수를 사용하는 순서에 따라서 다양한 모양이 만들어진다. 어떤 모양은 직사각형을 만들 수 없기도 한다.
거북이가 만들 수 있는 가장 큰 직사각형을 계산하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 거북이가 생각한 네 양의 정수 A, B, C, D가 주어진다. (0 < A, B, C, D < 100)
<출력값>
첫째 줄에 거북이가 만들 수 있는 가장 큰 직사각형의 면적을 출력한다.

<문제 2960>
에라토스테네스의 체는 N보다 작거나 같은 모든 소수를 찾는 유명한 알고리즘이다.
이 알고리즘은 다음과 같다.

2부터 N까지 모든 정수를 적는다.
아직 지우지 않은 수 중 가장 작은 수를 찾는다. 이것을 P라고 하고, 이 수는 소수이다.
P를 지우고, 아직 지우지 않은 P의 배수를 크기 순서대로 지운다.
아직 모든 수를 지우지 않았다면, 다시 2번 단계로 간다.

N, K가 주어졌을 때, K번째 지우는 수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N과 K가 주어진다. (1 ≤ K < N, max(2, K) < N ≤ 1000)
<출력값>
첫째 줄에 K번째 지워진 수를 출력한다.

<문제 2961>
도영이는 짜파구리 요리사로 명성을 날렸었다. 이번에는 이전에 없었던 새로운 요리에 도전을 해보려고 한다.
지금 도영이의 앞에는 재료가 N개 있다. 도영이는 각 재료의 신맛 S와 쓴맛 B를 알고 있다. 여러 재료를 이용해서 요리할 때, 그 음식의 신맛은 사용한 재료의 신맛의 곱이고, 쓴맛은 합이다.
시거나 쓴 음식을 좋아하는 사람은 많지 않다. 도영이는 재료를 적절히 섞어서 요리의 신맛과 쓴맛의 차이를 작게 만들려고 한다. 또, 물을 요리라고 할 수는 없기 때문에, 재료는 적어도 하나 사용해야 한다.
재료의 신맛과 쓴맛이 주어졌을 때, 신맛과 쓴맛의 차이가 가장 작은 요리를 만드는 프로그램을 작성하시오.
<입력값>
첫째 줄에 재료의 개수 N(1 ≤ N ≤ 10)이 주어진다. 다음 N개 줄에는 그 재료의 신맛과 쓴맛이 공백으로 구분되어 주어진다. 모든 재료를 사용해서 요리를 만들었을 때, 그 요리의 신맛과 쓴맛은 모두 1,000,000,000보다 작은 양의 정수이다.
<출력값>
첫째 줄에 신맛과 쓴맛의 차이가 가장 작은 요리의 차이를 출력한다.

<문제 2962>
네버랜드는 한국에서 가장 큰 규모를 자랑하는 동물원이다. 이번에 이 동물원은 야생 상태와 흡사한 생태 단지를 만들기 위해서 근처 부지를 구입했다.
동물원에서 가장 인기있는 동물은 원숭이이다. 원숭이는 점프하고 나무를 기어 오르는 것과 같은 기술을 이용해서 남녀노소 모든 방문객을 즐겁게 해준다.
원숭이는 크게 두 종으로 나눌 수 있다. 한 종은 나무를 오르고, 코코넛을 따는 것에 특화되어 있는 종이고, 다른 종은 코코넛을 여는데 특화되어있다.
첫 번째 원숭이 종은 총 N마리, 두 번째는 M마리가 있다. 각각의 종은 번호가 1부터 차례대로 매겨져 있다.
첫 번째 종의 원숭이 중 k번째 원숭이는 오를 나무를 찾아 첫 코코넛을 따는데 Ak초가 걸린다. 이후에 Bk초마다 새로운 코코넛을 생산한다.
두 번째 종의 원숭이 중 k번째 원숭이는 코코넛을 여는 좋은 도구를 찾고, 첫 코코넛을 여는데 Ck초가 걸린다. 이후 Dk초마다 새로운 코코넛을 열 수 있다.
안타깝게도, 두 원숭이 종은 서로 사이가 좋지 않기 때문에 동시에 같은 장소에 있을 수 없다. 따라서, 동물원 사육사는 첫 번째 원숭이 종이 코코넛을 모두 따면 즉시 우리로 돌려 보내고 두 번째 종을 부를 것이다.
동물원 사육사는 첫 번째 종이 모든 코코넛을 따는 즉시 도착한다. 우리로 보내는 시간과 우리에서 원숭이를 불러오는 시간은 무시할 수 있을 만큼 매우 작다.
상근이는 두 번째 종을 매우 좋아한다. 하지만, 언제 가야 되는지를 모르고 있다. 원숭이가 생태 단지에 있는 전체 시간이 주어졌을 때, 언제 도착하면 두 번째 원숭이를 볼 수 있는지 구하는 프로그램을 작성하시오. 상근이는 전체 코코넛의 개수를 알 수 없다.
<입력값>
첫째 줄에 원숭이가 생태 부지에 있는 전체 시간 T (1 ≤ T ≤ 1,000,000,000)가 주어진다.
둘째 줄에는 첫 번째 원숭이의 수 N이 주어진다. (1 ≤ N ≤ 100)
다음 N개 줄에는 k번째 원숭이의 정보 Ak와 Bk가 주어진다. (1 ≤ Ak, Bk ≤ 1,000,000,000)
다음 줄에는 두 번째 원숭이의 수 M이 주어진다. (1 ≤ M ≤ 100)
다음 M개 줄에는 k번째 원숭이의 정보 Ck와 Dk가 주어진다. (1 ≤ Ck, Dk, ≤ 1,000,000,000)
<출력값>
첫째 줄에 첫 번째 종이 우리로 들어가는 시간이자 두 번째 종이 생태 단지로 들어오는 시간을 출력한다.

<문제 2963>
다음과 같은 세가지 성질을 갖는 트리를 무한 이진 트리라고 한다.

모든 노드는 두 개의 자식 노드를 가지고 있다. 왼쪽 노드, 오른쪽 노드
어떤 노드의 번호가 X라면, 왼쪽 자식 노드의 번호는 2*X, 오른쪽 자식 노드의 번호는 2*X+1이다.
루트의 번호는 1이다.

무한 이진 트리를 탐색할 때는, 루트에서 시작한다. 그리고, 왼쪽 자식 또는 오른쪽 자식으로 이동하거나, 현재 노드에서 그대로 있을 수 있다.
탐색은 'L','R','P'로 이루어진 문자열로 표현할 수 있다.

'L': 왼쪽 자식으로 이동
'R': 오른쪽 자식으로 이동
'P': 현재 노드에 그대로 있음

탐색의 값은 마지막으로 방문한 노드의 번호이다. 예를 들어, LR의 값은 5이고, RPP의 값은 3이다.
탐색의 집합은 'L','R','P','*'로 이루어진 문자열로 표현할 수 있다. '*'는 3개중 그 어떤 것이 될 수 있다.
탐색의 집합은 문자열과 일치하는 모든 패턴을 포함한다.
예를 들어, L*R은 LLR, LRR, LPR이며, **은 LL,LR,LP,RL,RR,RP,PL,PR,PP이다.
마지막으로, 탐색의 집합의 값은 탐색의 집합에 포함되어 있는 모든 탐색의 값의 합이다.
탐색의 집합의 문자열이 주어졌을 때, 탐색의 집합의 합을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 탐색의 집합의 문자열이 주어진다. 이 문자열은 'L','R','P','*'로만 이루어져 있으며, 길이가 최대 10,000이다.
<출력값>
첫째 줄에 탐색의 집합의 합을 출력한다.

<문제 2964>
상근이의 방의 한쪽 벽에는 못이 N개 박혀 있다. 아침에 일찍 일어나서 이 벽을 바라보며 하루를 어떻게 살 것인가를 생각하던 중에 상근이는 이 벽은 2차원 평면이고, 못은 그 평면 위의 점과 같다는 생각을 했다. 서로 다른 두 못은 같은 x좌표나 y좌표를 갖지 않는다.
마침 바닥에 고무줄이 하나 떨어져 있었다. 상근이는 고무줄 안에 모든 못이 포함되도록 못에 고무줄을 걸어 놓았다. 이 고무줄은 매우 비싼 고무줄이기 때문에 끊어지지 않는다.
상근이는 벽에 있는 못의 개수가 세 개보다 적어질 때까지 아래와 같은 과정을 거쳐 벽에 있는 못을 빼려고 한다.

고무줄이 만드는 다각형의 면적을 적는다.
가장 왼쪽, 오른쪽, 위, 아래에 있는 못 중 하나를 고른다.
2번에서 고른 못을 벽에서 제거한다. 그럼 고무줄은 남은 못을 모두 감싸게 된다.

상근이가 2번 단계에서 고른 못이 어떤 못인지 주어졌을 때, 1번 단계에서 적는 면적을 모두 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 못의 개수 N이 주어진다. (3 ≤ N ≤ 300,000)
다음 N개 줄에는 못의 좌표가 주어진다. 모든 좌표는 1과 1,000,000,000 사이이며, 서로 다른 두 못이 같은 x좌표나 y좌표를 갖는 경우는 없다.
마지막 줄에는 'L', 'R',' U', 'D'로 이루어진 N-2개의 문자열이 주어진다. 이 문자열은 상근이가 2번단계에서 고른 못의 정보이며, 다음과 같은 의미를 갖는다.

'L': 가장 왼쪽 못 (가장 작은 x좌표)
'R': 가장 오른쪽 못 (가장 큰 x좌표)
'U': 가장 위쪽 못 (가장 큰 y좌표)
'D': 가장 아래쪽 못 (가장 작은 y좌표)
<출력값>
상근이가 1번 단계에서 구하는 면적을 순서대로 한 줄에 하나씩 출력한다. 출력은 소수점 첫째 자리까지 출력한다.

<문제 2965>
캥거루 세 마리가 사막에서 놀고 있다. 사막에는 수직선이 하나 있고, 캥거루는 서로 다른 한 좌표 위에 있다.
한 번 움직일 때, 바깥쪽의 두 캥거루 중 한 마리가 다른 두 캥거루 사이의 정수 좌표로 점프한다. 한 좌표 위에 있는 캥거루가 두 마리 이상일 수는 없다.
캥거루는 최대 몇 번 움직일 수 있을까?
<입력값>
첫째 줄에 세 캥거루의 초기 위치 A, B, C가 주어진다. (0 < A < B < C < 100)
<출력값>
캥거루가 최대 몇 번 움직일 수 있는지 출력한다.

<문제 2966>
상근이, 창영이, 현진이는 역사와 전통을 자랑하는 Sogang ACM-ICPC Team에 가입하려고 한다. 하지만, 가입하려고 하는 모든 지원자는 C언어 필기시험을 통과해야 한다. 이들은 C언어를 할 줄 모른다. 따라서, 필기시험을 모두 찍으려고 한다.
상근이는 A, B, C, A, B, C, A, B, C, A, B, C, ...와 같이 찍어야 통과할 수 있다고 생각한다. 
하지만, 창영이는 B, A, B, C, B, A, B, C, B, A, B, C, ...와 같이 찍는 방법이 만점의 지름길이라고 생각한다.
마지막으로, 현진이는 상근이와 창영이를 비웃으면서 C, C, A, A, B, B, C, C, A, A, B, B, ...와 같이 찍어야 통과한다고 말했다.
필기시험의 정답이 주어졌을 때, 상근이, 창영이, 현진이 중에서 가장 많은 문제를 맞힌 사람이 누구인지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 필기시험의 문제의 수 N이 주어진다. (1 ≤ N ≤ 100)
둘째 줄에는 시험의 정답이 주어진다.
<출력값>
첫째 줄에 가장 많은 문제를 맞춘 사람이 몇 문제를 맞혔는지 출력한다.
다음 줄에는 가장 많은 문제를 맞힌 사람의 아이디를 출력한다. 상근이의 아이디는 Adrian, 창영이의 아이디는 Bruno, 현진이의 아이디는 Goran이다. 아이디 여러 개를 출력하는 경우에는 상근이, 창영이, 현진이 순서로 출력하고, 한 줄에 하나씩 출력한다.

<문제 2967>
최근에 고고학자들이 그리스-로마 건축을 발견했다. 이 장소는 R*C칸으로 모델링 되어 있다. 고고학자들은 각 칸에 빌딩이 있었는지 없었는지를 표시해 두었다.

	고고학자들은 이 장소에 서로 다른 시대에 지어진 두 건물이 있었다는 사실을 알게되었다. 또, 두 건물의 바닥 모양은 정사각형이었다.

	두 건물이 서로 다른 시대에 지어졌기 때문에, 바닥이 겹칠 수도 있다. 이때, 가능한 위치와 크기를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 발견한 장소의 크기인 R과 C가 주어진다. (1 ≤ R ≤ 100, 1 ≤ C ≤ 100)

	다음 R개의 줄에는 C개의 문자가 주어진다. 각 문자는 '.' 또는 'x'이고, '.'인 경우에는 그 칸에 건물의 흔적이 없었다는 뜻이고, 'x'는 건물이 있었다는 뜻이다.
<출력값>
두 건물의 바닥의 왼쪽 위 좌표와 크기를 출력한다. 항상 답이 존재하는 경우만 주어진다.

<문제 2968>
동혁이는 창고에서 매우 재미있어 보이는 보드 게임을 발견했다. 이 게임의 보드는 R*C개의 정사각형 칸으로 이루어져 있다. 제일 위부터 0번부터 R-1까지 번호가 매겨져 있고, 제일 왼쪽부터 0번부터 C-1까지 번호가 매겨져 있다.

	이 보드게임의 칸은 색다른 방법으로 색칠되어 있고, 각 칸은 회색 또는 흰색으로 색칠되어 있다.

	행의 번호와 열의 번호를 이진수로 나타냈을 때, 적어도 한 위치에서 1이 겹치면 흰색이다. 예를 들어, (4, 5)는 흰색이다. 이러한 경우가 아니면 회색이다. 예를 들어, (2, 5)는 회색이다.

	10*10크기의 보드판은 다음과 같이 생겼다.



	동혁이는 자신의 말을 위쪽 오른쪽 그림과 같은 순서로 방문하려고 한다. 말은 (0, 0)에서 시작한다. 이때, 말이 회색 칸을 몇 번 방문하는지 구하려고 한다.

	동혁이의 말이 칸을 K번 방문하게 되면, 피곤하기 때문에 더이상 방문하지 않는다.

	N, M, K가 주어졌을 때, 회색칸을 몇 번 방문하는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 R과 C가 주어진다. (1 ≤ R,C ≤ 1,000,000)

	둘째 줄에는 K가 주어진다. (1 ≤ K ≤ R*C)
<출력값>
첫째 줄에 동혁이의 말이 방문한 회색 칸의 수를 출력한다.

<문제 2969>
꽃밭에 N*N개의 꽃이 N행 N열로 심어져 있다. 이 꽃밭에는 메뚜기가 한 마리 있는데, 메뚜기는 모든 꽃의 꽃잎의 개수를 알고 있다.
메뚜기는 맨 처음에 R행 C열에 있는 꽃 위에 있고, 다음과 같은 규칙을 지키면서 최대한 많은 꽃을 방문하려고 한다.
1. 메뚜기는 인접한 행 또는 열에 있는 꽃으로 점프할 수 있다. 만약, 인접한 행에 있는 꽃으로 이동할 때는, 적어도 두 열 이상 점프를 해야 한다. 또, 인접한 열에 있는 꽃으로 이동할 때는, 적어도 두 행 이상 점프를 해야 한다.
즉, (r1, c1)에서 (r2, c2)로 점프를 할 수 있으려면 다음과 같은 조건을 만족해야 한다.
- |r1-r2| = 1인 경우 |c1-c2| > 1 또는
- |c1-c2| = 1인 경우 |r1-r2| > 1
2. 점프하려고 하는 칸에 있는 꽃의 꽃잎의 개수는 현재 있는 칸의 꽃잎의 개수보다 많아야 한다.
메뚜기가 최대 몇 개의 꽃을 방문할 수 있는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 N이 주어진다. (1 ≤ N ≤ 1500)
둘째 줄에 메뚜기가 가장 처음에 있는 위치 R과 C가 주어진다. (1 ≤ R, C ≤ N)
다음 N개 줄에는 꽃잎의 수가 주어진다. 꽃잎의 수는 1,000,000보다 작거나 같다.
<출력값>
첫째 줄에 최대 몇 개의 꽃을 방문할 수 있는지 출력한다.

<문제 2970>
두더지는 땅에 터널을 파고 생활하는 동물이다. 땅속에 있는 두더지의 집은 방과 터널로 이루어져 있다.
방은 터널로 연결되어 있으며, 한 방에서 다른 방으로 가는 경로는 항상 유일하다. 두 방의 거리는 지나간 터널의 수와 같다.
어느 날, 두더지는 어떤 방과 어떤 방 사이의 거리라 너무 멀다고 생각했다. 두더지는 터널 하나를 막고, 터널 하나를 새로 파서 가장 먼 두 방의 거리를 최소로 만들려고 한다. 이때, 모든 방은 서로 연결되어 있어야 한다.
현재 두더지 집의 상태가 주어졌을 때, 터널 하나를 막고, 하나를 새로 파서 가장 먼 두 방의 거리를 최소로 만드는 프로그램을 작성하시오.
<입력값>
첫째 줄에 방의 개수 N이 주어진다. 방은 1번부터 N번까지 번호 매겨져 있다. (3 ≤ N ≤ 300,000)
다음 N-1개 줄에는 두 방을 연결하는 터널의 정보가 주어진다.
<출력값>
첫째 줄에 재건축을 하고난 이후에 가장 먼 두 집의 거리를 출력한다.
둘째 줄에는 닫을 터널의 정보를 출력한다.
셋째 줄에는 새로 만든 터널의 정보를 출력한다.
정답은 유일하지 않을 수 있다. 이런 경우에는 아무거나 출력하면 된다.

<문제 2973>
Brave Sir Robin has been thrown in the dungeon by the evil king. The dungeon consists of an infinite number of cube-shaped rooms with big stone walls. Rooms are connected by passages so that the entire dungeon, when viewed from above, looks like a spiral. The rooms are numbered as follows: 

After a big earthquake some of the walls collapsed, and new passages were formed between adjacent rooms. 
Sir Robin is initially in room 1. Sir Robin knows that the exit from the dungeon is located in room N, and wants to escape while everyone is distracted by the earthquake. Because the evil dragon is guarding the dungeon, Sir Robin wants to use the fastest way out of the dungeon. 
Write a program that, given the location of the exit N and the list of new passages, determines the smallest number of passages that Sir Robin must go through before he can exit the dungeon.
<입력값>
The first line of input contains an integer N (1 ≤ N ≤ 1015), the room in which the exit is located. 
The second line of input contains an integer K (1 ≤ K ≤ 100 000), the number of new passages. 
Each of the following K lines contains one integer B (4 ≤ B ≤ 1015), meaning that a new passage now connects adjacent rooms A and B, where A<B. The number A is not given explicitly, but it can be uniquely determined from B (for example, if B is 20, then A must be 7). Also, some rooms can never be room B (rooms 2, 3, 5, 7, 10, 13 etc.).
<출력값>
Output should consist of a single integer, the smallest number of passages that Sir Robin must go through before he can exit the dungeon.

<문제 2974>
양의 정수 N의 자리곱은 N의 모든 자리를 곱한 것이다. 예를 들어, 2612의 자리곱은 2×6×1×2 = 24 이다.
어떤 수 N의 자기곱은 N과 N의 자리곱을 곱한 수이다. 예를 들어, 2612의 자기곱은 2612×24 = 62688이다.
두 양의 정수 A와 B가 주어졌을 때, 자기곱이 A보다 크거나 같고, B보다 작거나 같은 양의 정수의 개수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 두 정수 A와 B가 주어진다. (1 ≤ A ≤ B < 1018)
<출력값>
자기곱이 A보다 크거나 같고, B보다 작거나 같은 양의 정수의 개수를 출력한다.

<문제 2975>
Whenever somebody goes to an ATM to withdraw or deposit money, a calculation has to be done to keep the person's bank balance correct. Your task in this problem is to do such calculations. There is a bank rule that says that a customer may not have an overdraft of more than $200, so any withdrawal that would take the balance below –200 must be stopped. (A minus sign is used to indicate an overdraft, or negative balance).
<입력값>
Input consists of a number of lines, each representing a transaction. Each transaction consists of an integer representing the starting balance (between –200 and +10,000), the letter W or the letter D (Withdrawal or Deposit), followed by a second integer representing the amount to be withdrawn or deposited (between 5 and 400). Input will be terminated by a line containing 0 W 0.
<출력값>
Output consists of one line for each line of input showing the new balance for each valid transaction If a withdrawal would take the balance below -200, the output must be the words ‘Not allowed’.

<문제 2976>
Nikola는 자신의 의지와는 상관없이 어떤 게임 속의 메인 캐릭터가 되어버렸다! 이 게임은 1부터 N까지의 번호가 쓰인 일렬로 된 N개의 발판 위에서 진행된다.  Nikola는 1번 발판 위에서 시작하여 다른 발판 위로 점프하여 이동할 수 있다. 처음 이동할 때는 무조건 2번 발판 위로 움직이게 되어 있으며, 이후의 이동에는 다음과 같은 제약이 따른다.

양의 방향으로 이동할 경우 바로 전 단계보다 1칸 더 먼 거리로 점프해야 한다.
음의 방향으로 이동할 경우 바로 전 단계에서 이동한 거리 만큼 점프할 수 있다.

예를 들어, 첫 번째 점프 이후(2번째 발판 위에 있는 상황), Nikola는 4번 발판으로 뛰어 갈 수 있으며, 반대 방향인 1번 발판으로 뛰어 갈 수 있다.
그가 매번 각 발판 위에 도달 했을 때, 해당 구역의 통행료를 내야만 한다. Nikola는 가능하다면 N번 발판까지 이동하면서 지불해야 하는 통행료를 최소로 만들고 싶어한다.
<입력값>
첫째 줄에는 발판의 개수 N이 2 ≤ N ≤ 1000 인 정수로 주어진다.
둘째 줄부터 N+1번째 줄에는 1번 발판부터 N번 발판까지 순서대로 각 발판 위로 점프하는데 지불해야 하는 통행료가 주어지며, 이들은 모두 500 이하의 양의 정수이다.
<출력값>
Nikola가 N번째 발판에 도달하기 위한 통행료의 최솟값을 첫 번째 줄에 출력한다.

<문제 2977>
효진이는 돈이 매우 많은 대학생이다. 어느 날, 효진이가 열심히 공부한 과목의 교수가 F학점을 주겠다고 '농담'을 했다. 하지만 효진이는 화가 나서 폭탄을 마구 만들어내 효진이가 소유한 개인소유의 섬에 무차별 폭파를 가하기로 했다. (효진이는 평화를 사랑하므로 대학교를 폭파하진 않는다.) 폭탄의 이름은 효진봄바이다. 효진봄바는 N개의 부품으로 이루어져있고, 효진봄바를 만들기 위해선 각 부품이 여러 개 필요하다.
효진이의 비밀창고에는 위의 부품들이 일부 보관돼있다. 효진이는 M달러로 암시장에 가서 부품들을 더 사려고 한다. 암시장엔 없는 부품이 없고, 소비자의 선택을 존중하기 위해 각 부품마다 소형 패키지와 대형 패키지가 준비돼있다.
효진이는 M달러로 부품들을 사, 폭탄을 최대한 많이 만들고 싶어한다.
<입력값>
첫 번째 줄에는 정수 N(1 ≤ N ≤ 100)과 M(1 ≤ M ≤ 100000)이 주어진다.
다음 N개의 각 줄마다 부품 하나의 정보를 의미하는 6개의 양의 정수가 주어진다.

X(10 ≤ X ≤ 100), 폭탄 한 개에 필요한 해당 부품의 개수
Y(1 ≤ Y ≤ 100), 효진이의 비밀창고에 있는 해당 부품의 개수
SM(1 ≤ SM < 100), 소형 패키지에 있는 부품의 개수
PM(10 ≤ PM < 100), 소형 패키지의 가격
SV(SM < SV ≤ 100), 대형 패키지에 있는 부품의 개수
PV(PM< PV ≤ 100), 대형 패키지의 가격
<출력값>
효진이가 M달러를 적절히 써서 만들 수 있는 폭탄의 최대 개수를 출력한다.

<문제 2978>
기말고사를 대비해서 수학을 예습하던 상근이는 놀라운 식을 발견했다. 바로 A=S이다. A=S가 놀라운 이유는 A와 S가 같지 않기 때문이다.
상근이는 A와 S가 서로 다른데 왜 A=S인지 궁금해 하다가 바로 밑에 쓰여 있는 이유를 발견했다.
좌변에 있는 숫자 A에 적절히 +기호를 삽입하여 식이 같아 지도록 만들면 된다는 것이었다.
예를 들어, 143175=120인 경우에 14+31+75=120을 만들면, A=S가 성립한다는 것을 알 수 있다.
A=S가 주어졌을 때, +를 적절히 삽입하여 등호가 성립하게 바꾸는 프로그램을 작성하시오.
<입력값>
첫째 줄에 등식 A=S가 주어진다. A와S는 0으로 시작하지 않는 양의 정수이다. A의 길이는 최대 1,000자리이고, S는 5,000보다 작거나 같다.
<출력값>
첫째 줄에 입력으로 주어진 A=S에 +를 적절히 삽입하여 등식이 성립하도록 바꾼 식을 출력한다. 만약 그러한 경우가 여러개일 경우에는 +를 적게 넣는 식을 출력한다. +를 적게 넣는 식이 여러 가지 존재한다면 아무거나 출력하면 된다. 항상 등식이 성립하게 바꿀 수 있는 입력만 주어진다.

<문제 2979>
상근이는 트럭을 총 세 대 가지고 있다. 오늘은 트럭을 주차하는데 비용이 얼마나 필요한지 알아보려고 한다.
상근이가 이용하는 주차장은 주차하는 트럭의 수에 따라서 주차 요금을 할인해 준다.
트럭을 한 대 주차할 때는 1분에 한 대당 A원을 내야 한다. 두 대를 주차할 때는 1분에 한 대당 B원, 세 대를 주차할 때는 1분에 한 대당 C원을 내야 한다.
A, B, C가 주어지고, 상근이의 트럭이 주차장에 주차된 시간이 주어졌을 때, 주차 요금으로 얼마를 내야 하는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 문제에서 설명한 주차 요금 A, B, C가 주어진다. (1 ≤ C ≤ B ≤ A ≤ 100)
다음 세 개 줄에는 두 정수가 주어진다. 이 정수는 상근이가 가지고 있는 트럭이 주차장에 도착한 시간과 주차장에서 떠난 시간이다. 도착한 시간은 항상 떠난 시간보다 앞선다. 입력으로 주어지는 시간은 1과 100사이 이다.
<출력값>
첫째 줄에 상근이가 내야하는 주차 요금을 출력한다.

<문제 2980>
상근이는 트럭을 가지고 긴 일직선 도로를 운전하고 있다. 도로에는 신호등이 설치되어 있다. 상근이는 각 신호등에 대해서 빨간 불이 지속되는 시간과 초록 불이 지속되는 시간을 미리 구해왔다. (빨강색과 초록색 불빛은 무한히 반복된다)
상근이의 트럭이 도로에 진입했을 때, 모든 신호등의 색상은 빨간색이고, 사이클이 막 시작한 상태이다. 상근이는 1초에 1미터를 움직인다. 신호등의 색상이 빨간색인 경우에는 그 자리에서 멈추고 초록색으로 바뀔때 까지 기다린다.
상근이가 도로의 끝까지 이동하는데 걸리는 시간을 구하는 프로그램을 작성하시오. 도로의 시작은 0미터이고, 끝은 L미터인 지점이다.
<입력값>
첫째 줄에 신호등의 개수 N과 도로의 길이 L이 주어진다. (1 ≤ N ≤ 100, 1 ≤ L ≤ 1000)
다음 N개 줄에는 각 신호등의 정보 D, R, G가 주어진다. (1 ≤ D < L, 1 ≤ R ≤ 100, 1 ≤ G ≤ 100) D는 신호등의 위치이며, R과 G는 빨간색, 초록색이 지속되는 시간이다.
신호등은 D가 증가하는 순서로 주어지며, 같은 위치에 있는 신호등이 두 개 이상 있는 경우는 없다.
<출력값>
첫째 줄에 상근이가 도로의 끝까지 이동하는데 걸리는 시간을 출력한다.

<문제 2981>
트럭을 타고 이동하던 상근이는 경찰의 검문을 받게 되었다. 경찰은 상근이가 운반하던 화물을 하나하나 모두 확인할 것이기 때문에, 검문하는데 엄청나게 오랜 시간이 걸린다.
상근이는 시간을 때우기 위해서 수학 게임을 하기로 했다.
먼저 근처에 보이는 숫자 N개를 종이에 적는다. 그 다음, 종이에 적은 수를 M으로 나누었을 때, 나머지가 모두 같게 되는 M을 모두 찾으려고 한다. M은 1보다 커야 한다.
N개의 수가 주어졌을 때, 가능한 M을 모두 찾는 프로그램을 작성하시오.
<입력값>
첫째 줄에 종이에 적은 수의 개수 N이 주어진다. (2 ≤ N ≤ 100)
다음 줄부터 N개 줄에는 종이에 적은 수가 하나씩 주어진다. 이 수는 모두 1보다 크거나 같고, 1,000,000,000보다 작거나 같은 자연수이다. 같은 수가 두 번 이상 주어지지 않는다.
항상 M이 하나 이상 존재하는 경우만 입력으로 주어진다.
<출력값>
첫째 줄에 가능한 M을 공백으로 구분하여 모두 출력한다. 이때, M은 증가하는 순서이어야 한다.

<문제 2982>
지난주에 상그니 아라비아의 국왕 고둘라 창지즈 영사우드가 한국에 도착했다. 고둘라는 매우 중요한 사람이다. 따라서, 경찰은 그가 타고 있는 차량이 길에 진입했을 때, 그가 길에 있는 동안에 다른 차량이 들어올 수 없게 통제할 것이다. 하지만, 그가 진입하기 전부터 길에 있던 차량은 계속 있을 수 있다.
상근이는 오토바이 소년 승환이의 뒤를 이어 근처에서 피자를 트럭으로 배달하는 사람이다. 상근이는 교통 통제 때문에 배달을 정시에 하지 못해서 짤릴뻔했다.
이미 고둘라 창지즈 영사우드는 상그니 아라비아로 돌아갔다. 하지만 상근이는 고둘라가 한국에 왔었을 때, 어떤 길로 이동을 했어야 배달을 빠르게 할 수 있었는지 알아보려고 한다. 상근이는 고둘라가 이동한 경로를 알고 있다.
도시는 여러 개의 교차로와 교차로를 서로 연결하는 양방향 도로로 모델링할 수 있다. 상근이는 각 도로를 이동하는데 걸리는 시간을 알고 있다. 고둘라가 그 도로를 이동하는데 걸리는 시간도 같다.
예를 들어, 고둘라가 10분이 되던 때에 어떤 도로에 도착했고, 그 도로를 통과하는데 걸리는 시간이 5라고 하자. 그럼 이 도로는 10, 11, 12, 13, 14분에는 진입할 수 없다. 상근이는 9분 이전, 15분 이후에 이 도로에 진입할 수 있다.
상근이가 배달을 하는데 걸리는 시간의 최솟값을 구하는 프로그램을 작성하시오. 상근이는 고둘라가 출발하고 K분이 지난 후에 배달을 시작한다.
<입력값>
첫째 줄에 교차로의 수 N과 도로의 수 M이 주어진다. 교차로는 1번부터 N번까지 번호가 매겨져 있다. (2 ≤ N ≤ 1000, 2 ≤ M ≤ 10,000)
둘째 줄에는 네 정수 A, B, K, G가 주어진다. (1 ≤ A, B ≤ N, 0 ≤ K ≤ 1000, 0 ≤ G ≤ 1000) A는 상근이가 배달을 시작하는 교차로, B는 상근이가 배달을 마치는 교차로이다. K는 고둘라가 출발한 시간과 상근이가 출발한 시간의 차이, G는 고둘라가 방문하는 교차로의 개수이다.
셋째 줄에는 G개의 정수가 주어진다.이 정수는 고둘라가 방문하는 교차로이다. 인접한 교차로 사이의 거리를 고둘라가 이동하는 것이다. 항상 도로는 존재하며, 각 도로를 최대 한 번만 이동한다.
넷째 줄부터 M개 줄에는 도로의 정보를 나타내는 세 정수 U, V, L이 주어진다. 교차로 U와 V를 연결하는 도로를 이동하는데 L분이 걸린다는 뜻이다. L은 1보다 크거나 같고, 1000보다 작거나 같은 정수이다.
<출력값>
첫째 줄에 상근이가 배달을 마치는데 필요한 가장 빠른 시간을 출력한다.

<문제 2983>
트럭을 타고 이동하던 중에 상근이는 휴식을 취하기 위해서 호수에 잠시 들렸다. 호수에는 개구리가 살고 있고, 개구리는 호수 위에 떠있는 식물 N개를 점프하면서 다닌다. 오래된 전설에 따르면 개구리에게 키스를 하면 개구리는 아름다운 공주로 변한다고 한다. 일단 개구리를 잡아야 전설이 사실인지 아닌지 확인할 수 있다. 개구리를 잡아보자.
호수는 2차원 평면으로 생각할 수 있고, 식물은 그 평면 위의 점으로 나타낼 수 있다. (x, y)위에 있는 개구리는 아래 네 가지 방향 중 한 방향으로 점프할 수 있다.

임의의 양의 정수 P에 대해서, (x+P, y+P)로 점프할 수 있다. 이 방향을 A라고 한다.
임의의 양의 정수 P에 대해서, (x+P, y-P)로 점프할 수 있다. 이 방향을 B라고 한다.
임의의 양의 정수 P에 대해서, (x-P, y+P)로 점프할 수 있다. 이 방향을 C라고 한다.
임의의 양의 정수 P에 대해서, (x-P, y-P)로 점프할 수 있다. 이 방향을 D라고 한다.

개구리는 네 방향 중 한 방향을 고른다. 그 다음 그 방향에 있는 가장 가까운 식물로 점프를 한다. 만약, 고른 방향에 식물이 없다면, 개구리는 그 위치에 그대로 있는다. 개구리가 점프를 하고 난 이후에, 원래 있던 식물은 호수로 가라앉게되고 사라진다.
상근이는 식물의 위치와 개구리가 고른 방향을 모두 알고 있다. 상근이는 개구리의 점프가 끝나는 꽃의 좌표를 알아낸 다음, 거기서 개구리를 잡으려고 한다.
개구리의 점프가 끝나는 식물의 위치는 어디일까?
<입력값>
첫째 줄에 식물의 수 N과 점프의 수 K가 주어진다. (1 ≤ N, K ≤ 100,000)
둘째 줄에는 개구리가 고른 방향 K개가 주어진다. 이 방향은 'A','B','C','D'로만 이루어져 있다.
셋째 줄부터 N개 줄에는 식물의 좌표가 X, Y가 주어진다. (0 ≤ X, Y ≤ 1,000,000,000) 처음으로 주어지는 식물에 개구리가 있다.
<출력값>
개구리의 점프가 끝나는 식물의 좌표를 출력한다.

<문제 2984>
상근이는 점점 부자가 되었고 트럭 운송 회사를 차렸다. 이 회사에는 트럭이 총 N대 있고, 모든 배달은 "공부 고속도로"를 통해 이루어진다.
공부 고속도로에는 나들목(인터체인지, IC)이 1,000,000개 있다. 그리고, 각 나들목은 1번부터 순서대로 번호가 매겨져 있다. 나들목에서는 고속도로로 들어오거나 나갈 수 있다.
고속도로에 들어갈 때는 들어온 나들목의 번호가 적혀있는 티켓을 하나 받게 된다. 이 티켓은 고속도로에서 나갈 때 요금소(톨게이트)에 제시해야하고, 들어온 나들목과 나가는 나들목 번호의 차이만큼 요금을 내야 한다. 예를 들어, 티켓에 적혀있는 나들목의 번호가 30이고 12번 나들목으로 나간다면, 요금은 18원이 된다.
고속도로 이용 요금은 점점 회사가 감당할 수 없는 수준까지 치솟았고, 상근이는 획기적인 방법을 생각해냈다. 바로, 고속도로 중간에서 두 운전사가 만나서 티켓을 교환하는 것이다. 이 방법은 서로 경로가 겹치지 않더라도 교환할 수 있으며, 티켓은 여러 번 교환할 수 있다.
하지만, 의심을 피하기 위해서 티켓에 적혀있는 나들목의 번호와 같은 나들목으로 나갈 수는 없다. 
운전사끼리 티켓을 적절히 교환했을 때, 내야하는 고속도로 이용 요금의 최솟값을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 트럭의 수 N이 주어진다. (1 ≤ N ≤ 100,000)
다음 N개 줄에는 각 트럭이 들어온 나들목의 번호와 나가야 하는 나들목의 번호가 공백으로 구분해서 주어진다. 나들목의 번호는 1보다 크거나 같고, 1,000,000보다 작거나 같은 자연수이다.
두 트럭이 고속도로로 들어올 때 사용하는 나들목의 번호나 나갈 때 사용하는 나들목의 번호가 같은 경우는 없다.
<출력값>
상근이네 트럭 운송 회사가 내야하는 고속도로 이용 요금의 최솟값을 출력한다. 이 값은 32비트 정수 범위를 넘어갈 수 있기 때문에, 64비트 정수(C/C++: long long)을 사용해야 한다.

<문제 2985>
수학을 못해도 너무 못하는 상근이는 정인이에게 과외를 받고 있다. 오늘은 상근이가 사칙연산을 배우는 날이다.

	정인이는 공책에 숫자 세개로 이루어진 등식을 적어주었다. (식은 자연수와 등호(=), 그리고 더하기, 빼기, 곱하기, 나누기 기호(+-*/)로 이루어져 있다)

	상근이는 이런 등식을 사칙연산을 모르는 창영이게 자랑하다가 그만... 창영이는 숫자를 제외한 기호를 모두 지워버리고 말았다.

	세 정수가 주어졌을 때, 원래 정인이가 적어준 등식을 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 정인이가 적어준 세 정수가 주어진다. 이 수는 100보다 작거나 같은 자연수이다. 항상 정답이 존재하는 경우만 입력으로 주어진다.
<출력값>
첫째 줄에 정인이가 원래 적어준 등식을 출력한다. 입력으로 주어진 숫자의 순서는 유지해야 하고, 등호 하나와 더하기, 빼기, 곱하기, 나누기 기호 중 하나로 이루어져 있어야 한다. 만약 등식이 여러 가지가 나올 수 있다면, 그 중 하나만 출력한다.

<문제 2986>
이 이야기는 고창영이 10살 때 있었던 실화이다.
창영이는 10살 때 파스칼을 독학했다. 창영이가 공부하던 책에는 다음과 같은 프로그램이 있었다.

readln(N); 
counter := 0; 
for i := N-1 downto 1 do begin 
    counter := counter + 1; 
    if N mod i = 0 then break; 
end; 
writeln(counter);

창영이는 N을 입력했을 때, 무엇이 출력될지 궁금해졌다.
창영이가 입력한 N이 주어졌을 때, 무엇이 출력되는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 창영이가 입력한 N이 주어진다. N은 1보다 크거나 같고, 10^9보다 작거나 같은 자연수이다.
<출력값>
첫째 줄에 결과를 출력한다.

<문제 2987>
백준이는 사과나무가 N개 심어져있는 땅의 일부를 구매했다. 백준이가 구매한 땅은 삼각형이다. 따라서, 어떤 사과나무가 백준이의 것인지 알기가 힘들었다.

	백준이 땅의 꼭짓점 좌표와 사과나무의 좌표가 주어졌을 때, 백준이 땅의 넓이와 백준이의 사과나무의 개수를 구하는 프로그램을 작성하시오.

	만약, 어떤 사과나무가 땅의 경계선에 걸쳐있다면, 이것은 백준이 사과나무이다.

	(xA,yA), (xB,yB), (xC,yC) 로 이루어진 삼각형의 넓이는 다음과 같이 구할 수 있다.

	|xA(yB-yC)+xB(yC-yA)+xC(yA-yB)| / 2
<입력값>
처음 세 개의 줄은 삼각형의 꼭짓점 좌표이다. 다음 줄에는 사과나무의 개수 N이 주어진다. (1 ≤ N ≤ 100). 다음 N개의 줄에는 사과나무의 좌표가 주어진다.

	모든 좌표는 1,000보다 작거나 같은 양의 정수이고, 공백으로 구분되어져 있다.
<출력값>
첫째 줄에는 백준이 땅의 넓이를 소수점 첫째자리까지 출력하고, 둘째 줄에는 백준이의 사과나무 개수를 출력한다.

<문제 2988>
동혁이는 화학을 매우 싫어한다. 어느 날 화학시간이었다. 선생님은 앞에서 아브가드로의 법칙을 설명하고 있었다. 아보가드로의 법칙은 모든 기체는 같은 온도, 같은 압력에서 같은 부피속에 같은 개수의 입자(분자)를 포함한다는 내용이다. 게다가 기체 분자는 화학적, 물리적 특성과는 무관하게 같은 온도와 압력에서 기체 시료가 차지하는 부피는 기체의 mol수(분자 수)에 비례한다. 예를 들면 분자의 mol수(분자 수)를 2배하면 부피도 2배가 된다는 것이다.

	지루해진 동혁이는 3*N크기의 표를 그렸다. 그리고, 첫째 줄에 1부터 N까지 숫자를 임의의 순서대로 중복없이 적었다. 둘째 줄과 셋째 줄에도 1부터 N까지 숫자를 적었는데, 이때 같은 숫자를 여러 번 적기도 했다. 

	이제 동혁이는 이 표에서 열을 적절히 지운 뒤, 각 행을 오름 차순으로 정렬했을 때, 각 열에 있는 숫자가 모두 일치하게 하려고 한다.

	동혁이가 지워야 하는 열의 최소 개수를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 표의 열의 개수 N (1 ≤ N ≤ 100,000)이 주어진다. 다음 3개의 줄에는 표에 적혀있는 순서대로 N개의 수가 주어진다.

	모든 숫자는 1보다 크거나 같고, N보다 작거나 같으며, 첫째 줄에는 모든 숫자가 한 번씩 나온다.
<출력값>
동혁이가 지워야 하는 열의 최소 개수를 출력한다.

<문제 2989>
개구리 왕눈이는 N개의 연꽃잎이 있는 연못에 살고 있다. 연꽃잎은 1부터 N까지 차례대로 번호가 매겨져 있다. 연못을 위에서 봤을 때 2차원 평면에 연꽃잎이 (x,y) 좌표에 떠 있는 것 처럼 보인다. 왕눈이는 대각선으로 뛰는 것과 음의 방향으로 뛰는 것을 무서워 한다. 좀 더 자세히 말하자면 (x 1,y1)에서 (x2,y2)로 뛰기 위해서는 아래 두 조건 중 하나를 만족해야한다.

x2 > x1 이고 y2 = y1
y2 > y1 이고 x2 = x1

각 연꽃잎 마다 일정 수의 파리가 있고, 왕눈이는 파리를 먹으며 힘을 회복한다.
왕눈이가 한 번 연꽃잎을 이동하기 위해서는 K 만큼 힘이 든다. 왕눈이는 처음 1번 연꽃잎에서 시작하여 N번 연꽃잎으로 이동하려고 한다. 다만, 도착하고 난 뒤 힘의 최대이고 싶어한다. 처음 왕눈이가 가진 힘은 0 이다. 힘은 항상 0 이상 이어야 한다.
왕눈이를 도와 연꽃잎 사이를 이동하는 경로를 출력하는 프로그램을 작성하시오.
<입력값>
첫 줄에 연꽃잎의 수 N과 한 번 이동하는데 필요한 힘 K가 주어진다. (2 ≤ N ≤ 300 000, 1 ≤ K ≤ 1000)
다음 N개의 줄에 걸쳐 각 연꽃잎의 좌표 X, Y와 파리의 양 F가 차례대로 주어진다. i+1번째 줄에 주어지는 좌표와 파리의 양은 i번 연꽃잎에 관한 정보이다. 연꽃잎의 좌표는 서로 다르다. (0 ≤ X, Y ≤ 100 000, 0 ≤ F ≤ 1000)
입력은 항상 답이 존재하도록 주어진다.
<출력값>
첫 줄에 N번 연꽃잎에 도착 한 뒤 최대 힘의 양을 출력한다.
두 번째 줄에는 1번 연꽃잎과 N번 연꽃잎을 포함하여 방문한 연꽃잎의 수 L을 출력한다.
다음 L개의 줄에 방문한 연꽃잎의 좌표들을 차례대로 출력한다.
만약, 가능한 답이 여러 가지인 경우 그 중 아무거나 하나 출력한다.

<문제 2990>
단어가 N개 있는 데이터베이스가 있다.

	이 데이터베이스에서 어떤 단어를 찾을 때 사용하는 알고리즘은 상당히 원시적이다.

	이 알고리즘은 단어 W와 데이터베이스에 있는 단어를 하나씩 비교한다. 단어를 비교할 때는, 각 단어의 가장 앞에서부터 다른 문자가 나오거나, 한 단어의 끝이 나올 때 까지 하나씩 비교한다. 만약, 단어 W를 찾으면 이 알고리즘은 그 즉시 종료된다.

	단어의 길이는 단어를 검색하기 전에 알 수 없으므로, 마지막 글자도 비교를 해야 단어가 끝났다는 것을 알게 된다. 즉, abc와 abcd가 있을 때, abc의 4번째 글자와 abcd의 4번째 글자를 비교할 때 단어가 서로 다르다는 것을 알 수 있는 것이다. 마찬가지로 단어가 같은 것도 마지막 글자 다음 글자를 비교해야 알 수 있다. abc와 abc가 있을 때, abc의 4번째 글자와 abc의 4번째 글자가 모두 없는 것으로 같으므로 단어를 찾았다는 뜻이다.

	단어 목록이 주어지고, 검색하려고 하는 단어가 주어졌을 때, 몇 번 비교만에 단어를 찾을 수 있는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 단어의 개수 N이 주어진다. (1 ≤ N ≤ 30,000)

	다음 N개의 줄에는 데이터베이스에 있는 단어가 주어진다. 단어를 검색할 때, 입력으로 주어진 단어 순서를 그대로 사용해야 한다. 또한, 모든 단어는 다르다.

	다음 줄에는 검색하려고 하는 단어의 개수 Q가 주어진다. (1 ≤ Q ≤ 30,000)

	다음 Q개 줄에는 검색하려고 하는 단어가 주어진다.

	모든 단어는 알파벳 소문자로 이루어져 있고, 길이는 30보다 작다.
<출력값>
Q개 줄에 걸쳐, 각 단어를 검색하는데 필요한 비교의 수를 출력한다.

<문제 2991>
창영 마을의 우체부, 우유배달원, 신문배달원은 상근이네 집에 가는 것을 매우 싫어한다. 그 이유는 상근이네 집에는 사나운 개 두 마리가 지키고 있기 때문이다. 하지만, 그들은 이 개의 행동이 예측 가능하다는 것을 모르고 있다.
매일 아침, 개 한마리는 A분동안 공격적이고, B분동안 조용히 쉬고 있다. 또다른 개는 C분동안 공격적이고, D분동안 조용히 쉰다. 두 개는 이 행동을 계속해서 연속적으로 반복한다.
우체부, 신문배달원, 우유배달원의 도착 시간이 주어졌을 때, 개 몇 마리에게 공격을 받는지 알아내는 프로그램을 작성하시오.
<입력값>
첫째 줄에 A, B, C, D가 주어진다. 
둘째 줄에는 P, M, N가 주어진다. P는 우체부의 도착 시간, M은 우유배달원의 도착 시간, N은 신문배달원의 도착 시간이다. 매일 아침이 시작하는 시간을 0이라고 한다. 도착 시간은 아침이 시작한 후 지난 시간이다. 예를 들어, P가 3이면, 우체부는 아침이 시작하고 세 번째 분이 진행되는 중에 도착했다는 뜻이다.
모든 수는 1보다 크거나 같고, 999보다 작거나 같은 정수이다.
<출력값>
첫째 줄에는 우체부, 둘째 줄에는 우유배달원, 셋째 줄에는 신문배달원이 개 몇 마리에게 공격 받는지 출력한다.

<문제 2992>
정수 X가 주어졌을 때, X와 구성이 같으면서 X보다 큰 수 중 가장 작은 수를 출력한다.
수의 구성이 같다는 말은, 수를 이루고 있는 각 자리수가 같다는 뜻이다. 예를 들어, 123과 321은 수의 구성이 같다. 하지만, 123과 432는 구성이 같지 않다.
<입력값>
첫째 줄에 X가 주어진다. (1 ≤ X ≤ 999999) X는 0으로 시작하지 않는다.
<출력값>
첫째 줄에 결과를 출력한다. 만약 그러한 숫자가 없는 경우에는 0을 출력한다.

<문제 2993>
독서를 싫어하는 원섭이는 책에서 단어 하나를 임의로 선택한다. 그 다음, 단어를 세 부분으로 나눈다.
세 부분으로 나눈 단어를 각각 순서를 뒤집는다. (첫 번째 글자와 마지막 글자의 위치를 바꾸고, 두 번째 위치와 뒤에서 두 번째 글자의 위치를 바꾸고... 이런 식으로 계속)
마지막으로, 이 세 단어를 나누기 전과 같은 순서로 합쳐 하나로 만든다.
원섭이는 사전순으로 가장 앞서는 단어를 만들려고 한다. 원섭이가 고른 단어가 주어졌을 때, 만들 수 있는 단어 중 가장 앞서는 단어를 출력하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 원섭이가 고른 단어가 주어진다. 고른 단어는 알파벳 소문자로 이루어져 있고, 길이는 3보다 크거나 같고, 50보다 작거나 같다.
<출력값>
첫째 줄에 원섭이가 만들 수 있는 단어 중 사전순으로 가장 앞서는 단어를 출력한다.

<문제 2994>
"The Drinking Musicians"는 2034년 그래미 어워즈에서 총 6관왕에 오른 유명한 N인조 밴드이다. 이 밴드의 음악은 엄청난 힘을 가지고 있어서, 사람의 생각을 조절할 수 있다. 대표적인 예로 결혼식에서 이 밴드의 "그 남자가 저기 있어"를 축가로 부르면, 모든 신부가 그 남자를 찾아 결혼식장을 나선다고 한다.

	이 밴드의 공연을 보는 것은 쉽지 않다. 밴드는 정시에 도착하지 않으며, 공연장의 위치도 잘 모른다. 또, 공연장에 도착했더라도 길을 자주 잃어서 공연장을 찾지 못한다.

	무대에 올라서 공연을 시작했다고 문제가 끝나는 것은 아니다. 각 멤버는 공연 도중에 자주 휴식을 취하러 백스테이지로 사라진다. 하지만 멤버 셋 이상이 동시에 휴식을 취하면, 무대 위의 남아있는 멤버들은 모두 큰 혼란에 빠지게 되고 연주를 더 이상 진행할 수 없다.

	콘서트는 총 T분이고, 콘서트 도중에 각 멤버는 적절히 휴식을 가질 것이다. 각 멤버가 가지는 휴식 시간은 미리 알고있다.

	이 밴드의 내한공연을 30년만에 성사시킨 상근이는 공연을 성공적으로 마치기 위해서 멤버들이 휴식을 가지는 시간을 계획하려고 한다. 무대 위에서 휴식을 취하러 가는 멤버는 많아야 두 명 이어야 한다. 또, 모든 휴식은 콘서트 도중에 일어나야 한다.

	모든 멤버는 단 한 번의 휴식을 가질 수 있다. 각 멤버들이 공연이 시작하고 몇 분이 지나면 휴식을 취하러 가도 되는지 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 콘서트의 길이 T와 멤버의 수 N이 주어진다. (1 ≤ T ≤ 5000, 1 ≤ N ≤ 500)

	다음 줄에는 각 멤버들이 휴식을 취하는 시간이 공백으로 구분되어서 주어진다.

	항상 답이 존재하는 경우만 입력으로 주어진다. 하지만, 답이 유일하지 않을 수도 있다.
<출력값>
각 멤버가 공연이 시작하고 몇 분이 지난 후에 휴식을 가져야 하는지 출력한다. 입력으로 주어진 순서대로 출력한다.

<문제 2995>
상근이는 생일 선물로 구간 N개를 받았다. 여기서 말하는 구간이란 수의 구간이며, [A, B]와 같은 구간이다. 구간을 어떻게 선물로 받았는 지는 잘 모르겠지만, 진짜로 그 수학에 나오는 구간이다.
상근이는 자신이 가지고 있는 구간 중에서 아래와 같은 조건을 만족하는 가장 긴 서로 다른 구간의 수열을 찾으려고 한다.
수열에 포함되는 모든 구간은 다음 위치에 있는 구간을 포함해야 한다.
가장 긴 수열을 찾는 프로그램을 작성하시오.
<입력값>
첫째 줄에 구간의 수 N이 주어진다. (1 ≤ N ≤ 100,000)
다음 N개 줄에는 각 구간 [A,B]의 정보 A와 B가 주어진다. (1 ≤ A < B ≤ 1,000,000)
<출력값>
첫째 줄에 수열의 길이 K를 출력한다. 다음 K줄에는 수열에 포함되는 구간을 입력 형식과 같이 한 줄에 하나씩 순서대로 출력한다.

<문제 2996>
로봇과 다섯 개의 큐브가 단위 정사각형으로 나누어진 큰 보드 위에 있다. 로봇과 큐브는 각각 한 정사각형을 모두 차지하는 크기이다.
로봇은 위, 아래, 왼쪽, 오른쪽으로 한 칸 이동할 수 있다. 만약, 로봇이 이동하려는 칸에 큐브가 있다면, 로봇은 큐브를 움직이는 방향으로 한 칸 밀게 된다.
큐브는 흥미로운 자성을 가지고 있다. 두 큐브가 서로 인접한 칸에 있을 때(변을 공유하는 정사각형), 큐브는 붙게되고 한 물체가 된다. 한 물체가 된 큐브는 같이 움직이게 된다. 즉, 로봇이 붙어있는 큐브 중 하나를 밀면, 붙어있는 나머지 큐브도 같은 방향으로 움직인다.
로봇은 다섯 개의 큐브를 모두 붙어있게 하나로 만들려고 한다. 이때, 위에서 봤을 때, 큐브가 이루는 모습은 T자 모양이어야 한다. (T자가 회전되면 안 된다)
큐브의 위치가 주어졌을 때, T자 모양으로 만드는 프로그램을 작성하시오.
<입력값>
입력은 총 다섯 줄이다. 각 줄에는 큐브의 위치 X와 Y가 주어진다. (-5 ≤ X, Y ≤ 5)
로봇은 가장 처음에 (0, 0)에 있고, 여기에는 큐브가 없다.
입력으로 주어지는 큐브가 처음부터 인접하는 상태는 없다. 즉, 변을 공유하는 큐브는 없다. 하지만 꼭짓점을 공유할 수는 있다.
<출력값>
로봇이 어떻게 움직여야 하는지 한 줄에 모두 출력한다. 위로 움직이는 것은 U, 왼쪽은 L, 오른쪽은 R, 아래는 D로 출력한다.
로봇이 움직이는 횟수는 9999를 넘을 수 없다.

<문제 2997>
상근이는 등차수열을 이루는 정수 4개를 골랐다. 이것은 상근이가 고른 수 4개를 정렬했을 때, 인접한 쌍의 차이가 일정하다는 것을 의미한다. 그 다음 이렇게 고른 숫자 4개를 노래로 만들어서 외우고 다닌다.

	어느 날, 상근이는 자신이 고른 4개 숫자 중 1개를 까먹었다. 

	상근이가 고른 네 개의 숫자 중 세 개가 주어졌을 때, 네 번째 숫자를 구하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 상근이가 고른 네 개의 숫자 중 세 개가 주어진다. 이 숫자는 크기 순이 아닐 수도 있고, -100보다 크거나 같고, 100보다 작거나 같은 정수이다.
<출력값>
첫째 줄에 네 번째 숫자를 출력한다. 정답이 여러 개일 경우에는 아무거나 출력하면 된다. 또한 정답이 존재하지 않는 경우는 입력으로 주어지지 않는다.

<문제 2998>
창영이는 여러 가지 진법을 공부하고 있다. 창영이는 어제 2진법을 배웠고, 오늘은 8진법을 배웠다. 이제, 2진법 수를 8진법 수로 변환하려고 한다.
창영이가 사용한 방법은 다음과 같다.

2진수의 길이가 3으로 나누어 떨어질 때 까지 수의 앞에 0을 붙인다.
그 다음, 3자리씩 그룹을 나눈다.
아래의 표를 참고해 8진수로 바꾼다.

2진수가 주어졌을 때, 창영이가 사용한 방법을 이용해 8진수로 바꾸는 프로그램을 작성하시오.



000
0


001
1


010
2


011
3


100
4


101
5


110
6


111
7
<입력값>
첫째 줄에 2진수가 주어진다. 이 수는 100자리 이내이고, 첫 번째 자리는 1이다.
<출력값>
첫째 줄에 8진수를 출력한다.

<문제 2999>
매일 밤, 정인이는 상근이에게 이메일을 보낸다. 정인이는 자신의 이메일이 해킹당할 수도 있다는 생각에, 내용을 항상 암호화해서 보낸다.
정인이가 사용하는 암호 알고리즘은 다음과 같다. 정인이가 보내는 메시지는 총 N글자이다.
먼저, 정인이는 R<=C이고, R*C=N인 R과 C를 고른다. 만약, 그러한 경우가 여러 개일 경우, R이 큰 값을 선택한다.
그 다음, 행이 R개고, 열이 C개인 행렬을 만든다.
이제 메시지를 행렬에 옮긴다. 첫 번째 행의 첫 번째 열부터 C번째 열까지 메시지를 순서대로 옮긴 뒤, 남은 메시지는 두 번째 행, 세 번째 행,... R번째 행에 첫 번째 행을 채운 방법과 동일한 순서대로 옮긴다.
행렬에 모두 메시지를 옮겼다면, 이 것을 첫 번째 열의 첫 번째 행부터 R번째 행까지 차례대로 읽으면서 다시 받아 적는다. 그 다음에, 두 번째 열, 세 번째 열,..., C번째 열에 쓰여 있는 문자를 첫 번째 열을 읽은 방법과 동일하게 받아적는다.
상근이는 매일 밤 정인이의 메시지를 해독하는데 지쳤다. 정인이의 암호 이메일이 주어졌을 때, 이를 해독하는 프로그램을 작성하시오.
<입력값>
첫째 줄에 상근이가 받은 메시지가 주어진다. 이 메시지는 알파벳 소문자로만 이루어져 있고, 최대 100글자이다.
<출력값>
첫째 줄에 상근이가 받은 메시지를 해독한 메시지를 출력한다.

<문제 3000>
좌표 평면에 점 N개가 있다.

	이때, 빗변을 제외한 나머지 두 변이 좌표축에 평행한 직각삼각형을 이루는 점 3개를 고르는 방법을 수를 구하는 프로그램을 작성하시오.

	직각삼각형은 한각이 직각인 삼각형이며, 직각의 대변을 빗변이라고 한다.
<입력값>
첫째 줄에 점의 개수 N(3 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N개의 줄에는 점의 좌표가 X Y 순서대로 주어진다. (1 ≤ X,Y ≤ 100,000) 겹치는 점은 없다.
<출력값>
첫째 줄에 직각삼각형의 개수를 출력한다.

